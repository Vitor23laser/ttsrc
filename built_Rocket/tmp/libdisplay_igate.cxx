/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/display -Ipanda/src/display -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdisplay_igate.cxx -od built_Rocket/pandac/input/libdisplay.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/display -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libdisplay config_display.h displayInformation.h displayRegion.h displayRegionCullCallbackData.h displayRegionDrawCallbackData.h displaySearchParameters.h display_composite.cxx drawableRegion.h frameBufferProperties.h graphicsBuffer.h graphicsDevice.h graphicsEngine.h graphicsOutput.h graphicsPipe.h graphicsPipeSelection.h graphicsStateGuardian.h graphicsThreadingModel.h graphicsWindow.h graphicsWindowInputDevice.h graphicsWindowProc.h graphicsWindowProcCallbackData.h lru.h nativeWindowHandle.h parasiteBuffer.h pythonGraphicsWindowProc.h standardMunger.h stencilRenderStates.h stereoDisplayRegion.h subprocessWindow.h subprocessWindowBuffer.h touchInfo.h windowHandle.h windowProperties.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdisplay
#include "py_panda.h"  

#include <assert.h>
#include "callbackData.h"
#include "callbackObject.h"
#include "configVariableBool.h"
#include "configVariableEnum.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "configVariableList.h"
#include "configVariableString.h"
#include "config_display.h"
#include "coordinateSystem.h"
#include "cullResult.h"
#include "cullTraverser.h"
#include "cycleData.h"
#include "cycleDataLockedReader.h"
#include "cycleDataReader.h"
#include "cycleDataStageWriter.h"
#include "cycleDataWriter.h"
#include "dconfig.h"
#include "deletedChain.h"
#include "displayInformation.h"
#include "displayRegion.h"
#include "displayRegionBase.h"
#include "displayRegionCullCallbackData.h"
#include "displayRegionDrawCallbackData.h"
#include "displaySearchParameters.h"
#include "drawableRegion.h"
#include "frameBufferProperties.h"
#include "graphicsBuffer.h"
#include "graphicsDevice.h"
#include "graphicsEngine.h"
#include "graphicsOutput.h"
#include "graphicsPipe.h"
#include "graphicsPipeSelection.h"
#include "graphicsStateGuardian.h"
#include "graphicsThreadingModel.h"
#include "graphicsWindow.h"
#include "graphicsWindowInputDevice.h"
#include "graphicsWindowProc.h"
#include "graphicsWindowProcCallbackData.h"
#include "lens.h"
#include "lru.h"
#include "nativeWindowHandle.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "parasiteBuffer.h"
#include "pipelineCycler.h"
#include "plist.h"
#include "pointerTo.h"
#include "pvector.h"
#include "pythonGraphicsWindowProc.h"
#include "referenceCount.h"
#include "sceneSetup.h"
#include "standardMunger.h"
#include <stdio.h>
#include "stencilRenderStates.h"
#include "stereoDisplayRegion.h"
#include <string>
#include "subprocessWindow.h"
#include "subprocessWindowBuffer.h"
#include "touchInfo.h"
#include "typedef.h"
#include "windowHandle.h"
#include "windowProperties.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. WindowHandle
//********************************************************************
typedef  WindowHandle  WindowHandle_localtype;
Define_Module_ClassRef(panda,WindowHandle,WindowHandle_localtype,WindowHandle);
//********************************************************************
//*** prototypes for .. WindowHandle_OSHandle
//********************************************************************
typedef  WindowHandle::OSHandle  WindowHandle_OSHandle_localtype;
Define_Module_ClassRef(panda,WindowHandle_OSHandle,WindowHandle_OSHandle_localtype,WindowHandle::OSHandle);
//********************************************************************
//*** prototypes for .. WindowProperties
//********************************************************************
typedef  WindowProperties  WindowProperties_localtype;
Define_Module_Class(panda,WindowProperties,WindowProperties_localtype,WindowProperties);
//********************************************************************
//*** prototypes for .. DisplayInformation
//********************************************************************
typedef  DisplayInformation  DisplayInformation_localtype;
Define_Module_Class(panda,DisplayInformation,DisplayInformation_localtype,DisplayInformation);
//********************************************************************
//*** prototypes for .. DrawableRegion
//********************************************************************
typedef  DrawableRegion  DrawableRegion_localtype;
Define_Module_Class(panda,DrawableRegion,DrawableRegion_localtype,DrawableRegion);
//********************************************************************
//*** prototypes for .. DisplayRegion
//********************************************************************
typedef  DisplayRegion  DisplayRegion_localtype;
Define_Module_ClassRef(panda,DisplayRegion,DisplayRegion_localtype,DisplayRegion);
//********************************************************************
//*** prototypes for .. DisplayRegionCullCallbackData
//********************************************************************
typedef  DisplayRegionCullCallbackData  DisplayRegionCullCallbackData_localtype;
Define_Module_Class(panda,DisplayRegionCullCallbackData,DisplayRegionCullCallbackData_localtype,DisplayRegionCullCallbackData);
//********************************************************************
//*** prototypes for .. DisplayRegionDrawCallbackData
//********************************************************************
typedef  DisplayRegionDrawCallbackData  DisplayRegionDrawCallbackData_localtype;
Define_Module_Class(panda,DisplayRegionDrawCallbackData,DisplayRegionDrawCallbackData_localtype,DisplayRegionDrawCallbackData);
//********************************************************************
//*** prototypes for .. DisplaySearchParameters
//********************************************************************
typedef  DisplaySearchParameters  DisplaySearchParameters_localtype;
Define_Module_Class(panda,DisplaySearchParameters,DisplaySearchParameters_localtype,DisplaySearchParameters);
//********************************************************************
//*** prototypes for .. FrameBufferProperties
//********************************************************************
typedef  FrameBufferProperties  FrameBufferProperties_localtype;
Define_Module_Class(panda,FrameBufferProperties,FrameBufferProperties_localtype,FrameBufferProperties);
//********************************************************************
//*** prototypes for .. GraphicsThreadingModel
//********************************************************************
typedef  GraphicsThreadingModel  GraphicsThreadingModel_localtype;
Define_Module_Class(panda,GraphicsThreadingModel,GraphicsThreadingModel_localtype,GraphicsThreadingModel);
//********************************************************************
//*** prototypes for .. GraphicsDevice
//********************************************************************
typedef  GraphicsDevice  GraphicsDevice_localtype;
Define_Module_ClassRef(panda,GraphicsDevice,GraphicsDevice_localtype,GraphicsDevice);
//********************************************************************
//*** prototypes for .. GraphicsPipe
//********************************************************************
typedef  GraphicsPipe  GraphicsPipe_localtype;
Define_Module_ClassRef(panda,GraphicsPipe,GraphicsPipe_localtype,GraphicsPipe);
//********************************************************************
//*** prototypes for .. StencilRenderStates
//********************************************************************
typedef  StencilRenderStates  StencilRenderStates_localtype;
Define_Module_Class(panda,StencilRenderStates,StencilRenderStates_localtype,StencilRenderStates);
//********************************************************************
//*** prototypes for .. GraphicsStateGuardian
//********************************************************************
typedef  GraphicsStateGuardian  GraphicsStateGuardian_localtype;
Define_Module_ClassRef(panda,GraphicsStateGuardian,GraphicsStateGuardian_localtype,GraphicsStateGuardian);
//********************************************************************
//*** prototypes for .. StereoDisplayRegion
//********************************************************************
typedef  StereoDisplayRegion  StereoDisplayRegion_localtype;
Define_Module_ClassRef(panda,StereoDisplayRegion,StereoDisplayRegion_localtype,StereoDisplayRegion);
//********************************************************************
//*** prototypes for .. GraphicsOutput
//********************************************************************
typedef  GraphicsOutput  GraphicsOutput_localtype;
Define_Module_ClassRef(panda,GraphicsOutput,GraphicsOutput_localtype,GraphicsOutput);
//********************************************************************
//*** prototypes for .. GraphicsBuffer
//********************************************************************
typedef  GraphicsBuffer  GraphicsBuffer_localtype;
Define_Module_ClassRef(panda,GraphicsBuffer,GraphicsBuffer_localtype,GraphicsBuffer);
//********************************************************************
//*** prototypes for .. TouchInfo
//********************************************************************
typedef  TouchInfo  TouchInfo_localtype;
Define_Module_Class(panda,TouchInfo,TouchInfo_localtype,TouchInfo);
//********************************************************************
//*** prototypes for .. GraphicsWindowProcCallbackData
//********************************************************************
typedef  GraphicsWindowProcCallbackData  GraphicsWindowProcCallbackData_localtype;
Define_Module_Class(panda,GraphicsWindowProcCallbackData,GraphicsWindowProcCallbackData_localtype,GraphicsWindowProcCallbackData);
//********************************************************************
//*** prototypes for .. GraphicsWindow
//********************************************************************
typedef  GraphicsWindow  GraphicsWindow_localtype;
Define_Module_ClassRef(panda,GraphicsWindow,GraphicsWindow_localtype,GraphicsWindow);
//********************************************************************
//*** prototypes for .. NativeWindowHandle
//********************************************************************
typedef  NativeWindowHandle  NativeWindowHandle_localtype;
Define_Module_ClassRef(panda,NativeWindowHandle,NativeWindowHandle_localtype,NativeWindowHandle);
//********************************************************************
//*** prototypes for .. ParasiteBuffer
//********************************************************************
typedef  ParasiteBuffer  ParasiteBuffer_localtype;
Define_Module_ClassRef(panda,ParasiteBuffer,ParasiteBuffer_localtype,ParasiteBuffer);
//********************************************************************
//*** prototypes for .. GraphicsEngine
//********************************************************************
typedef  GraphicsEngine  GraphicsEngine_localtype;
Define_Module_ClassRef(panda,GraphicsEngine,GraphicsEngine_localtype,GraphicsEngine);
//********************************************************************
//*** prototypes for .. GraphicsPipeSelection
//********************************************************************
typedef  GraphicsPipeSelection  GraphicsPipeSelection_localtype;
Define_Module_Class_Private(panda,GraphicsPipeSelection,GraphicsPipeSelection_localtype,GraphicsPipeSelection);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_BitMask_unsigned_int_32;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CallbackData;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CallbackObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CullResult;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CullTraverser;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DisplayRegionBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsOutputBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Lens;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Loader;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MouseData;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PNMImage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PreparedGraphicsObjects;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_SceneSetup;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextureAttrib;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextureStage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Thread;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. WindowHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline WindowHandle::OSHandle *WindowHandle::get_os_handle(void) const
 *******************************************************************/
static PyObject *Dtool_WindowHandle_get_os_handle_4(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline WindowHandle::OSHandle *WindowHandle::get_os_handle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOsHandle", key_word_list));
        else
            (PyArg_Parse(args, ":getOsHandle"));
        if(!PyErr_Occurred())
        {
            WindowHandle::OSHandle *return_value = ((const WindowHandle*)local_this)->get_os_handle();
            if (return_value != (WindowHandle::OSHandle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_WindowHandle_OSHandle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOsHandle(const WindowHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_get_os_handle_4_comment =
    "C++ Interface:\n"
    "getOsHandle(const WindowHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::get_os_handle\n"
    "//       Access: Published\n"
    "//  Description: Returns the OS-specific handle stored internally to\n"
    "//               the WindowHandle wrapper.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_get_os_handle_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowHandle::set_os_handle(WindowHandle::OSHandle *os_handle)
 *******************************************************************/
static PyObject *Dtool_WindowHandle_set_os_handle_5(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void WindowHandle::set_os_handle(WindowHandle::OSHandle *os_handle)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"os_handle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOsHandle", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOsHandle", &param1));
            if(!PyErr_Occurred())
            {
                WindowHandle::OSHandle *param1_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowHandle_OSHandle, 1, "WindowHandle.setOsHandle", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_os_handle(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WindowHandle.setOsHandle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOsHandle(non-const WindowHandle this, non-const OSHandle os_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_set_os_handle_5_comment =
    "C++ Interface:\n"
    "setOsHandle(non-const WindowHandle this, non-const OSHandle os_handle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::set_os_handle\n"
    "//       Access: Published\n"
    "//  Description: Changes the OS-specific handle stored internally to\n"
    "//               the WindowHandle wrapper.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_set_os_handle_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WindowHandle::send_windows_message(unsigned int msg, int wparam, int lparam)
 *******************************************************************/
static PyObject *Dtool_WindowHandle_send_windows_message_6(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void WindowHandle::send_windows_message(unsigned int msg, int wparam, int lparam)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"msg", (char *)"wparam", (char *)"lparam", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:sendWindowsMessage", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->send_windows_message(PyLong_AsUnsignedLong(param1_uint), (int)param2, (int)param3);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowHandle.sendWindowsMessage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendWindowsMessage(non-const WindowHandle this, unsigned int msg, int wparam, int lparam)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_send_windows_message_6_comment =
    "C++ Interface:\n"
    "sendWindowsMessage(non-const WindowHandle this, unsigned int msg, int wparam, int lparam)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::send_windows_message\n"
    "//       Access: Published\n"
    "//  Description: Call this method on a parent WindowHandle to deliver\n"
    "//               a Windows message to the current child window, if any.\n"
    "//               This is used in the web plugin system to deliver\n"
    "//               button events detected directly by the browser system\n"
    "//               into Panda, which is particularly necessary on Vista.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_send_windows_message_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int WindowHandle::get_int_handle(void) const
 *******************************************************************/
static PyObject *Dtool_WindowHandle_get_int_handle_7(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int WindowHandle::get_int_handle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIntHandle", key_word_list));
        else
            (PyArg_Parse(args, ":getIntHandle"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const WindowHandle*)local_this)->get_int_handle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntHandle(const WindowHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_get_int_handle_7_comment =
    "C++ Interface:\n"
    "getIntHandle(const WindowHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::get_int_handle\n"
    "//       Access: Published\n"
    "//  Description: Returns the OS-specific handle converted to an\n"
    "//               integer, if this is possible for the particular\n"
    "//               representation.  Returns 0 if it is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_get_int_handle_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WindowHandle::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_WindowHandle_output_8(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void WindowHandle::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "WindowHandle.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const WindowHandle*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const WindowHandle this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_output_8_comment =
    "C++ Interface:\n"
    "output(const WindowHandle this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_output_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle WindowHandle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_WindowHandle_get_class_type_13(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle WindowHandle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = WindowHandle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_get_class_type_13_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_WindowHandle_get_class_type_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline WindowHandle::WindowHandle(WindowHandle const &copy)
 * inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
 *******************************************************************/
int  Dtool_Init_WindowHandle(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"os_handle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:WindowHandle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:WindowHandle", &param0));
            if(!PyErr_Occurred())
            {
                WindowHandle::OSHandle *param0_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_WindowHandle_OSHandle, 0, "WindowHandle.WindowHandle", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    WindowHandle *return_value = new WindowHandle(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_WindowHandle,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline WindowHandle::WindowHandle(WindowHandle const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:WindowHandle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:WindowHandle", &param0));
            if(!PyErr_Occurred())
            {
                WindowHandle *param0_this = (WindowHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_WindowHandle, 0, "WindowHandle.WindowHandle", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    WindowHandle *return_value = new WindowHandle(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_WindowHandle,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "WindowHandle(non-const OSHandle os_handle)\n"
          "WindowHandle(const WindowHandle copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_WindowHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WindowHandle)
    {
        printf("WindowHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WindowHandle * local_this = (WindowHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WindowHandle)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WindowHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WindowHandle)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (WindowHandle*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (WindowHandle*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (WindowHandle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WindowHandle::OSHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual unsigned int WindowHandle::OSHandle::get_int_handle(void) const
 *******************************************************************/
static PyObject *Dtool_WindowHandle_OSHandle_get_int_handle_10(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle::OSHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle_OSHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual unsigned int WindowHandle::OSHandle::get_int_handle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIntHandle", key_word_list));
        else
            (PyArg_Parse(args, ":getIntHandle"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const WindowHandle::OSHandle*)local_this)->get_int_handle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntHandle(const OSHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_OSHandle_get_int_handle_10_comment =
    "C++ Interface:\n"
    "getIntHandle(const OSHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::OSHandle::get_int_handle\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the OS-specific handle converted to an\n"
    "//               integer, if this is possible for the particular\n"
    "//               representation.  Returns 0 if it is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_OSHandle_get_int_handle_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void WindowHandle::OSHandle::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_WindowHandle_OSHandle_output_11(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowHandle::OSHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle_OSHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void WindowHandle::OSHandle::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OSHandle.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const WindowHandle::OSHandle*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const OSHandle this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_OSHandle_output_11_comment =
    "C++ Interface:\n"
    "output(const OSHandle this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowHandle::OSHandle::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowHandle_OSHandle_output_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle WindowHandle::OSHandle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_WindowHandle_OSHandle_get_class_type_12(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle WindowHandle::OSHandle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = WindowHandle::OSHandle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowHandle_OSHandle_get_class_type_12_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_WindowHandle_OSHandle_get_class_type_12_comment = NULL;
#endif

int  Dtool_Init_WindowHandle_OSHandle(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (WindowHandle::OSHandle)");
       return -1;
}
inline void  * Dtool_UpcastInterface_WindowHandle_OSHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WindowHandle_OSHandle)
    {
        printf("WindowHandle_OSHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WindowHandle::OSHandle * local_this = (WindowHandle::OSHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WindowHandle_OSHandle)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WindowHandle_OSHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WindowHandle_OSHandle)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (WindowHandle::OSHandle*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (WindowHandle::OSHandle*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (WindowHandle::OSHandle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WindowProperties 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void WindowProperties::operator =(WindowProperties const &copy)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_operator_18(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void WindowProperties::operator =(WindowProperties const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                WindowProperties *param1_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowProperties, 1, "WindowProperties.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    WindowProperties *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WindowProperties.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const WindowProperties this, const WindowProperties copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_operator_18_comment =
    "C++ Interface:\n"
    "assign(non-const WindowProperties this, const WindowProperties copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_operator_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static WindowProperties WindowProperties::get_config_properties(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_config_properties_20(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static WindowProperties WindowProperties::get_config_properties(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getConfigProperties", key_word_list))
        {
            WindowProperties result = WindowProperties::get_config_properties();
            WindowProperties *return_value = new WindowProperties(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConfigProperties()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_config_properties_20_comment =
    "C++ Interface:\n"
    "getConfigProperties()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_config_properties\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a WindowProperties structure with all of the\n"
    "//               default values filled in according to the user's\n"
    "//               config file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_config_properties_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static WindowProperties WindowProperties::get_default(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_default_21(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static WindowProperties WindowProperties::get_default(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefault", key_word_list))
        {
            WindowProperties result = WindowProperties::get_default();
            WindowProperties *return_value = new WindowProperties(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefault()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_default_21_comment =
    "C++ Interface:\n"
    "getDefault()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_default\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the \"default\" WindowProperties.  If\n"
    "//               set_default() has been called, this returns that\n"
    "//               WindowProperties structure; otherwise, this returns\n"
    "//               get_config_properties().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_default_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void WindowProperties::set_default(WindowProperties const &default_properties)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_default_22(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void WindowProperties::set_default(WindowProperties const &default_properties)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"default_properties", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDefault", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setDefault", &param0));
            if(!PyErr_Occurred())
            {
                WindowProperties *param0_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_WindowProperties, 0, "WindowProperties.setDefault", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    WindowProperties::set_default(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefault(const WindowProperties default_properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_default_22_comment =
    "C++ Interface:\n"
    "setDefault(const WindowProperties default_properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_default\n"
    "//       Access: Published, Static\n"
    "//  Description: Replaces the \"default\" WindowProperties with the\n"
    "//               specified structure.  The specified WindowProperties\n"
    "//               will be returned by future calls to get_default(),\n"
    "//               until clear_default() is called.\n"
    "//\n"
    "//               Note that this completely replaces the default\n"
    "//               properties; it is not additive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_default_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void WindowProperties::clear_default(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_default_23(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void WindowProperties::clear_default(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDefault", key_word_list))
        {
            WindowProperties::clear_default();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDefault()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_default_23_comment =
    "C++ Interface:\n"
    "clearDefault()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_default\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the \"default\" WindowProperties to whatever\n"
    "//               is specified in the user's config file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_default_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static WindowProperties WindowProperties::size(int x_size, int y_size)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_size_24(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static WindowProperties WindowProperties::size(int x_size, int y_size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:size", key_word_list, &param0, &param1))
        {
            WindowProperties result = WindowProperties::size((int)param0, (int)param1);
            WindowProperties *return_value = new WindowProperties(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_size_24_comment =
    "C++ Interface:\n"
    "size(int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::size\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a WindowProperties structure with only the\n"
    "//               size specified.  The size is the only property that\n"
    "//               matters to buffers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_size_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool WindowProperties::operator ==(WindowProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_operator_25(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool WindowProperties::operator ==(WindowProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                WindowProperties *param1_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowProperties, 1, "WindowProperties.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const WindowProperties*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const WindowProperties this, const WindowProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_operator_25_comment =
    "C++ Interface:\n"
    "eq(const WindowProperties this, const WindowProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::operator == \n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_operator_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::operator !=(WindowProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_operator_26(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool WindowProperties::operator !=(WindowProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                WindowProperties *param1_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowProperties, 1, "WindowProperties.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const WindowProperties*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const WindowProperties this, const WindowProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_operator_26_comment =
    "C++ Interface:\n"
    "ne(const WindowProperties this, const WindowProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_operator_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WindowProperties::clear(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_27(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void WindowProperties::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_27_comment =
    "C++ Interface:\n"
    "clear(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear\n"
    "//       Access: Published\n"
    "//  Description: Unsets all properties that have been specified so\n"
    "//               far, and resets the WindowProperties structure to its\n"
    "//               initial empty state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::is_any_specified(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_is_any_specified_28(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::is_any_specified(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAnySpecified", key_word_list));
        else
            (PyArg_Parse(args, ":isAnySpecified"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->is_any_specified();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAnySpecified(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_is_any_specified_28_comment =
    "C++ Interface:\n"
    "isAnySpecified(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::is_any_specified\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any properties have been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_is_any_specified_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_origin(int x_origin, int y_origin)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_origin_29(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_origin(int x_origin, int y_origin)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x_origin", (char *)"y_origin", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setOrigin", key_word_list, &param1, &param2))
        {
            (local_this)->set_origin((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setOrigin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOrigin(non-const WindowProperties this, int x_origin, int y_origin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_origin_29_comment =
    "C++ Interface:\n"
    "setOrigin(non-const WindowProperties this, int x_origin, int y_origin)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_origin\n"
    "//       Access: Published\n"
    "//  Description: Specifies the origin on the screen (in pixels,\n"
    "//               relative to the top-left corner) at which the window\n"
    "//               should appear.  This is the origin of the top-left\n"
    "//               corner of the useful part of the window, not\n"
    "//               including decorations.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_origin_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WindowProperties::get_x_origin(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_x_origin_30(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WindowProperties::get_x_origin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":getXOrigin"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WindowProperties*)local_this)->get_x_origin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXOrigin(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_x_origin_30_comment =
    "C++ Interface:\n"
    "getXOrigin(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_x_origin\n"
    "//       Access: Published\n"
    "//  Description: Returns the x coordinate of the window's top-left\n"
    "//               corner, not including decorations.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_x_origin_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WindowProperties::get_y_origin(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_y_origin_31(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WindowProperties::get_y_origin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getYOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":getYOrigin"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WindowProperties*)local_this)->get_y_origin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYOrigin(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_y_origin_31_comment =
    "C++ Interface:\n"
    "getYOrigin(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_y_origin\n"
    "//       Access: Published\n"
    "//  Description: Returns the y coordinate of the window's top-left\n"
    "//               corner, not including decorations.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_y_origin_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_origin(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_origin_32(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_origin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":hasOrigin"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_origin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasOrigin(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_origin_32_comment =
    "C++ Interface:\n"
    "hasOrigin(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_origin\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window origin has been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_origin_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_origin(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_origin_33(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_origin(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":clearOrigin"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_origin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearOrigin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearOrigin(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_origin_33_comment =
    "C++ Interface:\n"
    "clearOrigin(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_origin\n"
    "//       Access: Published\n"
    "//  Description: Removes the origin specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_origin_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_size(int x_size, int y_size)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_size_34(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_size(int x_size, int y_size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_size((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSize(non-const WindowProperties this, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_size_34_comment =
    "C++ Interface:\n"
    "setSize(non-const WindowProperties this, int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_size\n"
    "//       Access: Published\n"
    "//  Description: Specifies the requested size of the window, in\n"
    "//               pixels.  This is the size of the useful part of the\n"
    "//               window, not including decorations.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_size_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WindowProperties::get_x_size(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_x_size_35(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WindowProperties::get_x_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXSize", key_word_list));
        else
            (PyArg_Parse(args, ":getXSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WindowProperties*)local_this)->get_x_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXSize(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_x_size_35_comment =
    "C++ Interface:\n"
    "getXSize(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_x_size\n"
    "//       Access: Published\n"
    "//  Description: Returns size in pixels in the x dimension of the\n"
    "//               useful part of the window, not including decorations.\n"
    "//               That is, this is the window's width.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_x_size_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WindowProperties::get_y_size(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_y_size_36(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WindowProperties::get_y_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getYSize", key_word_list));
        else
            (PyArg_Parse(args, ":getYSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WindowProperties*)local_this)->get_y_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYSize(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_y_size_36_comment =
    "C++ Interface:\n"
    "getYSize(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_y_size\n"
    "//       Access: Published\n"
    "//  Description: Returns size in pixels in the y dimension of the\n"
    "//               useful part of the window, not including decorations.\n"
    "//               That is, this is the window's height.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_y_size_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_size(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_size_37(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSize", key_word_list));
        else
            (PyArg_Parse(args, ":hasSize"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSize(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_size_37_comment =
    "C++ Interface:\n"
    "hasSize(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_size\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window size has been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_size_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_size(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_size_38(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSize", key_word_list));
        else
            (PyArg_Parse(args, ":clearSize"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSize(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_size_38_comment =
    "C++ Interface:\n"
    "clearSize(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_size\n"
    "//       Access: Published\n"
    "//  Description: Removes the size specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_size_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_mouse_mode(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_mouse_mode_39(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_mouse_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMouseMode", key_word_list));
        else
            (PyArg_Parse(args, ":hasMouseMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_mouse_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMouseMode(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_mouse_mode_39_comment =
    "C++ Interface:\n"
    "hasMouseMode(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_mouse_mode\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_mouse_mode_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_mouse_mode(WindowProperties::MouseMode mode)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_mouse_mode_40(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_mouse_mode(WindowProperties::MouseMode mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMouseMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMouseMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mouse_mode((WindowProperties::MouseMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setMouseMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMouseMode(non-const WindowProperties this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_mouse_mode_40_comment =
    "C++ Interface:\n"
    "setMouseMode(non-const WindowProperties this, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_mouse_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies the mode in which the window is to operate\n"
    "//               its mouse pointer.  The default is M_absolute, which\n"
    "//               is the normal mode in which a mouse pointer operates;\n"
    "//               but you can also set M_relative, which is\n"
    "//               particularly useful for FPS-style mouse movements\n"
    "//               where you have hidden the mouse pointer and are are\n"
    "//               more interested in how fast the mouse is moving,\n"
    "//               rather than precisely where the pointer is hovering.\n"
    "//\n"
    "//               This has no effect on Windows, which does not\n"
    "//               have this concept; but is important to do on OSX\n"
    "//               and Unix/X11 to properly enable a smooth FPS-style\n"
    "//               mouselook mode.  On Unix/X11, this requires the\n"
    "//               Xxf86dga extension to be available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_mouse_mode_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline WindowProperties::MouseMode WindowProperties::get_mouse_mode(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_mouse_mode_41(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline WindowProperties::MouseMode WindowProperties::get_mouse_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouseMode", key_word_list));
        else
            (PyArg_Parse(args, ":getMouseMode"));
        if(!PyErr_Occurred())
        {
            WindowProperties::MouseMode return_value = ((const WindowProperties*)local_this)->get_mouse_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouseMode(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_mouse_mode_41_comment =
    "C++ Interface:\n"
    "getMouseMode(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_mouse_mode\n"
    "//       Access: Published\n"
    "//  Description: See set_mouse_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_mouse_mode_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_mouse_mode(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_mouse_mode_42(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_mouse_mode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearMouseMode", key_word_list));
        else
            (PyArg_Parse(args, ":clearMouseMode"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_mouse_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearMouseMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearMouseMode(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_mouse_mode_42_comment =
    "C++ Interface:\n"
    "clearMouseMode(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_mouse_mode\n"
    "//       Access: Published\n"
    "//  Description: Removes the mouse_mode specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_mouse_mode_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_title(basic_string< char > const &title)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_title_43(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_title(basic_string< char > const &title)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"title", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setTitle", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setTitle", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_title(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setTitle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTitle(non-const WindowProperties this, string title)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_title_43_comment =
    "C++ Interface:\n"
    "setTitle(non-const WindowProperties this, string title)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_title\n"
    "//       Access: Published\n"
    "//  Description: Specifies the title that should be assigned to the\n"
    "//               window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_title_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &WindowProperties::get_title(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_title_44(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &WindowProperties::get_title(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTitle", key_word_list));
        else
            (PyArg_Parse(args, ":getTitle"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const WindowProperties*)local_this)->get_title();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTitle(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_title_44_comment =
    "C++ Interface:\n"
    "getTitle(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_title\n"
    "//       Access: Published\n"
    "//  Description: Returns the window's title.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_title_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_title(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_title_45(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_title(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTitle", key_word_list));
        else
            (PyArg_Parse(args, ":hasTitle"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_title();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTitle(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_title_45_comment =
    "C++ Interface:\n"
    "hasTitle(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_title\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window title has been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_title_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_title(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_title_46(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_title(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTitle", key_word_list));
        else
            (PyArg_Parse(args, ":clearTitle"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_title();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearTitle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTitle(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_title_46_comment =
    "C++ Interface:\n"
    "clearTitle(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_title\n"
    "//       Access: Published\n"
    "//  Description: Removes the title specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_title_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_undecorated(bool undecorated)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_undecorated_47(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_undecorated(bool undecorated)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"undecorated", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUndecorated", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUndecorated", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_undecorated((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setUndecorated() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUndecorated(non-const WindowProperties this, bool undecorated)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_undecorated_47_comment =
    "C++ Interface:\n"
    "setUndecorated(non-const WindowProperties this, bool undecorated)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_undecorated\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should be created with a\n"
    "//               visible title and border (false, the default) or not\n"
    "//               (true).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_undecorated_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_undecorated(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_undecorated_48(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_undecorated(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUndecorated", key_word_list));
        else
            (PyArg_Parse(args, ":getUndecorated"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_undecorated();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUndecorated(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_undecorated_48_comment =
    "C++ Interface:\n"
    "getUndecorated(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_undecorated\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window has no border.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_undecorated_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_undecorated(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_undecorated_49(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_undecorated(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasUndecorated", key_word_list));
        else
            (PyArg_Parse(args, ":hasUndecorated"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_undecorated();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasUndecorated(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_undecorated_49_comment =
    "C++ Interface:\n"
    "hasUndecorated(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_undecorated\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_undecorated() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_undecorated_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_undecorated(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_undecorated_50(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_undecorated(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearUndecorated", key_word_list));
        else
            (PyArg_Parse(args, ":clearUndecorated"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_undecorated();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearUndecorated() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearUndecorated(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_undecorated_50_comment =
    "C++ Interface:\n"
    "clearUndecorated(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_undecorated\n"
    "//       Access: Published\n"
    "//  Description: Removes the undecorated specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_undecorated_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_fixed_size(bool fixed_size)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_fixed_size_51(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_fixed_size(bool fixed_size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"fixed_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFixedSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFixedSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fixed_size((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setFixedSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFixedSize(non-const WindowProperties this, bool fixed_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_fixed_size_51_comment =
    "C++ Interface:\n"
    "setFixedSize(non-const WindowProperties this, bool fixed_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_fixed_size\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should be resizable by\n"
    "//               the user.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_fixed_size_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_fixed_size(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_fixed_size_52(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_fixed_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFixedSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFixedSize"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_fixed_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFixedSize(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_fixed_size_52_comment =
    "C++ Interface:\n"
    "getFixedSize(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_fixed_size\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window cannot be resized by the\n"
    "//               user, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_fixed_size_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_fixed_size(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_fixed_size_53(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_fixed_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasFixedSize", key_word_list));
        else
            (PyArg_Parse(args, ":hasFixedSize"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_fixed_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFixedSize(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_fixed_size_53_comment =
    "C++ Interface:\n"
    "hasFixedSize(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_fixed_size\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_fixed_size() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_fixed_size_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_fixed_size(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_fixed_size_54(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_fixed_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFixedSize", key_word_list));
        else
            (PyArg_Parse(args, ":clearFixedSize"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_fixed_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearFixedSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFixedSize(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_fixed_size_54_comment =
    "C++ Interface:\n"
    "clearFixedSize(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_fixed_size\n"
    "//       Access: Published\n"
    "//  Description: Removes the fixed_size specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_fixed_size_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_fullscreen(bool fullscreen)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_fullscreen_55(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_fullscreen(bool fullscreen)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"fullscreen", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFullscreen", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFullscreen", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fullscreen((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setFullscreen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFullscreen(non-const WindowProperties this, bool fullscreen)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_fullscreen_55_comment =
    "C++ Interface:\n"
    "setFullscreen(non-const WindowProperties this, bool fullscreen)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_fullscreen\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should be opened in\n"
    "//               fullscreen mode (true) or normal windowed mode\n"
    "//               (false, the default).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_fullscreen_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_fullscreen(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_fullscreen_56(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_fullscreen(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullscreen", key_word_list));
        else
            (PyArg_Parse(args, ":getFullscreen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_fullscreen();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullscreen(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_fullscreen_56_comment =
    "C++ Interface:\n"
    "getFullscreen(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_fullscreen\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window is in fullscreen mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_fullscreen_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_fullscreen(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_fullscreen_57(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_fullscreen(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasFullscreen", key_word_list));
        else
            (PyArg_Parse(args, ":hasFullscreen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_fullscreen();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFullscreen(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_fullscreen_57_comment =
    "C++ Interface:\n"
    "hasFullscreen(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_fullscreen\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_fullscreen() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_fullscreen_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_fullscreen(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_fullscreen_58(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_fullscreen(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFullscreen", key_word_list));
        else
            (PyArg_Parse(args, ":clearFullscreen"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_fullscreen();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearFullscreen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFullscreen(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_fullscreen_58_comment =
    "C++ Interface:\n"
    "clearFullscreen(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_fullscreen\n"
    "//       Access: Published\n"
    "//  Description: Removes the fullscreen specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_fullscreen_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_foreground(bool foreground)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_foreground_59(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_foreground(bool foreground)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"foreground", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setForeground", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setForeground", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_foreground((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setForeground() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForeground(non-const WindowProperties this, bool foreground)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_foreground_59_comment =
    "C++ Interface:\n"
    "setForeground(non-const WindowProperties this, bool foreground)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_foreground\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should be opened in\n"
    "//               the foreground (true), or left in the background\n"
    "//               (false).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_foreground_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_foreground(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_foreground_60(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_foreground(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForeground", key_word_list));
        else
            (PyArg_Parse(args, ":getForeground"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_foreground();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForeground(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_foreground_60_comment =
    "C++ Interface:\n"
    "getForeground(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_foreground\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window is in the foreground.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_foreground_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_foreground(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_foreground_61(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_foreground(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasForeground", key_word_list));
        else
            (PyArg_Parse(args, ":hasForeground"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_foreground();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasForeground(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_foreground_61_comment =
    "C++ Interface:\n"
    "hasForeground(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_foreground\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_foreground() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_foreground_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_foreground(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_foreground_62(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_foreground(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearForeground", key_word_list));
        else
            (PyArg_Parse(args, ":clearForeground"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_foreground();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearForeground() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearForeground(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_foreground_62_comment =
    "C++ Interface:\n"
    "clearForeground(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_foreground\n"
    "//       Access: Published\n"
    "//  Description: Removes the foreground specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_foreground_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_minimized(bool minimized)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_minimized_63(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_minimized(bool minimized)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"minimized", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMinimized", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setMinimized", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_minimized((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setMinimized() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinimized(non-const WindowProperties this, bool minimized)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_minimized_63_comment =
    "C++ Interface:\n"
    "setMinimized(non-const WindowProperties this, bool minimized)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_minimized\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should be created\n"
    "//               minimized (true), or normal (false).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_minimized_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_minimized(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_minimized_64(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_minimized(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinimized", key_word_list));
        else
            (PyArg_Parse(args, ":getMinimized"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_minimized();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinimized(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_minimized_64_comment =
    "C++ Interface:\n"
    "getMinimized(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_minimized\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window is minimized.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_minimized_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_minimized(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_minimized_65(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_minimized(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMinimized", key_word_list));
        else
            (PyArg_Parse(args, ":hasMinimized"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_minimized();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMinimized(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_minimized_65_comment =
    "C++ Interface:\n"
    "hasMinimized(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_minimized\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_minimized() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_minimized_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_minimized(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_minimized_66(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_minimized(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearMinimized", key_word_list));
        else
            (PyArg_Parse(args, ":clearMinimized"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_minimized();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearMinimized() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearMinimized(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_minimized_66_comment =
    "C++ Interface:\n"
    "clearMinimized(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_minimized\n"
    "//       Access: Published\n"
    "//  Description: Removes the minimized specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_minimized_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_raw_mice(bool raw_mice)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_raw_mice_67(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_raw_mice(bool raw_mice)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"raw_mice", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRawMice", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRawMice", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_raw_mice((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setRawMice() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRawMice(non-const WindowProperties this, bool raw_mice)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_raw_mice_67_comment =
    "C++ Interface:\n"
    "setRawMice(non-const WindowProperties this, bool raw_mice)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_raw_mice\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should read the raw\n"
    "//               mouse devices.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_raw_mice_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_raw_mice(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_raw_mice_68(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_raw_mice(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRawMice", key_word_list));
        else
            (PyArg_Parse(args, ":getRawMice"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_raw_mice();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRawMice(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_raw_mice_68_comment =
    "C++ Interface:\n"
    "getRawMice(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_raw_mice\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window reads the raw mice.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_raw_mice_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_raw_mice(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_raw_mice_69(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_raw_mice(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasRawMice", key_word_list));
        else
            (PyArg_Parse(args, ":hasRawMice"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_raw_mice();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasRawMice(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_raw_mice_69_comment =
    "C++ Interface:\n"
    "hasRawMice(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_raw_mice\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_raw_mice() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_raw_mice_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_raw_mice(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_raw_mice_70(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_raw_mice(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearRawMice", key_word_list));
        else
            (PyArg_Parse(args, ":clearRawMice"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_raw_mice();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearRawMice() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRawMice(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_raw_mice_70_comment =
    "C++ Interface:\n"
    "clearRawMice(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_raw_mice\n"
    "//       Access: Published\n"
    "//  Description: Removes the raw_mice specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_raw_mice_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_open(bool open)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_open_71(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_open(bool open)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"open", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOpen", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setOpen", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_open((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setOpen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOpen(non-const WindowProperties this, bool open)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_open_71_comment =
    "C++ Interface:\n"
    "setOpen(non-const WindowProperties this, bool open)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_open\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the window should be open.  It is\n"
    "//               legal to create a GraphicsWindow in the closed state,\n"
    "//               and later request it to open by changing this flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_open_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_open(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_open_72(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_open(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOpen", key_word_list));
        else
            (PyArg_Parse(args, ":getOpen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_open();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOpen(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_open_72_comment =
    "C++ Interface:\n"
    "getOpen(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_open\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window is open.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_open_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_open(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_open_73(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_open(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasOpen", key_word_list));
        else
            (PyArg_Parse(args, ":hasOpen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_open();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasOpen(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_open_73_comment =
    "C++ Interface:\n"
    "hasOpen(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_open\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_open() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_open_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_open(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_open_74(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearOpen", key_word_list));
        else
            (PyArg_Parse(args, ":clearOpen"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_open();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearOpen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearOpen(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_open_74_comment =
    "C++ Interface:\n"
    "clearOpen(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_open\n"
    "//       Access: Published\n"
    "//  Description: Removes the open specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_open_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_cursor_hidden(bool cursor_hidden)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_cursor_hidden_75(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_cursor_hidden(bool cursor_hidden)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"cursor_hidden", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCursorHidden", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCursorHidden", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cursor_hidden((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setCursorHidden() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCursorHidden(non-const WindowProperties this, bool cursor_hidden)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_cursor_hidden_75_comment =
    "C++ Interface:\n"
    "setCursorHidden(non-const WindowProperties this, bool cursor_hidden)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_cursor_hidden\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the mouse cursor should be visible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_cursor_hidden_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::get_cursor_hidden(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_cursor_hidden_76(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::get_cursor_hidden(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorHidden", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorHidden"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->get_cursor_hidden();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorHidden(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_cursor_hidden_76_comment =
    "C++ Interface:\n"
    "getCursorHidden(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_cursor_hidden\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse cursor is invisible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_cursor_hidden_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_cursor_hidden(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_cursor_hidden_77(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_cursor_hidden(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCursorHidden", key_word_list));
        else
            (PyArg_Parse(args, ":hasCursorHidden"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_cursor_hidden();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCursorHidden(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_cursor_hidden_77_comment =
    "C++ Interface:\n"
    "hasCursorHidden(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_cursor_hidden\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_cursor_hidden() has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_cursor_hidden_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_cursor_hidden(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_cursor_hidden_78(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_cursor_hidden(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCursorHidden", key_word_list));
        else
            (PyArg_Parse(args, ":clearCursorHidden"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_cursor_hidden();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearCursorHidden() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCursorHidden(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_cursor_hidden_78_comment =
    "C++ Interface:\n"
    "clearCursorHidden(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_cursor_hidden\n"
    "//       Access: Published\n"
    "//  Description: Removes the cursor_hidden specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_cursor_hidden_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_icon_filename(Filename const &icon_filename)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_icon_filename_79(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void WindowProperties::set_icon_filename(Filename const &icon_filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"icon_filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIconFilename", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setIconFilename", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "WindowProperties.setIconFilename", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_icon_filename(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WindowProperties.setIconFilename() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIconFilename(non-const WindowProperties this, const Filename icon_filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_icon_filename_79_comment =
    "C++ Interface:\n"
    "setIconFilename(non-const WindowProperties this, const Filename icon_filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_icon_filename\n"
    "//       Access: Published\n"
    "//  Description: Specifies the file that contains the icon to\n"
    "//               associate with the window when it is minimized.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_icon_filename_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &WindowProperties::get_icon_filename(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_icon_filename_80(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &WindowProperties::get_icon_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIconFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getIconFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const WindowProperties*)local_this)->get_icon_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIconFilename(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_icon_filename_80_comment =
    "C++ Interface:\n"
    "getIconFilename(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_icon_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the icon filename associated with the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_icon_filename_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_icon_filename(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_icon_filename_81(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_icon_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasIconFilename", key_word_list));
        else
            (PyArg_Parse(args, ":hasIconFilename"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_icon_filename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasIconFilename(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_icon_filename_81_comment =
    "C++ Interface:\n"
    "hasIconFilename(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_icon_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_icon_filename() has been\n"
    "//               specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_icon_filename_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_icon_filename(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_icon_filename_82(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_icon_filename(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearIconFilename", key_word_list));
        else
            (PyArg_Parse(args, ":clearIconFilename"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_icon_filename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearIconFilename() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearIconFilename(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_icon_filename_82_comment =
    "C++ Interface:\n"
    "clearIconFilename(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_icon_filename\n"
    "//       Access: Published\n"
    "//  Description: Removes the icon_filename specification from the\n"
    "//               properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_icon_filename_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_cursor_filename(Filename const &cursor_filename)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_cursor_filename_83(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void WindowProperties::set_cursor_filename(Filename const &cursor_filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cursor_filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCursorFilename", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCursorFilename", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "WindowProperties.setCursorFilename", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_cursor_filename(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WindowProperties.setCursorFilename() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCursorFilename(non-const WindowProperties this, const Filename cursor_filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_cursor_filename_83_comment =
    "C++ Interface:\n"
    "setCursorFilename(non-const WindowProperties this, const Filename cursor_filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_cursor_filename\n"
    "//       Access: Published\n"
    "//  Description: Specifies the file that contains the icon to\n"
    "//               associate with the mouse cursor when it is within the\n"
    "//               window (and visible).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_cursor_filename_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &WindowProperties::get_cursor_filename(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_cursor_filename_84(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &WindowProperties::get_cursor_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const WindowProperties*)local_this)->get_cursor_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorFilename(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_cursor_filename_84_comment =
    "C++ Interface:\n"
    "getCursorFilename(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_cursor_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the icon filename associated with the mouse\n"
    "//               cursor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_cursor_filename_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_cursor_filename(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_cursor_filename_85(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_cursor_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCursorFilename", key_word_list));
        else
            (PyArg_Parse(args, ":hasCursorFilename"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_cursor_filename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCursorFilename(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_cursor_filename_85_comment =
    "C++ Interface:\n"
    "hasCursorFilename(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_cursor_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_cursor_filename() has been\n"
    "//               specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_cursor_filename_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_cursor_filename(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_cursor_filename_86(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_cursor_filename(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCursorFilename", key_word_list));
        else
            (PyArg_Parse(args, ":clearCursorFilename"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_cursor_filename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearCursorFilename() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCursorFilename(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_cursor_filename_86_comment =
    "C++ Interface:\n"
    "clearCursorFilename(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_cursor_filename\n"
    "//       Access: Published\n"
    "//  Description: Removes the cursor_filename specification from the\n"
    "//               properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_cursor_filename_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_z_order(WindowProperties::ZOrder z_order)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_z_order_87(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::set_z_order(WindowProperties::ZOrder z_order)
        int param1;
        static char * key_word_list[] = {(char *)"z_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setZOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setZOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_z_order((WindowProperties::ZOrder)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.setZOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZOrder(non-const WindowProperties this, int z_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_z_order_87_comment =
    "C++ Interface:\n"
    "setZOrder(non-const WindowProperties this, int z_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_z_order\n"
    "//       Access: Published\n"
    "//  Description: Specifies the relative ordering of the window with\n"
    "//               respect to other windows.  If the z_order is Z_top,\n"
    "//               the window will always be on top of other windows; if\n"
    "//               it is Z_bottom, it will always be below other\n"
    "//               windows.  Most windows will want to be Z_normal,\n"
    "//               which allows the user to control the order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_z_order_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline WindowProperties::ZOrder WindowProperties::get_z_order(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_z_order_88(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline WindowProperties::ZOrder WindowProperties::get_z_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getZOrder"));
        if(!PyErr_Occurred())
        {
            WindowProperties::ZOrder return_value = ((const WindowProperties*)local_this)->get_z_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZOrder(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_z_order_88_comment =
    "C++ Interface:\n"
    "getZOrder(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_z_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the window's z_order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_z_order_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_z_order(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_z_order_89(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_z_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasZOrder", key_word_list));
        else
            (PyArg_Parse(args, ":hasZOrder"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_z_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasZOrder(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_z_order_89_comment =
    "C++ Interface:\n"
    "hasZOrder(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_z_order\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window z_order has been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_z_order_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_z_order(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_z_order_90(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_z_order(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearZOrder", key_word_list));
        else
            (PyArg_Parse(args, ":clearZOrder"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_z_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearZOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearZOrder(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_z_order_90_comment =
    "C++ Interface:\n"
    "clearZOrder(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_z_order\n"
    "//       Access: Published\n"
    "//  Description: Removes the z_order specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_z_order_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
 * inline void WindowProperties::set_parent_window(WindowHandle *parent_window = ((void *)(0)))
 * void WindowProperties::set_parent_window(unsigned int parent)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_set_parent_window_91(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void WindowProperties::set_parent_window(WindowHandle *parent_window = ((void *)(0)))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setParentWindow", key_word_list));
            else
                (PyArg_Parse(args, ":setParentWindow"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_parent_window();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WindowProperties.setParentWindow() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"parent_window", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setParentWindow", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setParentWindow", &param1));
                if(!PyErr_Occurred())
                {
                    WindowHandle *param1_this = (WindowHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowHandle, 1, "WindowProperties.setParentWindow", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_parent_window(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void WindowProperties::set_parent_window(unsigned int parent)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"parent", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setParentWindow", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setParentWindow", &param1));
                if(!PyErr_Occurred())
                {
                     PyObject *param1_uint = PyNumber_Long(param1);
                    if (!((param1_uint == NULL)))
                    {
                        (local_this)->set_parent_window(PyLong_AsUnsignedLong(param1_uint));
                         Py_XDECREF(param1_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setParentWindow() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setParentWindow(non-const WindowProperties this)\n"
          "setParentWindow(non-const WindowProperties this, non-const WindowHandle parent_window)\n"
          "setParentWindow(non-const WindowProperties this, unsigned int parent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_set_parent_window_91_comment =
    "C++ Interface:\n"
    "setParentWindow(non-const WindowProperties this)\n"
    "setParentWindow(non-const WindowProperties this, non-const WindowHandle parent_window)\n"
    "setParentWindow(non-const WindowProperties this, unsigned int parent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_parent_window\n"
    "//       Access: Published\n"
    "//  Description: Specifies the window that this window should be\n"
    "//               attached to.  If this is NULL or unspecified, the\n"
    "//               window will be created as a toplevel window on the\n"
    "//               desktop; if this is non-NULL, the window will be\n"
    "//               bound as a child window to the indicated parent\n"
    "//               window.\n"
    "//\n"
    "//               You should use GraphicsPipe::make_window_handle() to\n"
    "//               create an instance of a WindowHandle object given an\n"
    "//               appropriate OS-specific window handle representation.\n"
    "//               Each OS-specific GraphicsPipe class defines a\n"
    "//               make_window_handle() method that returns an\n"
    "//               appropriate WindowHandle object to wrap the\n"
    "//               particular OS-specific representation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::set_parent_window\n"
    "//       Access: Published\n"
    "//  Description: Specifies the window that this window should be\n"
    "//               attached to.\n"
    "//\n"
    "//               This is a deprecated variant on this method, and\n"
    "//               exists only for backward compatibility.  Future code\n"
    "//               should use the version of set_parent_window() below\n"
    "//               that receives a WindowHandle object; that interface\n"
    "//               is much more robust.\n"
    "//\n"
    "//               In this deprecated variant, the actual value for\n"
    "//               \"parent\" is platform-specific.  On Windows, it is the\n"
    "//               HWND of the parent window, cast to an unsigned\n"
    "//               integer.  On X11, it is the Window pointer of the\n"
    "//               parent window, similarly cast.  On OSX, this is the\n"
    "//               NSWindow pointer, which doesn't appear to work at\n"
    "//               all.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_set_parent_window_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline WindowHandle *WindowProperties::get_parent_window(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_get_parent_window_92(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline WindowHandle *WindowProperties::get_parent_window(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParentWindow", key_word_list));
        else
            (PyArg_Parse(args, ":getParentWindow"));
        if(!PyErr_Occurred())
        {
            WindowHandle *return_value = ((const WindowProperties*)local_this)->get_parent_window();
            if (return_value != (WindowHandle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_WindowHandle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParentWindow(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_get_parent_window_92_comment =
    "C++ Interface:\n"
    "getParentWindow(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::get_parent_window\n"
    "//       Access: Published\n"
    "//  Description: Returns the parent window specification, or NULL if\n"
    "//               there is no parent window specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_get_parent_window_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WindowProperties::has_parent_window(void) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_has_parent_window_93(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WindowProperties::has_parent_window(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasParentWindow", key_word_list));
        else
            (PyArg_Parse(args, ":hasParentWindow"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WindowProperties*)local_this)->has_parent_window();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasParentWindow(const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_has_parent_window_93_comment =
    "C++ Interface:\n"
    "hasParentWindow(const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::has_parent_window\n"
    "//       Access: Published\n"
    "//  Description: Checks the S_parent_window specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_has_parent_window_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WindowProperties::clear_parent_window(void)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_clear_parent_window_94(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void WindowProperties::clear_parent_window(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearParentWindow", key_word_list));
        else
            (PyArg_Parse(args, ":clearParentWindow"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_parent_window();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WindowProperties.clearParentWindow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearParentWindow(non-const WindowProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_clear_parent_window_94_comment =
    "C++ Interface:\n"
    "clearParentWindow(non-const WindowProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::clear_parent_window\n"
    "//       Access: Published\n"
    "//  Description: Removes the S_parent_window specification from the properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_clear_parent_window_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WindowProperties::add_properties(WindowProperties const &other)
 *******************************************************************/
static PyObject *Dtool_WindowProperties_add_properties_95(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void WindowProperties::add_properties(WindowProperties const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addProperties", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addProperties", &param1));
            if(!PyErr_Occurred())
            {
                WindowProperties *param1_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowProperties, 1, "WindowProperties.addProperties", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_properties(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WindowProperties.addProperties() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addProperties(non-const WindowProperties this, const WindowProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_add_properties_95_comment =
    "C++ Interface:\n"
    "addProperties(non-const WindowProperties this, const WindowProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::add_properties\n"
    "//       Access: Published\n"
    "//  Description: Sets any properties that are explicitly specified in\n"
    "//               other on this object.  Leaves other properties\n"
    "//               unchanged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_add_properties_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WindowProperties::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_WindowProperties_output_96(PyObject *self, PyObject *args,PyObject *kwds) {
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void WindowProperties::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "WindowProperties.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const WindowProperties*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const WindowProperties this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowProperties_output_96_comment =
    "C++ Interface:\n"
    "output(const WindowProperties this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowProperties::output\n"
    "//       Access: Published\n"
    "//  Description: Sets any properties that are explicitly specified in\n"
    "//               other on this object.  Leaves other properties\n"
    "//               unchanged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowProperties_output_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * WindowProperties::WindowProperties(void)
 * inline WindowProperties::WindowProperties(WindowProperties const &copy)
 *******************************************************************/
int  Dtool_Init_WindowProperties(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-WindowProperties::WindowProperties(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":WindowProperties", key_word_list))
            {
                WindowProperties *return_value = new WindowProperties();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_WindowProperties,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline WindowProperties::WindowProperties(WindowProperties const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:WindowProperties", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:WindowProperties", &param0));
                if(!PyErr_Occurred())
                {
                    WindowProperties *param0_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_WindowProperties, 0, "WindowProperties.WindowProperties", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        WindowProperties *return_value = new WindowProperties(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_WindowProperties,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "WindowProperties() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "WindowProperties()\n"
          "WindowProperties(const WindowProperties copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_WindowProperties(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WindowProperties)
    {
        printf("WindowProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WindowProperties * local_this = (WindowProperties *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WindowProperties)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WindowProperties(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WindowProperties)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DisplayInformation 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_display_state(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_display_state_101(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_display_state(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayState", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayState"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_display_state();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDisplayState() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayState(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_display_state_101_comment =
    "C++ Interface:\n"
    "getDisplayState(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_display_state_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_maximum_window_width(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_maximum_window_width_102(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_maximum_window_width(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaximumWindowWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getMaximumWindowWidth"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_maximum_window_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getMaximumWindowWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaximumWindowWidth(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_maximum_window_width_102_comment =
    "C++ Interface:\n"
    "getMaximumWindowWidth(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_maximum_window_width\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_maximum_window_width_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_maximum_window_height(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_maximum_window_height_103(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_maximum_window_height(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaximumWindowHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getMaximumWindowHeight"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_maximum_window_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getMaximumWindowHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaximumWindowHeight(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_maximum_window_height_103_comment =
    "C++ Interface:\n"
    "getMaximumWindowHeight(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_maximum_window_height\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_maximum_window_height_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_window_bits_per_pixel(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_window_bits_per_pixel_104(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_window_bits_per_pixel(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindowBitsPerPixel", key_word_list));
        else
            (PyArg_Parse(args, ":getWindowBitsPerPixel"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_window_bits_per_pixel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getWindowBitsPerPixel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindowBitsPerPixel(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_window_bits_per_pixel_104_comment =
    "C++ Interface:\n"
    "getWindowBitsPerPixel(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_window_bits_per_pixel\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_window_bits_per_pixel_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_total_display_modes(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_total_display_modes_105(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_total_display_modes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTotalDisplayModes", key_word_list));
        else
            (PyArg_Parse(args, ":getTotalDisplayModes"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_total_display_modes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getTotalDisplayModes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTotalDisplayModes(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_total_display_modes_105_comment =
    "C++ Interface:\n"
    "getTotalDisplayModes(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_total_display_modes\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_total_display_modes_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_display_mode_width(int display_index)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_display_mode_width_106(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_display_mode_width(int display_index)
        int param1;
        static char * key_word_list[] = {(char *)"display_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDisplayModeWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDisplayModeWidth", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_display_mode_width((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDisplayModeWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayModeWidth(non-const DisplayInformation this, int display_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_display_mode_width_106_comment =
    "C++ Interface:\n"
    "getDisplayModeWidth(non-const DisplayInformation this, int display_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_display_mode_width\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_display_mode_width_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_display_mode_height(int display_index)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_display_mode_height_107(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_display_mode_height(int display_index)
        int param1;
        static char * key_word_list[] = {(char *)"display_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDisplayModeHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDisplayModeHeight", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_display_mode_height((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDisplayModeHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayModeHeight(non-const DisplayInformation this, int display_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_display_mode_height_107_comment =
    "C++ Interface:\n"
    "getDisplayModeHeight(non-const DisplayInformation this, int display_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_display_mode_height\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_display_mode_height_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_display_mode_bits_per_pixel(int display_index)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_display_mode_bits_per_pixel_108(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_display_mode_bits_per_pixel(int display_index)
        int param1;
        static char * key_word_list[] = {(char *)"display_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDisplayModeBitsPerPixel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDisplayModeBitsPerPixel", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_display_mode_bits_per_pixel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDisplayModeBitsPerPixel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayModeBitsPerPixel(non-const DisplayInformation this, int display_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_display_mode_bits_per_pixel_108_comment =
    "C++ Interface:\n"
    "getDisplayModeBitsPerPixel(non-const DisplayInformation this, int display_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_display_mode_bits_per_pixel\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_display_mode_bits_per_pixel_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_display_mode_refresh_rate(int display_index)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_display_mode_refresh_rate_109(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_display_mode_refresh_rate(int display_index)
        int param1;
        static char * key_word_list[] = {(char *)"display_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDisplayModeRefreshRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDisplayModeRefreshRate", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_display_mode_refresh_rate((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDisplayModeRefreshRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayModeRefreshRate(non-const DisplayInformation this, int display_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_display_mode_refresh_rate_109_comment =
    "C++ Interface:\n"
    "getDisplayModeRefreshRate(non-const DisplayInformation this, int display_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_display_mode_refresh_rate\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_display_mode_refresh_rate_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_display_mode_fullscreen_only(int display_index)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_display_mode_fullscreen_only_110(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_display_mode_fullscreen_only(int display_index)
        int param1;
        static char * key_word_list[] = {(char *)"display_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDisplayModeFullscreenOnly", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDisplayModeFullscreenOnly", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_display_mode_fullscreen_only((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDisplayModeFullscreenOnly() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayModeFullscreenOnly(non-const DisplayInformation this, int display_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_display_mode_fullscreen_only_110_comment =
    "C++ Interface:\n"
    "getDisplayModeFullscreenOnly(non-const DisplayInformation this, int display_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_display_mode_fullscreen_only\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_display_mode_fullscreen_only_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_shader_model(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_shader_model_111(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_shader_model(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShaderModel", key_word_list));
        else
            (PyArg_Parse(args, ":getShaderModel"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_shader_model();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getShaderModel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShaderModel(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_shader_model_111_comment =
    "C++ Interface:\n"
    "getShaderModel(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_shader_model\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_shader_model_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_video_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_video_memory_112(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_video_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVideoMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getVideoMemory"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_video_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getVideoMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVideoMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_video_memory_112_comment =
    "C++ Interface:\n"
    "getVideoMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_video_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_video_memory_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_texture_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_texture_memory_113(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_texture_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureMemory"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_texture_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getTextureMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_texture_memory_113_comment =
    "C++ Interface:\n"
    "getTextureMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_texture_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_texture_memory_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplayInformation::update_memory_information(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_update_memory_information_114(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplayInformation::update_memory_information(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":updateMemoryInformation", key_word_list));
        else
            (PyArg_Parse(args, ":updateMemoryInformation"));
        if(!PyErr_Occurred())
        {
            (local_this)->update_memory_information();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.updateMemoryInformation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateMemoryInformation(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_update_memory_information_114_comment =
    "C++ Interface:\n"
    "updateMemoryInformation(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::update_memory_information\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_update_memory_information_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_physical_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_physical_memory_115(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_physical_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicalMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicalMemory"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_physical_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getPhysicalMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicalMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_physical_memory_115_comment =
    "C++ Interface:\n"
    "getPhysicalMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_physical_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_physical_memory_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_available_physical_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_available_physical_memory_116(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_available_physical_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAvailablePhysicalMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getAvailablePhysicalMemory"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_available_physical_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getAvailablePhysicalMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAvailablePhysicalMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_available_physical_memory_116_comment =
    "C++ Interface:\n"
    "getAvailablePhysicalMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_available_physical_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_available_physical_memory_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_page_file_size(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_page_file_size_117(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_page_file_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageFileSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPageFileSize"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_page_file_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getPageFileSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageFileSize(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_page_file_size_117_comment =
    "C++ Interface:\n"
    "getPageFileSize(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_page_file_size\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_page_file_size_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_available_page_file_size(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_available_page_file_size_118(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_available_page_file_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAvailablePageFileSize", key_word_list));
        else
            (PyArg_Parse(args, ":getAvailablePageFileSize"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_available_page_file_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getAvailablePageFileSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAvailablePageFileSize(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_available_page_file_size_118_comment =
    "C++ Interface:\n"
    "getAvailablePageFileSize(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_available_page_file_size\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_available_page_file_size_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_process_virtual_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_process_virtual_memory_119(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_process_virtual_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProcessVirtualMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getProcessVirtualMemory"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_process_virtual_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getProcessVirtualMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProcessVirtualMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_process_virtual_memory_119_comment =
    "C++ Interface:\n"
    "getProcessVirtualMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::_process_virtual_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_process_virtual_memory_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_available_process_virtual_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_available_process_virtual_memory_120(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_available_process_virtual_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAvailableProcessVirtualMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getAvailableProcessVirtualMemory"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_available_process_virtual_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getAvailableProcessVirtualMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAvailableProcessVirtualMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_available_process_virtual_memory_120_comment =
    "C++ Interface:\n"
    "getAvailableProcessVirtualMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_available_process_virtual_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_available_process_virtual_memory_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_memory_load(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_memory_load_121(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_memory_load(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMemoryLoad", key_word_list));
        else
            (PyArg_Parse(args, ":getMemoryLoad"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_memory_load();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getMemoryLoad() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMemoryLoad(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_memory_load_121_comment =
    "C++ Interface:\n"
    "getMemoryLoad(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_memory_load\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_memory_load_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_page_fault_count(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_page_fault_count_122(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_page_fault_count(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageFaultCount", key_word_list));
        else
            (PyArg_Parse(args, ":getPageFaultCount"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_page_fault_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getPageFaultCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageFaultCount(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_page_fault_count_122_comment =
    "C++ Interface:\n"
    "getPageFaultCount(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_page_fault_count\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_page_fault_count_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_process_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_process_memory_123(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_process_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProcessMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getProcessMemory"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_process_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getProcessMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProcessMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_process_memory_123_comment =
    "C++ Interface:\n"
    "getProcessMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_process_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_process_memory_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_peak_process_memory(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_peak_process_memory_124(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_peak_process_memory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPeakProcessMemory", key_word_list));
        else
            (PyArg_Parse(args, ":getPeakProcessMemory"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_peak_process_memory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getPeakProcessMemory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPeakProcessMemory(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_peak_process_memory_124_comment =
    "C++ Interface:\n"
    "getPeakProcessMemory(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_peak_process_memory\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_peak_process_memory_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_page_file_usage(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_page_file_usage_125(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_page_file_usage(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageFileUsage", key_word_list));
        else
            (PyArg_Parse(args, ":getPageFileUsage"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_page_file_usage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getPageFileUsage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageFileUsage(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_page_file_usage_125_comment =
    "C++ Interface:\n"
    "getPageFileUsage(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_page_file_usage\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_page_file_usage_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_peak_page_file_usage(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_peak_page_file_usage_126(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_peak_page_file_usage(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPeakPageFileUsage", key_word_list));
        else
            (PyArg_Parse(args, ":getPeakPageFileUsage"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_peak_page_file_usage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getPeakPageFileUsage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPeakPageFileUsage(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_peak_page_file_usage_126_comment =
    "C++ Interface:\n"
    "getPeakPageFileUsage(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_peak_page_file_usage\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_peak_page_file_usage_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_vendor_id(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_vendor_id_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_vendor_id(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVendorId", key_word_list));
        else
            (PyArg_Parse(args, ":getVendorId"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_vendor_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getVendorId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVendorId(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_vendor_id_127_comment =
    "C++ Interface:\n"
    "getVendorId(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_vendor_id\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_vendor_id_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_device_id(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_device_id_128(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_device_id(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDeviceId", key_word_list));
        else
            (PyArg_Parse(args, ":getDeviceId"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_device_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDeviceId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDeviceId(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_device_id_128_comment =
    "C++ Interface:\n"
    "getDeviceId(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_device_id\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_device_id_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_product(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_product_129(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_product(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverProduct", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverProduct"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_product();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverProduct() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverProduct(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_product_129_comment =
    "C++ Interface:\n"
    "getDriverProduct(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_product\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_product_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_version(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_version_130(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_version(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverVersion", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverVersion"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverVersion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverVersion(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_version_130_comment =
    "C++ Interface:\n"
    "getDriverVersion(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_version\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_version_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_sub_version(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_sub_version_131(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_sub_version(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverSubVersion", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverSubVersion"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_sub_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverSubVersion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverSubVersion(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_sub_version_131_comment =
    "C++ Interface:\n"
    "getDriverSubVersion(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_sub_version\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_sub_version_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_build(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_build_132(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_build(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverBuild", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverBuild"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_build();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverBuild() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverBuild(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_build_132_comment =
    "C++ Interface:\n"
    "getDriverBuild(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_build\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_build_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_date_month(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_date_month_133(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_date_month(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverDateMonth", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverDateMonth"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_date_month();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverDateMonth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverDateMonth(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_date_month_133_comment =
    "C++ Interface:\n"
    "getDriverDateMonth(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_date_month\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_date_month_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_date_day(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_date_day_134(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_date_day(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverDateDay", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverDateDay"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_date_day();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverDateDay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverDateDay(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_date_day_134_comment =
    "C++ Interface:\n"
    "getDriverDateDay(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_date_day\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_date_day_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_driver_date_year(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_driver_date_year_135(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_driver_date_year(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDriverDateYear", key_word_list));
        else
            (PyArg_Parse(args, ":getDriverDateYear"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_driver_date_year();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getDriverDateYear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDriverDateYear(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_driver_date_year_135_comment =
    "C++ Interface:\n"
    "getDriverDateYear(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_driver_date_year\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_driver_date_year_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_cpu_id_version(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_id_version_136(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_cpu_id_version(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuIdVersion", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuIdVersion"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_cpu_id_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuIdVersion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuIdVersion(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_id_version_136_comment =
    "C++ Interface:\n"
    "getCpuIdVersion(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_id_version\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_id_version_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_cpu_id_size(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_id_size_137(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_cpu_id_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuIdSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuIdSize"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_cpu_id_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuIdSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuIdSize(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_id_size_137_comment =
    "C++ Interface:\n"
    "getCpuIdSize(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_id_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of 32-bit values for cpu id \n"
    "//               binary data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_id_size_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DisplayInformation::get_cpu_id_data(int index)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_id_data_138(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DisplayInformation::get_cpu_id_data(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCpuIdData", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCpuIdData", &param1));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_cpu_id_data((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuIdData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuIdData(non-const DisplayInformation this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_id_data_138_comment =
    "C++ Interface:\n"
    "getCpuIdData(non-const DisplayInformation this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_id_data\n"
    "//       Access: Published\n"
    "//  Description: Returns part of cpu id binary data based on the \n"
    "//               index.  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_id_data_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *DisplayInformation::get_cpu_vendor_string(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_vendor_string_139(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char const *DisplayInformation::get_cpu_vendor_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuVendorString", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuVendorString"));
        if(!PyErr_Occurred())
        {
            char const *return_value = (local_this)->get_cpu_vendor_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuVendorString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuVendorString(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_vendor_string_139_comment =
    "C++ Interface:\n"
    "getCpuVendorString(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_vendor_string\n"
    "//       Access: Published\n"
    "//  Description:  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_vendor_string_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *DisplayInformation::get_cpu_brand_string(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_brand_string_140(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char const *DisplayInformation::get_cpu_brand_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuBrandString", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuBrandString"));
        if(!PyErr_Occurred())
        {
            char const *return_value = (local_this)->get_cpu_brand_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuBrandString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuBrandString(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_brand_string_140_comment =
    "C++ Interface:\n"
    "getCpuBrandString(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_brand_string\n"
    "//       Access: Published\n"
    "//  Description:  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_brand_string_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DisplayInformation::get_cpu_version_information(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_version_information_141(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DisplayInformation::get_cpu_version_information(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuVersionInformation", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuVersionInformation"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_cpu_version_information();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuVersionInformation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuVersionInformation(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_version_information_141_comment =
    "C++ Interface:\n"
    "getCpuVersionInformation(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_version_information\n"
    "//       Access: Published\n"
    "//  Description:  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_version_information_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int DisplayInformation::get_cpu_brand_index(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_brand_index_142(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int DisplayInformation::get_cpu_brand_index(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuBrandIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuBrandIndex"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_cpu_brand_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuBrandIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuBrandIndex(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_brand_index_142_comment =
    "C++ Interface:\n"
    "getCpuBrandIndex(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_brand_index\n"
    "//       Access: Published\n"
    "//  Description:  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_brand_index_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_cpu_frequency(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_frequency_143(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_cpu_frequency(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuFrequency", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuFrequency"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_cpu_frequency();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuFrequency() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuFrequency(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_frequency_143_comment =
    "C++ Interface:\n"
    "getCpuFrequency(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_frequency\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_frequency_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_cpu_time(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_cpu_time_144(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_cpu_time(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCpuTime", key_word_list));
        else
            (PyArg_Parse(args, ":getCpuTime"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_cpu_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCpuTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCpuTime(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_cpu_time_144_comment =
    "C++ Interface:\n"
    "getCpuTime(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_cpu_time\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_cpu_time_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_maximum_cpu_frequency(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_maximum_cpu_frequency_145(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_maximum_cpu_frequency(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaximumCpuFrequency", key_word_list));
        else
            (PyArg_Parse(args, ":getMaximumCpuFrequency"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_maximum_cpu_frequency();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getMaximumCpuFrequency() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaximumCpuFrequency(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_maximum_cpu_frequency_145_comment =
    "C++ Interface:\n"
    "getMaximumCpuFrequency(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_maximum_cpu_frequency\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_maximum_cpu_frequency_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned __int64 DisplayInformation::get_current_cpu_frequency(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_current_cpu_frequency_146(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned __int64 DisplayInformation::get_current_cpu_frequency(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentCpuFrequency", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentCpuFrequency"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_current_cpu_frequency();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getCurrentCpuFrequency() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentCpuFrequency(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_current_cpu_frequency_146_comment =
    "C++ Interface:\n"
    "getCurrentCpuFrequency(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_current_cpu_frequency\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_current_cpu_frequency_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplayInformation::update_cpu_frequency(int processor_number)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_update_cpu_frequency_147(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplayInformation::update_cpu_frequency(int processor_number)
        int param1;
        static char * key_word_list[] = {(char *)"processor_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:updateCpuFrequency", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:updateCpuFrequency", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->update_cpu_frequency((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.updateCpuFrequency() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateCpuFrequency(non-const DisplayInformation this, int processor_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_update_cpu_frequency_147_comment =
    "C++ Interface:\n"
    "updateCpuFrequency(non-const DisplayInformation this, int processor_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::update_cpu_frequency\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_update_cpu_frequency_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_num_cpu_cores(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_num_cpu_cores_148(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_num_cpu_cores(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCpuCores", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCpuCores"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_cpu_cores();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getNumCpuCores() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCpuCores(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_num_cpu_cores_148_comment =
    "C++ Interface:\n"
    "getNumCpuCores(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_num_cpu_cores\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of individual CPU cores in the\n"
    "//               system, or 0 if this number is not available.  A\n"
    "//               hyperthreaded CPU counts once here.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_num_cpu_cores_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_num_logical_cpus(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_num_logical_cpus_149(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_num_logical_cpus(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLogicalCpus", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLogicalCpus"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_logical_cpus();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getNumLogicalCpus() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLogicalCpus(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_num_logical_cpus_149_comment =
    "C++ Interface:\n"
    "getNumLogicalCpus(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_num_logical_cpus\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of logical CPU's in the\n"
    "//               system, or 0 if this number is not available.  A\n"
    "//               hyperthreaded CPU counts as two or more here.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_num_logical_cpus_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_os_version_major(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_os_version_major_150(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_os_version_major(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOsVersionMajor", key_word_list));
        else
            (PyArg_Parse(args, ":getOsVersionMajor"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_os_version_major();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getOsVersionMajor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOsVersionMajor(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_os_version_major_150_comment =
    "C++ Interface:\n"
    "getOsVersionMajor(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_os_version_major\n"
    "//       Access: Published\n"
    "//  Description: Returns -1 if not set. \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_os_version_major_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_os_version_minor(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_os_version_minor_151(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_os_version_minor(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOsVersionMinor", key_word_list));
        else
            (PyArg_Parse(args, ":getOsVersionMinor"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_os_version_minor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getOsVersionMinor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOsVersionMinor(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_os_version_minor_151_comment =
    "C++ Interface:\n"
    "getOsVersionMinor(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_os_version_minor\n"
    "//       Access: Published\n"
    "//  Description: Returns -1 if not set. \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_os_version_minor_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_os_version_build(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_os_version_build_152(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_os_version_build(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOsVersionBuild", key_word_list));
        else
            (PyArg_Parse(args, ":getOsVersionBuild"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_os_version_build();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getOsVersionBuild() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOsVersionBuild(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_os_version_build_152_comment =
    "C++ Interface:\n"
    "getOsVersionBuild(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_os_version_build\n"
    "//       Access: Published\n"
    "//  Description: Returns -1 if not set. \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_os_version_build_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DisplayInformation::get_os_platform_id(void)
 *******************************************************************/
static PyObject *Dtool_DisplayInformation_get_os_platform_id_153(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayInformation * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayInformation,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DisplayInformation::get_os_platform_id(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOsPlatformId", key_word_list));
        else
            (PyArg_Parse(args, ":getOsPlatformId"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_os_platform_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayInformation.getOsPlatformId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOsPlatformId(non-const DisplayInformation this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayInformation_get_os_platform_id_153_comment =
    "C++ Interface:\n"
    "getOsPlatformId(non-const DisplayInformation this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayInformation::get_os_platform_id\n"
    "//       Access: Published\n"
    "//  Description: Returns -1 if not set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayInformation_get_os_platform_id_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DisplayInformation::DisplayInformation(void)
 *******************************************************************/
int  Dtool_Init_DisplayInformation(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DisplayInformation::DisplayInformation(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DisplayInformation", key_word_list))
        {
            DisplayInformation *return_value = new DisplayInformation();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DisplayInformation,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DisplayInformation()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DisplayInformation(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DisplayInformation)
    {
        printf("DisplayInformation ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DisplayInformation * local_this = (DisplayInformation *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DisplayInformation)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DisplayInformation(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DisplayInformation)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DrawableRegion 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DrawableRegion::set_clear_color_active(bool clear_color_active)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_color_active_157(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DrawableRegion::set_clear_color_active(bool clear_color_active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"clear_color_active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClearColorActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setClearColorActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_clear_color_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setClearColorActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearColorActive(non-const DrawableRegion this, bool clear_color_active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_color_active_157_comment =
    "C++ Interface:\n"
    "setClearColorActive(non-const DrawableRegion this, bool clear_color_active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_color_active\n"
    "//       Access: Published\n"
    "//  Description: Toggles the flag that indicates whether the color\n"
    "//               buffer should be cleared every frame.  If this is\n"
    "//               true, the color buffer will be cleared to the color\n"
    "//               indicated by set_clear_color(); otherwise, it will be\n"
    "//               left alone.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_color_active_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DrawableRegion::get_clear_color_active(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_color_active_158(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DrawableRegion::get_clear_color_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClearColorActive", key_word_list));
        else
            (PyArg_Parse(args, ":getClearColorActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DrawableRegion*)local_this)->get_clear_color_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearColorActive(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_color_active_158_comment =
    "C++ Interface:\n"
    "getClearColorActive(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_color_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the flag that\n"
    "//               indicates whether the color buffer should be cleared\n"
    "//               every frame.  See set_clear_color_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_color_active_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DrawableRegion::set_clear_depth_active(bool clear_depth_active)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_depth_active_159(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DrawableRegion::set_clear_depth_active(bool clear_depth_active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"clear_depth_active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClearDepthActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setClearDepthActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_clear_depth_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setClearDepthActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearDepthActive(non-const DrawableRegion this, bool clear_depth_active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_depth_active_159_comment =
    "C++ Interface:\n"
    "setClearDepthActive(non-const DrawableRegion this, bool clear_depth_active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_depth_active\n"
    "//       Access: Published\n"
    "//  Description: Toggles the flag that indicates whether the depth\n"
    "//               buffer should be cleared every frame.  If this is\n"
    "//               true, the depth buffer will be cleared to the depth\n"
    "//               value indicated by set_clear_depth(); otherwise, it\n"
    "//               will be left alone.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_depth_active_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DrawableRegion::get_clear_depth_active(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_depth_active_160(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DrawableRegion::get_clear_depth_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClearDepthActive", key_word_list));
        else
            (PyArg_Parse(args, ":getClearDepthActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DrawableRegion*)local_this)->get_clear_depth_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearDepthActive(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_depth_active_160_comment =
    "C++ Interface:\n"
    "getClearDepthActive(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_depth_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the flag that\n"
    "//               indicates whether the depth buffer should be cleared\n"
    "//               every frame.  See set_clear_depth_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_depth_active_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DrawableRegion::set_clear_stencil_active(bool clear_stencil_active)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_stencil_active_161(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DrawableRegion::set_clear_stencil_active(bool clear_stencil_active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"clear_stencil_active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClearStencilActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setClearStencilActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_clear_stencil_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setClearStencilActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearStencilActive(non-const DrawableRegion this, bool clear_stencil_active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_stencil_active_161_comment =
    "C++ Interface:\n"
    "setClearStencilActive(non-const DrawableRegion this, bool clear_stencil_active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_stencil_active\n"
    "//       Access: Published\n"
    "//  Description: Toggles the flag that indicates whether the stencil\n"
    "//               buffer should be cleared every frame.  If this is\n"
    "//               true, the stencil buffer will be cleared to the value\n"
    "//               indicated by set_clear_stencil(); otherwise, it will be\n"
    "//               left alone.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_stencil_active_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DrawableRegion::get_clear_stencil_active(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_stencil_active_162(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DrawableRegion::get_clear_stencil_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClearStencilActive", key_word_list));
        else
            (PyArg_Parse(args, ":getClearStencilActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DrawableRegion*)local_this)->get_clear_stencil_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearStencilActive(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_stencil_active_162_comment =
    "C++ Interface:\n"
    "getClearStencilActive(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_stencil_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the flag that\n"
    "//               indicates whether the color buffer should be cleared\n"
    "//               every frame.  See set_clear_stencil_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_stencil_active_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DrawableRegion::set_clear_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_color_163(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DrawableRegion::set_clear_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClearColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setClearColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DrawableRegion.setClearColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_clear_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DrawableRegion.setClearColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearColor(non-const DrawableRegion this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_color_163_comment =
    "C++ Interface:\n"
    "setClearColor(non-const DrawableRegion this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_color\n"
    "//       Access: Published\n"
    "//  Description: Sets the clear color to the indicated value.  This is\n"
    "//               the value that will be used to clear the color buffer\n"
    "//               every frame, but only if get_clear_color_active()\n"
    "//               returns true.  If get_clear_color_active() returns\n"
    "//               false, this is meaningless.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_color_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &DrawableRegion::get_clear_color(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_color_164(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &DrawableRegion::get_clear_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClearColor", key_word_list));
        else
            (PyArg_Parse(args, ":getClearColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const DrawableRegion*)local_this)->get_clear_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearColor(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_color_164_comment =
    "C++ Interface:\n"
    "getClearColor(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the current clear color value.  This is\n"
    "//               the value that will be used to clear the color buffer\n"
    "//               every frame, but only if get_clear_color_active()\n"
    "//               returns true.  If get_clear_color_active() returns\n"
    "//               false, this is meaningless.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_color_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DrawableRegion::set_clear_depth(float depth)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_depth_165(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DrawableRegion::set_clear_depth(float depth)
        double param1;
        static char * key_word_list[] = {(char *)"depth", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setClearDepth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setClearDepth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_clear_depth((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setClearDepth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearDepth(non-const DrawableRegion this, float depth)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_depth_165_comment =
    "C++ Interface:\n"
    "setClearDepth(non-const DrawableRegion this, float depth)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_depth\n"
    "//       Access: Published\n"
    "//  Description: Sets the clear depth to the indicated value.  This is\n"
    "//               the value that will be used to clear the depth buffer\n"
    "//               every frame, but only if get_clear_depth_active()\n"
    "//               returns true.  If get_clear_depth_active() returns\n"
    "//               false, this is meaningless.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_depth_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DrawableRegion::get_clear_depth(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_depth_166(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DrawableRegion::get_clear_depth(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClearDepth", key_word_list));
        else
            (PyArg_Parse(args, ":getClearDepth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DrawableRegion*)local_this)->get_clear_depth();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearDepth(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_depth_166_comment =
    "C++ Interface:\n"
    "getClearDepth(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_depth\n"
    "//       Access: Published\n"
    "//  Description: Returns the current clear depth value.  This is\n"
    "//               the value that will be used to clear the depth buffer\n"
    "//               every frame, but only if get_clear_depth_active()\n"
    "//               returns true.  If get_clear_depth_active() returns\n"
    "//               false, this is meaningless.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_depth_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DrawableRegion::set_clear_stencil(unsigned int stencil)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_stencil_167(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DrawableRegion::set_clear_stencil(unsigned int stencil)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"stencil", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClearStencil", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setClearStencil", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_clear_stencil(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setClearStencil() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearStencil(non-const DrawableRegion this, unsigned int stencil)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_stencil_167_comment =
    "C++ Interface:\n"
    "setClearStencil(non-const DrawableRegion this, unsigned int stencil)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_stencil\n"
    "//       Access: Published\n"
    "//  Description: Sets the clear stencil to the indicated value.  This is\n"
    "//               the value that will be used to clear the stencil buffer\n"
    "//               every frame, but only if get_clear_color_active()\n"
    "//               returns true.  If get_clear_stencil_active() returns\n"
    "//               false, this is meaningless.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_stencil_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DrawableRegion::get_clear_stencil(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_stencil_168(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int DrawableRegion::get_clear_stencil(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClearStencil", key_word_list));
        else
            (PyArg_Parse(args, ":getClearStencil"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const DrawableRegion*)local_this)->get_clear_stencil();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearStencil(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_stencil_168_comment =
    "C++ Interface:\n"
    "getClearStencil(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_stencil\n"
    "//       Access: Published\n"
    "//  Description: Returns the current clear stencil value.  This is\n"
    "//               the value that will be used to clear the stencil buffer\n"
    "//               every frame, but only if get_clear_stencil_active()\n"
    "//               returns true.  If get_clear_stencil_active() returns\n"
    "//               false, this is meaningless.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_stencil_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DrawableRegion::set_clear_active(int n, bool clear_aux_active)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_active_169(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DrawableRegion::set_clear_active(int n, bool clear_aux_active)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"clear_aux_active", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setClearActive", key_word_list, &param1, &param2))
        {
            (local_this)->set_clear_active((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setClearActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearActive(non-const DrawableRegion this, int n, bool clear_aux_active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_active_169_comment =
    "C++ Interface:\n"
    "setClearActive(non-const DrawableRegion this, int n, bool clear_aux_active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the clear-active flag for any bitplane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_active_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DrawableRegion::get_clear_active(int n) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_active_170(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool DrawableRegion::get_clear_active(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getClearActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getClearActive", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DrawableRegion*)local_this)->get_clear_active((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearActive(const DrawableRegion this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_active_170_comment =
    "C++ Interface:\n"
    "getClearActive(const DrawableRegion this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Gets the clear-active flag for any bitplane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_active_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DrawableRegion::set_clear_value(int n, LVecBase4f const &clear_value)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_clear_value_171(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void DrawableRegion::set_clear_value(int n, LVecBase4f const &clear_value)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"clear_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setClearValue", key_word_list, &param1, &param2))
            {
                LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "DrawableRegion.setClearValue", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_clear_value((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DrawableRegion.setClearValue() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClearValue(non-const DrawableRegion this, int n, const VBase4 clear_value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_clear_value_171_comment =
    "C++ Interface:\n"
    "setClearValue(non-const DrawableRegion this, int n, const VBase4 clear_value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_clear_value\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the clear value for any bitplane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_clear_value_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LVecBase4f const &DrawableRegion::get_clear_value(int n) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_clear_value_172(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LVecBase4f const &DrawableRegion::get_clear_value(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getClearValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getClearValue", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const DrawableRegion*)local_this)->get_clear_value((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClearValue(const DrawableRegion this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_clear_value_172_comment =
    "C++ Interface:\n"
    "getClearValue(const DrawableRegion this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_clear_value\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the clear value for any bitplane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_clear_value_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DrawableRegion::disable_clears(void)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_disable_clears_173(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DrawableRegion::disable_clears(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":disableClears", key_word_list));
        else
            (PyArg_Parse(args, ":disableClears"));
        if(!PyErr_Occurred())
        {
            (local_this)->disable_clears();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.disableClears() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disableClears(non-const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_disable_clears_173_comment =
    "C++ Interface:\n"
    "disableClears(non-const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::disable_clears\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Disables both the color and depth clear.  See\n"
    "//               set_clear_color_active and set_clear_depth_active.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_disable_clears_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DrawableRegion::is_any_clear_active(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_is_any_clear_active_174(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool DrawableRegion::is_any_clear_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAnyClearActive", key_word_list));
        else
            (PyArg_Parse(args, ":isAnyClearActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DrawableRegion*)local_this)->is_any_clear_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAnyClearActive(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_is_any_clear_active_174_comment =
    "C++ Interface:\n"
    "isAnyClearActive(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::is_any_clear_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if any of the clear types (so far there\n"
    "//               are just color or depth) have been set active, or\n"
    "//               false if none of them are active and there is no need\n"
    "//               to clear.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_is_any_clear_active_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DrawableRegion::set_pixel_zoom(float pixel_zoom)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_set_pixel_zoom_175(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DrawableRegion::set_pixel_zoom(float pixel_zoom)
        double param1;
        static char * key_word_list[] = {(char *)"pixel_zoom", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPixelZoom", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPixelZoom", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_pixel_zoom((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.setPixelZoom() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPixelZoom(non-const DrawableRegion this, float pixel_zoom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_set_pixel_zoom_175_comment =
    "C++ Interface:\n"
    "setPixelZoom(non-const DrawableRegion this, float pixel_zoom)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::set_pixel_zoom\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the amount by which the pixels of the region are\n"
    "//               scaled internally when filling the image interally.\n"
    "//               Setting this number larger makes the pixels blockier,\n"
    "//               but may make the rendering faster, particularly for\n"
    "//               software renderers.  Setting this number to 2.0\n"
    "//               reduces the number of pixels that have to be filled\n"
    "//               by the renderer by a factor of 2.0.  It doesn't make\n"
    "//               sense to set this lower than 1.0.\n"
    "//\n"
    "//               It is possible to set this on either individual\n"
    "//               DisplayRegions or on overall GraphicsWindows, but you\n"
    "//               will get better performance for setting it on the\n"
    "//               window rather than its individual DisplayRegions.\n"
    "//               Also, you may not set it on a DisplayRegion that\n"
    "//               doesn't have both clear_color() and clear_depth()\n"
    "//               enabled.\n"
    "//\n"
    "//               This property is only supported on renderers for\n"
    "//               which it is particularly useful--currently, this is\n"
    "//               the tinydisplay software renderer.  Other kinds of\n"
    "//               renderers allow you to set this property, but ignore\n"
    "//               it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_set_pixel_zoom_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DrawableRegion::get_pixel_zoom(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_pixel_zoom_176(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DrawableRegion::get_pixel_zoom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelZoom", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelZoom"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DrawableRegion*)local_this)->get_pixel_zoom();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelZoom(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_pixel_zoom_176_comment =
    "C++ Interface:\n"
    "getPixelZoom(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_pixel_zoom\n"
    "//       Access: Published\n"
    "//  Description: Returns the value set by set_pixel_zoom(), regardless\n"
    "//               of whether it is being respected or not.  Also see\n"
    "//               get_pixel_factor().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_pixel_zoom_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DrawableRegion::get_pixel_factor(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_pixel_factor_177(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DrawableRegion::get_pixel_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DrawableRegion*)local_this)->get_pixel_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelFactor(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_pixel_factor_177_comment =
    "C++ Interface:\n"
    "getPixelFactor(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_pixel_factor\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount by which the height and width of\n"
    "//               the region will be scaled internally, based on the\n"
    "//               zoom factor set by set_pixel_zoom().  This will\n"
    "//               return 1.0 if the pixel_zoom was not set or if it is\n"
    "//               not being respected (for instance, because the\n"
    "//               underlying renderer doesn't support it--see\n"
    "//               supports_pixel_zoom).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_pixel_factor_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DrawableRegion::supports_pixel_zoom(void) const
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_supports_pixel_zoom_178(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool DrawableRegion::supports_pixel_zoom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":supportsPixelZoom", key_word_list));
        else
            (PyArg_Parse(args, ":supportsPixelZoom"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DrawableRegion*)local_this)->supports_pixel_zoom();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "supportsPixelZoom(const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_supports_pixel_zoom_178_comment =
    "C++ Interface:\n"
    "supportsPixelZoom(const DrawableRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::supports_pixel_zoom\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if a call to set_pixel_zoom() will be\n"
    "//               respected, false if it will be ignored.  If this\n"
    "//               returns false, then get_pixel_factor() will always\n"
    "//               return 1.0, regardless of what value you specify for\n"
    "//               set_pixel_zoom().\n"
    "//\n"
    "//               This may return false if the underlying renderer\n"
    "//               doesn't support pixel zooming, or if you have called\n"
    "//               this on a DisplayRegion that doesn't have both\n"
    "//               set_clear_color() and set_clear_depth() enabled.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_supports_pixel_zoom_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int DrawableRegion::get_renderbuffer_type(int plane)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_get_renderbuffer_type_179(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int DrawableRegion::get_renderbuffer_type(int plane)
        int param0;
        static char * key_word_list[] = {(char *)"plane", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getRenderbufferType", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getRenderbufferType", &param0));
        if(!PyErr_Occurred())
        {
            int return_value = DrawableRegion::get_renderbuffer_type((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderbufferType(int plane)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_get_renderbuffer_type_179_comment =
    "C++ Interface:\n"
    "getRenderbufferType(int plane)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DrawableRegion::get_renderbuffer_type\n"
    "//       Access: Static, Published\n"
    "//  Description: Returns the RenderBuffer::Type that corresponds\n"
    "//               to a RenderTexturePlane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DrawableRegion_get_renderbuffer_type_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DisplayRegion *DrawableRegion::downcast_to_DisplayRegion(void)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_downcast_to_DisplayRegion_185(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DisplayRegion *DrawableRegion::downcast_to_DisplayRegion(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDisplayRegion", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDisplayRegion"));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = (DisplayRegion *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.downcastToDisplayRegion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDisplayRegion(non-const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_downcast_to_DisplayRegion_185_comment =
    "C++ Interface:\n"
    "downcastToDisplayRegion(non-const DrawableRegion this)\n"
    "\n"
    "downcast from DrawableRegion to DisplayRegion\n"
    "";
#else
static const char * Dtool_DrawableRegion_downcast_to_DisplayRegion_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutput *DrawableRegion::downcast_to_GraphicsOutput(void)
 *******************************************************************/
static PyObject *Dtool_DrawableRegion_downcast_to_GraphicsOutput_416(PyObject *self, PyObject *args,PyObject *kwds) {
    DrawableRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DrawableRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-GraphicsOutput *DrawableRegion::downcast_to_GraphicsOutput(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToGraphicsOutput", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToGraphicsOutput"));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = (GraphicsOutput *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DrawableRegion.downcastToGraphicsOutput() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToGraphicsOutput(non-const DrawableRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DrawableRegion_downcast_to_GraphicsOutput_416_comment =
    "C++ Interface:\n"
    "downcastToGraphicsOutput(non-const DrawableRegion this)\n"
    "\n"
    "downcast from DrawableRegion to GraphicsOutput\n"
    "";
#else
static const char * Dtool_DrawableRegion_downcast_to_GraphicsOutput_416_comment = NULL;
#endif

int  Dtool_Init_DrawableRegion(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DrawableRegion)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DrawableRegion(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DrawableRegion)
    {
        printf("DrawableRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DrawableRegion * local_this = (DrawableRegion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DrawableRegion)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DrawableRegion(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DrawableRegion)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DisplayRegion 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float DisplayRegion::get_left(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_left_188(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DisplayRegion::get_left(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeft", key_word_list));
        else
            (PyArg_Parse(args, ":getLeft"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DisplayRegion*)local_this)->get_left();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeft(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_left_188_comment =
    "C++ Interface:\n"
    "getLeft(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_left\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the x coordinate of the left edge of the\n"
    "//               rectangle within its GraphicsOutput.  This number\n"
    "//               will be in the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_left_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DisplayRegion::get_right(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_right_189(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DisplayRegion::get_right(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRight", key_word_list));
        else
            (PyArg_Parse(args, ":getRight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DisplayRegion*)local_this)->get_right();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRight(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_right_189_comment =
    "C++ Interface:\n"
    "getRight(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_right\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the x coordinate of the right edge of the\n"
    "//               rectangle within its GraphicsOutput.  This number\n"
    "//               will be in the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_right_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DisplayRegion::get_bottom(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_bottom_190(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DisplayRegion::get_bottom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBottom", key_word_list));
        else
            (PyArg_Parse(args, ":getBottom"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DisplayRegion*)local_this)->get_bottom();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBottom(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_bottom_190_comment =
    "C++ Interface:\n"
    "getBottom(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_bottom\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the y coordinate of the bottom edge of \n"
    "//               the rectangle within its GraphicsOutput.  This \n"
    "//               number will be in the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_bottom_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DisplayRegion::get_top(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_top_191(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DisplayRegion::get_top(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTop", key_word_list));
        else
            (PyArg_Parse(args, ":getTop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DisplayRegion*)local_this)->get_top();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTop(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_top_191_comment =
    "C++ Interface:\n"
    "getTop(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_top\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the y coordinate of the top edge of the\n"
    "//               rectangle within its GraphicsOutput.  This number\n"
    "//               will be in the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_top_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_dimensions(float l, float r, float b, float t)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_dimensions_192(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_dimensions(float l, float r, float b, float t)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"b", (char *)"t", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setDimensions", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_dimensions((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setDimensions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDimensions(non-const DisplayRegion this, float l, float r, float b, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_dimensions_192_comment =
    "C++ Interface:\n"
    "setDimensions(non-const DisplayRegion this, float l, float r, float b, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_dimensions\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Changes the portion of the framebuffer this\n"
    "//               DisplayRegion corresponds to.  The parameters range\n"
    "//               from 0 to 1, where 0,0 is the lower left corner and\n"
    "//               1,1 is the upper right; (0, 1, 0, 1) represents the\n"
    "//               whole screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_dimensions_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput *DisplayRegion::get_window(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_window_193(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsOutput *DisplayRegion::get_window(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindow", key_word_list));
        else
            (PyArg_Parse(args, ":getWindow"));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = ((const DisplayRegion*)local_this)->get_window();
            if (return_value != (GraphicsOutput *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindow(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_window_193_comment =
    "C++ Interface:\n"
    "getWindow(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_window\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsOutput that this DisplayRegion is\n"
    "//               ultimately associated with, or NULL if no window is\n"
    "//               associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_window_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsPipe *DisplayRegion::get_pipe(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_pipe_194(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-GraphicsPipe *DisplayRegion::get_pipe(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPipe", key_word_list));
        else
            (PyArg_Parse(args, ":getPipe"));
        if(!PyErr_Occurred())
        {
            GraphicsPipe *return_value = ((const DisplayRegion*)local_this)->get_pipe();
            if (return_value != (GraphicsPipe *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsPipe,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPipe(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_pipe_194_comment =
    "C++ Interface:\n"
    "getPipe(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_pipe\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsPipe that this DisplayRegion is\n"
    "//               ultimately associated with, or NULL if no pipe is\n"
    "//               associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_pipe_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DisplayRegion::is_stereo(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_is_stereo_195(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool DisplayRegion::is_stereo(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStereo", key_word_list));
        else
            (PyArg_Parse(args, ":isStereo"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DisplayRegion*)local_this)->is_stereo();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStereo(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_is_stereo_195_comment =
    "C++ Interface:\n"
    "isStereo(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::is_stereo\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if this is a StereoDisplayRegion, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_is_stereo_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_camera(NodePath const &camera)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_camera_196(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void DisplayRegion::set_camera(NodePath const &camera)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"camera", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCamera", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCamera", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DisplayRegion.setCamera", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_camera(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.setCamera() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCamera(non-const DisplayRegion this, const NodePath camera)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_camera_196_comment =
    "C++ Interface:\n"
    "setCamera(non-const DisplayRegion this, const NodePath camera)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_camera\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the camera that is associated with this\n"
    "//               DisplayRegion.  There is a one-to-many association\n"
    "//               between cameras and DisplayRegions; one camera may be\n"
    "//               shared by multiple DisplayRegions.\n"
    "//\n"
    "//               The camera is actually set via a NodePath, which\n"
    "//               clarifies which instance of the camera (if there\n"
    "//               happen to be multiple instances) we should use.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_camera_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath DisplayRegion::get_camera(Thread *current_thread) const
 * inline NodePath DisplayRegion::get_camera(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_camera_197(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline NodePath DisplayRegion::get_camera(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getCamera", key_word_list));
            else
                (PyArg_Parse(args, ":getCamera"));
            if(!PyErr_Occurred())
            {
                NodePath result = ((const DisplayRegion*)local_this)->get_camera();
                NodePath *return_value = new NodePath(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline NodePath DisplayRegion::get_camera(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getCamera", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getCamera", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "DisplayRegion.getCamera", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        NodePath result = ((const DisplayRegion*)local_this)->get_camera(param1_this);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCamera() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCamera(const DisplayRegion this)\n"
          "getCamera(const DisplayRegion this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_camera_197_comment =
    "C++ Interface:\n"
    "getCamera(const DisplayRegion this)\n"
    "getCamera(const DisplayRegion this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_camera\n"
    "//       Access: Published\n"
    "//  Description: Returns the camera associated with this\n"
    "//               DisplayRegion, or an empty NodePath if no camera is\n"
    "//               associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_camera_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_active_198(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const DisplayRegion this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_active_198_comment =
    "C++ Interface:\n"
    "setActive(non-const DisplayRegion this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the active flag associated with the\n"
    "//               DisplayRegion.  If the DisplayRegion is marked\n"
    "//               inactive, nothing is rendered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_active_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DisplayRegion::is_active(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_is_active_199(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DisplayRegion::is_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isActive", key_word_list));
        else
            (PyArg_Parse(args, ":isActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DisplayRegion*)local_this)->is_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isActive(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_is_active_199_comment =
    "C++ Interface:\n"
    "isActive(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::is_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the active flag associated with the\n"
    "//               DisplayRegion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_is_active_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_sort(int sort)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_sort_200(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_sort(int sort)
        int param1;
        static char * key_word_list[] = {(char *)"sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSort(non-const DisplayRegion this, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_sort_200_comment =
    "C++ Interface:\n"
    "setSort(non-const DisplayRegion this, int sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_sort\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the sort value associated with the\n"
    "//               DisplayRegion.  Within a window, DisplayRegions will\n"
    "//               be rendered in order from the lowest sort value to\n"
    "//               the highest.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_sort_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DisplayRegion::get_sort(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_sort_201(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DisplayRegion::get_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSort", key_word_list));
        else
            (PyArg_Parse(args, ":getSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DisplayRegion*)local_this)->get_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSort(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_sort_201_comment =
    "C++ Interface:\n"
    "getSort(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the sort value associated with the\n"
    "//               DisplayRegion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_sort_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_stereo_channel(Lens::StereoChannel stereo_channel)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_stereo_channel_202(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_stereo_channel(Lens::StereoChannel stereo_channel)
        int param1;
        static char * key_word_list[] = {(char *)"stereo_channel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setStereoChannel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setStereoChannel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_stereo_channel((Lens::StereoChannel)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setStereoChannel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStereoChannel(non-const DisplayRegion this, int stereo_channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_stereo_channel_202_comment =
    "C++ Interface:\n"
    "setStereoChannel(non-const DisplayRegion this, int stereo_channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_stereo_channel\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Specifies whether the DisplayRegion represents the\n"
    "//               left or right channel of a stereo pair, or whether it\n"
    "//               is a normal, monocular image.  This automatically\n"
    "//               adjusts the lens that is used to render to this\n"
    "//               DisplayRegion to its left or right eye, according to\n"
    "//               the lens's stereo properties.\n"
    "//\n"
    "//               When the DisplayRegion is attached to a stereo window\n"
    "//               (one for which is_stereo() returns true), this also\n"
    "//               specifies which physical channel the DisplayRegion\n"
    "//               renders to.\n"
    "//\n"
    "//               Normally you would create at least two DisplayRegions\n"
    "//               for a stereo window, one for each of the left and\n"
    "//               right channels.  The two DisplayRegions may share the\n"
    "//               same camera (and thus the same lens); this parameter\n"
    "//               is used to control the exact properties of the lens\n"
    "//               when it is used to render into this DisplayRegion.\n"
    "//\n"
    "//               Also see the StereoDisplayRegion, which automates\n"
    "//               managing a pair of left/right DisplayRegions.\n"
    "//\n"
    "//               An ordinary DisplayRegion may be set to SC_mono,\n"
    "//               SC_left, or SC_right.  You may set SC_stereo only on\n"
    "//               a StereoDisplayRegion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_stereo_channel_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Lens::StereoChannel DisplayRegion::get_stereo_channel(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_stereo_channel_203(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline Lens::StereoChannel DisplayRegion::get_stereo_channel(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStereoChannel", key_word_list));
        else
            (PyArg_Parse(args, ":getStereoChannel"));
        if(!PyErr_Occurred())
        {
            Lens::StereoChannel return_value = (local_this)->get_stereo_channel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.getStereoChannel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStereoChannel(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_stereo_channel_203_comment =
    "C++ Interface:\n"
    "getStereoChannel(non-const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_stereo_channel\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the DisplayRegion is specified as the\n"
    "//               left or right channel of a stereo pair, or whether it\n"
    "//               is a normal, monocular image.  See\n"
    "//               set_stereo_channel().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_stereo_channel_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_incomplete_render(bool incomplete_render)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_incomplete_render_204(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_incomplete_render(bool incomplete_render)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"incomplete_render", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIncompleteRender", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setIncompleteRender", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_incomplete_render((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setIncompleteRender() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIncompleteRender(non-const DisplayRegion this, bool incomplete_render)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_incomplete_render_204_comment =
    "C++ Interface:\n"
    "setIncompleteRender(non-const DisplayRegion this, bool incomplete_render)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_incomplete_render\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets the incomplete_render flag.  When this is\n"
    "//               true, the frame will be rendered even if some of the\n"
    "//               geometry or textures in the scene are not available\n"
    "//               (e.g. they have been temporarily paged out).  When\n"
    "//               this is false, the frame will be held up while this\n"
    "//               data is reloaded.\n"
    "//\n"
    "//               This flag may also be set on the\n"
    "//               GraphicsStateGuardian.  It will be considered true\n"
    "//               for a given DisplayRegion only if it is true on both\n"
    "//               the GSG and on the DisplayRegion.\n"
    "//\n"
    "//               See GraphicsStateGuardian::set_incomplete_render()\n"
    "//               for more detail.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_incomplete_render_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DisplayRegion::get_incomplete_render(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_incomplete_render_205(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DisplayRegion::get_incomplete_render(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIncompleteRender", key_word_list));
        else
            (PyArg_Parse(args, ":getIncompleteRender"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DisplayRegion*)local_this)->get_incomplete_render();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIncompleteRender(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_incomplete_render_205_comment =
    "C++ Interface:\n"
    "getIncompleteRender(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_incomplete_render\n"
    "//       Access: Published\n"
    "//  Description: Returns the incomplete_render flag.  See\n"
    "//               set_incomplete_render().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_incomplete_render_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_texture_reload_priority(int texture_reload_priority)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_texture_reload_priority_206(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_texture_reload_priority(int texture_reload_priority)
        int param1;
        static char * key_word_list[] = {(char *)"texture_reload_priority", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTextureReloadPriority", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTextureReloadPriority", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_texture_reload_priority((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setTextureReloadPriority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextureReloadPriority(non-const DisplayRegion this, int texture_reload_priority)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_texture_reload_priority_206_comment =
    "C++ Interface:\n"
    "setTextureReloadPriority(non-const DisplayRegion this, int texture_reload_priority)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_texture_reload_priority\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Specifies an integer priority which is assigned to\n"
    "//               any asynchronous texture reload requests spawned\n"
    "//               while processing this DisplayRegion.  This controls\n"
    "//               which textures are loaded first when multiple\n"
    "//               textures need to be reloaded at once; it also\n"
    "//               controls the relative priority between asynchronous\n"
    "//               texture loads and asynchronous model or animation\n"
    "//               loads.\n"
    "//\n"
    "//               Specifying a larger number here makes the textures\n"
    "//               rendered by this DisplayRegion load up first.  This\n"
    "//               may be particularly useful to do, for instance, for\n"
    "//               the DisplayRegion that renders the gui.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_texture_reload_priority_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DisplayRegion::get_texture_reload_priority(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_texture_reload_priority_207(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DisplayRegion::get_texture_reload_priority(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureReloadPriority", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureReloadPriority"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DisplayRegion*)local_this)->get_texture_reload_priority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureReloadPriority(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_texture_reload_priority_207_comment =
    "C++ Interface:\n"
    "getTextureReloadPriority(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_texture_reload_priority\n"
    "//       Access: Published\n"
    "//  Description: Returns the priority which is assigned to\n"
    "//               asynchronous texture reload requests.  See\n"
    "//               set_texture_reload_priority().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_texture_reload_priority_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplayRegion::set_lens_index(int index)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_lens_index_208(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplayRegion::set_lens_index(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLensIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLensIndex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_lens_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setLensIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLensIndex(non-const DisplayRegion this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_lens_index_208_comment =
    "C++ Interface:\n"
    "setLensIndex(non-const DisplayRegion this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_lens_index\n"
    "//       Access: Published\n"
    "//  Description: Sets the lens index, allows for multiple lenses to\n"
    "//               be attached to a camera.  This is useful for a \n"
    "//               variety of setups, such as fish eye rendering.\n"
    "//               The default is 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_lens_index_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DisplayRegion::get_lens_index(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_lens_index_209(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DisplayRegion::get_lens_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLensIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getLensIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DisplayRegion*)local_this)->get_lens_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLensIndex(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_lens_index_209_comment =
    "C++ Interface:\n"
    "getLensIndex(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_lens_index\n"
    "//       Access: Public\n"
    "//  Description: Returns the specific lens of the associated Camera\n"
    "//               that will be used for rendering this scene.  Most\n"
    "//               Cameras hold only one lens, but for multiple lenses\n"
    "//               this method may be used to selected between them.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_lens_index_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_cull_traverser(CullTraverser *trav)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_cull_traverser_210(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void DisplayRegion::set_cull_traverser(CullTraverser *trav)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"trav", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCullTraverser", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCullTraverser", &param1));
            if(!PyErr_Occurred())
            {
                CullTraverser *param1_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CullTraverser, 1, "DisplayRegion.setCullTraverser", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_cull_traverser(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.setCullTraverser() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCullTraverser(non-const DisplayRegion this, non-const CullTraverser trav)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_cull_traverser_210_comment =
    "C++ Interface:\n"
    "setCullTraverser(non-const DisplayRegion this, non-const CullTraverser trav)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_cull_traverser\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Specifies the CullTraverser that will be used to draw\n"
    "//               the contents of this DisplayRegion.  Normally the\n"
    "//               default CullTraverser is sufficient, but this may be\n"
    "//               changed to change the default cull behavior.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_cull_traverser_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CullTraverser *DisplayRegion::get_cull_traverser(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_cull_traverser_211(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-CullTraverser *DisplayRegion::get_cull_traverser(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullTraverser", key_word_list));
        else
            (PyArg_Parse(args, ":getCullTraverser"));
        if(!PyErr_Occurred())
        {
            CullTraverser *return_value = (local_this)->get_cull_traverser();
            if (return_value != (CullTraverser *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CullTraverser,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.getCullTraverser() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullTraverser(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_cull_traverser_211_comment =
    "C++ Interface:\n"
    "getCullTraverser(non-const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_cull_traverser\n"
    "//       Access: Published\n"
    "//  Description: Returns the CullTraverser that will be used to draw\n"
    "//               the contents of this DisplayRegion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_cull_traverser_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::set_cube_map_index(int cube_map_index)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_cube_map_index_212(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DisplayRegion::set_cube_map_index(int cube_map_index)
        int param1;
        static char * key_word_list[] = {(char *)"cube_map_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCubeMapIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCubeMapIndex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cube_map_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.setCubeMapIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCubeMapIndex(non-const DisplayRegion this, int cube_map_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_cube_map_index_212_comment =
    "C++ Interface:\n"
    "setCubeMapIndex(non-const DisplayRegion this, int cube_map_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_cube_map_index\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This is a special parameter that is only used when\n"
    "//               rendering the faces of a cube map.  Normally you\n"
    "//               should not need to set it directly.  This sets up the\n"
    "//               DisplayRegion to render to the nth cube map face; the\n"
    "//               value must be between 0 and 5, inclusive.  A normal\n"
    "//               DisplayRegion that is not associated with any\n"
    "//               particular cube map should be set to -1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_cube_map_index_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DisplayRegion::get_cube_map_index(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_cube_map_index_213(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DisplayRegion::get_cube_map_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCubeMapIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getCubeMapIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DisplayRegion*)local_this)->get_cube_map_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCubeMapIndex(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_cube_map_index_213_comment =
    "C++ Interface:\n"
    "getCubeMapIndex(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_cube_map_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the cube map face index associated with this\n"
    "//               particular DisplayRegion, or -1 if it is not\n"
    "//               associated with a cube map.  See\n"
    "//               set_cube_map_index().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_cube_map_index_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DisplayRegion::set_cull_callback(CallbackObject *object)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_cull_callback_214(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DisplayRegion::set_cull_callback(CallbackObject *object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCullCallback", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCullCallback", &param1));
            if(!PyErr_Occurred())
            {
                CallbackObject *param1_this = (CallbackObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CallbackObject, 1, "DisplayRegion.setCullCallback", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_cull_callback(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.setCullCallback() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCullCallback(non-const DisplayRegion this, non-const CallbackObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_cull_callback_214_comment =
    "C++ Interface:\n"
    "setCullCallback(non-const DisplayRegion this, non-const CallbackObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_cull_callback\n"
    "//       Access: Published\n"
    "//  Description: Sets the CallbackObject that will be notified when\n"
    "//               the DisplayRegion is visited during the cull\n"
    "//               traversal.  This callback will be made during the\n"
    "//               cull thread.\n"
    "//\n"
    "//               The cull traversal is responsible for determining\n"
    "//               which nodes are visible and within the view frustum,\n"
    "//               and for accumulating state and transform, and\n"
    "//               generally building up the list of CullableObjects\n"
    "//               that are to be eventually passed to the draw\n"
    "//               traversal for rendering.\n"
    "//\n"
    "//               At the time the cull traversal callback is made, the\n"
    "//               traversal for this DisplayRegion has not yet started.\n"
    "//\n"
    "//               The callback is passed an instance of a\n"
    "//               DisplayRegionCullCallbackData, which contains\n"
    "//               pointers to the current scene information, as well as\n"
    "//               the current DisplayRegion and GSG.  The callback\n"
    "//               *replaces* the normal cull behavior, so if your\n"
    "//               callback does nothing, the scene graph will not be\n"
    "//               traversed and therefore nothing will be drawn.  If\n"
    "//               you wish the normal cull traversal to be performed\n"
    "//               for this DisplayRegion, you must call\n"
    "//               cbdata->upcall() from your callback.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_cull_callback_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DisplayRegion::clear_cull_callback(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_clear_cull_callback_215(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DisplayRegion::clear_cull_callback(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCullCallback", key_word_list));
        else
            (PyArg_Parse(args, ":clearCullCallback"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_cull_callback();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.clearCullCallback() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCullCallback(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_clear_cull_callback_215_comment =
    "C++ Interface:\n"
    "clearCullCallback(non-const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::clear_cull_callback\n"
    "//       Access: Published\n"
    "//  Description: Removes the callback set by an earlier call to\n"
    "//               set_cull_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_clear_cull_callback_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CallbackObject *DisplayRegion::get_cull_callback(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_cull_callback_216(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CallbackObject *DisplayRegion::get_cull_callback(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullCallback", key_word_list));
        else
            (PyArg_Parse(args, ":getCullCallback"));
        if(!PyErr_Occurred())
        {
            CallbackObject *return_value = ((const DisplayRegion*)local_this)->get_cull_callback();
            if (return_value != (CallbackObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CallbackObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullCallback(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_cull_callback_216_comment =
    "C++ Interface:\n"
    "getCullCallback(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_cull_callback\n"
    "//       Access: Published\n"
    "//  Description: Returns the CallbackObject set by set_cull_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_cull_callback_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DisplayRegion::set_draw_callback(CallbackObject *object)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_set_draw_callback_217(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DisplayRegion::set_draw_callback(CallbackObject *object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDrawCallback", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDrawCallback", &param1));
            if(!PyErr_Occurred())
            {
                CallbackObject *param1_this = (CallbackObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CallbackObject, 1, "DisplayRegion.setDrawCallback", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_draw_callback(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.setDrawCallback() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDrawCallback(non-const DisplayRegion this, non-const CallbackObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_set_draw_callback_217_comment =
    "C++ Interface:\n"
    "setDrawCallback(non-const DisplayRegion this, non-const CallbackObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::set_draw_callback\n"
    "//       Access: Published\n"
    "//  Description: Sets the CallbackObject that will be notified when\n"
    "//               the contents of DisplayRegion is drawn during the\n"
    "//               draw traversal.  This callback will be made during\n"
    "//               the draw thread.\n"
    "//\n"
    "//               The draw traversal is responsible for actually\n"
    "//               issuing the commands to the graphics engine to draw\n"
    "//               primitives.  Its job is to walk through the list of\n"
    "//               CullableObjects build up by the cull traversal, as\n"
    "//               quickly as possible, issuing the appropriate commands\n"
    "//               to draw each one.\n"
    "//\n"
    "//               At the time the draw traversal callback is made, the\n"
    "//               graphics state is in the initial state, and no\n"
    "//               projection matrix or modelview matrix is in effect.\n"
    "//               begin_scene() has not yet been called, and no objects\n"
    "//               have yet been drawn.  However, the viewport has\n"
    "//               already been set to the appropriate part of the\n"
    "//               window, and the clear commands for this DisplayRegion\n"
    "//               (if any) have been issued.\n"
    "//\n"
    "//               The callback is passed an instance of a\n"
    "//               DisplayRegionDrawCallbackData, which contains\n"
    "//               pointers to the current scene information, as well as\n"
    "//               the current DisplayRegion and GSG.  The callback\n"
    "//               *replaces* the normal draw behavior, so if your\n"
    "//               callback does nothing, nothing in the DisplayRegion\n"
    "//               will be drawn.  If you wish the draw traversal to\n"
    "//               continue to draw the contents of this DisplayRegion,\n"
    "//               you must call cbdata->upcall() from your callback.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_set_draw_callback_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DisplayRegion::clear_draw_callback(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_clear_draw_callback_218(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DisplayRegion::clear_draw_callback(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDrawCallback", key_word_list));
        else
            (PyArg_Parse(args, ":clearDrawCallback"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_draw_callback();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.clearDrawCallback() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDrawCallback(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_clear_draw_callback_218_comment =
    "C++ Interface:\n"
    "clearDrawCallback(non-const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::clear_draw_callback\n"
    "//       Access: Published\n"
    "//  Description: Removes the callback set by an earlier call to\n"
    "//               set_draw_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_clear_draw_callback_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CallbackObject *DisplayRegion::get_draw_callback(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_draw_callback_219(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CallbackObject *DisplayRegion::get_draw_callback(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDrawCallback", key_word_list));
        else
            (PyArg_Parse(args, ":getDrawCallback"));
        if(!PyErr_Occurred())
        {
            CallbackObject *return_value = ((const DisplayRegion*)local_this)->get_draw_callback();
            if (return_value != (CallbackObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CallbackObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDrawCallback(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_draw_callback_219_comment =
    "C++ Interface:\n"
    "getDrawCallback(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_draw_callback\n"
    "//       Access: Published\n"
    "//  Description: Returns the CallbackObject set by set_draw_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_draw_callback_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DisplayRegion::get_pixel_width(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_pixel_width_220(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DisplayRegion::get_pixel_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelWidth"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DisplayRegion*)local_this)->get_pixel_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelWidth(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_pixel_width_220_comment =
    "C++ Interface:\n"
    "getPixelWidth(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_pixel_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of the DisplayRegion in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_pixel_width_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DisplayRegion::get_pixel_height(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_pixel_height_221(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DisplayRegion::get_pixel_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelHeight"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DisplayRegion*)local_this)->get_pixel_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelHeight(const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_pixel_height_221_comment =
    "C++ Interface:\n"
    "getPixelHeight(const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_pixel_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the height of the DisplayRegion in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_pixel_height_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegion::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_output_222(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void DisplayRegion::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DisplayRegion.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DisplayRegion*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DisplayRegion this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_output_222_comment =
    "C++ Interface:\n"
    "output(const DisplayRegion this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_output_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename DisplayRegion::make_screenshot_filename(basic_string< char > const &prefix)
 * static Filename DisplayRegion::make_screenshot_filename(basic_string< char > const &prefix = ("screenshot"))
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_make_screenshot_filename_223(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-static Filename DisplayRegion::make_screenshot_filename(basic_string< char > const &prefix = ("screenshot"))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":makeScreenshotFilename", key_word_list))
            {
                Filename result = DisplayRegion::make_screenshot_filename();
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-static Filename DisplayRegion::make_screenshot_filename(basic_string< char > const &prefix)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makeScreenshotFilename", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:makeScreenshotFilename", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                Filename result = DisplayRegion::make_screenshot_filename(basic_string<char>(param0_str, param0_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeScreenshotFilename() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeScreenshotFilename()\n"
          "makeScreenshotFilename(string prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_make_screenshot_filename_223_comment =
    "C++ Interface:\n"
    "makeScreenshotFilename()\n"
    "makeScreenshotFilename(string prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::make_screenshot_filename\n"
    "//       Access: Published, Static\n"
    "//  Description: Synthesizes a suitable default filename for passing\n"
    "//               to save_screenshot().\n"
    "//\n"
    "//               The default filename is generated from the supplied\n"
    "//               prefix and from the Config variable\n"
    "//               screenshot-filename, which contains the following\n"
    "//               strings:\n"
    "//\n"
    "//                 %~p - the supplied prefix\n"
    "//                 %~f - the frame count\n"
    "//                 %~e - the value of screenshot-extension\n"
    "//                 All other % strings in strftime().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_make_screenshot_filename_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Filename DisplayRegion::save_screenshot_default(basic_string< char > const &prefix)
 * Filename DisplayRegion::save_screenshot_default(basic_string< char > const &prefix = ("screenshot"))
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_save_screenshot_default_224(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-Filename DisplayRegion::save_screenshot_default(basic_string< char > const &prefix = ("screenshot"))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":saveScreenshotDefault", key_word_list));
            else
                (PyArg_Parse(args, ":saveScreenshotDefault"));
            if(!PyErr_Occurred())
            {
                Filename result = (local_this)->save_screenshot_default();
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.saveScreenshotDefault() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-Filename DisplayRegion::save_screenshot_default(basic_string< char > const &prefix)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:saveScreenshotDefault", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:saveScreenshotDefault", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                Filename result = (local_this)->save_screenshot_default(basic_string<char>(param1_str, param1_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.saveScreenshotDefault() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "saveScreenshotDefault() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "saveScreenshotDefault(non-const DisplayRegion this)\n"
          "saveScreenshotDefault(non-const DisplayRegion this, string prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_save_screenshot_default_224_comment =
    "C++ Interface:\n"
    "saveScreenshotDefault(non-const DisplayRegion this)\n"
    "saveScreenshotDefault(non-const DisplayRegion this, string prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::save_screenshot_default\n"
    "//       Access: Published\n"
    "//  Description: Saves a screenshot of the region to a default\n"
    "//               filename, and returns the filename, or empty string\n"
    "//               if the screenshot failed.  The filename is generated\n"
    "//               by make_screenshot_filename().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_save_screenshot_default_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DisplayRegion::save_screenshot(Filename const &filename, basic_string< char > const &image_comment)
 * bool DisplayRegion::save_screenshot(Filename const &filename, basic_string< char > const &image_comment = (""))
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_save_screenshot_225(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool DisplayRegion::save_screenshot(Filename const &filename, basic_string< char > const &image_comment = (""))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:saveScreenshot", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:saveScreenshot", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DisplayRegion.saveScreenshot", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->save_screenshot(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DisplayRegion.saveScreenshot() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool DisplayRegion::save_screenshot(Filename const &filename, basic_string< char > const &image_comment)
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"filename", (char *)"image_comment", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:saveScreenshot", key_word_list, &param1, &param2_str, &param2_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DisplayRegion.saveScreenshot", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->save_screenshot(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DisplayRegion.saveScreenshot() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "saveScreenshot() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "saveScreenshot(non-const DisplayRegion this, const Filename filename)\n"
          "saveScreenshot(non-const DisplayRegion this, const Filename filename, string image_comment)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_save_screenshot_225_comment =
    "C++ Interface:\n"
    "saveScreenshot(non-const DisplayRegion this, const Filename filename)\n"
    "saveScreenshot(non-const DisplayRegion this, const Filename filename, string image_comment)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::save_screenshot\n"
    "//       Access: Published\n"
    "//  Description: Saves a screenshot of the region to the indicated\n"
    "//               filename.  Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_save_screenshot_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DisplayRegion::get_screenshot(PNMImage &image)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_screenshot_226(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool DisplayRegion::get_screenshot(PNMImage &image)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"image", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getScreenshot", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getScreenshot", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "DisplayRegion.getScreenshot", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_screenshot(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DisplayRegion.getScreenshot() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScreenshot(non-const DisplayRegion this, non-const PNMImage image)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_screenshot_226_comment =
    "C++ Interface:\n"
    "getScreenshot(non-const DisplayRegion this, non-const PNMImage image)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::get_screenshot\n"
    "//       Access: Published\n"
    "//  Description: Captures the most-recently rendered image from the\n"
    "//               framebuffer into the indicated PNMImage.  Returns\n"
    "//               true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_screenshot_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< PandaNode > DisplayRegion::make_cull_result_graph(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_make_cull_result_graph_227(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< PandaNode > DisplayRegion::make_cull_result_graph(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCullResultGraph", key_word_list));
        else
            (PyArg_Parse(args, ":makeCullResultGraph"));
        if(!PyErr_Occurred())
        {
            PointerTo< PandaNode > return_value = (local_this)->make_cull_result_graph();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.makeCullResultGraph() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCullResultGraph(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_make_cull_result_graph_227_comment =
    "C++ Interface:\n"
    "makeCullResultGraph(non-const DisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegion::make_cull_result_graph\n"
    "//       Access: Published\n"
    "//  Description: Returns a special scene graph constructed to\n"
    "//               represent the results of the last frame's cull\n"
    "//               operation.\n"
    "//\n"
    "//               This will be a hierarchy of nodes, one node for each\n"
    "//               bin, each of which will in term be a parent of a\n"
    "//               number of GeomNodes, representing the geometry drawn\n"
    "//               in each bin.\n"
    "//\n"
    "//               This is useful mainly for high-level debugging and\n"
    "//               abstraction tools; it should not be mistaken for the\n"
    "//               low-level cull result itself, which is constructed\n"
    "//               and maintained internally.  No such scene graph is\n"
    "//               normally constructed during the rendering of a frame;\n"
    "//               this is an artificial construct created for the\n"
    "//               purpose of making it easy to analyze the results of\n"
    "//               the cull operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegion_make_cull_result_graph_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DisplayRegion::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_get_class_type_228(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DisplayRegion::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DisplayRegion::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_get_class_type_228_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DisplayRegion_get_class_type_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DisplayRegionBase *DisplayRegion::upcast_to_DisplayRegionBase(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_upcast_to_DisplayRegionBase_182(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DisplayRegionBase *DisplayRegion::upcast_to_DisplayRegionBase(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDisplayRegionBase", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDisplayRegionBase"));
        if(!PyErr_Occurred())
        {
            DisplayRegionBase *return_value = (DisplayRegionBase *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegionBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.upcastToDisplayRegionBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDisplayRegionBase(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_upcast_to_DisplayRegionBase_182_comment =
    "C++ Interface:\n"
    "upcastToDisplayRegionBase(non-const DisplayRegion this)\n"
    "\n"
    "upcast from DisplayRegion to DisplayRegionBase\n"
    "";
#else
static const char * Dtool_DisplayRegion_upcast_to_DisplayRegionBase_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DrawableRegion *DisplayRegion::upcast_to_DrawableRegion(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegion_upcast_to_DrawableRegion_184(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DrawableRegion *DisplayRegion::upcast_to_DrawableRegion(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDrawableRegion", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDrawableRegion"));
        if(!PyErr_Occurred())
        {
            DrawableRegion *return_value = (DrawableRegion *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DrawableRegion,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplayRegion.upcastToDrawableRegion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDrawableRegion(non-const DisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegion_upcast_to_DrawableRegion_184_comment =
    "C++ Interface:\n"
    "upcastToDrawableRegion(non-const DisplayRegion this)\n"
    "\n"
    "upcast from DisplayRegion to DrawableRegion\n"
    "";
#else
static const char * Dtool_DisplayRegion_upcast_to_DrawableRegion_184_comment = NULL;
#endif

int  Dtool_Init_DisplayRegion(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DisplayRegion)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DisplayRegion(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DisplayRegion)
    {
        printf("DisplayRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DisplayRegion * local_this = (DisplayRegion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DisplayRegion)
        return local_this;
    if(requested_type == &Dtool_DisplayRegionBase)
        return ( DisplayRegionBase *) local_this;
    if(requested_type == &Dtool_DrawableRegion)
        return ( DrawableRegion *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DisplayRegionBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DisplayRegionBase *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DisplayRegionBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DisplayRegion(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DisplayRegion)
        return from_this;
    if(from_type == &Dtool_DisplayRegionBase)
    {
          DisplayRegionBase* other_this = (DisplayRegionBase*)from_this;
          return (DisplayRegion*)other_this;
    }
    if(from_type == &Dtool_DrawableRegion)
    {
          DrawableRegion* other_this = (DrawableRegion*)from_this;
          return (DisplayRegion*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DisplayRegion*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DisplayRegion*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DisplayRegion*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DisplayRegionCullCallbackData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline SceneSetup *DisplayRegionCullCallbackData::get_scene_setup(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegionCullCallbackData_get_scene_setup_232(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegionCullCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegionCullCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SceneSetup *DisplayRegionCullCallbackData::get_scene_setup(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSceneSetup", key_word_list));
        else
            (PyArg_Parse(args, ":getSceneSetup"));
        if(!PyErr_Occurred())
        {
            SceneSetup *return_value = ((const DisplayRegionCullCallbackData*)local_this)->get_scene_setup();
            if (return_value != (SceneSetup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SceneSetup,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSceneSetup(const DisplayRegionCullCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionCullCallbackData_get_scene_setup_232_comment =
    "C++ Interface:\n"
    "getSceneSetup(const DisplayRegionCullCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegionCullCallbackData::get_scene_setup\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the SceneSetup object, which\n"
    "//               contains information about the camera and such.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegionCullCallbackData_get_scene_setup_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DisplayRegionCullCallbackData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegionCullCallbackData_get_class_type_233(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DisplayRegionCullCallbackData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DisplayRegionCullCallbackData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionCullCallbackData_get_class_type_233_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DisplayRegionCullCallbackData_get_class_type_233_comment = NULL;
#endif

int  Dtool_Init_DisplayRegionCullCallbackData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DisplayRegionCullCallbackData)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DisplayRegionCullCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DisplayRegionCullCallbackData)
    {
        printf("DisplayRegionCullCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DisplayRegionCullCallbackData * local_this = (DisplayRegionCullCallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DisplayRegionCullCallbackData)
        return local_this;
    if(requested_type == &Dtool_CallbackData)
        return ( CallbackData *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( CallbackData *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DisplayRegionCullCallbackData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DisplayRegionCullCallbackData)
        return from_this;
    if(from_type == &Dtool_CallbackData)
    {
          CallbackData* other_this = (CallbackData*)from_this;
          return (DisplayRegionCullCallbackData*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DisplayRegionCullCallbackData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DisplayRegionDrawCallbackData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CullResult *DisplayRegionDrawCallbackData::get_cull_result(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegionDrawCallbackData_get_cull_result_236(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegionDrawCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegionDrawCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CullResult *DisplayRegionDrawCallbackData::get_cull_result(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullResult", key_word_list));
        else
            (PyArg_Parse(args, ":getCullResult"));
        if(!PyErr_Occurred())
        {
            CullResult *return_value = ((const DisplayRegionDrawCallbackData*)local_this)->get_cull_result();
            if (return_value != (CullResult *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_CullResult,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullResult(const DisplayRegionDrawCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionDrawCallbackData_get_cull_result_236_comment =
    "C++ Interface:\n"
    "getCullResult(const DisplayRegionDrawCallbackData this)\n"
    "\n"
    "// Filename: displayRegionDrawCallbackData.I\n"
    "// Created by:  drose (13Mar09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegionDrawCallbackData::get_cull_result\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the CullResult, the list of\n"
    "//               CullableObjects that should be drawn in this\n"
    "//               DisplayRegion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegionDrawCallbackData_get_cull_result_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SceneSetup *DisplayRegionDrawCallbackData::get_scene_setup(void) const
 *******************************************************************/
static PyObject *Dtool_DisplayRegionDrawCallbackData_get_scene_setup_237(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegionDrawCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegionDrawCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SceneSetup *DisplayRegionDrawCallbackData::get_scene_setup(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSceneSetup", key_word_list));
        else
            (PyArg_Parse(args, ":getSceneSetup"));
        if(!PyErr_Occurred())
        {
            SceneSetup *return_value = ((const DisplayRegionDrawCallbackData*)local_this)->get_scene_setup();
            if (return_value != (SceneSetup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SceneSetup,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSceneSetup(const DisplayRegionDrawCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionDrawCallbackData_get_scene_setup_237_comment =
    "C++ Interface:\n"
    "getSceneSetup(const DisplayRegionDrawCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplayRegionDrawCallbackData::get_scene_setup\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the SceneSetup object, which\n"
    "//               contains information about the camera and such.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplayRegionDrawCallbackData_get_scene_setup_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DisplayRegionDrawCallbackData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegionDrawCallbackData_get_class_type_238(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DisplayRegionDrawCallbackData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DisplayRegionDrawCallbackData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionDrawCallbackData_get_class_type_238_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DisplayRegionDrawCallbackData_get_class_type_238_comment = NULL;
#endif

int  Dtool_Init_DisplayRegionDrawCallbackData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DisplayRegionDrawCallbackData)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DisplayRegionDrawCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DisplayRegionDrawCallbackData)
    {
        printf("DisplayRegionDrawCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DisplayRegionDrawCallbackData * local_this = (DisplayRegionDrawCallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DisplayRegionDrawCallbackData)
        return local_this;
    if(requested_type == &Dtool_CallbackData)
        return ( CallbackData *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( CallbackData *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DisplayRegionDrawCallbackData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DisplayRegionDrawCallbackData)
        return from_this;
    if(from_type == &Dtool_CallbackData)
    {
          CallbackData* other_this = (CallbackData*)from_this;
          return (DisplayRegionDrawCallbackData*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DisplayRegionDrawCallbackData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DisplaySearchParameters 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DisplaySearchParameters::set_minimum_width(int minimum_width)
 *******************************************************************/
static PyObject *Dtool_DisplaySearchParameters_set_minimum_width_243(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplaySearchParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplaySearchParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplaySearchParameters::set_minimum_width(int minimum_width)
        int param1;
        static char * key_word_list[] = {(char *)"minimum_width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMinimumWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMinimumWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_minimum_width((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplaySearchParameters.setMinimumWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinimumWidth(non-const DisplaySearchParameters this, int minimum_width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplaySearchParameters_set_minimum_width_243_comment =
    "C++ Interface:\n"
    "setMinimumWidth(non-const DisplaySearchParameters this, int minimum_width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplaySearchParameters::set_minimum_width\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplaySearchParameters_set_minimum_width_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplaySearchParameters::set_maximum_width(int maximum_width)
 *******************************************************************/
static PyObject *Dtool_DisplaySearchParameters_set_maximum_width_244(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplaySearchParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplaySearchParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplaySearchParameters::set_maximum_width(int maximum_width)
        int param1;
        static char * key_word_list[] = {(char *)"maximum_width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaximumWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaximumWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_maximum_width((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplaySearchParameters.setMaximumWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaximumWidth(non-const DisplaySearchParameters this, int maximum_width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplaySearchParameters_set_maximum_width_244_comment =
    "C++ Interface:\n"
    "setMaximumWidth(non-const DisplaySearchParameters this, int maximum_width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplaySearchParameters::set_maximum_width\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplaySearchParameters_set_maximum_width_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplaySearchParameters::set_minimum_height(int minimum_height)
 *******************************************************************/
static PyObject *Dtool_DisplaySearchParameters_set_minimum_height_245(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplaySearchParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplaySearchParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplaySearchParameters::set_minimum_height(int minimum_height)
        int param1;
        static char * key_word_list[] = {(char *)"minimum_height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMinimumHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMinimumHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_minimum_height((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplaySearchParameters.setMinimumHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinimumHeight(non-const DisplaySearchParameters this, int minimum_height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplaySearchParameters_set_minimum_height_245_comment =
    "C++ Interface:\n"
    "setMinimumHeight(non-const DisplaySearchParameters this, int minimum_height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplaySearchParameters::set_minimum_height\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplaySearchParameters_set_minimum_height_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplaySearchParameters::set_maximum_height(int maximum_height)
 *******************************************************************/
static PyObject *Dtool_DisplaySearchParameters_set_maximum_height_246(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplaySearchParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplaySearchParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplaySearchParameters::set_maximum_height(int maximum_height)
        int param1;
        static char * key_word_list[] = {(char *)"maximum_height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaximumHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaximumHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_maximum_height((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplaySearchParameters.setMaximumHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaximumHeight(non-const DisplaySearchParameters this, int maximum_height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplaySearchParameters_set_maximum_height_246_comment =
    "C++ Interface:\n"
    "setMaximumHeight(non-const DisplaySearchParameters this, int maximum_height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplaySearchParameters::set_maximum_height\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplaySearchParameters_set_maximum_height_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplaySearchParameters::set_minimum_bits_per_pixel(int minimum_bits_per_pixel)
 *******************************************************************/
static PyObject *Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_247(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplaySearchParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplaySearchParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplaySearchParameters::set_minimum_bits_per_pixel(int minimum_bits_per_pixel)
        int param1;
        static char * key_word_list[] = {(char *)"minimum_bits_per_pixel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMinimumBitsPerPixel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMinimumBitsPerPixel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_minimum_bits_per_pixel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplaySearchParameters.setMinimumBitsPerPixel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinimumBitsPerPixel(non-const DisplaySearchParameters this, int minimum_bits_per_pixel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_247_comment =
    "C++ Interface:\n"
    "setMinimumBitsPerPixel(non-const DisplaySearchParameters this, int minimum_bits_per_pixel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplaySearchParameters::set_minimum_bits_per_pixel\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DisplaySearchParameters::set_maximum_bits_per_pixel(int maximum_bits_per_pixel)
 *******************************************************************/
static PyObject *Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_248(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplaySearchParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplaySearchParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DisplaySearchParameters::set_maximum_bits_per_pixel(int maximum_bits_per_pixel)
        int param1;
        static char * key_word_list[] = {(char *)"maximum_bits_per_pixel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaximumBitsPerPixel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaximumBitsPerPixel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_maximum_bits_per_pixel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DisplaySearchParameters.setMaximumBitsPerPixel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaximumBitsPerPixel(non-const DisplaySearchParameters this, int maximum_bits_per_pixel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_248_comment =
    "C++ Interface:\n"
    "setMaximumBitsPerPixel(non-const DisplaySearchParameters this, int maximum_bits_per_pixel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DisplaySearchParameters::set_maximum_bits_per_pixel\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DisplaySearchParameters::DisplaySearchParameters(void)
 *******************************************************************/
int  Dtool_Init_DisplaySearchParameters(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DisplaySearchParameters::DisplaySearchParameters(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DisplaySearchParameters", key_word_list))
        {
            DisplaySearchParameters *return_value = new DisplaySearchParameters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DisplaySearchParameters,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DisplaySearchParameters()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DisplaySearchParameters(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DisplaySearchParameters)
    {
        printf("DisplaySearchParameters ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DisplaySearchParameters * local_this = (DisplaySearchParameters *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DisplaySearchParameters)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DisplaySearchParameters(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DisplaySearchParameters)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FrameBufferProperties 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_depth_bits(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_depth_bits_250(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_depth_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDepthBits", key_word_list));
        else
            (PyArg_Parse(args, ":getDepthBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_depth_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDepthBits(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_depth_bits_250_comment =
    "C++ Interface:\n"
    "getDepthBits(const FrameBufferProperties this)\n"
    "\n"
    "// Individual queries.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_depth_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_depth_bits_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_color_bits(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_color_bits_251(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_color_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorBits", key_word_list));
        else
            (PyArg_Parse(args, ":getColorBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_color_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorBits(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_color_bits_251_comment =
    "C++ Interface:\n"
    "getColorBits(const FrameBufferProperties this)\n"
    "\n"
    "// Individual queries.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_color_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_color_bits_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_alpha_bits(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_alpha_bits_252(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_alpha_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlphaBits", key_word_list));
        else
            (PyArg_Parse(args, ":getAlphaBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_alpha_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlphaBits(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_alpha_bits_252_comment =
    "C++ Interface:\n"
    "getAlphaBits(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_alpha_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_alpha_bits_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_stencil_bits(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_stencil_bits_253(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_stencil_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStencilBits", key_word_list));
        else
            (PyArg_Parse(args, ":getStencilBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_stencil_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStencilBits(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_stencil_bits_253_comment =
    "C++ Interface:\n"
    "getStencilBits(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_stencil_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_stencil_bits_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_accum_bits(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_accum_bits_254(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_accum_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAccumBits", key_word_list));
        else
            (PyArg_Parse(args, ":getAccumBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_accum_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAccumBits(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_accum_bits_254_comment =
    "C++ Interface:\n"
    "getAccumBits(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_accum_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_accum_bits_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_aux_rgba(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_aux_rgba_255(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_aux_rgba(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAuxRgba", key_word_list));
        else
            (PyArg_Parse(args, ":getAuxRgba"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_aux_rgba();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAuxRgba(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_aux_rgba_255_comment =
    "C++ Interface:\n"
    "getAuxRgba(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_aux_rgba\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_aux_rgba_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_aux_hrgba(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_aux_hrgba_256(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_aux_hrgba(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAuxHrgba", key_word_list));
        else
            (PyArg_Parse(args, ":getAuxHrgba"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_aux_hrgba();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAuxHrgba(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_aux_hrgba_256_comment =
    "C++ Interface:\n"
    "getAuxHrgba(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_aux_hrgba\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_aux_hrgba_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_aux_float(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_aux_float_257(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_aux_float(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAuxFloat", key_word_list));
        else
            (PyArg_Parse(args, ":getAuxFloat"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_aux_float();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAuxFloat(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_aux_float_257_comment =
    "C++ Interface:\n"
    "getAuxFloat(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_aux_float\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_aux_float_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_multisamples(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_multisamples_258(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_multisamples(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMultisamples", key_word_list));
        else
            (PyArg_Parse(args, ":getMultisamples"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_multisamples();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMultisamples(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_multisamples_258_comment =
    "C++ Interface:\n"
    "getMultisamples(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_multisamples\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_multisamples_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_coverage_samples(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_coverage_samples_259(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_coverage_samples(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoverageSamples", key_word_list));
        else
            (PyArg_Parse(args, ":getCoverageSamples"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_coverage_samples();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoverageSamples(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_coverage_samples_259_comment =
    "C++ Interface:\n"
    "getCoverageSamples(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_coverage_samples\n"
    "//       Access: Published\n"
    "//  Description: If coverage samples are specified, and there is\n"
    "//               hardware support, we use coverage multisampling.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_coverage_samples_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_back_buffers(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_back_buffers_260(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_back_buffers(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBackBuffers", key_word_list));
        else
            (PyArg_Parse(args, ":getBackBuffers"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_back_buffers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBackBuffers(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_back_buffers_260_comment =
    "C++ Interface:\n"
    "getBackBuffers(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_back_buffers\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_back_buffers_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_indexed_color(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_indexed_color_261(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_indexed_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndexedColor", key_word_list));
        else
            (PyArg_Parse(args, ":getIndexedColor"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_indexed_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndexedColor(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_indexed_color_261_comment =
    "C++ Interface:\n"
    "getIndexedColor(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_indexed_color\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_indexed_color_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_rgb_color(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_rgb_color_262(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_rgb_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRgbColor", key_word_list));
        else
            (PyArg_Parse(args, ":getRgbColor"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_rgb_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRgbColor(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_rgb_color_262_comment =
    "C++ Interface:\n"
    "getRgbColor(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_rgb_color\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_rgb_color_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_stereo(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_stereo_263(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_stereo(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStereo", key_word_list));
        else
            (PyArg_Parse(args, ":getStereo"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_stereo();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStereo(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_stereo_263_comment =
    "C++ Interface:\n"
    "getStereo(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_stereo\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_stereo_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_force_hardware(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_force_hardware_264(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_force_hardware(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceHardware", key_word_list));
        else
            (PyArg_Parse(args, ":getForceHardware"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_force_hardware();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceHardware(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_force_hardware_264_comment =
    "C++ Interface:\n"
    "getForceHardware(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_force_hardware\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_force_hardware_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FrameBufferProperties::get_force_software(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_force_software_265(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FrameBufferProperties::get_force_software(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceSoftware", key_word_list));
        else
            (PyArg_Parse(args, ":getForceSoftware"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_force_software();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceSoftware(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_force_software_265_comment =
    "C++ Interface:\n"
    "getForceSoftware(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_force_software\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_force_software_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_depth_bits(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_depth_bits_266(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_depth_bits(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setDepthBits", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setDepthBits", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_depth_bits((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setDepthBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDepthBits(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_depth_bits_266_comment =
    "C++ Interface:\n"
    "setDepthBits(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "// Individual assigners.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_depth_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_depth_bits_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_color_bits(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_color_bits_267(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_color_bits(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setColorBits", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setColorBits", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_color_bits((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setColorBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColorBits(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_color_bits_267_comment =
    "C++ Interface:\n"
    "setColorBits(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "// Individual assigners.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_color_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_color_bits_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_alpha_bits(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_alpha_bits_268(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_alpha_bits(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAlphaBits", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAlphaBits", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_alpha_bits((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setAlphaBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlphaBits(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_alpha_bits_268_comment =
    "C++ Interface:\n"
    "setAlphaBits(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_alpha_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_alpha_bits_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_stencil_bits(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_stencil_bits_269(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_stencil_bits(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setStencilBits", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setStencilBits", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_stencil_bits((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setStencilBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStencilBits(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_stencil_bits_269_comment =
    "C++ Interface:\n"
    "setStencilBits(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_stencil_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_stencil_bits_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_accum_bits(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_accum_bits_270(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_accum_bits(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAccumBits", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAccumBits", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_accum_bits((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setAccumBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAccumBits(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_accum_bits_270_comment =
    "C++ Interface:\n"
    "setAccumBits(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_accum_bits\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_accum_bits_270_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_aux_rgba(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_aux_rgba_271(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_aux_rgba(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAuxRgba", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAuxRgba", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_aux_rgba((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setAuxRgba() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAuxRgba(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_aux_rgba_271_comment =
    "C++ Interface:\n"
    "setAuxRgba(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_aux_rgba\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_aux_rgba_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_aux_hrgba(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_aux_hrgba_272(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_aux_hrgba(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAuxHrgba", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAuxHrgba", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_aux_hrgba((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setAuxHrgba() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAuxHrgba(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_aux_hrgba_272_comment =
    "C++ Interface:\n"
    "setAuxHrgba(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_aux_hrgba\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_aux_hrgba_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_aux_float(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_aux_float_273(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_aux_float(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAuxFloat", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAuxFloat", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_aux_float((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setAuxFloat() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAuxFloat(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_aux_float_273_comment =
    "C++ Interface:\n"
    "setAuxFloat(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_aux_float\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_aux_float_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_multisamples(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_multisamples_274(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_multisamples(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMultisamples", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMultisamples", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_multisamples((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setMultisamples() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMultisamples(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_multisamples_274_comment =
    "C++ Interface:\n"
    "setMultisamples(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_multisamples\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_multisamples_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_coverage_samples(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_coverage_samples_275(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_coverage_samples(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCoverageSamples", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCoverageSamples", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coverage_samples((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setCoverageSamples() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoverageSamples(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_coverage_samples_275_comment =
    "C++ Interface:\n"
    "setCoverageSamples(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_coverage_samples\n"
    "//       Access: Published\n"
    "//  Description: If coverage samples are specified, and there is\n"
    "//               hardware support, we use coverage multisampling\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_coverage_samples_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_back_buffers(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_back_buffers_276(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_back_buffers(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBackBuffers", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBackBuffers", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_back_buffers((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setBackBuffers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBackBuffers(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_back_buffers_276_comment =
    "C++ Interface:\n"
    "setBackBuffers(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_back_buffers\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_back_buffers_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_indexed_color(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_indexed_color_277(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_indexed_color(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setIndexedColor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setIndexedColor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_indexed_color((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setIndexedColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIndexedColor(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_indexed_color_277_comment =
    "C++ Interface:\n"
    "setIndexedColor(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_indexed_color\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_indexed_color_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_rgb_color(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_rgb_color_278(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_rgb_color(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRgbColor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRgbColor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_rgb_color((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setRgbColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRgbColor(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_rgb_color_278_comment =
    "C++ Interface:\n"
    "setRgbColor(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_rgb_color\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_rgb_color_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_stereo(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_stereo_279(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_stereo(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setStereo", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setStereo", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_stereo((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setStereo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStereo(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_stereo_279_comment =
    "C++ Interface:\n"
    "setStereo(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_stereo\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_stereo_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_force_hardware(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_force_hardware_280(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_force_hardware(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setForceHardware", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setForceHardware", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_force_hardware((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setForceHardware() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForceHardware(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_force_hardware_280_comment =
    "C++ Interface:\n"
    "setForceHardware(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_force_hardware\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_force_hardware_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameBufferProperties::set_force_software(int n)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_force_software_281(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameBufferProperties::set_force_software(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setForceSoftware", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setForceSoftware", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_force_software((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setForceSoftware() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForceSoftware(non-const FrameBufferProperties this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_force_software_281_comment =
    "C++ Interface:\n"
    "setForceSoftware(non-const FrameBufferProperties this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_force_software\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_force_software_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameBufferProperties::operator =(FrameBufferProperties const &copy)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_operator_284(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void FrameBufferProperties::operator =(FrameBufferProperties const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    FrameBufferProperties *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_FrameBufferProperties,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrameBufferProperties.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const FrameBufferProperties this, const FrameBufferProperties copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_operator_284_comment =
    "C++ Interface:\n"
    "assign(non-const FrameBufferProperties this, const FrameBufferProperties copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_operator_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static FrameBufferProperties const &FrameBufferProperties::get_default(void)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_default_285(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static FrameBufferProperties const &FrameBufferProperties::get_default(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefault", key_word_list))
        {
            FrameBufferProperties const *return_value = &(FrameBufferProperties::get_default());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_FrameBufferProperties,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefault()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_default_285_comment =
    "C++ Interface:\n"
    "getDefault()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_default\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a FrameBufferProperties structure with all of\n"
    "//               the default values filled in according to the user's\n"
    "//               config file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_default_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::operator ==(FrameBufferProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_operator_286(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool FrameBufferProperties::operator ==(FrameBufferProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const FrameBufferProperties*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const FrameBufferProperties this, const FrameBufferProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_operator_286_comment =
    "C++ Interface:\n"
    "eq(const FrameBufferProperties this, const FrameBufferProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::operator == \n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_operator_286_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool FrameBufferProperties::operator !=(FrameBufferProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_operator_287(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool FrameBufferProperties::operator !=(FrameBufferProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const FrameBufferProperties*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const FrameBufferProperties this, const FrameBufferProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_operator_287_comment =
    "C++ Interface:\n"
    "ne(const FrameBufferProperties this, const FrameBufferProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_operator_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameBufferProperties::clear(void)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_clear_288(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FrameBufferProperties::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_clear_288_comment =
    "C++ Interface:\n"
    "clear(non-const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::clear\n"
    "//       Access: Published\n"
    "//  Description: Unsets all properties that have been specified so\n"
    "//               far, and resets the FrameBufferProperties structure to its\n"
    "//               initial empty state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_clear_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameBufferProperties::set_all_specified(void)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_all_specified_289(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FrameBufferProperties::set_all_specified(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setAllSpecified", key_word_list));
        else
            (PyArg_Parse(args, ":setAllSpecified"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_all_specified();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setAllSpecified() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAllSpecified(non-const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_all_specified_289_comment =
    "C++ Interface:\n"
    "setAllSpecified(non-const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_all_specified\n"
    "//       Access: Published\n"
    "//  Description: sets all the specified bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_all_specified_289_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::subsumes(FrameBufferProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_subsumes_290(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool FrameBufferProperties::subsumes(FrameBufferProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:subsumes", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:subsumes", &param1));
            if(!PyErr_Occurred())
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.subsumes", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const FrameBufferProperties*)local_this)->subsumes(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "subsumes(const FrameBufferProperties this, const FrameBufferProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_subsumes_290_comment =
    "C++ Interface:\n"
    "subsumes(const FrameBufferProperties this, const FrameBufferProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::subsumes\n"
    "//       Access: Public\n"
    "//  Description: Returns true if this set of properties makes\n"
    "//               strictly greater or equal demands of the framebuffer\n"
    "//               than the other set of framebuffer properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_subsumes_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameBufferProperties::add_properties(FrameBufferProperties const &other)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_add_properties_291(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void FrameBufferProperties::add_properties(FrameBufferProperties const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addProperties", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addProperties", &param1));
            if(!PyErr_Occurred())
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.addProperties", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_properties(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrameBufferProperties.addProperties() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addProperties(non-const FrameBufferProperties this, const FrameBufferProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_add_properties_291_comment =
    "C++ Interface:\n"
    "addProperties(non-const FrameBufferProperties this, const FrameBufferProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::add_properties\n"
    "//       Access: Published\n"
    "//  Description: Sets any properties that are explicitly specified in\n"
    "//               other on this object.  Leaves other properties\n"
    "//               unchanged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_add_properties_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameBufferProperties::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_output_292(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void FrameBufferProperties::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "FrameBufferProperties.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const FrameBufferProperties*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const FrameBufferProperties this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_output_292_comment =
    "C++ Interface:\n"
    "output(const FrameBufferProperties this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::output\n"
    "//       Access: Published\n"
    "//  Description: Sets any properties that are explicitly specified in\n"
    "//               other on this object.  Leaves other properties\n"
    "//               unchanged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_output_292_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameBufferProperties::set_one_bit_per_channel(void)
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_set_one_bit_per_channel_293(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FrameBufferProperties::set_one_bit_per_channel(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setOneBitPerChannel", key_word_list));
        else
            (PyArg_Parse(args, ":setOneBitPerChannel"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_one_bit_per_channel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameBufferProperties.setOneBitPerChannel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOneBitPerChannel(non-const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_set_one_bit_per_channel_293_comment =
    "C++ Interface:\n"
    "setOneBitPerChannel(non-const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::set_one_bit_per_channel\n"
    "//       Access: Published\n"
    "//  Description: If any of the depth, color, alpha, accum, or\n"
    "//               stencil properties is set to more than one,\n"
    "//               then they are reduced to one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_set_one_bit_per_channel_293_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::is_stereo(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_is_stereo_294(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool FrameBufferProperties::is_stereo(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStereo", key_word_list));
        else
            (PyArg_Parse(args, ":isStereo"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const FrameBufferProperties*)local_this)->is_stereo();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStereo(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_is_stereo_294_comment =
    "C++ Interface:\n"
    "isStereo(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::is_stereo\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_is_stereo_294_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::is_single_buffered(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_is_single_buffered_295(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool FrameBufferProperties::is_single_buffered(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSingleBuffered", key_word_list));
        else
            (PyArg_Parse(args, ":isSingleBuffered"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const FrameBufferProperties*)local_this)->is_single_buffered();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSingleBuffered(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_is_single_buffered_295_comment =
    "C++ Interface:\n"
    "isSingleBuffered(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::is_single_buffered\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_is_single_buffered_295_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int FrameBufferProperties::get_quality(FrameBufferProperties const &reqs) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_quality_296(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int FrameBufferProperties::get_quality(FrameBufferProperties const &reqs) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"reqs", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getQuality", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getQuality", &param1));
            if(!PyErr_Occurred())
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.getQuality", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const FrameBufferProperties*)local_this)->get_quality(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuality(const FrameBufferProperties this, const FrameBufferProperties reqs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_quality_296_comment =
    "C++ Interface:\n"
    "getQuality(const FrameBufferProperties this, const FrameBufferProperties reqs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_quality\n"
    "//       Access: Published\n"
    "//  Description: Assumes that these properties are a description of\n"
    "//               a window.\n"
    "//\n"
    "//               Measures how well this window satisfies a specified\n"
    "//               set of requirements.  A higher quality number means\n"
    "//               that more requirements were satisfied.  A quality of\n"
    "//               zero means that the window is unsuitable.\n"
    "//\n"
    "//               The routine deducts a lot if the window fails to\n"
    "//               provide a requested feature.  It deducts less\n"
    "//               if the window provides a feature, but at a degraded\n"
    "//               level of functionality (ie, the user asks for rgba8,\n"
    "//               color, but the window only provides rgba4).  The\n"
    "//               routine also deducts a small amount for unnecessary\n"
    "//               features.  For example, if the window has an\n"
    "//               accumulation buffer when one is not requested will\n"
    "//               reduce quality slightly.  Maximum quality is obtained\n"
    "//               when the window exactly matches the request.\n"
    "//\n"
    "//               If you want to know whether the window satisfies\n"
    "//               all of the requirements, use the \"subsumes\" function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_quality_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::is_any_specified(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_is_any_specified_297(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool FrameBufferProperties::is_any_specified(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAnySpecified", key_word_list));
        else
            (PyArg_Parse(args, ":isAnySpecified"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const FrameBufferProperties*)local_this)->is_any_specified();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAnySpecified(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_is_any_specified_297_comment =
    "C++ Interface:\n"
    "isAnySpecified(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::is_any_specified\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any properties have been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_is_any_specified_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::is_basic(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_is_basic_298(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool FrameBufferProperties::is_basic(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBasic", key_word_list));
        else
            (PyArg_Parse(args, ":isBasic"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const FrameBufferProperties*)local_this)->is_basic();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBasic(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_is_basic_298_comment =
    "C++ Interface:\n"
    "isBasic(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::is_basic\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the properties are extremely basic.\n"
    "//               The following count as basic: rgb or rgba, depth.\n"
    "//               If anything else is specified, the properties are\n"
    "//               non-basic.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_is_basic_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int FrameBufferProperties::get_aux_mask(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_aux_mask_299(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int FrameBufferProperties::get_aux_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAuxMask", key_word_list));
        else
            (PyArg_Parse(args, ":getAuxMask"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_aux_mask();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAuxMask(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_aux_mask_299_comment =
    "C++ Interface:\n"
    "getAuxMask(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_aux_mask\n"
    "//       Access: Published\n"
    "//  Description: Converts the aux bitplanes of the\n"
    "//               framebuffer into a RenderBuffer::Type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_aux_mask_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int FrameBufferProperties::get_buffer_mask(void) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_get_buffer_mask_300(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int FrameBufferProperties::get_buffer_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBufferMask", key_word_list));
        else
            (PyArg_Parse(args, ":getBufferMask"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FrameBufferProperties*)local_this)->get_buffer_mask();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBufferMask(const FrameBufferProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_get_buffer_mask_300_comment =
    "C++ Interface:\n"
    "getBufferMask(const FrameBufferProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::get_buffer_mask\n"
    "//       Access: Private\n"
    "//  Description: Converts the non-aux bitplanes of the\n"
    "//               framebuffer into a RenderBuffer::Type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_get_buffer_mask_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool FrameBufferProperties::verify_hardware_software(FrameBufferProperties const &props, basic_string< char > const &renderer) const
 *******************************************************************/
static PyObject *Dtool_FrameBufferProperties_verify_hardware_software_301(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool FrameBufferProperties::verify_hardware_software(FrameBufferProperties const &props, basic_string< char > const &renderer) const
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"props", (char *)"renderer", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:verifyHardwareSoftware", key_word_list, &param1, &param2_str, &param2_len))
            {
                FrameBufferProperties *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FrameBufferProperties, 1, "FrameBufferProperties.verifyHardwareSoftware", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const FrameBufferProperties*)local_this)->verify_hardware_software(*param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "verifyHardwareSoftware(const FrameBufferProperties this, const FrameBufferProperties props, string renderer)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameBufferProperties_verify_hardware_software_301_comment =
    "C++ Interface:\n"
    "verifyHardwareSoftware(const FrameBufferProperties this, const FrameBufferProperties props, string renderer)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameBufferProperties::verify_hardware_software\n"
    "//       Access: Public\n"
    "//  Description: Validates that the properties represent the desired\n"
    "//               kind of renderer (hardware or software).  If not,\n"
    "//               prints out an error message and returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameBufferProperties_verify_hardware_software_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FrameBufferProperties::FrameBufferProperties(void)
 * inline FrameBufferProperties::FrameBufferProperties(FrameBufferProperties const &copy)
 *******************************************************************/
int  Dtool_Init_FrameBufferProperties(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-FrameBufferProperties::FrameBufferProperties(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":FrameBufferProperties", key_word_list))
            {
                FrameBufferProperties *return_value = new FrameBufferProperties();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_FrameBufferProperties,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline FrameBufferProperties::FrameBufferProperties(FrameBufferProperties const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:FrameBufferProperties", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:FrameBufferProperties", &param0));
                if(!PyErr_Occurred())
                {
                    FrameBufferProperties *param0_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_FrameBufferProperties, 0, "FrameBufferProperties.FrameBufferProperties", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        FrameBufferProperties *return_value = new FrameBufferProperties(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_FrameBufferProperties,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FrameBufferProperties() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FrameBufferProperties()\n"
          "FrameBufferProperties(const FrameBufferProperties copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FrameBufferProperties(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FrameBufferProperties)
    {
        printf("FrameBufferProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FrameBufferProperties * local_this = (FrameBufferProperties *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FrameBufferProperties)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FrameBufferProperties(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FrameBufferProperties)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsThreadingModel 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsThreadingModel::operator =(GraphicsThreadingModel const &copy)
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_operator_304(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void GraphicsThreadingModel::operator =(GraphicsThreadingModel const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsThreadingModel *param1_this = (GraphicsThreadingModel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsThreadingModel, 1, "GraphicsThreadingModel.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    GraphicsThreadingModel *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsThreadingModel,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsThreadingModel.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const GraphicsThreadingModel this, const GraphicsThreadingModel copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_operator_304_comment =
    "C++ Interface:\n"
    "assign(non-const GraphicsThreadingModel this, const GraphicsThreadingModel copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_operator_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > GraphicsThreadingModel::get_model(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_get_model_305(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > GraphicsThreadingModel::get_model(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModel", key_word_list));
        else
            (PyArg_Parse(args, ":getModel"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const GraphicsThreadingModel*)local_this)->get_model();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModel(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_get_model_305_comment =
    "C++ Interface:\n"
    "getModel(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::get_model\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that describes the threading\n"
    "//               model.  See the constructor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_get_model_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &GraphicsThreadingModel::get_cull_name(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_get_cull_name_306(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &GraphicsThreadingModel::get_cull_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullName", key_word_list));
        else
            (PyArg_Parse(args, ":getCullName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const GraphicsThreadingModel*)local_this)->get_cull_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullName(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_get_cull_name_306_comment =
    "C++ Interface:\n"
    "getCullName(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::get_cull_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the thread that will handle\n"
    "//               culling in this model.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_get_cull_name_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsThreadingModel::set_cull_name(basic_string< char > const &cull_name)
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_set_cull_name_307(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsThreadingModel::set_cull_name(basic_string< char > const &cull_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"cull_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCullName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCullName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cull_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsThreadingModel.setCullName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCullName(non-const GraphicsThreadingModel this, string cull_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_set_cull_name_307_comment =
    "C++ Interface:\n"
    "setCullName(non-const GraphicsThreadingModel this, string cull_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::set_cull_name\n"
    "//       Access: Published\n"
    "//  Description: Changes the name of the thread that will handle\n"
    "//               culling in this model.  This won't change any windows\n"
    "//               that were already created with this model; this only\n"
    "//               has an effect on newly-opened windows.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_set_cull_name_307_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsThreadingModel::get_cull_stage(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_get_cull_stage_308(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsThreadingModel::get_cull_stage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullStage", key_word_list));
        else
            (PyArg_Parse(args, ":getCullStage"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsThreadingModel*)local_this)->get_cull_stage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullStage(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_get_cull_stage_308_comment =
    "C++ Interface:\n"
    "getCullStage(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::get_cull_stage\n"
    "//       Access: Published\n"
    "//  Description: Returns the pipeline stage from which the cull thread\n"
    "//               should access data.  This will be 0 if the cull is\n"
    "//               run in the same thread as app, or 1 if it is its own\n"
    "//               thread.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_get_cull_stage_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &GraphicsThreadingModel::get_draw_name(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_get_draw_name_309(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &GraphicsThreadingModel::get_draw_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDrawName", key_word_list));
        else
            (PyArg_Parse(args, ":getDrawName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const GraphicsThreadingModel*)local_this)->get_draw_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDrawName(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_get_draw_name_309_comment =
    "C++ Interface:\n"
    "getDrawName(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::get_draw_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the thread that will handle\n"
    "//               sending the actual graphics primitives to the\n"
    "//               graphics API in this model.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_get_draw_name_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsThreadingModel::set_draw_name(basic_string< char > const &cull_name)
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_set_draw_name_310(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsThreadingModel::set_draw_name(basic_string< char > const &cull_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"cull_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDrawName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDrawName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_draw_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsThreadingModel.setDrawName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDrawName(non-const GraphicsThreadingModel this, string cull_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_set_draw_name_310_comment =
    "C++ Interface:\n"
    "setDrawName(non-const GraphicsThreadingModel this, string cull_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::set_draw_name\n"
    "//       Access: Published\n"
    "//  Description: Changes the name of the thread that will handle\n"
    "//               drawing in this model.  This won't change any windows\n"
    "//               that were already created with this model; this only\n"
    "//               has an effect on newly-opened windows.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_set_draw_name_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsThreadingModel::get_draw_stage(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_get_draw_stage_311(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsThreadingModel::get_draw_stage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDrawStage", key_word_list));
        else
            (PyArg_Parse(args, ":getDrawStage"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsThreadingModel*)local_this)->get_draw_stage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDrawStage(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_get_draw_stage_311_comment =
    "C++ Interface:\n"
    "getDrawStage(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::get_draw_stage\n"
    "//       Access: Published\n"
    "//  Description: Returns the pipeline stage from which the draw thread\n"
    "//               should access data.  This will be the same value as\n"
    "//               get_cull_stage() if cull and draw are run in the same\n"
    "//               thread, or one more than that value if draw should be\n"
    "//               in its own thread.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_get_draw_stage_311_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsThreadingModel::get_cull_sorting(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_get_cull_sorting_312(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsThreadingModel::get_cull_sorting(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullSorting", key_word_list));
        else
            (PyArg_Parse(args, ":getCullSorting"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsThreadingModel*)local_this)->get_cull_sorting();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullSorting(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_get_cull_sorting_312_comment =
    "C++ Interface:\n"
    "getCullSorting(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::get_cull_sorting\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the model involves a separate cull\n"
    "//               pass, or false if culling happens implicitly, at the\n"
    "//               same time as draw.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_get_cull_sorting_312_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsThreadingModel::set_cull_sorting(bool cull_sorting)
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_set_cull_sorting_313(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsThreadingModel::set_cull_sorting(bool cull_sorting)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"cull_sorting", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCullSorting", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCullSorting", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cull_sorting((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsThreadingModel.setCullSorting() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCullSorting(non-const GraphicsThreadingModel this, bool cull_sorting)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_set_cull_sorting_313_comment =
    "C++ Interface:\n"
    "setCullSorting(non-const GraphicsThreadingModel this, bool cull_sorting)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::set_cull_sorting\n"
    "//       Access: Published\n"
    "//  Description: Changes the flag that indicates whether the threading\n"
    "//               model involves a separate cull pass.  This won't\n"
    "//               change any windows that were already created with\n"
    "//               this model; this only has an effect on newly-opened\n"
    "//               windows.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_set_cull_sorting_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsThreadingModel::is_single_threaded(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_is_single_threaded_314(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsThreadingModel::is_single_threaded(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSingleThreaded", key_word_list));
        else
            (PyArg_Parse(args, ":isSingleThreaded"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsThreadingModel*)local_this)->is_single_threaded();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSingleThreaded(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_is_single_threaded_314_comment =
    "C++ Interface:\n"
    "isSingleThreaded(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::is_single_threaded\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the threading model is a\n"
    "//               single-threaded model, or false if it involves\n"
    "//               threads.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_is_single_threaded_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsThreadingModel::is_default(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_is_default_315(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsThreadingModel::is_default(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDefault", key_word_list));
        else
            (PyArg_Parse(args, ":isDefault"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsThreadingModel*)local_this)->is_default();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDefault(const GraphicsThreadingModel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_is_default_315_comment =
    "C++ Interface:\n"
    "isDefault(const GraphicsThreadingModel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::is_default\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the threading model is the default,\n"
    "//               cull-then-draw single-threaded model, or false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_is_default_315_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsThreadingModel::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_GraphicsThreadingModel_output_316(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void GraphicsThreadingModel::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "GraphicsThreadingModel.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const GraphicsThreadingModel*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const GraphicsThreadingModel this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsThreadingModel_output_316_comment =
    "C++ Interface:\n"
    "output(const GraphicsThreadingModel this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsThreadingModel::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsThreadingModel_output_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsThreadingModel::GraphicsThreadingModel(GraphicsThreadingModel const &copy)
 * GraphicsThreadingModel::GraphicsThreadingModel(basic_string< char > const &model)
 * GraphicsThreadingModel::GraphicsThreadingModel(basic_string< char > const &model = ((string())))
 *******************************************************************/
int  Dtool_Init_GraphicsThreadingModel(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-GraphicsThreadingModel::GraphicsThreadingModel(basic_string< char > const &model = ((string())))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":GraphicsThreadingModel", key_word_list))
            {
                GraphicsThreadingModel *return_value = new GraphicsThreadingModel();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_GraphicsThreadingModel,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 GraphicsThreadingModel::GraphicsThreadingModel(basic_string< char > const &model)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"model", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GraphicsThreadingModel", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:GraphicsThreadingModel", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    GraphicsThreadingModel *return_value = new GraphicsThreadingModel(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_GraphicsThreadingModel,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline GraphicsThreadingModel::GraphicsThreadingModel(GraphicsThreadingModel const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:GraphicsThreadingModel", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:GraphicsThreadingModel", &param0));
                if(!PyErr_Occurred())
                {
                    GraphicsThreadingModel *param0_this = (GraphicsThreadingModel *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GraphicsThreadingModel, 0, "GraphicsThreadingModel.GraphicsThreadingModel", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        GraphicsThreadingModel *return_value = new GraphicsThreadingModel(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_GraphicsThreadingModel,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GraphicsThreadingModel() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GraphicsThreadingModel()\n"
          "GraphicsThreadingModel(string model)\n"
          "GraphicsThreadingModel(const GraphicsThreadingModel copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_GraphicsThreadingModel(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsThreadingModel)
    {
        printf("GraphicsThreadingModel ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsThreadingModel * local_this = (GraphicsThreadingModel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsThreadingModel)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsThreadingModel(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsThreadingModel)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsDevice 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline GraphicsPipe *GraphicsDevice::get_pipe(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsDevice_get_pipe_319(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsDevice * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsDevice,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsPipe *GraphicsDevice::get_pipe(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPipe", key_word_list));
        else
            (PyArg_Parse(args, ":getPipe"));
        if(!PyErr_Occurred())
        {
            GraphicsPipe *return_value = ((const GraphicsDevice*)local_this)->get_pipe();
            if (return_value != (GraphicsPipe *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsPipe,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPipe(const GraphicsDevice this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsDevice_get_pipe_319_comment =
    "C++ Interface:\n"
    "getPipe(const GraphicsDevice this)\n"
    "\n"
    "// Filename: graphicsDevice.I\n"
    "// Created by:  masad (21Jul03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsDevice::get_pipe\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsPipe that this device is\n"
    "//               associated with.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsDevice_get_pipe_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsDevice::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsDevice_get_class_type_320(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsDevice::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsDevice::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsDevice_get_class_type_320_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsDevice_get_class_type_320_comment = NULL;
#endif

int  Dtool_Init_GraphicsDevice(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsDevice)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GraphicsDevice(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsDevice)
    {
        printf("GraphicsDevice ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsDevice * local_this = (GraphicsDevice *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsDevice)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsDevice(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsDevice)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsDevice*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsDevice*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (GraphicsDevice*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsPipe 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsPipe::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_is_valid_324(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsPipe::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsPipe*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_is_valid_324_comment =
    "C++ Interface:\n"
    "isValid(const GraphicsPipe this)\n"
    "\n"
    "// Filename: graphicsPipe.I\n"
    "// Created by:  frang (07Mar99)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns false if this pipe is known to be invalid,\n"
    "//               meaning that an attempt to create a GraphicsWindow\n"
    "//               with the pipe will certainly fail.  Returns true if\n"
    "//               the pipe is probably valid (is this case, an attempt\n"
    "//               to create a GraphicsWindow should succeed, but might\n"
    "//               still fail).\n"
    "//\n"
    "//               Use the GraphicsEngine class to create a\n"
    "//               GraphicsWindow on a particular pipe.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_is_valid_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsPipe::get_supported_types(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_get_supported_types_325(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsPipe::get_supported_types(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportedTypes", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportedTypes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsPipe*)local_this)->get_supported_types();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportedTypes(const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_get_supported_types_325_comment =
    "C++ Interface:\n"
    "getSupportedTypes(const GraphicsPipe this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::get_supported_types\n"
    "//       Access: Published\n"
    "//  Description: Returns the mask of bits that represents the kinds of\n"
    "//               GraphicsOutput objects this pipe might be able to\n"
    "//               successfully create.  The return value is the union\n"
    "//               of bits in GraphicsPipe::OutputTypes that represents\n"
    "//               the set of GraphicsOutput types.\n"
    "//\n"
    "//               A 1 bit in a particular position is not a guarantee\n"
    "//               of success, but a 0 bit is a guarantee of failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_get_supported_types_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsPipe::supports_type(int flags) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_supports_type_326(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsPipe::supports_type(int flags) const
        int param1;
        static char * key_word_list[] = {(char *)"flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:supportsType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:supportsType", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsPipe*)local_this)->supports_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "supportsType(const GraphicsPipe this, int flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_supports_type_326_comment =
    "C++ Interface:\n"
    "supportsType(const GraphicsPipe this, int flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::supports_type\n"
    "//       Access: Published\n"
    "//  Description: A convenience function to ask if a particular type or\n"
    "//               types of GraphicsObjects are supported.  The\n"
    "//               parameter is a union of one or more bits defined in\n"
    "//               GrpahicsPipe::OutputTypes.\n"
    "//\n"
    "//               Returns true if all of the requested types are listed\n"
    "//               in the supported_types mask, false if any one of them\n"
    "//               is not.  This is not a guarantee that the indicated\n"
    "//               output type will successfully be created when it is\n"
    "//               attempted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_supports_type_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsPipe::get_display_width(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_get_display_width_327(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsPipe::get_display_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayWidth"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsPipe*)local_this)->get_display_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayWidth(const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_get_display_width_327_comment =
    "C++ Interface:\n"
    "getDisplayWidth(const GraphicsPipe this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::get_display_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of the entire display, if it is\n"
    "//               known.  This may return 0.  This is not a guarantee\n"
    "//               that windows (particularly fullscreen windows) may\n"
    "//               not be created larger than this width, but it is\n"
    "//               intended to provide a hint to the application.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_get_display_width_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsPipe::get_display_height(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_get_display_height_328(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsPipe::get_display_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayHeight"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsPipe*)local_this)->get_display_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayHeight(const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_get_display_height_328_comment =
    "C++ Interface:\n"
    "getDisplayHeight(const GraphicsPipe this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::get_display_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the height of the entire display, if it is\n"
    "//               known.  This may return 0.  See the caveats for\n"
    "//               get_display_width().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_get_display_height_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DisplayInformation *GraphicsPipe::get_display_information(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_get_display_information_329(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DisplayInformation *GraphicsPipe::get_display_information(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayInformation", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayInformation"));
        if(!PyErr_Occurred())
        {
            DisplayInformation *return_value = (local_this)->get_display_information();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DisplayInformation,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsPipe.getDisplayInformation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayInformation(non-const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_get_display_information_329_comment =
    "C++ Interface:\n"
    "getDisplayInformation(non-const GraphicsPipe this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::get_display_information\n"
    "//       Access: Published\n"
    "//  Description: Gets the pipe's DisplayInformation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_get_display_information_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsPipe::lookup_cpu_data(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_lookup_cpu_data_330(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsPipe::lookup_cpu_data(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":lookupCpuData", key_word_list));
        else
            (PyArg_Parse(args, ":lookupCpuData"));
        if(!PyErr_Occurred())
        {
            (local_this)->lookup_cpu_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsPipe.lookupCpuData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lookupCpuData(non-const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_lookup_cpu_data_330_comment =
    "C++ Interface:\n"
    "lookupCpuData(non-const GraphicsPipe this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipe::lookup_cpu_data\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Looks up the detailed CPU information and stores it\n"
    "//               in _display_information, if supported by the OS.\n"
    "//               This may take a second or two.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipe_lookup_cpu_data_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual basic_string< char > GraphicsPipe::get_interface_name(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_get_interface_name_331(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipe * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipe,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual basic_string< char > GraphicsPipe::get_interface_name(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInterfaceName", key_word_list));
        else
            (PyArg_Parse(args, ":getInterfaceName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const GraphicsPipe*)local_this)->get_interface_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInterfaceName(const GraphicsPipe this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_get_interface_name_331_comment =
    "C++ Interface:\n"
    "getInterfaceName(const GraphicsPipe this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsPipe_get_interface_name_331_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsPipe::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipe_get_class_type_332(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsPipe::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsPipe::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipe_get_class_type_332_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsPipe_get_class_type_332_comment = NULL;
#endif

int  Dtool_Init_GraphicsPipe(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsPipe)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GraphicsPipe(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsPipe)
    {
        printf("GraphicsPipe ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsPipe * local_this = (GraphicsPipe *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsPipe)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsPipe(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsPipe)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsPipe*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsPipe*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (GraphicsPipe*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StencilRenderStates 
//********************************************************************
int  Dtool_Init_StencilRenderStates(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (StencilRenderStates)");
       return -1;
}
inline void  * Dtool_UpcastInterface_StencilRenderStates(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StencilRenderStates)
    {
        printf("StencilRenderStates ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StencilRenderStates * local_this = (StencilRenderStates *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StencilRenderStates)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StencilRenderStates(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StencilRenderStates)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsStateGuardian 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsStateGuardian::release_all(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_release_all_341(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsStateGuardian::release_all(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":releaseAll", key_word_list));
        else
            (PyArg_Parse(args, ":releaseAll"));
        if(!PyErr_Occurred())
        {
            (local_this)->release_all();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.releaseAll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseAll(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_release_all_341_comment =
    "C++ Interface:\n"
    "releaseAll(non-const GraphicsStateGuardian this)\n"
    "\n"
    "// Filename: graphicsStateGuardian.I\n"
    "// Created by:  drose (24Sep99)\n"
    "// Updated by: fperazzi, PandaSE (29Apr10) (added \n"
    "// get_max_2d_texture_array_layers and related)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::release_all\n"
    "//       Access: Public\n"
    "//  Description: Releases all prepared objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_release_all_341_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::release_all_textures(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_release_all_textures_342(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int GraphicsStateGuardian::release_all_textures(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":releaseAllTextures", key_word_list));
        else
            (PyArg_Parse(args, ":releaseAllTextures"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->release_all_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.releaseAllTextures() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseAllTextures(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_release_all_textures_342_comment =
    "C++ Interface:\n"
    "releaseAllTextures(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::release_all_textures\n"
    "//       Access: Public\n"
    "//  Description: Frees the resources for all textures associated with\n"
    "//               this GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_release_all_textures_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::release_all_geoms(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_release_all_geoms_343(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int GraphicsStateGuardian::release_all_geoms(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":releaseAllGeoms", key_word_list));
        else
            (PyArg_Parse(args, ":releaseAllGeoms"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->release_all_geoms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.releaseAllGeoms() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseAllGeoms(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_release_all_geoms_343_comment =
    "C++ Interface:\n"
    "releaseAllGeoms(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::release_all_geoms\n"
    "//       Access: Public\n"
    "//  Description: Frees the resources for all geoms associated with\n"
    "//               this GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_release_all_geoms_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::release_all_vertex_buffers(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_release_all_vertex_buffers_344(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int GraphicsStateGuardian::release_all_vertex_buffers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":releaseAllVertexBuffers", key_word_list));
        else
            (PyArg_Parse(args, ":releaseAllVertexBuffers"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->release_all_vertex_buffers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.releaseAllVertexBuffers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseAllVertexBuffers(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_release_all_vertex_buffers_344_comment =
    "C++ Interface:\n"
    "releaseAllVertexBuffers(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::release_all_vertex_buffers\n"
    "//       Access: Public\n"
    "//  Description: Frees the resources for all vertex buffers associated\n"
    "//               with this GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_release_all_vertex_buffers_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::release_all_index_buffers(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_release_all_index_buffers_345(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int GraphicsStateGuardian::release_all_index_buffers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":releaseAllIndexBuffers", key_word_list));
        else
            (PyArg_Parse(args, ":releaseAllIndexBuffers"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->release_all_index_buffers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.releaseAllIndexBuffers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseAllIndexBuffers(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_release_all_index_buffers_345_comment =
    "C++ Interface:\n"
    "releaseAllIndexBuffers(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::release_all_index_buffers\n"
    "//       Access: Public\n"
    "//  Description: Frees the resources for all index buffers associated\n"
    "//               with this GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_release_all_index_buffers_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsStateGuardian::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_active_346(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsStateGuardian::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const GraphicsStateGuardian this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_active_346_comment =
    "C++ Interface:\n"
    "setActive(non-const GraphicsStateGuardian this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_active\n"
    "//       Access: Published\n"
    "//  Description: Sets the active flag associated with the\n"
    "//               GraphicsStateGuardian.  If the GraphicsStateGuardian\n"
    "//               is marked inactive, nothing is rendered.  This is not\n"
    "//               normally turned off unless there is a problem with\n"
    "//               the rendering detected at a low level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_active_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::is_active(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_is_active_347(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::is_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isActive", key_word_list));
        else
            (PyArg_Parse(args, ":isActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->is_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isActive(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_is_active_347_comment =
    "C++ Interface:\n"
    "isActive(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::is_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the active flag associated with the\n"
    "//               GraphicsStateGuardian.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_is_active_347_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_is_valid_348(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_is_valid_348_comment =
    "C++ Interface:\n"
    "isValid(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the GSG has been correctly\n"
    "//               initialized within a graphics context, false if there\n"
    "//               has been some problem or it hasn't been initialized\n"
    "//               yet.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_is_valid_348_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::needs_reset(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_needs_reset_349(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::needs_reset(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":needsReset", key_word_list));
        else
            (PyArg_Parse(args, ":needsReset"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->needs_reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "needsReset(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_needs_reset_349_comment =
    "C++ Interface:\n"
    "needsReset(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::needs_reset\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the gsg is marked as needing a\n"
    "//               reset.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_needs_reset_349_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsStateGuardian::set_incomplete_render(bool incomplete_render)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_incomplete_render_350(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsStateGuardian::set_incomplete_render(bool incomplete_render)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"incomplete_render", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIncompleteRender", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setIncompleteRender", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_incomplete_render((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.setIncompleteRender() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIncompleteRender(non-const GraphicsStateGuardian this, bool incomplete_render)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_incomplete_render_350_comment =
    "C++ Interface:\n"
    "setIncompleteRender(non-const GraphicsStateGuardian this, bool incomplete_render)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_incomplete_render\n"
    "//       Access: Public\n"
    "//  Description: Sets the incomplete_render flag.  When this is\n"
    "//               true, the frame will be rendered even if some of the\n"
    "//               geometry or textures in the scene are not available\n"
    "//               (e.g. they have been temporarily paged out).  When\n"
    "//               this is false, the frame will be held up while this\n"
    "//               data is reloaded.\n"
    "//\n"
    "//               Setting this true allows for a smoother frame rate,\n"
    "//               but occasionally parts of the frame will be invisible\n"
    "//               or missing (they will generally come in within a\n"
    "//               second or two).  Setting this false guarantees that\n"
    "//               every frame will be complete, but may cause more\n"
    "//               chugs as things are loaded up at runtime.\n"
    "//\n"
    "//               You may want to set this false during loading\n"
    "//               screens, to guarantee that all of your assets are\n"
    "//               available by the time you take the loading screen\n"
    "//               down.\n"
    "//\n"
    "//               This flag may also be set individually on each\n"
    "//               DisplayRegion.  It will be considered true for a\n"
    "//               given DisplayRegion only if it is true on both the\n"
    "//               GSG and on the DisplayRegion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_incomplete_render_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsStateGuardian::set_loader(Loader *loader)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_loader_351(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void GraphicsStateGuardian::set_loader(Loader *loader)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"loader", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLoader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLoader", &param1));
            if(!PyErr_Occurred())
            {
                Loader *param1_this = (Loader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Loader, 1, "GraphicsStateGuardian.setLoader", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_loader(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsStateGuardian.setLoader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLoader(non-const GraphicsStateGuardian this, non-const PandaLoader loader)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_loader_351_comment =
    "C++ Interface:\n"
    "setLoader(non-const GraphicsStateGuardian this, non-const PandaLoader loader)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_loader\n"
    "//       Access: Public\n"
    "//  Description: Sets the Loader object that will be used by this GSG\n"
    "//               to load textures when necessary, if\n"
    "//               get_incomplete_render() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_loader_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Loader *GraphicsStateGuardian::get_loader(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_loader_352(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Loader *GraphicsStateGuardian::get_loader(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLoader", key_word_list));
        else
            (PyArg_Parse(args, ":getLoader"));
        if(!PyErr_Occurred())
        {
            Loader *return_value = ((const GraphicsStateGuardian*)local_this)->get_loader();
            if (return_value != (Loader *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Loader,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLoader(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_loader_352_comment =
    "C++ Interface:\n"
    "getLoader(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_loader\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Returns the Loader object that will be used by this\n"
    "//               GSG to load textures when necessary, if\n"
    "//               get_incomplete_render() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_loader_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsPipe *GraphicsStateGuardian::get_pipe(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_pipe_353(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsPipe *GraphicsStateGuardian::get_pipe(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPipe", key_word_list));
        else
            (PyArg_Parse(args, ":getPipe"));
        if(!PyErr_Occurred())
        {
            GraphicsPipe *return_value = ((const GraphicsStateGuardian*)local_this)->get_pipe();
            if (return_value != (GraphicsPipe *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsPipe,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPipe(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_pipe_353_comment =
    "C++ Interface:\n"
    "getPipe(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_pipe\n"
    "//       Access: Published\n"
    "//  Description: Returns the graphics pipe on which this GSG was\n"
    "//               created.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_pipe_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsEngine *GraphicsStateGuardian::get_engine(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_engine_354(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-GraphicsEngine *GraphicsStateGuardian::get_engine(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEngine", key_word_list));
        else
            (PyArg_Parse(args, ":getEngine"));
        if(!PyErr_Occurred())
        {
            GraphicsEngine *return_value = ((const GraphicsStateGuardian*)local_this)->get_engine();
            if (return_value != (GraphicsEngine *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsEngine,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEngine(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_engine_354_comment =
    "C++ Interface:\n"
    "getEngine(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_engine\n"
    "//       Access: Published\n"
    "//  Description: Returns the graphics engine that created this GSG.\n"
    "//               Since there is normally only one GraphicsEngine\n"
    "//               object in an application, this is usually the same as\n"
    "//               the global GraphicsEngine.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_engine_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsThreadingModel const &GraphicsStateGuardian::get_threading_model(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_threading_model_355(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsThreadingModel const &GraphicsStateGuardian::get_threading_model(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThreadingModel", key_word_list));
        else
            (PyArg_Parse(args, ":getThreadingModel"));
        if(!PyErr_Occurred())
        {
            GraphicsThreadingModel const *return_value = &(((const GraphicsStateGuardian*)local_this)->get_threading_model());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsThreadingModel,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThreadingModel(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_threading_model_355_comment =
    "C++ Interface:\n"
    "getThreadingModel(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_threading_model\n"
    "//       Access: Published\n"
    "//  Description: Returns the threading model that was used to create\n"
    "//               this GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_threading_model_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::is_hardware(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_is_hardware_356(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::is_hardware(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isHardware", key_word_list));
        else
            (PyArg_Parse(args, ":isHardware"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->is_hardware();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isHardware(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_is_hardware_356_comment =
    "C++ Interface:\n"
    "isHardware(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::is_hardware\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG appears to be\n"
    "//               hardware-accelerated, or false if it is known to be\n"
    "//               software only.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_is_hardware_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_texture_stages(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_texture_stages_357(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_texture_stages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxTextureStages", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxTextureStages"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_texture_stages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxTextureStages(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_texture_stages_357_comment =
    "C++ Interface:\n"
    "getMaxTextureStages(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_texture_stages\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of simultaneous textures\n"
    "//               that may be applied to geometry with multitexturing,\n"
    "//               as supported by this particular GSG.  If you exceed\n"
    "//               this number, the lowest-priority texture stages will\n"
    "//               not be applied.  Use TextureStage::set_priority() to\n"
    "//               adjust the relative importance of the different\n"
    "//               texture stages.\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_texture_stages_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_3d_texture_dimension(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_358(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_3d_texture_dimension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMax3dTextureDimension", key_word_list));
        else
            (PyArg_Parse(args, ":getMax3dTextureDimension"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_3d_texture_dimension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMax3dTextureDimension(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_358_comment =
    "C++ Interface:\n"
    "getMax3dTextureDimension(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_3d_texture_dimension\n"
    "//       Access: Published\n"
    "//  Description: Returns the largest possible texture size in any one\n"
    "//               dimension for a 3-d texture, or -1 if there is no\n"
    "//               particular limit.  Returns 0 if 3-d textures are not\n"
    "//               supported.\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_2d_texture_array_layers(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_359(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_2d_texture_array_layers(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMax2dTextureArrayLayers", key_word_list));
        else
            (PyArg_Parse(args, ":getMax2dTextureArrayLayers"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_2d_texture_array_layers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMax2dTextureArrayLayers(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_359_comment =
    "C++ Interface:\n"
    "getMax2dTextureArrayLayers(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_2d_texture_array_layers\n"
    "//       Access: Published\n"
    "//  Description: Returns the largest possible number of pages, or -1 \n"
    "//               if there is no particular limit. Returns 0 if 2-d\n"
    "//               texture arrays not supported.\n"
    "//               \n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_cube_map_dimension(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_360(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_cube_map_dimension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxCubeMapDimension", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxCubeMapDimension"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_cube_map_dimension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxCubeMapDimension(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_360_comment =
    "C++ Interface:\n"
    "getMaxCubeMapDimension(const GraphicsStateGuardian this)\n"
    "\n"
    "//z axis\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_cube_map_dimension\n"
    "//       Access: Published\n"
    "//  Description: Returns the largest possible texture size in any one\n"
    "//               dimension for a cube map texture, or -1 if there is\n"
    "//               no particular limit.  Returns 0 if cube map textures\n"
    "//               are not supported.\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_texture_combine(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_texture_combine_361(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_texture_combine(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsTextureCombine", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsTextureCombine"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_texture_combine();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsTextureCombine(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_texture_combine_361_comment =
    "C++ Interface:\n"
    "getSupportsTextureCombine(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_texture_combine\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG can use the\n"
    "//               TextureStage::M_combine mode, which includes all of\n"
    "//               the texture blend modes specified by\n"
    "//               set_combine_rgb() and/or set_combine_alpha().  If\n"
    "//               this is false, you must limit yourself to using the\n"
    "//               simpler blend modes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_texture_combine_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_texture_saved_result(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_362(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_texture_saved_result(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsTextureSavedResult", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsTextureSavedResult"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_texture_saved_result();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsTextureSavedResult(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_362_comment =
    "C++ Interface:\n"
    "getSupportsTextureSavedResult(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_texture_saved_result\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can use the\n"
    "//               TextureStage::CS_last_saved_result source, which\n"
    "//               allows you to save the result of a TextureStage and\n"
    "//               re-use it for multiple inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_texture_dot3(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_texture_dot3_363(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_texture_dot3(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsTextureDot3", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsTextureDot3"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_texture_dot3();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsTextureDot3(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_texture_dot3_363_comment =
    "C++ Interface:\n"
    "getSupportsTextureDot3(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_texture_dot3\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can use the\n"
    "//               TextureStage::CM_dot3_rgb or CM_dot3_rgba combine\n"
    "//               modes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_texture_dot3_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_3d_texture(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_3d_texture_364(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_3d_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupports3dTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getSupports3dTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_3d_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupports3dTexture(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_3d_texture_364_comment =
    "C++ Interface:\n"
    "getSupports3dTexture(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_3d_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can render 3-d (volumetric)\n"
    "//               textures.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_3d_texture_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_2d_texture_array(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_365(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_2d_texture_array(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupports2dTextureArray", key_word_list));
        else
            (PyArg_Parse(args, ":getSupports2dTextureArray"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_2d_texture_array();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupports2dTextureArray(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_365_comment =
    "C++ Interface:\n"
    "getSupports2dTextureArray(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_2d_texture_array\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can render 2-d textures\n"
    "//               array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_cube_map(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_cube_map_366(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_cube_map(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsCubeMap", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsCubeMap"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_cube_map();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsCubeMap(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_cube_map_366_comment =
    "C++ Interface:\n"
    "getSupportsCubeMap(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_cube_map\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can render cube map textures.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_cube_map_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_tex_non_pow2(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_367(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_tex_non_pow2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsTexNonPow2", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsTexNonPow2"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_tex_non_pow2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsTexNonPow2(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_367_comment =
    "C++ Interface:\n"
    "getSupportsTexNonPow2(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_tex_non_pow2\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can handle non power of two\n"
    "//               sized textures.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_compressed_texture(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_compressed_texture_368(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_compressed_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsCompressedTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsCompressedTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_compressed_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsCompressedTexture(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_compressed_texture_368_comment =
    "C++ Interface:\n"
    "getSupportsCompressedTexture(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_compressed_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this GSG can compress textures as it\n"
    "//               loads them into texture memory, and/or accept\n"
    "//               pre-compressed textures for storing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_compressed_texture_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_lights(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_lights_369(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_lights(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxLights", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxLights"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_lights();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxLights(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_lights_369_comment =
    "C++ Interface:\n"
    "getMaxLights(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_lights\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of simultaneous lights\n"
    "//               that may be rendered on geometry, or -1 if there is\n"
    "//               no particular limit.\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_lights_369_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_clip_planes(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_clip_planes_370(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_clip_planes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxClipPlanes", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxClipPlanes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_clip_planes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxClipPlanes(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_clip_planes_370_comment =
    "C++ Interface:\n"
    "getMaxClipPlanes(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_clip_planes\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of simultaneous clip planes\n"
    "//               that may be applied to geometry, or -1 if there is\n"
    "//               no particular limit.\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_clip_planes_370_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_vertex_transforms(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_vertex_transforms_371(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_vertex_transforms(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxVertexTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxVertexTransforms"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_vertex_transforms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxVertexTransforms(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_vertex_transforms_371_comment =
    "C++ Interface:\n"
    "getMaxVertexTransforms(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_vertex_transforms\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of transform matrices that\n"
    "//               may be simultaneously used to transform any one\n"
    "//               vertex by the graphics hardware.  If this number is\n"
    "//               0, then the hardware (or the graphics backend)\n"
    "//               doesn't support soft-skinned vertices (in which case\n"
    "//               Panda will animate the vertices in software).\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_vertex_transforms_371_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_max_vertex_transform_indices(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_372(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_max_vertex_transform_indices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxVertexTransformIndices", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxVertexTransformIndices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_max_vertex_transform_indices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxVertexTransformIndices(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_372_comment =
    "C++ Interface:\n"
    "getMaxVertexTransformIndices(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_max_vertex_transform_indices\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of transforms there may be\n"
    "//               in a single TransformTable for this graphics\n"
    "//               hardware.  If this number is 0 (but\n"
    "//               get_max_transforms() is nonzero), then the graphics\n"
    "//               hardware (or API) doesn't support indexed transforms,\n"
    "//               but can support direct transform references.\n"
    "//\n"
    "//               The value returned may not be meaningful until after\n"
    "//               the graphics context has been fully created (e.g. the\n"
    "//               window has been opened).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_372_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_copy_texture_inverted(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_copy_texture_inverted_373(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_copy_texture_inverted(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCopyTextureInverted", key_word_list));
        else
            (PyArg_Parse(args, ":getCopyTextureInverted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_copy_texture_inverted();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCopyTextureInverted(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_copy_texture_inverted_373_comment =
    "C++ Interface:\n"
    "getCopyTextureInverted(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_copy_texture_inverted\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG has the property\n"
    "//               that any framebuffer-to-texture copy results in a\n"
    "//               texture that is upside-down and backwards from\n"
    "//               Panda's usual convention; that is, it copies into a\n"
    "//               texture from the bottom up instead of from the top\n"
    "//               down.\n"
    "//\n"
    "//               If this is true, then on offscreen GraphicsBuffer\n"
    "//               created for the purposes of rendering into a texture\n"
    "//               should be created with the invert flag set true, to\n"
    "//               compensate.  Panda will do this automatically if you\n"
    "//               create an offscreen buffer using\n"
    "//               GraphicsOutput::make_texture_buffer().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_copy_texture_inverted_373_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_generate_mipmap(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_374(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_generate_mipmap(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsGenerateMipmap", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsGenerateMipmap"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_generate_mipmap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsGenerateMipmap(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_374_comment =
    "C++ Interface:\n"
    "getSupportsGenerateMipmap(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_generate_mipmap\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG can generate\n"
    "//               mipmaps for a texture automatically, or if they must\n"
    "//               be generated in software.  If this is true, then\n"
    "//               mipmaps can safely be enabled for rendered textures\n"
    "//               (e.g. using the MultitexReducer).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_374_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_render_texture(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_render_texture_375(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_render_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsRenderTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsRenderTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_render_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsRenderTexture(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_render_texture_375_comment =
    "C++ Interface:\n"
    "getSupportsRenderTexture(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_render_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG can render\n"
    "//               directly into a texture, or false if it must always\n"
    "//               copy-to-texture at the end of each frame to achieve\n"
    "//               this effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_render_texture_375_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_depth_texture(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_depth_texture_376(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_depth_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsDepthTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsDepthTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_depth_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsDepthTexture(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_depth_texture_376_comment =
    "C++ Interface:\n"
    "getSupportsDepthTexture(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_depth_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               textures whose format is F_depth_stencil.  This\n"
    "//               returns true if the GSG supports GL_DEPTH_COMPONENT\n"
    "//               textures, which are considered a limited but still\n"
    "//               valid case of F_depth_stencil.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_depth_texture_376_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_depth_stencil(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_depth_stencil_377(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_depth_stencil(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsDepthStencil", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsDepthStencil"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_depth_stencil();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsDepthStencil(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_depth_stencil_377_comment =
    "C++ Interface:\n"
    "getSupportsDepthStencil(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_depth_stencil\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               textures whose format is F_depth_stencil.  This\n"
    "//               only returns true if the GSG supports the full\n"
    "//               packed depth-stencil functionality.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_depth_stencil_377_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_basic_shaders(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_basic_shaders_378(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_basic_shaders(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsBasicShaders", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsBasicShaders"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_basic_shaders();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsBasicShaders(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_basic_shaders_378_comment =
    "C++ Interface:\n"
    "getSupportsBasicShaders(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_basic_shaders\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               arbfp1+arbvp1 or above.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_basic_shaders_378_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_glsl(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_glsl_379(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_glsl(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsGlsl", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsGlsl"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_glsl();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsGlsl(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_glsl_379_comment =
    "C++ Interface:\n"
    "getSupportsGlsl(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_glsl\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               GLSL shaders.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_glsl_379_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_stencil(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_stencil_380(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_stencil(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsStencil", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsStencil"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_stencil();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsStencil(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_stencil_380_comment =
    "C++ Interface:\n"
    "getSupportsStencil(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_stencil\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               stencil buffers at all.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_stencil_380_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_two_sided_stencil(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_381(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_two_sided_stencil(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsTwoSidedStencil", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsTwoSidedStencil"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_two_sided_stencil();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsTwoSidedStencil(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_381_comment =
    "C++ Interface:\n"
    "getSupportsTwoSidedStencil(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_two_sided_stencil\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               two sided stencil: different stencil settings for the\n"
    "//               front and back side of the same polygon.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_381_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_supports_geometry_instancing(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_382(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_supports_geometry_instancing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsGeometryInstancing", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsGeometryInstancing"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_geometry_instancing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsGeometryInstancing(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_382_comment =
    "C++ Interface:\n"
    "getSupportsGeometryInstancing(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_geometry_instancing\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG supports\n"
    "//               hardware geometry instancing: the ability to render\n"
    "//               multiple copies of a model. In OpenGL, this is\n"
    "//               done using the EXT_draw_instanced extension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_382_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_maximum_simultaneous_render_targets(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_383(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_maximum_simultaneous_render_targets(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaximumSimultaneousRenderTargets", key_word_list));
        else
            (PyArg_Parse(args, ":getMaximumSimultaneousRenderTargets"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_maximum_simultaneous_render_targets();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaximumSimultaneousRenderTargets(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_383_comment =
    "C++ Interface:\n"
    "getMaximumSimultaneousRenderTargets(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_maximum_simultaneous_render_targets\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum simultaneous render targets \n"
    "//               supported.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_383_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsStateGuardian::get_shader_model(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_shader_model_384(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsStateGuardian::get_shader_model(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShaderModel", key_word_list));
        else
            (PyArg_Parse(args, ":getShaderModel"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardian*)local_this)->get_shader_model();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShaderModel(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_shader_model_384_comment =
    "C++ Interface:\n"
    "getShaderModel(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_shader_model\n"
    "//       Access: Published\n"
    "//  Description: Returns the ShaderModel\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_shader_model_384_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsStateGuardian::set_shader_model(int shader_model)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_shader_model_385(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsStateGuardian::set_shader_model(int shader_model)
        int param1;
        static char * key_word_list[] = {(char *)"shader_model", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setShaderModel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setShaderModel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_shader_model((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.setShaderModel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setShaderModel(non-const GraphicsStateGuardian this, int shader_model)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_shader_model_385_comment =
    "C++ Interface:\n"
    "setShaderModel(non-const GraphicsStateGuardian this, int shader_model)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_shader_model\n"
    "//       Access: Published\n"
    "//  Description: Sets the ShaderModel.  This will override the auto-\n"
    "//               detected shader model during GSG reset.  Useful for\n"
    "//               testing lower-end shaders.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_shader_model_385_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardian::get_supports_cg_profile(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_supports_cg_profile_386(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardian::get_supports_cg_profile(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getSupportsCgProfile", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getSupportsCgProfile", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_supports_cg_profile(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsCgProfile(const GraphicsStateGuardian this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_supports_cg_profile_386_comment =
    "C++ Interface:\n"
    "getSupportsCgProfile(const GraphicsStateGuardian this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_supports_cg_profile\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if this particular GSG supports the \n"
    "//               specified Cg Shader Profile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_supports_cg_profile_386_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_color_scale_via_lighting(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_387(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_color_scale_via_lighting(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorScaleViaLighting", key_word_list));
        else
            (PyArg_Parse(args, ":getColorScaleViaLighting"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_color_scale_via_lighting();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorScaleViaLighting(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_387_comment =
    "C++ Interface:\n"
    "getColorScaleViaLighting(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_color_scale_via_lighting\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG can implement (or\n"
    "//               would prefer to implement) set color and/or color\n"
    "//               scale using materials and/or ambient lights, or\n"
    "//               false if we need to actually munge the color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_387_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(void) const
 * inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(TextureAttrib const *tex_attrib) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_388(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlphaScaleViaTexture", key_word_list));
            else
                (PyArg_Parse(args, ":getAlphaScaleViaTexture"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const GraphicsStateGuardian*)local_this)->get_alpha_scale_via_texture();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(TextureAttrib const *tex_attrib) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"tex_attrib", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getAlphaScaleViaTexture", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getAlphaScaleViaTexture", &param1));
                if(!PyErr_Occurred())
                {
                    TextureAttrib *param1_this = (TextureAttrib *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextureAttrib, 1, "GraphicsStateGuardian.getAlphaScaleViaTexture", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const GraphicsStateGuardian*)local_this)->get_alpha_scale_via_texture(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getAlphaScaleViaTexture() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getAlphaScaleViaTexture(const GraphicsStateGuardian this)\n"
          "getAlphaScaleViaTexture(const GraphicsStateGuardian this, const TextureAttrib tex_attrib)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_388_comment =
    "C++ Interface:\n"
    "getAlphaScaleViaTexture(const GraphicsStateGuardian this)\n"
    "getAlphaScaleViaTexture(const GraphicsStateGuardian this, const TextureAttrib tex_attrib)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_alpha_scale_via_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG can implement (or\n"
    "//               would prefer to implement) an alpha scale via an\n"
    "//               additional Texture layer, or false if we need to\n"
    "//               actually munge the alpha.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_alpha_scale_via_texture\n"
    "//       Access: Published\n"
    "//  Description: This variant of get_alpha_scale_via_texture() answers\n"
    "//               the question of whether the GSG can implement an\n"
    "//               alpha scale via an additional Texture layer,\n"
    "//               considering the current TextureAttrib that will be in\n"
    "//               effect.  This considers whether there is at least one\n"
    "//               additional texture slot available on the GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_388_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsStateGuardian::get_runtime_color_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_runtime_color_scale_389(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsStateGuardian::get_runtime_color_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRuntimeColorScale", key_word_list));
        else
            (PyArg_Parse(args, ":getRuntimeColorScale"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardian*)local_this)->get_runtime_color_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRuntimeColorScale(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_runtime_color_scale_389_comment =
    "C++ Interface:\n"
    "getRuntimeColorScale(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_runtime_color_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this particular GSG can implement (or\n"
    "//               would prefer to implement) set color and/or color\n"
    "//               scale directly, without requiring any munging of\n"
    "//               vertices or tricks with lighting.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_runtime_color_scale_389_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline TextureStage *GraphicsStateGuardian::get_alpha_scale_texture_stage(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_390(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline TextureStage *GraphicsStateGuardian::get_alpha_scale_texture_stage(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlphaScaleTextureStage", key_word_list))
        {
            TextureStage *return_value = GraphicsStateGuardian::get_alpha_scale_texture_stage();
            if (return_value != (TextureStage *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextureStage,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlphaScaleTextureStage()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_390_comment =
    "C++ Interface:\n"
    "getAlphaScaleTextureStage()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_alpha_scale_texture_stage\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the TextureStage that will be used to apply\n"
    "//               an alpha scale, if get_alpha_scale_via_texture()\n"
    "//               returns true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_390_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsStateGuardian::set_coordinate_system(CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_coordinate_system_391(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsStateGuardian::set_coordinate_system(CoordinateSystem cs)
        int param1;
        static char * key_word_list[] = {(char *)"cs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.setCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoordinateSystem(non-const GraphicsStateGuardian this, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_coordinate_system_391_comment =
    "C++ Interface:\n"
    "setCoordinateSystem(non-const GraphicsStateGuardian this, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Changes the coordinate system in effect on this\n"
    "//               particular gsg.  This is also called the \"external\"\n"
    "//               coordinate system, since it is the coordinate system\n"
    "//               used by the scene graph, external to to GSG.\n"
    "//\n"
    "//               Normally, this will be the default coordinate system,\n"
    "//               but it might be set differently at runtime.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_coordinate_system_391_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CoordinateSystem GraphicsStateGuardian::get_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_coordinate_system_392(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CoordinateSystem GraphicsStateGuardian::get_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const GraphicsStateGuardian*)local_this)->get_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoordinateSystem(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_coordinate_system_392_comment =
    "C++ Interface:\n"
    "getCoordinateSystem(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate system in effect on this\n"
    "//               particular gsg.  Normally, this will be the default\n"
    "//               coordinate system, but it might be set differently at\n"
    "//               runtime.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_coordinate_system_392_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual CoordinateSystem GraphicsStateGuardian::get_internal_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_internal_coordinate_system_393(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual CoordinateSystem GraphicsStateGuardian::get_internal_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInternalCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getInternalCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const GraphicsStateGuardian*)local_this)->get_internal_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInternalCoordinateSystem(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_internal_coordinate_system_393_comment =
    "C++ Interface:\n"
    "getInternalCoordinateSystem(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_internal_coordinate_system\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the coordinate system used internally by the\n"
    "//               GSG.  This may be the same as the external coordinate\n"
    "//               system reported by get_coordinate_system(), or it may\n"
    "//               be something different.\n"
    "//\n"
    "//               In any case, vertices that have been transformed\n"
    "//               before being handed to the GSG (that is, vertices\n"
    "//               with a contents value of C_clip_point) will be\n"
    "//               expected to be in this coordinate system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_internal_coordinate_system_393_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PreparedGraphicsObjects *GraphicsStateGuardian::get_prepared_objects(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_prepared_objects_394(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PreparedGraphicsObjects *GraphicsStateGuardian::get_prepared_objects(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPreparedObjects", key_word_list));
        else
            (PyArg_Parse(args, ":getPreparedObjects"));
        if(!PyErr_Occurred())
        {
            PreparedGraphicsObjects *return_value = (local_this)->get_prepared_objects();
            if (return_value != (PreparedGraphicsObjects *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PreparedGraphicsObjects,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.getPreparedObjects() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPreparedObjects(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_prepared_objects_394_comment =
    "C++ Interface:\n"
    "getPreparedObjects(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_prepared_objects\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Returns the set of texture and geom objects that have\n"
    "//               been prepared with this GSG (and possibly other GSG's\n"
    "//               that share objects).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_prepared_objects_394_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardian::set_gamma(float gamma)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_gamma_395(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool GraphicsStateGuardian::set_gamma(float gamma)
        double param1;
        static char * key_word_list[] = {(char *)"gamma", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGamma", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setGamma", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_gamma((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.setGamma() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGamma(non-const GraphicsStateGuardian this, float gamma)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_gamma_395_comment =
    "C++ Interface:\n"
    "setGamma(non-const GraphicsStateGuardian this, float gamma)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_gamma\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Set gamma.  Returns true on success.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_gamma_395_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float GraphicsStateGuardian::get_gamma(float gamma)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_gamma_396(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-float GraphicsStateGuardian::get_gamma(float gamma)
        double param1;
        static char * key_word_list[] = {(char *)"gamma", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:getGamma", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:getGamma", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_gamma((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.getGamma() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGamma(non-const GraphicsStateGuardian this, float gamma)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_gamma_396_comment =
    "C++ Interface:\n"
    "getGamma(non-const GraphicsStateGuardian this, float gamma)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_gamma\n"
    "//       Access: Published\n"
    "//  Description: Get the current gamma setting.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_gamma_396_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsStateGuardian::restore_gamma(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_restore_gamma_397(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsStateGuardian::restore_gamma(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":restoreGamma", key_word_list));
        else
            (PyArg_Parse(args, ":restoreGamma"));
        if(!PyErr_Occurred())
        {
            (local_this)->restore_gamma();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.restoreGamma() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "restoreGamma(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_restore_gamma_397_comment =
    "C++ Interface:\n"
    "restoreGamma(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::restore_gamma\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Restore original gamma setting.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_restore_gamma_397_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsStateGuardian::set_texture_quality_override(Texture::QualityLevel quality_level)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_texture_quality_override_398(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsStateGuardian::set_texture_quality_override(Texture::QualityLevel quality_level)
        int param1;
        static char * key_word_list[] = {(char *)"quality_level", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTextureQualityOverride", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTextureQualityOverride", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_texture_quality_override((Texture::QualityLevel)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.setTextureQualityOverride() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextureQualityOverride(non-const GraphicsStateGuardian this, int quality_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_texture_quality_override_398_comment =
    "C++ Interface:\n"
    "setTextureQualityOverride(non-const GraphicsStateGuardian this, int quality_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_texture_quality_override\n"
    "//       Access: Published\n"
    "//  Description: Specifies the global quality_level to be imposed for\n"
    "//               all Textures rendered by this GSG.  This overrides\n"
    "//               the value set on individual textures via\n"
    "//               Texture::set_quality_level().  Set this to\n"
    "//               Texture::QL_default in order to allow the individual\n"
    "//               texture quality levels to be respected.\n"
    "//\n"
    "//               This is mainly useful for the tinydisplay software\n"
    "//               renderer.  See Texture::set_quality_level().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_texture_quality_override_398_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture::QualityLevel GraphicsStateGuardian::get_texture_quality_override(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_texture_quality_override_399(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Texture::QualityLevel GraphicsStateGuardian::get_texture_quality_override(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureQualityOverride", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureQualityOverride"));
        if(!PyErr_Occurred())
        {
            Texture::QualityLevel return_value = ((const GraphicsStateGuardian*)local_this)->get_texture_quality_override();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureQualityOverride(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_texture_quality_override_399_comment =
    "C++ Interface:\n"
    "getTextureQualityOverride(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_texture_quality_override\n"
    "//       Access: Published\n"
    "//  Description: Returns the global quality_level override specified\n"
    "//               by set_texture_quality_override.\n"
    "//\n"
    "//               This is mainly useful for the tinydisplay software\n"
    "//               renderer.  See Texture::set_quality_level().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_texture_quality_override_399_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *GraphicsStateGuardian::get_prepared_textures(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_prepared_textures_400(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *GraphicsStateGuardian::get_prepared_textures(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPreparedTextures", key_word_list));
        else
            (PyArg_Parse(args, ":getPreparedTextures"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const GraphicsStateGuardian*)local_this)->get_prepared_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPreparedTextures(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_prepared_textures_400_comment =
    "C++ Interface:\n"
    "getPreparedTextures(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_prepared_textures\n"
    "//       Access: Published\n"
    "//  Description: Returns a Python list of all of the\n"
    "//               currently-prepared textures within the GSG.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_prepared_textures_400_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsStateGuardian::set_scene(SceneSetup *scene_setup)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_set_scene_402(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool GraphicsStateGuardian::set_scene(SceneSetup *scene_setup)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"scene_setup", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScene", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setScene", &param1));
            if(!PyErr_Occurred())
            {
                SceneSetup *param1_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SceneSetup, 1, "GraphicsStateGuardian.setScene", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_scene(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsStateGuardian.setScene() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScene(non-const GraphicsStateGuardian this, non-const SceneSetup scene_setup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_set_scene_402_comment =
    "C++ Interface:\n"
    "setScene(non-const GraphicsStateGuardian this, non-const SceneSetup scene_setup)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::set_scene\n"
    "//       Access: Published\n"
    "//  Description: Sets the SceneSetup object that indicates the initial\n"
    "//               camera position, etc.  This must be called before\n"
    "//               traversal begins.  Returns true if the scene is\n"
    "//               acceptable, false if something's wrong.  This should\n"
    "//               be called in the draw thread only.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_set_scene_402_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual SceneSetup *GraphicsStateGuardian::get_scene(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_scene_403(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual SceneSetup *GraphicsStateGuardian::get_scene(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScene", key_word_list));
        else
            (PyArg_Parse(args, ":getScene"));
        if(!PyErr_Occurred())
        {
            SceneSetup *return_value = ((const GraphicsStateGuardian*)local_this)->get_scene();
            if (return_value != (SceneSetup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SceneSetup,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScene(const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_scene_403_comment =
    "C++ Interface:\n"
    "getScene(const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::get_scene\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the current SceneSetup object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_scene_403_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardian::begin_scene(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_begin_scene_404(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool GraphicsStateGuardian::begin_scene(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":beginScene", key_word_list));
        else
            (PyArg_Parse(args, ":beginScene"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->begin_scene();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.beginScene() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginScene(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_begin_scene_404_comment =
    "C++ Interface:\n"
    "beginScene(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::begin_scene\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Called between begin_frame() and end_frame() to mark\n"
    "//               the beginning of drawing commands for a \"scene\"\n"
    "//               (usually a particular DisplayRegion) within a frame.\n"
    "//               All 3-D drawing commands, except the clear operation,\n"
    "//               must be enclosed within begin_scene() .. end_scene().\n"
    "//               This must be called in the draw thread.\n"
    "//\n"
    "//               The return value is true if successful (in which case\n"
    "//               the scene will be drawn and end_scene() will be\n"
    "//               called later), or false if unsuccessful (in which\n"
    "//               case nothing will be drawn and end_scene() will not\n"
    "//               be called).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_begin_scene_404_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsStateGuardian::end_scene(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_end_scene_405(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardian * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardian,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsStateGuardian::end_scene(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":endScene", key_word_list));
        else
            (PyArg_Parse(args, ":endScene"));
        if(!PyErr_Occurred())
        {
            (local_this)->end_scene();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsStateGuardian.endScene() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "endScene(non-const GraphicsStateGuardian this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_end_scene_405_comment =
    "C++ Interface:\n"
    "endScene(non-const GraphicsStateGuardian this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardian::end_scene\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Called between begin_frame() and end_frame() to mark\n"
    "//               the end of drawing commands for a \"scene\" (usually a\n"
    "//               particular DisplayRegion) within a frame.  All 3-D\n"
    "//               drawing commands, except the clear operation, must be\n"
    "//               enclosed within begin_scene() .. end_scene().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_end_scene_405_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsStateGuardian::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardian_get_class_type_406(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsStateGuardian::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsStateGuardian::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardian_get_class_type_406_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardian_get_class_type_406_comment = NULL;
#endif

int  Dtool_Init_GraphicsStateGuardian(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsStateGuardian)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GraphicsStateGuardian(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsStateGuardian)
    {
        printf("GraphicsStateGuardian ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsStateGuardian * local_this = (GraphicsStateGuardian *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsStateGuardian)
        return local_this;
    if(requested_type == &Dtool_GraphicsStateGuardianBase)
        return ( GraphicsStateGuardianBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( GraphicsStateGuardianBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsStateGuardianBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsStateGuardianBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( GraphicsStateGuardianBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsStateGuardian(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsStateGuardian)
        return from_this;
    if(from_type == &Dtool_GraphicsStateGuardianBase)
    {
          GraphicsStateGuardianBase* other_this = (GraphicsStateGuardianBase*)from_this;
          return (GraphicsStateGuardian*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsStateGuardian*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsStateGuardian*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GraphicsStateGuardian*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GraphicsStateGuardian*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StereoDisplayRegion 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *StereoDisplayRegion::get_left_eye(void)
 *******************************************************************/
static PyObject *Dtool_StereoDisplayRegion_get_left_eye_408(PyObject *self, PyObject *args,PyObject *kwds) {
    StereoDisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StereoDisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline DisplayRegion *StereoDisplayRegion::get_left_eye(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeftEye", key_word_list));
        else
            (PyArg_Parse(args, ":getLeftEye"));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = (local_this)->get_left_eye();
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StereoDisplayRegion.getLeftEye() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeftEye(non-const StereoDisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StereoDisplayRegion_get_left_eye_408_comment =
    "C++ Interface:\n"
    "getLeftEye(non-const StereoDisplayRegion this)\n"
    "\n"
    "// Filename: stereoDisplayRegion.I\n"
    "// Created by:  drose (19Feb09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StereoDisplayRegion::get_left_eye\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the left DisplayRegion managed\n"
    "//               by this stereo object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StereoDisplayRegion_get_left_eye_408_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *StereoDisplayRegion::get_right_eye(void)
 *******************************************************************/
static PyObject *Dtool_StereoDisplayRegion_get_right_eye_409(PyObject *self, PyObject *args,PyObject *kwds) {
    StereoDisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StereoDisplayRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline DisplayRegion *StereoDisplayRegion::get_right_eye(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRightEye", key_word_list));
        else
            (PyArg_Parse(args, ":getRightEye"));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = (local_this)->get_right_eye();
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StereoDisplayRegion.getRightEye() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRightEye(non-const StereoDisplayRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StereoDisplayRegion_get_right_eye_409_comment =
    "C++ Interface:\n"
    "getRightEye(non-const StereoDisplayRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StereoDisplayRegion::get_right_eye\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the right DisplayRegion managed\n"
    "//               by this stereo object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StereoDisplayRegion_get_right_eye_409_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle StereoDisplayRegion::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_StereoDisplayRegion_get_class_type_410(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle StereoDisplayRegion::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = StereoDisplayRegion::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StereoDisplayRegion_get_class_type_410_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_StereoDisplayRegion_get_class_type_410_comment = NULL;
#endif

int  Dtool_Init_StereoDisplayRegion(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (StereoDisplayRegion)");
       return -1;
}
inline void  * Dtool_UpcastInterface_StereoDisplayRegion(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StereoDisplayRegion)
    {
        printf("StereoDisplayRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StereoDisplayRegion * local_this = (StereoDisplayRegion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StereoDisplayRegion)
        return local_this;
    if(requested_type == &Dtool_DisplayRegion)
        return ( DisplayRegion *) local_this;
    if(requested_type == &Dtool_DisplayRegionBase)
        return ( DisplayRegionBase *)( DisplayRegion *) local_this;
    if(requested_type == &Dtool_DrawableRegion)
        return ( DrawableRegion *)( DisplayRegion *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DisplayRegionBase *)( DisplayRegion *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DisplayRegionBase *)( DisplayRegion *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DisplayRegionBase *)( DisplayRegion *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StereoDisplayRegion(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StereoDisplayRegion)
        return from_this;
    if(from_type == &Dtool_DisplayRegion)
    {
          DisplayRegion* other_this = (DisplayRegion*)from_this;
          return (StereoDisplayRegion*)other_this;
    }
    if(from_type == &Dtool_DisplayRegionBase)
    {
          DisplayRegionBase* other_this = (DisplayRegionBase*)from_this;
          return (StereoDisplayRegion*)other_this;
    }
    if(from_type == &Dtool_DrawableRegion)
    {
          DrawableRegion* other_this = (DrawableRegion*)from_this;
          return (StereoDisplayRegion*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (StereoDisplayRegion*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (StereoDisplayRegion*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (StereoDisplayRegion*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsOutput 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline GraphicsStateGuardian *GraphicsOutput::get_gsg(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_gsg_420(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsStateGuardian *GraphicsOutput::get_gsg(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGsg", key_word_list));
        else
            (PyArg_Parse(args, ":getGsg"));
        if(!PyErr_Occurred())
        {
            GraphicsStateGuardian *return_value = ((const GraphicsOutput*)local_this)->get_gsg();
            if (return_value != (GraphicsStateGuardian *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsStateGuardian,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGsg(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_gsg_420_comment =
    "C++ Interface:\n"
    "getGsg(const GraphicsOutput this)\n"
    "\n"
    "// Filename: graphicsOutput.I\n"
    "// Created by:  drose (06Feb04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_gsg\n"
    "//       Access: Published\n"
    "//  Description: Returns the GSG that is associated with this window.\n"
    "//               There is a one-to-one association between windows and\n"
    "//               GSG's.\n"
    "//\n"
    "//               This may return NULL if the graphics context has not\n"
    "//               yet been created for the window, e.g. before the\n"
    "//               first frame has rendered; or after the window has\n"
    "//               been closed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_gsg_420_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsPipe *GraphicsOutput::get_pipe(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_pipe_421(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsPipe *GraphicsOutput::get_pipe(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPipe", key_word_list));
        else
            (PyArg_Parse(args, ":getPipe"));
        if(!PyErr_Occurred())
        {
            GraphicsPipe *return_value = ((const GraphicsOutput*)local_this)->get_pipe();
            if (return_value != (GraphicsPipe *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsPipe,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPipe(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_pipe_421_comment =
    "C++ Interface:\n"
    "getPipe(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_pipe\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsPipe that this window is\n"
    "//               associated with.  It is possible that the\n"
    "//               GraphicsPipe might have been deleted while an\n"
    "//               outstanding PT(GraphicsOutput) prevented all of its\n"
    "//               children windows from also being deleted; in this\n"
    "//               unlikely case, get_pipe() may return NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_pipe_421_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsEngine *GraphicsOutput::get_engine(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_engine_422(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsEngine *GraphicsOutput::get_engine(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEngine", key_word_list));
        else
            (PyArg_Parse(args, ":getEngine"));
        if(!PyErr_Occurred())
        {
            GraphicsEngine *return_value = ((const GraphicsOutput*)local_this)->get_engine();
            if (return_value != (GraphicsEngine *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsEngine,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEngine(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_engine_422_comment =
    "C++ Interface:\n"
    "getEngine(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_engine\n"
    "//       Access: Published\n"
    "//  Description: Returns the graphics engine that created this output.\n"
    "//               Since there is normally only one GraphicsEngine\n"
    "//               object in an application, this is usually the same as\n"
    "//               the global GraphicsEngine.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_engine_422_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &GraphicsOutput::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_name_423(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &GraphicsOutput::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const GraphicsOutput*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_name_423_comment =
    "C++ Interface:\n"
    "getName(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name that was passed to the\n"
    "//               GraphicsOutput constructor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_name_423_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::count_textures(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_count_textures_424(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::count_textures(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":countTextures", key_word_list));
        else
            (PyArg_Parse(args, ":countTextures"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->count_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "countTextures(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_count_textures_424_comment =
    "C++ Interface:\n"
    "countTextures(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::count_textures\n"
    "//       Access: Published\n"
    "//  Description: If the GraphicsOutput is set to render into a\n"
    "//               texture, returns the number of textures that are\n"
    "//               being rendered into.  Normally, the textures would\n"
    "//               be associated with different buffers - a color\n"
    "//               texture, a depth texture, and a stencil texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_count_textures_424_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::has_texture(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_has_texture_425(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::has_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTexture", key_word_list));
        else
            (PyArg_Parse(args, ":hasTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->has_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTexture(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_has_texture_425_comment =
    "C++ Interface:\n"
    "hasTexture(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::has_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the GraphicsOutput is rendering \n"
    "//               into any textures at all.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_has_texture_425_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual inline Texture *GraphicsOutput::get_texture(int i) const
 * virtual inline Texture *GraphicsOutput::get_texture(int i = (0)) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_texture_426(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual inline Texture *GraphicsOutput::get_texture(int i = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexture", key_word_list));
            else
                (PyArg_Parse(args, ":getTexture"));
            if(!PyErr_Occurred())
            {
                Texture *return_value = ((const GraphicsOutput*)local_this)->get_texture();
                if (return_value != (Texture *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-virtual inline Texture *GraphicsOutput::get_texture(int i) const
            int param1;
            static char * key_word_list[] = {(char *)"i", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTexture", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getTexture", &param1));
            if(!PyErr_Occurred())
            {
                Texture *return_value = ((const GraphicsOutput*)local_this)->get_texture((int)param1);
                if (return_value != (Texture *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getTexture() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getTexture(const GraphicsOutput this)\n"
          "getTexture(const GraphicsOutput this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_texture_426_comment =
    "C++ Interface:\n"
    "getTexture(const GraphicsOutput this)\n"
    "getTexture(const GraphicsOutput this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth texture into which the GraphicsOutput\n"
    "//               renders.  Returns NULL if there is no such texture.\n"
    "//\n"
    "//               If the texture is non-NULL, it may be applied to\n"
    "//               geometry to be rendered for any other windows or\n"
    "//               outputs that share the same GSG as this\n"
    "//               GraphicsOutput.  The effect is undefined for windows\n"
    "//               that share a different GSG; usually in these cases\n"
    "//               the texture will be invalid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_texture_426_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DrawableRegion::RenderTexturePlane GraphicsOutput::get_texture_plane(int i) const
 * inline DrawableRegion::RenderTexturePlane GraphicsOutput::get_texture_plane(int i = (0)) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_texture_plane_427(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline DrawableRegion::RenderTexturePlane GraphicsOutput::get_texture_plane(int i = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexturePlane", key_word_list));
            else
                (PyArg_Parse(args, ":getTexturePlane"));
            if(!PyErr_Occurred())
            {
                DrawableRegion::RenderTexturePlane return_value = ((const GraphicsOutput*)local_this)->get_texture_plane();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline DrawableRegion::RenderTexturePlane GraphicsOutput::get_texture_plane(int i) const
            int param1;
            static char * key_word_list[] = {(char *)"i", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTexturePlane", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getTexturePlane", &param1));
            if(!PyErr_Occurred())
            {
                DrawableRegion::RenderTexturePlane return_value = ((const GraphicsOutput*)local_this)->get_texture_plane((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getTexturePlane() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getTexturePlane(const GraphicsOutput this)\n"
          "getTexturePlane(const GraphicsOutput this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_texture_plane_427_comment =
    "C++ Interface:\n"
    "getTexturePlane(const GraphicsOutput this)\n"
    "getTexturePlane(const GraphicsOutput this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_texture_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the RenderTexturePlane associated with the\n"
    "//               nth render-texture.  Returns 0 if there is no such\n"
    "//               texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_texture_plane_427_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput::RenderTextureMode GraphicsOutput::get_rtm_mode(int i) const
 * inline GraphicsOutput::RenderTextureMode GraphicsOutput::get_rtm_mode(int i = (0)) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_rtm_mode_428(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline GraphicsOutput::RenderTextureMode GraphicsOutput::get_rtm_mode(int i = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getRtmMode", key_word_list));
            else
                (PyArg_Parse(args, ":getRtmMode"));
            if(!PyErr_Occurred())
            {
                GraphicsOutput::RenderTextureMode return_value = ((const GraphicsOutput*)local_this)->get_rtm_mode();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline GraphicsOutput::RenderTextureMode GraphicsOutput::get_rtm_mode(int i) const
            int param1;
            static char * key_word_list[] = {(char *)"i", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getRtmMode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getRtmMode", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsOutput::RenderTextureMode return_value = ((const GraphicsOutput*)local_this)->get_rtm_mode((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getRtmMode() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getRtmMode(const GraphicsOutput this)\n"
          "getRtmMode(const GraphicsOutput this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_rtm_mode_428_comment =
    "C++ Interface:\n"
    "getRtmMode(const GraphicsOutput this)\n"
    "getRtmMode(const GraphicsOutput this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_rtm_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the RenderTextureMode associated with the\n"
    "//               nth render-texture.  Returns RTM_none if there is\n"
    "//               no such texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_rtm_mode_428_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsOutput::clear_render_textures(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_clear_render_textures_429(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsOutput::clear_render_textures(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearRenderTextures", key_word_list));
        else
            (PyArg_Parse(args, ":clearRenderTextures"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_render_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.clearRenderTextures() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRenderTextures(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_clear_render_textures_429_comment =
    "C++ Interface:\n"
    "clearRenderTextures(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::clear_render_textures\n"
    "//       Access: Published\n"
    "//  Description: If the GraphicsOutput is currently rendering to\n"
    "//               a texture, then all textures are dissociated from\n"
    "//               the GraphicsOuput.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_clear_render_textures_429_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsOutput::add_render_texture(Texture *tex, GraphicsOutput::RenderTextureMode mode, DrawableRegion::RenderTexturePlane bitplane)
 * void GraphicsOutput::add_render_texture(Texture *tex, GraphicsOutput::RenderTextureMode mode, DrawableRegion::RenderTexturePlane bitplane = (RTP_COUNT))
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_add_render_texture_430(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void GraphicsOutput::add_render_texture(Texture *tex, GraphicsOutput::RenderTextureMode mode, DrawableRegion::RenderTexturePlane bitplane = (RTP_COUNT))
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"tex", (char *)"mode", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:addRenderTexture", key_word_list, &param1, &param2))
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "GraphicsOutput.addRenderTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_render_texture(param1_this, (GraphicsOutput::RenderTextureMode)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.addRenderTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void GraphicsOutput::add_render_texture(Texture *tex, GraphicsOutput::RenderTextureMode mode, DrawableRegion::RenderTexturePlane bitplane)
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"tex", (char *)"mode", (char *)"bitplane", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:addRenderTexture", key_word_list, &param1, &param2, &param3))
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "GraphicsOutput.addRenderTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_render_texture(param1_this, (GraphicsOutput::RenderTextureMode)param2, (DrawableRegion::RenderTexturePlane)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.addRenderTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addRenderTexture() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addRenderTexture(non-const GraphicsOutput this, non-const Texture tex, int mode)\n"
          "addRenderTexture(non-const GraphicsOutput this, non-const Texture tex, int mode, int bitplane)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_add_render_texture_430_comment =
    "C++ Interface:\n"
    "addRenderTexture(non-const GraphicsOutput this, non-const Texture tex, int mode)\n"
    "addRenderTexture(non-const GraphicsOutput this, non-const Texture tex, int mode, int bitplane)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::add_render_texture\n"
    "//       Access: Published\n"
    "//  Description: Creates a new Texture object, suitable for rendering\n"
    "//               the contents of this buffer into, and appends it to\n"
    "//               the list of render textures.\n"
    "//\n"
    "//               If tex is not NULL, it is the texture that will be\n"
    "//               set up for rendering into; otherwise, a new Texture\n"
    "//               object will be created, in which case you may call\n"
    "//               get_texture() to retrieve the new texture pointer.\n"
    "//\n"
    "//               You can specify a bitplane to attach the texture to.\n"
    "//               the legal choices are:\n"
    "//\n"
    "//               * RTP_depth\n"
    "//               * RTP_depth_stencil\n"
    "//               * RTP_color\n"
    "//               * RTP_aux_rgba_0\n"
    "//               * RTP_aux_rgba_1\n"
    "//               * RTP_aux_rgba_2\n"
    "//               * RTP_aux_rgba_3\n"
    "//\n"
    "//               If you do not specify a bitplane to attach the\n"
    "//               texture to, this routine will use a default based\n"
    "//               on the texture's format:\n"
    "//\n"
    "//               * F_depth_component attaches to RTP_depth\n"
    "//               * F_depth_stencil attaches to RTP_depth_stencil\n"
    "//               * all other formats attach to RTP_color.\n"
    "//\n"
    "//               The texture's format will be changed to match\n"
    "//               the format of the bitplane to which it is attached.\n"
    "//               For example, if you pass in an F_rgba texture and\n"
    "//               order that it be attached to RTP_depth_stencil, it will turn\n"
    "//               into an F_depth_stencil texture.\n"
    "//\n"
    "//               Also see make_texture_buffer(), which is a\n"
    "//               higher-level interface for preparing\n"
    "//               render-to-a-texture mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_add_render_texture_430_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsOutput::setup_render_texture(Texture *tex, bool allow_bind, bool to_ram)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_setup_render_texture_431(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void GraphicsOutput::setup_render_texture(Texture *tex, bool allow_bind, bool to_ram)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"tex", (char *)"allow_bind", (char *)"to_ram", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setupRenderTexture", key_word_list, &param1, &param2, &param3))
            {
                Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "GraphicsOutput.setupRenderTexture", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->setup_render_texture(param1_this, (PyObject_IsTrue(param2)!=0), (PyObject_IsTrue(param3)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.setupRenderTexture() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupRenderTexture(non-const GraphicsOutput this, non-const Texture tex, bool allow_bind, bool to_ram)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_setup_render_texture_431_comment =
    "C++ Interface:\n"
    "setupRenderTexture(non-const GraphicsOutput this, non-const Texture tex, bool allow_bind, bool to_ram)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::setup_render_texture\n"
    "//       Access: Published\n"
    "//  Description: This is a deprecated interface that made sense back\n"
    "//               when GraphicsOutputs could only render into one\n"
    "//               texture at a time.  From now on, use\n"
    "//               clear_render_textures and add_render_texture\n"
    "//               instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_setup_render_texture_431_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::get_x_size(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_x_size_432(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::get_x_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXSize", key_word_list));
        else
            (PyArg_Parse(args, ":getXSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_x_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXSize(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_x_size_432_comment =
    "C++ Interface:\n"
    "getXSize(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_x_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the visible width of the window or buffer, if\n"
    "//               it is known.  In certain cases (e.g. fullscreen\n"
    "//               windows), the size may not be known until after the\n"
    "//               object has been fully created.  Check has_size()\n"
    "//               first.\n"
    "//\n"
    "//               Certain objects (like windows) may change size\n"
    "//               spontaneously; this method is not thread-safe.  To\n"
    "//               get the size of a window in a thread-safe manner,\n"
    "//               query get_properties().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_x_size_432_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::get_y_size(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_y_size_433(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::get_y_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getYSize", key_word_list));
        else
            (PyArg_Parse(args, ":getYSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_y_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYSize(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_y_size_433_comment =
    "C++ Interface:\n"
    "getYSize(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_y_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the visible height of the window or buffer,\n"
    "//               if it is known.  In certain cases (e.g. fullscreen\n"
    "//               windows), the size may not be known until after the\n"
    "//               object has been fully created.  Check has_size()\n"
    "//               first.\n"
    "//\n"
    "//               Certain objects (like windows) may change size\n"
    "//               spontaneously; this method is not thread-safe.  To\n"
    "//               get the size of a window in a thread-safe manner,\n"
    "//               query get_properties().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_y_size_433_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::get_fb_x_size(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_fb_x_size_434(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::get_fb_x_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFbXSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFbXSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_fb_x_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFbXSize(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_fb_x_size_434_comment =
    "C++ Interface:\n"
    "getFbXSize(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_fb_x_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the internal width of the window or buffer.\n"
    "//               This is almost always the same as get_x_size(),\n"
    "//               except when a pixel_zoom is in effect--see\n"
    "//               set_pixel_zoom().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_fb_x_size_434_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::get_fb_y_size(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_fb_y_size_435(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::get_fb_y_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFbYSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFbYSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_fb_y_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFbYSize(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_fb_y_size_435_comment =
    "C++ Interface:\n"
    "getFbYSize(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_fb_y_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the internal height of the window or buffer.\n"
    "//               This is almost always the same as get_y_size(),\n"
    "//               except when a pixel_zoom is in effect--see\n"
    "//               set_pixel_zoom().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_fb_y_size_435_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::has_size(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_has_size_436(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::has_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSize", key_word_list));
        else
            (PyArg_Parse(args, ":hasSize"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->has_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSize(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_has_size_436_comment =
    "C++ Interface:\n"
    "hasSize(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::has_size\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the size of the window/frame buffer\n"
    "//               is known, false otherwise.  In certain cases the size\n"
    "//               may not be known until after the object has been\n"
    "//               fully created.  Also, certain objects (like windows)\n"
    "//               may change size spontaneously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_has_size_436_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_is_valid_437(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_is_valid_437_comment =
    "C++ Interface:\n"
    "isValid(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the output is fully created and ready\n"
    "//               for rendering, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_is_valid_437_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsOutput::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_set_active_438(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsOutput::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const GraphicsOutput this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_set_active_438_comment =
    "C++ Interface:\n"
    "setActive(non-const GraphicsOutput this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::set_active\n"
    "//       Access: Published\n"
    "//  Description: Sets the active flag associated with the\n"
    "//               GraphicsOutput.  If the GraphicsOutput is marked\n"
    "//               inactive, nothing is rendered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_set_active_438_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsOutput::is_active(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_is_active_439(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsOutput::is_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isActive", key_word_list));
        else
            (PyArg_Parse(args, ":isActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->is_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isActive(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_is_active_439_comment =
    "C++ Interface:\n"
    "isActive(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::is_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if the window is ready to be rendered\n"
    "//               into, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_is_active_439_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsOutput::set_one_shot(bool one_shot)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_set_one_shot_440(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsOutput::set_one_shot(bool one_shot)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"one_shot", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOneShot", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setOneShot", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_one_shot((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.setOneShot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOneShot(non-const GraphicsOutput this, bool one_shot)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_set_one_shot_440_comment =
    "C++ Interface:\n"
    "setOneShot(non-const GraphicsOutput this, bool one_shot)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::set_one_shot\n"
    "//       Access: Published\n"
    "//  Description: Changes the current setting of the one-shot flag.\n"
    "//               When this is true, the GraphicsOutput will render one\n"
    "//               frame and then automatically set itself inactive.\n"
    "//               This is particularly useful for buffers that are\n"
    "//               created for the purposes of render-to-texture, for\n"
    "//               static textures that don't need to be continually\n"
    "//               re-rendered once they have been rendered the first\n"
    "//               time.\n"
    "//\n"
    "//               Setting the buffer inactive is not the same thing as\n"
    "//               destroying it.  You are still responsible for passing\n"
    "//               this buffer to GraphicsEngine::remove_window() when\n"
    "//               you no longer need the texture, in order to clean up\n"
    "//               fully.  (However, you should not call remove_window()\n"
    "//               on this buffer while the texture is still needed,\n"
    "//               because depending on the render-to-texture mechanism\n"
    "//               in use, this may invalidate the texture contents.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_set_one_shot_440_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::get_one_shot(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_one_shot_441(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::get_one_shot(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOneShot", key_word_list));
        else
            (PyArg_Parse(args, ":getOneShot"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->get_one_shot();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOneShot(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_one_shot_441_comment =
    "C++ Interface:\n"
    "getOneShot(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_one_shot\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the one-shot flag.\n"
    "//               When this is true, the GraphicsOutput will\n"
    "//               automatically detach its texture (if it has one) and\n"
    "//               remove itself from the GraphicsEngine after it\n"
    "//               renders the next frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_one_shot_441_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsOutput::set_inverted(bool inverted)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_set_inverted_442(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsOutput::set_inverted(bool inverted)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"inverted", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInverted", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setInverted", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_inverted((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.setInverted() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInverted(non-const GraphicsOutput this, bool inverted)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_set_inverted_442_comment =
    "C++ Interface:\n"
    "setInverted(non-const GraphicsOutput this, bool inverted)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::set_inverted\n"
    "//       Access: Published\n"
    "//  Description: Changes the current setting of the inverted flag.\n"
    "//               When this is true, the scene is rendered into the\n"
    "//               window upside-down and backwards, that is, inverted\n"
    "//               as if viewed through a mirror placed on the floor.\n"
    "//\n"
    "//               This is primarily intended to support DirectX (and a\n"
    "//               few buggy OpenGL graphics drivers) that perform a\n"
    "//               framebuffer-to-texture copy upside-down from the\n"
    "//               usual OpenGL (and Panda) convention.  Panda will\n"
    "//               automatically set this flag for offscreen buffers on\n"
    "//               hardware that is known to do this, to compensate when\n"
    "//               rendering offscreen into a texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_set_inverted_442_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::get_inverted(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_inverted_443(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::get_inverted(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInverted", key_word_list));
        else
            (PyArg_Parse(args, ":getInverted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->get_inverted();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInverted(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_inverted_443_comment =
    "C++ Interface:\n"
    "getInverted(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_inverted\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the inverted flag.\n"
    "//               When this is true, the scene is rendered into the\n"
    "//               window upside-down, flipped like a mirror along the X\n"
    "//               axis.  See set_inverted().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_inverted_443_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsOutput::set_red_blue_stereo(bool red_blue_stereo, unsigned int left_eye_color_mask, unsigned int right_eye_color_mask)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_set_red_blue_stereo_444(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsOutput::set_red_blue_stereo(bool red_blue_stereo, unsigned int left_eye_color_mask, unsigned int right_eye_color_mask)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"red_blue_stereo", (char *)"left_eye_color_mask", (char *)"right_eye_color_mask", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setRedBlueStereo", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param2_uint == NULL)|| (param3_uint == NULL)))
            {
                (local_this)->set_red_blue_stereo((PyObject_IsTrue(param1)!=0), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.setRedBlueStereo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRedBlueStereo(non-const GraphicsOutput this, bool red_blue_stereo, unsigned int left_eye_color_mask, unsigned int right_eye_color_mask)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_set_red_blue_stereo_444_comment =
    "C++ Interface:\n"
    "setRedBlueStereo(non-const GraphicsOutput this, bool red_blue_stereo, unsigned int left_eye_color_mask, unsigned int right_eye_color_mask)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::set_red_blue_stereo\n"
    "//       Access: Published\n"
    "//  Description: Enables red-blue stereo mode on this particular\n"
    "//               window.  When red-blue stereo mode is in effect,\n"
    "//               DisplayRegions that have the \"left\" channel set will\n"
    "//               render in the red (or specified) channel only, while\n"
    "//               DisplayRegions that have the \"right\" channel set will\n"
    "//               render in the blue (or specified) channel only.\n"
    "//\n"
    "//               The remaining two parameters specify the particular\n"
    "//               color channel(s) to associate with each eye.  Use the\n"
    "//               bits defined in ColorWriteAttrib::Channels.\n"
    "//\n"
    "//               This can be used to achieve a cheesy stereo mode in\n"
    "//               the absence of hardware-supported stereo.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_set_red_blue_stereo_444_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::get_red_blue_stereo(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_red_blue_stereo_445(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::get_red_blue_stereo(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRedBlueStereo", key_word_list));
        else
            (PyArg_Parse(args, ":getRedBlueStereo"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->get_red_blue_stereo();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRedBlueStereo(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_red_blue_stereo_445_comment =
    "C++ Interface:\n"
    "getRedBlueStereo(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_red_blue_stereo\n"
    "//       Access: Published\n"
    "//  Description: Returns whether red-blue stereo mode is in effect for\n"
    "//               this particular window.  See set_red_blue_stereo().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_red_blue_stereo_445_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int GraphicsOutput::get_left_eye_color_mask(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_left_eye_color_mask_446(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int GraphicsOutput::get_left_eye_color_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeftEyeColorMask", key_word_list));
        else
            (PyArg_Parse(args, ":getLeftEyeColorMask"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const GraphicsOutput*)local_this)->get_left_eye_color_mask();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeftEyeColorMask(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_left_eye_color_mask_446_comment =
    "C++ Interface:\n"
    "getLeftEyeColorMask(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_left_eye_color_mask\n"
    "//       Access: Published\n"
    "//  Description: Returns the color mask in effect when rendering a\n"
    "//               left-eye view in red_blue stereo mode.  This is one\n"
    "//               or more bits defined in ColorWriteAttrib::Channels.\n"
    "//               See set_red_blue_stereo().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_left_eye_color_mask_446_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int GraphicsOutput::get_right_eye_color_mask(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_right_eye_color_mask_447(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int GraphicsOutput::get_right_eye_color_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRightEyeColorMask", key_word_list));
        else
            (PyArg_Parse(args, ":getRightEyeColorMask"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const GraphicsOutput*)local_this)->get_right_eye_color_mask();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRightEyeColorMask(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_right_eye_color_mask_447_comment =
    "C++ Interface:\n"
    "getRightEyeColorMask(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_right_eye_color_mask\n"
    "//       Access: Published\n"
    "//  Description: Returns the color mask in effect when rendering a\n"
    "//               right-eye view in red_blue stereo mode.  This is one\n"
    "//               or more bits defined in ColorWriteAttrib::Channels.\n"
    "//               See set_red_blue_stereo().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_right_eye_color_mask_447_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline FrameBufferProperties const &GraphicsOutput::get_fb_properties(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_fb_properties_448(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline FrameBufferProperties const &GraphicsOutput::get_fb_properties(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFbProperties", key_word_list));
        else
            (PyArg_Parse(args, ":getFbProperties"));
        if(!PyErr_Occurred())
        {
            FrameBufferProperties const *return_value = &(((const GraphicsOutput*)local_this)->get_fb_properties());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_FrameBufferProperties,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFbProperties(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_fb_properties_448_comment =
    "C++ Interface:\n"
    "getFbProperties(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_fb_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the framebuffer properties of the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_fb_properties_448_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::is_stereo(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_is_stereo_449(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::is_stereo(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStereo", key_word_list));
        else
            (PyArg_Parse(args, ":isStereo"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->is_stereo();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStereo(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_is_stereo_449_comment =
    "C++ Interface:\n"
    "isStereo(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::is_stereo\n"
    "//       Access: Published\n"
    "//  Description: Returns Returns true if this window can render stereo\n"
    "//               DisplayRegions, either through red-blue stereo (see\n"
    "//               set_red_blue_stereo()) or through true hardware\n"
    "//               stereo rendering.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_is_stereo_449_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsOutput::clear_delete_flag(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_clear_delete_flag_450(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsOutput::clear_delete_flag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDeleteFlag", key_word_list));
        else
            (PyArg_Parse(args, ":clearDeleteFlag"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_delete_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.clearDeleteFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDeleteFlag(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_clear_delete_flag_450_comment =
    "C++ Interface:\n"
    "clearDeleteFlag(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::clear_delete_flag\n"
    "//       Access: Published\n"
    "//  Description: Resets the delete flag, so the GraphicsOutput will\n"
    "//               not be automatically deleted before the beginning of\n"
    "//               the next frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_clear_delete_flag_450_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::get_delete_flag(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_delete_flag_451(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsOutput::get_delete_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDeleteFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getDeleteFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsOutput*)local_this)->get_delete_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDeleteFlag(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_delete_flag_451_comment =
    "C++ Interface:\n"
    "getDeleteFlag(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_delete_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the delete flag.  When\n"
    "//               this is true, the GraphicsOutput will automatically\n"
    "//               be removed before the beginning of the next frame by\n"
    "//               the GraphicsEngine.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_delete_flag_451_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsOutput::set_sort(int sort)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_set_sort_452(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsOutput::set_sort(int sort)
        int param1;
        static char * key_word_list[] = {(char *)"sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.setSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSort(non-const GraphicsOutput this, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_set_sort_452_comment =
    "C++ Interface:\n"
    "setSort(non-const GraphicsOutput this, int sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::set_sort\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Adjusts the sorting order of this particular\n"
    "//               GraphicsOutput, relative to other GraphicsOutputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_set_sort_452_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::get_sort(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_sort_453(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::get_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSort", key_word_list));
        else
            (PyArg_Parse(args, ":getSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSort(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_sort_453_comment =
    "C++ Interface:\n"
    "getSort(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the sorting order of this particular\n"
    "//               GraphicsOutput.  The various GraphicsOutputs within a\n"
    "//               particular thread will be rendered in the indicated\n"
    "//               order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_sort_453_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsOutput::set_child_sort(int child_sort)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_set_child_sort_454(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsOutput::set_child_sort(int child_sort)
        int param1;
        static char * key_word_list[] = {(char *)"child_sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setChildSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setChildSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_child_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.setChildSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChildSort(non-const GraphicsOutput this, int child_sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_set_child_sort_454_comment =
    "C++ Interface:\n"
    "setChildSort(non-const GraphicsOutput this, int child_sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::set_child_sort\n"
    "//       Access: Published\n"
    "//  Description: Specifies the sort value of future offscreen buffers\n"
    "//               created by make_texture_sort().\n"
    "//\n"
    "//               The purpose of this method is to allow the user to\n"
    "//               limit the sort value chosen for a buffer created via\n"
    "//               make_texture_buffer().  Normally, this buffer will be\n"
    "//               assigned a value of get_sort() - 1, so that it\n"
    "//               will be rendered before this window is rendered; but\n"
    "//               sometimes this isn't sufficiently early, especially\n"
    "//               if other buffers also have a view into the same\n"
    "//               scene.\n"
    "//\n"
    "//               If you specify a value here, then new buffers created\n"
    "//               via make_texture_buffer() will be given that sort\n"
    "//               value instead of get_sort() - 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_set_child_sort_454_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsOutput::clear_child_sort(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_clear_child_sort_455(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsOutput::clear_child_sort(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearChildSort", key_word_list));
        else
            (PyArg_Parse(args, ":clearChildSort"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_child_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.clearChildSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearChildSort(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_clear_child_sort_455_comment =
    "C++ Interface:\n"
    "clearChildSort(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::clear_child_sort\n"
    "//       Access: Published\n"
    "//  Description: Resets the sort value of future offscreen buffers\n"
    "//               created by make_texture_sort() to the default value.\n"
    "//               See set_child_sort().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_clear_child_sort_455_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsOutput::get_child_sort(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_child_sort_456(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsOutput::get_child_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChildSort", key_word_list));
        else
            (PyArg_Parse(args, ":getChildSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_child_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChildSort(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_child_sort_456_comment =
    "C++ Interface:\n"
    "getChildSort(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_child_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the sort value of future offscreen buffers\n"
    "//               created by make_texture_sort(). See set_child_sort().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_child_sort_456_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsOutput::trigger_copy(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_trigger_copy_457(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsOutput::trigger_copy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":triggerCopy", key_word_list));
        else
            (PyArg_Parse(args, ":triggerCopy"));
        if(!PyErr_Occurred())
        {
            (local_this)->trigger_copy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.triggerCopy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "triggerCopy(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_trigger_copy_457_comment =
    "C++ Interface:\n"
    "triggerCopy(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::trigger_copy\n"
    "//       Access: Published\n"
    "//  Description: When the GraphicsOutput is in triggered copy mode,\n"
    "//               this function triggers the copy (at the end of the\n"
    "//               next frame).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_trigger_copy_457_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *GraphicsOutput::make_display_region(void)
 * DisplayRegion *GraphicsOutput::make_display_region(float l, float r, float b, float t)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_make_display_region_458(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline DisplayRegion *GraphicsOutput::make_display_region(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeDisplayRegion", key_word_list));
            else
                (PyArg_Parse(args, ":makeDisplayRegion"));
            if(!PyErr_Occurred())
            {
                DisplayRegion *return_value = (local_this)->make_display_region();
                if (return_value != (DisplayRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-DisplayRegion *GraphicsOutput::make_display_region(float l, float r, float b, float t)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"b", (char *)"t", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makeDisplayRegion", key_word_list, &param1, &param2, &param3, &param4))
            {
                DisplayRegion *return_value = (local_this)->make_display_region((float)param1, (float)param2, (float)param3, (float)param4);
                if (return_value != (DisplayRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeDisplayRegion() takes 1 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeDisplayRegion(non-const GraphicsOutput this)\n"
          "makeDisplayRegion(non-const GraphicsOutput this, float l, float r, float b, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_make_display_region_458_comment =
    "C++ Interface:\n"
    "makeDisplayRegion(non-const GraphicsOutput this)\n"
    "makeDisplayRegion(non-const GraphicsOutput this, float l, float r, float b, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_display_region\n"
    "//       Access: Published\n"
    "//  Description: Creates a new DisplayRegion that covers the entire\n"
    "//               window.\n"
    "//\n"
    "//               If is_stereo() is true for this window, and\n"
    "//               default-stereo-camera is configured true, this\n"
    "//               actually makes a StereoDisplayRegion.  Call\n"
    "//               make_mono_display_region() or\n"
    "//               make_stereo_display_region() if you want to insist on\n"
    "//               one or the other.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_display_region\n"
    "//       Access: Published\n"
    "//  Description: Creates a new DisplayRegion that covers the indicated\n"
    "//               sub-rectangle within the window.  The range on all\n"
    "//               parameters is 0..1.\n"
    "//\n"
    "//               If is_stereo() is true for this window, and\n"
    "//               default-stereo-camera is configured true, this\n"
    "//               actually makes a StereoDisplayRegion.  Call\n"
    "//               make_mono_display_region() or\n"
    "//               make_stereo_display_region() if you want to insist on\n"
    "//               one or the other.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_make_display_region_458_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *GraphicsOutput::make_mono_display_region(void)
 * DisplayRegion *GraphicsOutput::make_mono_display_region(float l, float r, float b, float t)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_make_mono_display_region_459(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline DisplayRegion *GraphicsOutput::make_mono_display_region(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeMonoDisplayRegion", key_word_list));
            else
                (PyArg_Parse(args, ":makeMonoDisplayRegion"));
            if(!PyErr_Occurred())
            {
                DisplayRegion *return_value = (local_this)->make_mono_display_region();
                if (return_value != (DisplayRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeMonoDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-DisplayRegion *GraphicsOutput::make_mono_display_region(float l, float r, float b, float t)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"b", (char *)"t", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makeMonoDisplayRegion", key_word_list, &param1, &param2, &param3, &param4))
            {
                DisplayRegion *return_value = (local_this)->make_mono_display_region((float)param1, (float)param2, (float)param3, (float)param4);
                if (return_value != (DisplayRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeMonoDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeMonoDisplayRegion() takes 1 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeMonoDisplayRegion(non-const GraphicsOutput this)\n"
          "makeMonoDisplayRegion(non-const GraphicsOutput this, float l, float r, float b, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_make_mono_display_region_459_comment =
    "C++ Interface:\n"
    "makeMonoDisplayRegion(non-const GraphicsOutput this)\n"
    "makeMonoDisplayRegion(non-const GraphicsOutput this, float l, float r, float b, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_mono_display_region\n"
    "//       Access: Published\n"
    "//  Description: Creates a new DisplayRegion that covers the entire\n"
    "//               window.\n"
    "//\n"
    "//               This always returns a mono DisplayRegion, even if\n"
    "//               is_stereo() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_mono_display_region\n"
    "//       Access: Published\n"
    "//  Description: Creates a new DisplayRegion that covers the indicated\n"
    "//               sub-rectangle within the window.  The range on all\n"
    "//               parameters is 0..1.\n"
    "//\n"
    "//               This always returns a mono DisplayRegion, even if\n"
    "//               is_stereo() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_make_mono_display_region_459_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(void)
 * StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(float l, float r, float b, float t)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_make_stereo_display_region_460(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeStereoDisplayRegion", key_word_list));
            else
                (PyArg_Parse(args, ":makeStereoDisplayRegion"));
            if(!PyErr_Occurred())
            {
                StereoDisplayRegion *return_value = (local_this)->make_stereo_display_region();
                if (return_value != (StereoDisplayRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_StereoDisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeStereoDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(float l, float r, float b, float t)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"b", (char *)"t", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makeStereoDisplayRegion", key_word_list, &param1, &param2, &param3, &param4))
            {
                StereoDisplayRegion *return_value = (local_this)->make_stereo_display_region((float)param1, (float)param2, (float)param3, (float)param4);
                if (return_value != (StereoDisplayRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_StereoDisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeStereoDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeStereoDisplayRegion() takes 1 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeStereoDisplayRegion(non-const GraphicsOutput this)\n"
          "makeStereoDisplayRegion(non-const GraphicsOutput this, float l, float r, float b, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_make_stereo_display_region_460_comment =
    "C++ Interface:\n"
    "makeStereoDisplayRegion(non-const GraphicsOutput this)\n"
    "makeStereoDisplayRegion(non-const GraphicsOutput this, float l, float r, float b, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_stereo_display_region\n"
    "//       Access: Published\n"
    "//  Description: Creates a new DisplayRegion that covers the entire\n"
    "//               window.\n"
    "//\n"
    "//               This always returns a stereo DisplayRegion, even if\n"
    "//               is_stereo() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_stereo_display_region\n"
    "//       Access: Published\n"
    "//  Description: Creates a new DisplayRegion that covers the indicated\n"
    "//               sub-rectangle within the window.  The range on all\n"
    "//               parameters is 0..1.\n"
    "//\n"
    "//               This always returns a stereo DisplayRegion, even if\n"
    "//               is_stereo() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_make_stereo_display_region_460_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsOutput::remove_display_region(DisplayRegion *display_region)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_remove_display_region_461(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool GraphicsOutput::remove_display_region(DisplayRegion *display_region)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"display_region", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeDisplayRegion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeDisplayRegion", &param1));
            if(!PyErr_Occurred())
            {
                DisplayRegion *param1_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DisplayRegion, 1, "GraphicsOutput.removeDisplayRegion", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_display_region(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.removeDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeDisplayRegion(non-const GraphicsOutput this, non-const DisplayRegion display_region)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_remove_display_region_461_comment =
    "C++ Interface:\n"
    "removeDisplayRegion(non-const GraphicsOutput this, non-const DisplayRegion display_region)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::remove_display_region\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated DisplayRegion from the window,\n"
    "//               and destructs it if there are no other references.\n"
    "//\n"
    "//               Returns true if the DisplayRegion is found and\n"
    "//               removed, false if it was not a part of the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_remove_display_region_461_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsOutput::remove_all_display_regions(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_remove_all_display_regions_462(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsOutput::remove_all_display_regions(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAllDisplayRegions", key_word_list));
        else
            (PyArg_Parse(args, ":removeAllDisplayRegions"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_all_display_regions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.removeAllDisplayRegions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAllDisplayRegions(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_remove_all_display_regions_462_comment =
    "C++ Interface:\n"
    "removeAllDisplayRegions(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::remove_all_display_regions\n"
    "//       Access: Published\n"
    "//  Description: Removes all display regions from the window, except\n"
    "//               the default one that is created with the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_remove_all_display_regions_462_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int GraphicsOutput::get_num_display_regions(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_num_display_regions_463(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int GraphicsOutput::get_num_display_regions(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDisplayRegions", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDisplayRegions"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_num_display_regions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDisplayRegions(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_num_display_regions_463_comment =
    "C++ Interface:\n"
    "getNumDisplayRegions(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_num_display_regions\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of DisplayRegions that have\n"
    "//               been created within the window, active or otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_num_display_regions_463_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DisplayRegion > GraphicsOutput::get_display_region(int n) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_display_region_464(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< DisplayRegion > GraphicsOutput::get_display_region(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDisplayRegion", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDisplayRegion", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< DisplayRegion > return_value = ((const GraphicsOutput*)local_this)->get_display_region((int)param1);
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DisplayRegion,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayRegion(const GraphicsOutput this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_display_region_464_comment =
    "C++ Interface:\n"
    "getDisplayRegion(const GraphicsOutput this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_display_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth DisplayRegion of those that have been\n"
    "//               created within the window.  This may return NULL if n\n"
    "//               is out of bounds; particularly likely if the number\n"
    "//               of display regions has changed since the last call to\n"
    "//               get_num_display_regions().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_display_region_464_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int GraphicsOutput::get_num_active_display_regions(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_num_active_display_regions_465(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int GraphicsOutput::get_num_active_display_regions(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumActiveDisplayRegions", key_word_list));
        else
            (PyArg_Parse(args, ":getNumActiveDisplayRegions"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsOutput*)local_this)->get_num_active_display_regions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumActiveDisplayRegions(const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_num_active_display_regions_465_comment =
    "C++ Interface:\n"
    "getNumActiveDisplayRegions(const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_num_active_display_regions\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of active DisplayRegions that have\n"
    "//               been created within the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_num_active_display_regions_465_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DisplayRegion > GraphicsOutput::get_active_display_region(int n) const
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_active_display_region_466(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< DisplayRegion > GraphicsOutput::get_active_display_region(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getActiveDisplayRegion", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getActiveDisplayRegion", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< DisplayRegion > return_value = ((const GraphicsOutput*)local_this)->get_active_display_region((int)param1);
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DisplayRegion,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActiveDisplayRegion(const GraphicsOutput this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_active_display_region_466_comment =
    "C++ Interface:\n"
    "getActiveDisplayRegion(const GraphicsOutput this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_active_display_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth active DisplayRegion of those that\n"
    "//               have been created within the window.  This may return\n"
    "//               NULL if n is out of bounds; particularly likely if\n"
    "//               the number of display regions has changed since the\n"
    "//               last call to get_num_active_display_regions().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_active_display_region_466_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex, bool to_ram, FrameBufferProperties *fbp)
 * GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex, bool to_ram, FrameBufferProperties *fbp = ((void *)(0)))
 * GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex, bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
 * GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex = ((void *)(0)), bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_make_texture_buffer_467(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex = ((void *)(0)), bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"x_size", (char *)"y_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:makeTextureBuffer", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                GraphicsOutput *return_value = (local_this)->make_texture_buffer(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
                if (return_value != (GraphicsOutput *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.makeTextureBuffer() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex, bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
                char *param1_str; int param1_len;
                int param2;
                int param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"name", (char *)"x_size", (char *)"y_size", (char *)"tex", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iiO:makeTextureBuffer", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4))
                {
                    Texture *param4_this = (Texture *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_Texture, 4, "GraphicsOutput.makeTextureBuffer", 0, coerced_ptr, report_errors);

                    if (!((param4_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_texture_buffer(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3, param4_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeTextureBuffer() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex, bool to_ram, FrameBufferProperties *fbp = ((void *)(0)))
                char *param1_str; int param1_len;
                int param2;
                int param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"name", (char *)"x_size", (char *)"y_size", (char *)"tex", (char *)"to_ram", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iiOO:makeTextureBuffer", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5))
                {
                    Texture *param4_this = (Texture *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_Texture, 4, "GraphicsOutput.makeTextureBuffer", 0, coerced_ptr, report_errors);

                    if (!((param4_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_texture_buffer(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3, param4_this, (PyObject_IsTrue(param5)!=0));
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeTextureBuffer() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_texture_buffer(basic_string< char > const &name, int x_size, int y_size, Texture *tex, bool to_ram, FrameBufferProperties *fbp)
                char *param1_str; int param1_len;
                int param2;
                int param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                static char * key_word_list[] = {(char *)"name", (char *)"x_size", (char *)"y_size", (char *)"tex", (char *)"to_ram", (char *)"fbp", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iiOOO:makeTextureBuffer", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6))
                {
                    Texture *param4_this = (Texture *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_Texture, 4, "GraphicsOutput.makeTextureBuffer", 0, coerced_ptr, report_errors);
FrameBufferProperties *param6_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_FrameBufferProperties, 6, "GraphicsOutput.makeTextureBuffer", 0, coerced_ptr, report_errors);

                    if (!((param4_this == NULL)|| (param6_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_texture_buffer(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3, param4_this, (PyObject_IsTrue(param5)!=0), param6_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeTextureBuffer() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeTextureBuffer() takes 4, 5, 6, or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size)\n"
          "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size, non-const Texture tex)\n"
          "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size, non-const Texture tex, bool to_ram)\n"
          "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size, non-const Texture tex, bool to_ram, non-const FrameBufferProperties fbp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_make_texture_buffer_467_comment =
    "C++ Interface:\n"
    "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size)\n"
    "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size, non-const Texture tex)\n"
    "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size, non-const Texture tex, bool to_ram)\n"
    "makeTextureBuffer(non-const GraphicsOutput this, string name, int x_size, int y_size, non-const Texture tex, bool to_ram, non-const FrameBufferProperties fbp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_texture_buffer\n"
    "//       Access: Published\n"
    "//  Description: Creates and returns an offscreen buffer for rendering\n"
    "//               into, the result of which will be a texture suitable\n"
    "//               for applying to geometry within the scene rendered\n"
    "//               into this window.\n"
    "//\n"
    "//               If tex is not NULL, it is the texture that will be\n"
    "//               set up for rendering into; otherwise, a new Texture\n"
    "//               object will be created.  In either case, the target\n"
    "//               texture can be retrieved from the return value with\n"
    "//               buffer->get_texture() (assuming the return value is\n"
    "//               not NULL).\n"
    "//\n"
    "//               If to_ram is true, the buffer will be set up to\n"
    "//               download its contents to the system RAM memory\n"
    "//               associated with the Texture object, instead of\n"
    "//               keeping it strictly within texture memory; this is\n"
    "//               much slower, but it allows using the texture with any\n"
    "//               GSG.\n"
    "//\n"
    "//               This will attempt to be smart about maximizing render\n"
    "//               performance while minimizing framebuffer waste.  It\n"
    "//               might return a GraphicsBuffer set to render directly\n"
    "//               into a texture, if possible; or it might return a\n"
    "//               ParasiteBuffer that renders into this window.  The\n"
    "//               return value is NULL if the buffer could not be\n"
    "//               created for some reason.\n"
    "//\n"
    "//               When you are done using the buffer, you should remove\n"
    "//               it with a call to GraphicsEngine::remove_window() (or\n"
    "//               set the one_shot flag so it removes itself after one\n"
    "//               frame).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_make_texture_buffer_467_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask, bool to_ram, FrameBufferProperties *fbp)
 * GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask, bool to_ram, FrameBufferProperties *fbp = ((void *)(0)))
 * GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask, bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
 * GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask = ((get_all_camera_mask())), bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_make_cube_map_468(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask = ((get_all_camera_mask())), bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
                char *param1_str; int param1_len;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"name", (char *)"size", (char *)"camera_rig", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iO:makeCubeMap", key_word_list, &param1_str, &param1_len, &param2, &param3))
                {
                    NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "GraphicsOutput.makeCubeMap", 0, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_cube_map(basic_string<char>(param1_str, param1_len), (int)param2, *param3_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeCubeMap() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask, bool to_ram = (0), FrameBufferProperties *fbp = ((void *)(0)))
                char *param1_str; int param1_len;
                int param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"name", (char *)"size", (char *)"camera_rig", (char *)"camera_mask", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iOO:makeCubeMap", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4))
                {
                    NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "GraphicsOutput.makeCubeMap", 0, coerced_ptr, report_errors);
BitMask< unsigned int, 32 > *param4_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_BitMask_unsigned_int_32, 4, "GraphicsOutput.makeCubeMap", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_cube_map(basic_string<char>(param1_str, param1_len), (int)param2, *param3_this, *param4_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeCubeMap() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask, bool to_ram, FrameBufferProperties *fbp = ((void *)(0)))
                char *param1_str; int param1_len;
                int param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"name", (char *)"size", (char *)"camera_rig", (char *)"camera_mask", (char *)"to_ram", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iOOO:makeCubeMap", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5))
                {
                    NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "GraphicsOutput.makeCubeMap", 0, coerced_ptr, report_errors);
BitMask< unsigned int, 32 > *param4_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_BitMask_unsigned_int_32, 4, "GraphicsOutput.makeCubeMap", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_cube_map(basic_string<char>(param1_str, param1_len), (int)param2, *param3_this, *param4_this, (PyObject_IsTrue(param5)!=0));
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeCubeMap() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsOutput::make_cube_map(basic_string< char > const &name, int size, NodePath &camera_rig, BitMask< unsigned int, 32 > camera_mask, bool to_ram, FrameBufferProperties *fbp)
                char *param1_str; int param1_len;
                int param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                static char * key_word_list[] = {(char *)"name", (char *)"size", (char *)"camera_rig", (char *)"camera_mask", (char *)"to_ram", (char *)"fbp", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#iOOOO:makeCubeMap", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6))
                {
                    NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "GraphicsOutput.makeCubeMap", 0, coerced_ptr, report_errors);
BitMask< unsigned int, 32 > *param4_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_BitMask_unsigned_int_32, 4, "GraphicsOutput.makeCubeMap", 1, coerced_ptr, report_errors);
FrameBufferProperties *param6_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_FrameBufferProperties, 6, "GraphicsOutput.makeCubeMap", 0, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)|| (param6_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_cube_map(basic_string<char>(param1_str, param1_len), (int)param2, *param3_this, *param4_this, (PyObject_IsTrue(param5)!=0), param6_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.makeCubeMap() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeCubeMap() takes 4, 5, 6, or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig)\n"
          "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig, const BitMask camera_mask)\n"
          "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig, const BitMask camera_mask, bool to_ram)\n"
          "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig, const BitMask camera_mask, bool to_ram, non-const FrameBufferProperties fbp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_make_cube_map_468_comment =
    "C++ Interface:\n"
    "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig)\n"
    "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig, const BitMask camera_mask)\n"
    "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig, const BitMask camera_mask, bool to_ram)\n"
    "makeCubeMap(non-const GraphicsOutput this, string name, int size, non-const NodePath camera_rig, const BitMask camera_mask, bool to_ram, non-const FrameBufferProperties fbp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_cube_map\n"
    "//       Access: Published\n"
    "//  Description: This is similar to make_texture_buffer() in that it\n"
    "//               allocates a separate buffer suitable for rendering to\n"
    "//               a texture that can be assigned to geometry in this\n"
    "//               window, but in this case, the buffer is set up to\n"
    "//               render the six faces of a cube map.\n"
    "//\n"
    "//               The buffer is automatically set up with six display\n"
    "//               regions and six cameras, each of which are assigned\n"
    "//               the indicated draw_mask and parented to the given\n"
    "//               camera_rig node (which you should then put in your\n"
    "//               scene to render the cube map from the appropriate\n"
    "//               point of view).\n"
    "//\n"
    "//               You may take the texture associated with the buffer\n"
    "//               and apply it to geometry, particularly with\n"
    "//               TexGenAttrib::M_world_cube_map also in effect, to\n"
    "//               apply a reflection of everything seen by the camera\n"
    "//               rig.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_make_cube_map_468_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename GraphicsOutput::make_screenshot_filename(basic_string< char > const &prefix)
 * static inline Filename GraphicsOutput::make_screenshot_filename(basic_string< char > const &prefix = ("screenshot"))
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_make_screenshot_filename_469(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-static inline Filename GraphicsOutput::make_screenshot_filename(basic_string< char > const &prefix = ("screenshot"))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":makeScreenshotFilename", key_word_list))
            {
                Filename result = GraphicsOutput::make_screenshot_filename();
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-static inline Filename GraphicsOutput::make_screenshot_filename(basic_string< char > const &prefix)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makeScreenshotFilename", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:makeScreenshotFilename", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                Filename result = GraphicsOutput::make_screenshot_filename(basic_string<char>(param0_str, param0_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeScreenshotFilename() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeScreenshotFilename()\n"
          "makeScreenshotFilename(string prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_make_screenshot_filename_469_comment =
    "C++ Interface:\n"
    "makeScreenshotFilename()\n"
    "makeScreenshotFilename(string prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::make_screenshot_filename\n"
    "//       Access: Published, Static\n"
    "//  Description: Saves a screenshot of the region to a default\n"
    "//               filename, and returns the filename, or empty string\n"
    "//               if the screenshot failed.  The default filename is\n"
    "//               generated from the supplied prefix and from the\n"
    "//               Config variable screenshot-filename, which contains\n"
    "//               the following strings:\n"
    "//\n"
    "//                 %~p - the supplied prefix\n"
    "//                 %~f - the frame count\n"
    "//                 %~e - the value of screenshot-extension\n"
    "//                 All other % strings in strftime().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_make_screenshot_filename_469_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename GraphicsOutput::save_screenshot_default(basic_string< char > const &prefix)
 * inline Filename GraphicsOutput::save_screenshot_default(basic_string< char > const &prefix = ("screenshot"))
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_save_screenshot_default_470(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline Filename GraphicsOutput::save_screenshot_default(basic_string< char > const &prefix = ("screenshot"))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":saveScreenshotDefault", key_word_list));
            else
                (PyArg_Parse(args, ":saveScreenshotDefault"));
            if(!PyErr_Occurred())
            {
                Filename result = (local_this)->save_screenshot_default();
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.saveScreenshotDefault() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline Filename GraphicsOutput::save_screenshot_default(basic_string< char > const &prefix)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:saveScreenshotDefault", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:saveScreenshotDefault", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                Filename result = (local_this)->save_screenshot_default(basic_string<char>(param1_str, param1_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.saveScreenshotDefault() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "saveScreenshotDefault() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "saveScreenshotDefault(non-const GraphicsOutput this)\n"
          "saveScreenshotDefault(non-const GraphicsOutput this, string prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_save_screenshot_default_470_comment =
    "C++ Interface:\n"
    "saveScreenshotDefault(non-const GraphicsOutput this)\n"
    "saveScreenshotDefault(non-const GraphicsOutput this, string prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::save_screenshot_default\n"
    "//       Access: Published\n"
    "//  Description: Saves a screenshot of the region to a default\n"
    "//               filename, and returns the filename, or empty string\n"
    "//               if the screenshot failed.  The filename is generated\n"
    "//               by make_screenshot_filename().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_save_screenshot_default_470_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::save_screenshot(Filename const &filename, basic_string< char > const &image_comment)
 * inline bool GraphicsOutput::save_screenshot(Filename const &filename, basic_string< char > const &image_comment = (""))
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_save_screenshot_471(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool GraphicsOutput::save_screenshot(Filename const &filename, basic_string< char > const &image_comment = (""))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:saveScreenshot", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:saveScreenshot", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "GraphicsOutput.saveScreenshot", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->save_screenshot(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.saveScreenshot() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool GraphicsOutput::save_screenshot(Filename const &filename, basic_string< char > const &image_comment)
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"filename", (char *)"image_comment", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:saveScreenshot", key_word_list, &param1, &param2_str, &param2_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "GraphicsOutput.saveScreenshot", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->save_screenshot(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsOutput.saveScreenshot() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "saveScreenshot() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "saveScreenshot(non-const GraphicsOutput this, const Filename filename)\n"
          "saveScreenshot(non-const GraphicsOutput this, const Filename filename, string image_comment)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_save_screenshot_471_comment =
    "C++ Interface:\n"
    "saveScreenshot(non-const GraphicsOutput this, const Filename filename)\n"
    "saveScreenshot(non-const GraphicsOutput this, const Filename filename, string image_comment)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::save_screenshot\n"
    "//       Access: Published\n"
    "//  Description: Saves a screenshot of the region to the indicated\n"
    "//               filename.  The image comment is an optional user\n"
    "//               readable string that will be saved with the header\n"
    "//               of the image (if the file format supports embedded\n"
    "//               data; for example jpg allows comments).  Returns\n"
    "//               true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_save_screenshot_471_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsOutput::get_screenshot(PNMImage &image)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_screenshot_472(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool GraphicsOutput::get_screenshot(PNMImage &image)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"image", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getScreenshot", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getScreenshot", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "GraphicsOutput.getScreenshot", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_screenshot(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.getScreenshot() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScreenshot(non-const GraphicsOutput this, non-const PNMImage image)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_screenshot_472_comment =
    "C++ Interface:\n"
    "getScreenshot(non-const GraphicsOutput this, non-const PNMImage image)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_screenshot\n"
    "//       Access: Published\n"
    "//  Description: Captures the most-recently rendered image from the\n"
    "//               framebuffer into the indicated PNMImage.  Returns\n"
    "//               true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_screenshot_472_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath GraphicsOutput::get_texture_card(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_texture_card_473(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePath GraphicsOutput::get_texture_card(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureCard", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureCard"));
        if(!PyErr_Occurred())
        {
            NodePath result = (local_this)->get_texture_card();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.getTextureCard() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureCard(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_texture_card_473_comment =
    "C++ Interface:\n"
    "getTextureCard(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::get_texture_card\n"
    "//       Access: Published\n"
    "//  Description: Returns a PandaNode containing a square polygon.\n"
    "//               The dimensions are (-1,0,-1) to (1,0,1). The texture\n"
    "//               coordinates are such that the texture of this\n"
    "//               GraphicsOutput is aligned properly to the polygon.\n"
    "//               The GraphicsOutput promises to surgically update\n"
    "//               the Geom inside the PandaNode if necessary to maintain\n"
    "//               this invariant.\n"
    "//\n"
    "//               Each invocation of this function returns a freshly-\n"
    "//               allocated PandaNode.  You can therefore safely modify\n"
    "//               the RenderAttribs of the PandaNode.  The\n"
    "//               PandaNode is initially textured with the texture\n"
    "//               of this GraphicOutput.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_texture_card_473_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsOutput::share_depth_buffer(GraphicsOutput *graphics_output)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_share_depth_buffer_474(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool GraphicsOutput::share_depth_buffer(GraphicsOutput *graphics_output)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"graphics_output", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:shareDepthBuffer", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:shareDepthBuffer", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "GraphicsOutput.shareDepthBuffer", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->share_depth_buffer(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsOutput.shareDepthBuffer() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shareDepthBuffer(non-const GraphicsOutput this, non-const GraphicsOutput graphics_output)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_share_depth_buffer_474_comment =
    "C++ Interface:\n"
    "shareDepthBuffer(non-const GraphicsOutput this, non-const GraphicsOutput graphics_output)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::share_depth_buffer\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Will attempt to use the depth buffer of the input\n"
    "//               graphics_output. The buffer sizes must be exactly\n"
    "//               the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_share_depth_buffer_474_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsOutput::unshare_depth_buffer(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_unshare_depth_buffer_475(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsOutput::unshare_depth_buffer(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unshareDepthBuffer", key_word_list));
        else
            (PyArg_Parse(args, ":unshareDepthBuffer"));
        if(!PyErr_Occurred())
        {
            (local_this)->unshare_depth_buffer();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.unshareDepthBuffer() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unshareDepthBuffer(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_unshare_depth_buffer_475_comment =
    "C++ Interface:\n"
    "unshareDepthBuffer(non-const GraphicsOutput this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsOutput::unshare_depth_buffer\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Discontinue sharing the depth buffer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsOutput_unshare_depth_buffer_475_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsOutput::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_get_class_type_476(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsOutput::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsOutput::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_get_class_type_476_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsOutput_get_class_type_476_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutputBase *GraphicsOutput::upcast_to_GraphicsOutputBase(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_413(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-GraphicsOutputBase *GraphicsOutput::upcast_to_GraphicsOutputBase(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToGraphicsOutputBase", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToGraphicsOutputBase"));
        if(!PyErr_Occurred())
        {
            GraphicsOutputBase *return_value = (GraphicsOutputBase *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutputBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.upcastToGraphicsOutputBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToGraphicsOutputBase(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_413_comment =
    "C++ Interface:\n"
    "upcastToGraphicsOutputBase(non-const GraphicsOutput this)\n"
    "\n"
    "upcast from GraphicsOutput to GraphicsOutputBase\n"
    "";
#else
static const char * Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_413_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DrawableRegion *GraphicsOutput::upcast_to_DrawableRegion(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutput_upcast_to_DrawableRegion_415(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutput * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutput,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DrawableRegion *GraphicsOutput::upcast_to_DrawableRegion(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDrawableRegion", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDrawableRegion"));
        if(!PyErr_Occurred())
        {
            DrawableRegion *return_value = (DrawableRegion *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DrawableRegion,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutput.upcastToDrawableRegion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDrawableRegion(non-const GraphicsOutput this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutput_upcast_to_DrawableRegion_415_comment =
    "C++ Interface:\n"
    "upcastToDrawableRegion(non-const GraphicsOutput this)\n"
    "\n"
    "upcast from GraphicsOutput to DrawableRegion\n"
    "";
#else
static const char * Dtool_GraphicsOutput_upcast_to_DrawableRegion_415_comment = NULL;
#endif

int  Dtool_Init_GraphicsOutput(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsOutput)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_GraphicsOutput_get_display_regions(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumDisplayRegions", "getDisplayRegion");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_GraphicsOutput_get_active_display_regions(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumActiveDisplayRegions", "getActiveDisplayRegion");
}
inline void  * Dtool_UpcastInterface_GraphicsOutput(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsOutput)
    {
        printf("GraphicsOutput ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsOutput * local_this = (GraphicsOutput *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsOutput)
        return local_this;
    if(requested_type == &Dtool_DrawableRegion)
        return ( DrawableRegion *) local_this;
    if(requested_type == &Dtool_GraphicsOutputBase)
        return ( GraphicsOutputBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( GraphicsOutputBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( GraphicsOutputBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsOutput(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsOutput)
        return from_this;
    if(from_type == &Dtool_DrawableRegion)
    {
          DrawableRegion* other_this = (DrawableRegion*)from_this;
          return (GraphicsOutput*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutputBase)
    {
          GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
          return (GraphicsOutput*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsOutput*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsOutput*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GraphicsOutput*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GraphicsOutput*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsBuffer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void GraphicsBuffer::set_size(int x, int y)
 *******************************************************************/
static PyObject *Dtool_GraphicsBuffer_set_size_478(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsBuffer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsBuffer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsBuffer::set_size(int x, int y)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_size((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsBuffer.setSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSize(non-const GraphicsBuffer this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsBuffer_set_size_478_comment =
    "C++ Interface:\n"
    "setSize(non-const GraphicsBuffer this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsBuffer::set_size\n"
    "//       Access: Public, Virtual\n"
    "//  Description: This is called by the GraphicsEngine to request that\n"
    "//               the buffer resize itself.  Although calls to get the\n"
    "//               size will return the new value, much of the actual\n"
    "//               resizing work doesn't take place until the next\n"
    "//               begin_frame.  Not all buffers are resizeable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsBuffer_set_size_478_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsBuffer::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsBuffer_get_class_type_479(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsBuffer::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsBuffer::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsBuffer_get_class_type_479_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsBuffer_get_class_type_479_comment = NULL;
#endif

int  Dtool_Init_GraphicsBuffer(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsBuffer)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GraphicsBuffer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsBuffer)
    {
        printf("GraphicsBuffer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsBuffer * local_this = (GraphicsBuffer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsBuffer)
        return local_this;
    if(requested_type == &Dtool_DrawableRegion)
        return ( DrawableRegion *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_GraphicsOutput)
        return ( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_GraphicsOutputBase)
        return ( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsBuffer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsBuffer)
        return from_this;
    if(from_type == &Dtool_DrawableRegion)
    {
          DrawableRegion* other_this = (DrawableRegion*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutput)
    {
          GraphicsOutput* other_this = (GraphicsOutput*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutputBase)
    {
          GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GraphicsBuffer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TouchInfo 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int TouchInfo::get_x(void)
 *******************************************************************/
static PyObject *Dtool_TouchInfo_get_x_482(PyObject *self, PyObject *args,PyObject *kwds) {
    TouchInfo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TouchInfo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TouchInfo::get_x(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getX", key_word_list));
        else
            (PyArg_Parse(args, ":getX"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TouchInfo.getX() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getX(non-const TouchInfo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TouchInfo_get_x_482_comment =
    "C++ Interface:\n"
    "getX(non-const TouchInfo this)\n"
    "\n"
    "";
#else
static const char * Dtool_TouchInfo_get_x_482_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TouchInfo::get_y(void)
 *******************************************************************/
static PyObject *Dtool_TouchInfo_get_y_483(PyObject *self, PyObject *args,PyObject *kwds) {
    TouchInfo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TouchInfo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TouchInfo::get_y(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getY", key_word_list));
        else
            (PyArg_Parse(args, ":getY"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TouchInfo.getY() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getY(non-const TouchInfo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TouchInfo_get_y_483_comment =
    "C++ Interface:\n"
    "getY(non-const TouchInfo this)\n"
    "\n"
    "";
#else
static const char * Dtool_TouchInfo_get_y_483_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TouchInfo::get_id(void)
 *******************************************************************/
static PyObject *Dtool_TouchInfo_get_id_484(PyObject *self, PyObject *args,PyObject *kwds) {
    TouchInfo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TouchInfo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TouchInfo::get_id(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TouchInfo.getId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(non-const TouchInfo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TouchInfo_get_id_484_comment =
    "C++ Interface:\n"
    "getId(non-const TouchInfo this)\n"
    "\n"
    "";
#else
static const char * Dtool_TouchInfo_get_id_484_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TouchInfo::get_flags(void)
 *******************************************************************/
static PyObject *Dtool_TouchInfo_get_flags_485(PyObject *self, PyObject *args,PyObject *kwds) {
    TouchInfo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TouchInfo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TouchInfo::get_flags(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TouchInfo.getFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFlags(non-const TouchInfo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TouchInfo_get_flags_485_comment =
    "C++ Interface:\n"
    "getFlags(non-const TouchInfo this)\n"
    "\n"
    "";
#else
static const char * Dtool_TouchInfo_get_flags_485_comment = NULL;
#endif

int  Dtool_Init_TouchInfo(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TouchInfo)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TouchInfo(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TouchInfo)
    {
        printf("TouchInfo ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TouchInfo * local_this = (TouchInfo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TouchInfo)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TouchInfo(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TouchInfo)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsWindowProcCallbackData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsWindowProcCallbackData::get_hwnd(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_hwnd_488(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsWindowProcCallbackData::get_hwnd(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHwnd", key_word_list));
        else
            (PyArg_Parse(args, ":getHwnd"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsWindowProcCallbackData*)local_this)->get_hwnd();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHwnd(const GraphicsWindowProcCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_hwnd_488_comment =
    "C++ Interface:\n"
    "getHwnd(const GraphicsWindowProcCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindowProcCallbackData::get_hwnd\n"
    "//       Access: Published\n"
    "//  Description: Returns the Windows proc hwnd parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_hwnd_488_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsWindowProcCallbackData::get_msg(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_msg_489(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsWindowProcCallbackData::get_msg(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMsg", key_word_list));
        else
            (PyArg_Parse(args, ":getMsg"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsWindowProcCallbackData*)local_this)->get_msg();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMsg(const GraphicsWindowProcCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_msg_489_comment =
    "C++ Interface:\n"
    "getMsg(const GraphicsWindowProcCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindowProcCallbackData::get_msg\n"
    "//       Access: Published\n"
    "//  Description: Returns the Windows proc msg parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_msg_489_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsWindowProcCallbackData::get_wparam(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_wparam_490(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsWindowProcCallbackData::get_wparam(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWparam", key_word_list));
        else
            (PyArg_Parse(args, ":getWparam"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsWindowProcCallbackData*)local_this)->get_wparam();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWparam(const GraphicsWindowProcCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_wparam_490_comment =
    "C++ Interface:\n"
    "getWparam(const GraphicsWindowProcCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindowProcCallbackData::get_wparam\n"
    "//       Access: Published\n"
    "//  Description: Returns the Windows proc wparam parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_wparam_490_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsWindowProcCallbackData::get_lparam(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_lparam_491(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsWindowProcCallbackData::get_lparam(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLparam", key_word_list));
        else
            (PyArg_Parse(args, ":getLparam"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsWindowProcCallbackData*)local_this)->get_lparam();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLparam(const GraphicsWindowProcCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_lparam_491_comment =
    "C++ Interface:\n"
    "getLparam(const GraphicsWindowProcCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindowProcCallbackData::get_lparam\n"
    "//       Access: Published\n"
    "//  Description: Returns the Windows proc lparam parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_lparam_491_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsWindowProcCallbackData::is_touch_event(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_is_touch_event_492(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool GraphicsWindowProcCallbackData::is_touch_event(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isTouchEvent", key_word_list));
        else
            (PyArg_Parse(args, ":isTouchEvent"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_touch_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindowProcCallbackData.isTouchEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTouchEvent(non-const GraphicsWindowProcCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_is_touch_event_492_comment =
    "C++ Interface:\n"
    "isTouchEvent(non-const GraphicsWindowProcCallbackData this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_is_touch_event_492_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int GraphicsWindowProcCallbackData::get_num_touches(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_num_touches_493(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int GraphicsWindowProcCallbackData::get_num_touches(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTouches", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTouches"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_touches();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindowProcCallbackData.getNumTouches() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTouches(non-const GraphicsWindowProcCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_num_touches_493_comment =
    "C++ Interface:\n"
    "getNumTouches(non-const GraphicsWindowProcCallbackData this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_num_touches_493_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TouchInfo GraphicsWindowProcCallbackData::get_touch_info(int index)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_touch_info_494(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindowProcCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindowProcCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TouchInfo GraphicsWindowProcCallbackData::get_touch_info(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTouchInfo", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTouchInfo", &param1));
        if(!PyErr_Occurred())
        {
            TouchInfo result = (local_this)->get_touch_info((int)param1);
            TouchInfo *return_value = new TouchInfo(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TouchInfo,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindowProcCallbackData.getTouchInfo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTouchInfo(non-const GraphicsWindowProcCallbackData this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_touch_info_494_comment =
    "C++ Interface:\n"
    "getTouchInfo(non-const GraphicsWindowProcCallbackData this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_touch_info_494_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsWindowProcCallbackData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_class_type_495(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsWindowProcCallbackData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsWindowProcCallbackData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindowProcCallbackData_get_class_type_495_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsWindowProcCallbackData_get_class_type_495_comment = NULL;
#endif

int  Dtool_Init_GraphicsWindowProcCallbackData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsWindowProcCallbackData)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GraphicsWindowProcCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsWindowProcCallbackData)
    {
        printf("GraphicsWindowProcCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsWindowProcCallbackData * local_this = (GraphicsWindowProcCallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsWindowProcCallbackData)
        return local_this;
    if(requested_type == &Dtool_CallbackData)
        return ( CallbackData *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( CallbackData *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsWindowProcCallbackData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsWindowProcCallbackData)
        return from_this;
    if(from_type == &Dtool_CallbackData)
    {
          CallbackData* other_this = (CallbackData*)from_this;
          return (GraphicsWindowProcCallbackData*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsWindowProcCallbackData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsWindow 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * WindowProperties const GraphicsWindow::get_properties(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_properties_498(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-WindowProperties const GraphicsWindow::get_properties(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProperties", key_word_list));
        else
            (PyArg_Parse(args, ":getProperties"));
        if(!PyErr_Occurred())
        {
            WindowProperties const result = ((const GraphicsWindow*)local_this)->get_properties();
            WindowProperties const *return_value = new WindowProperties const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProperties(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_properties_498_comment =
    "C++ Interface:\n"
    "getProperties(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the current properties of the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_properties_498_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * WindowProperties const GraphicsWindow::get_requested_properties(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_requested_properties_499(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-WindowProperties const GraphicsWindow::get_requested_properties(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRequestedProperties", key_word_list));
        else
            (PyArg_Parse(args, ":getRequestedProperties"));
        if(!PyErr_Occurred())
        {
            WindowProperties const result = ((const GraphicsWindow*)local_this)->get_requested_properties();
            WindowProperties const *return_value = new WindowProperties const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRequestedProperties(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_requested_properties_499_comment =
    "C++ Interface:\n"
    "getRequestedProperties(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_requested_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the properties of the window that are\n"
    "//               currently requested.  These properties will be\n"
    "//               applied to the window (if valid) at the next\n"
    "//               execution of process_events().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_requested_properties_499_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::clear_rejected_properties(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_clear_rejected_properties_500(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::clear_rejected_properties(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearRejectedProperties", key_word_list));
        else
            (PyArg_Parse(args, ":clearRejectedProperties"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_rejected_properties();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.clearRejectedProperties() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRejectedProperties(non-const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_clear_rejected_properties_500_comment =
    "C++ Interface:\n"
    "clearRejectedProperties(non-const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::clear_rejected_properties\n"
    "//       Access: Published\n"
    "//  Description: Empties the set of failed properties that will be\n"
    "//               returned by get_rejected_properties().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_clear_rejected_properties_500_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * WindowProperties GraphicsWindow::get_rejected_properties(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_rejected_properties_501(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-WindowProperties GraphicsWindow::get_rejected_properties(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRejectedProperties", key_word_list));
        else
            (PyArg_Parse(args, ":getRejectedProperties"));
        if(!PyErr_Occurred())
        {
            WindowProperties result = ((const GraphicsWindow*)local_this)->get_rejected_properties();
            WindowProperties *return_value = new WindowProperties(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_WindowProperties,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRejectedProperties(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_rejected_properties_501_comment =
    "C++ Interface:\n"
    "getRejectedProperties(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_rejected_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of properties that have recently been\n"
    "//               requested, but could not be applied to the window for\n"
    "//               some reason.  This set of properties will remain\n"
    "//               unchanged until they are changed by a new failed\n"
    "//               request, or clear_rejected_properties() is called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_rejected_properties_501_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::request_properties(WindowProperties const &requested_properties)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_request_properties_502(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void GraphicsWindow::request_properties(WindowProperties const &requested_properties)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"requested_properties", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:requestProperties", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:requestProperties", &param1));
            if(!PyErr_Occurred())
            {
                WindowProperties *param1_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_WindowProperties, 1, "GraphicsWindow.requestProperties", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->request_properties(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsWindow.requestProperties() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "requestProperties(non-const GraphicsWindow this, const WindowProperties requested_properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_request_properties_502_comment =
    "C++ Interface:\n"
    "requestProperties(non-const GraphicsWindow this, const WindowProperties requested_properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::request_properties\n"
    "//       Access: Published\n"
    "//  Description: Requests a property change on the window.  For\n"
    "//               example, use this method to request a window change\n"
    "//               size or minimize or something.\n"
    "//\n"
    "//               The change is not made immediately; rather, the\n"
    "//               request is saved and will be applied the next time\n"
    "//               the window task is run (probably at the next frame).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_request_properties_502_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsWindow::is_closed(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_is_closed_503(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsWindow::is_closed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsWindow*)local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_is_closed_503_comment =
    "C++ Interface:\n"
    "isClosed(const GraphicsWindow this)\n"
    "\n"
    "// Filename: graphicsWindow.I\n"
    "// Created by:  frang (07Mar99)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::is_closed\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window has not yet been opened,\n"
    "//               or has been fully closed, false if it is open.  The\n"
    "//               window is not opened immediately after\n"
    "//               GraphicsEngine::make_window() is called; nor is it\n"
    "//               closed immediately after\n"
    "//               GraphicsEngine::remove_window() is called.  Either\n"
    "//               operation may take a frame or two.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_is_closed_503_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsWindow::is_fullscreen(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_is_fullscreen_504(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsWindow::is_fullscreen(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isFullscreen", key_word_list));
        else
            (PyArg_Parse(args, ":isFullscreen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsWindow*)local_this)->is_fullscreen();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFullscreen(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_is_fullscreen_504_comment =
    "C++ Interface:\n"
    "isFullscreen(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::is_fullscreen\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the window has been opened as a\n"
    "//               fullscreen window, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_is_fullscreen_504_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::set_window_event(basic_string< char > const &window_event)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_set_window_event_505(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::set_window_event(basic_string< char > const &window_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"window_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setWindowEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setWindowEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_window_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.setWindowEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWindowEvent(non-const GraphicsWindow this, string window_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_set_window_event_505_comment =
    "C++ Interface:\n"
    "setWindowEvent(non-const GraphicsWindow this, string window_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::set_window_event\n"
    "//       Access: Published\n"
    "//  Description: Changes the name of the event that is generated when\n"
    "//               this window is modified externally, e.g. to be\n"
    "//               resized or closed by the user.\n"
    "//\n"
    "//               By default, all windows have the same window event\n"
    "//               unless they are explicitly changed.  When the event\n"
    "//               is generated, it includes one parameter: the window\n"
    "//               itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_set_window_event_505_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > GraphicsWindow::get_window_event(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_window_event_506(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > GraphicsWindow::get_window_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindowEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getWindowEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const GraphicsWindow*)local_this)->get_window_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindowEvent(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_window_event_506_comment =
    "C++ Interface:\n"
    "getWindowEvent(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_window_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the event that is generated when\n"
    "//               this window is modified externally, e.g. to be\n"
    "//               resized or closed by the user.  See set_window_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_window_event_506_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::set_close_request_event(basic_string< char > const &close_request_event)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_set_close_request_event_507(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::set_close_request_event(basic_string< char > const &close_request_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"close_request_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCloseRequestEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCloseRequestEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_close_request_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.setCloseRequestEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCloseRequestEvent(non-const GraphicsWindow this, string close_request_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_set_close_request_event_507_comment =
    "C++ Interface:\n"
    "setCloseRequestEvent(non-const GraphicsWindow this, string close_request_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::set_close_request_event\n"
    "//       Access: Published\n"
    "//  Description: Sets the event that is triggered when the user\n"
    "//               requests to close the window, e.g. via alt-F4, or\n"
    "//               clicking on the close box.\n"
    "//\n"
    "//               The default for each window is for this event to be\n"
    "//               the empty string, which means the window-close\n"
    "//               request is handled immediately by Panda (and the\n"
    "//               window will be closed without the app getting a\n"
    "//               chance to intervene).  If you set this to a nonempty\n"
    "//               string, then the window is not closed, but instead\n"
    "//               the event is thrown.  It is then up to the app to\n"
    "//               respond appropriately, for instance by presenting an\n"
    "//               \"are you sure?\" dialog box, and eventually calling\n"
    "//               close_window() when the user is sure.\n"
    "//\n"
    "//               It is considered poor form to set this string and\n"
    "//               then not handle the event.  This can frustrate the\n"
    "//               user by making it difficult for him to cleanly shut\n"
    "//               down the application (and may force the user to\n"
    "//               hard-kill the app, or reboot the machine).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_set_close_request_event_507_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > GraphicsWindow::get_close_request_event(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_close_request_event_508(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > GraphicsWindow::get_close_request_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCloseRequestEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getCloseRequestEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const GraphicsWindow*)local_this)->get_close_request_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCloseRequestEvent(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_close_request_event_508_comment =
    "C++ Interface:\n"
    "getCloseRequestEvent(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_close_request_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the event set via\n"
    "//               set_close_request_event().  If this string is\n"
    "//               nonempty, then when the user requests to close\n"
    "//               window, this event will be generated instead.  See\n"
    "//               set_close_request_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_close_request_event_508_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline WindowHandle *GraphicsWindow::get_window_handle(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_window_handle_509(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline WindowHandle *GraphicsWindow::get_window_handle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindowHandle", key_word_list));
        else
            (PyArg_Parse(args, ":getWindowHandle"));
        if(!PyErr_Occurred())
        {
            WindowHandle *return_value = ((const GraphicsWindow*)local_this)->get_window_handle();
            if (return_value != (WindowHandle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_WindowHandle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindowHandle(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_window_handle_509_comment =
    "C++ Interface:\n"
    "getWindowHandle(const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_window_handle\n"
    "//       Access: Published\n"
    "//  Description: Returns the WindowHandle corresponding to this window\n"
    "//               on the desktop.  This is mainly useful for\n"
    "//               communicating with external libraries.  Use\n"
    "//               window_handle->get_os_handle()->get_handle(), or\n"
    "//               window_handle->get_string_handle(), to get the actual\n"
    "//               OS-specific window handle object, whatever type that\n"
    "//               might be.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_window_handle_509_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int GraphicsWindow::get_num_input_devices(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_num_input_devices_510(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int GraphicsWindow::get_num_input_devices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumInputDevices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumInputDevices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsWindow*)local_this)->get_num_input_devices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumInputDevices(const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_num_input_devices_510_comment =
    "C++ Interface:\n"
    "getNumInputDevices(const GraphicsWindow this)\n"
    "\n"
    "// Mouse and keyboard routines\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_num_input_devices\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of separate input devices\n"
    "//               associated with the window.  Typically, a window will\n"
    "//               have exactly one input device: the keyboard/mouse\n"
    "//               pair.  However, some windows may have no input\n"
    "//               devices, and others may add additional devices, for\n"
    "//               instance for a joystick.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_num_input_devices_510_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > GraphicsWindow::get_input_device_name(int device) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_input_device_name_511(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > GraphicsWindow::get_input_device_name(int device) const
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getInputDeviceName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getInputDeviceName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const GraphicsWindow*)local_this)->get_input_device_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInputDeviceName(const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_input_device_name_511_comment =
    "C++ Interface:\n"
    "getInputDeviceName(const GraphicsWindow this, int device)\n"
    "\n"
    "// Mouse and keyboard routines\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_input_device_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the nth input device.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_input_device_name_511_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsWindow::has_pointer(int device) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_has_pointer_512(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool GraphicsWindow::has_pointer(int device) const
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasPointer", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasPointer", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsWindow*)local_this)->has_pointer((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasPointer(const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_has_pointer_512_comment =
    "C++ Interface:\n"
    "hasPointer(const GraphicsWindow this, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::has_pointer\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the nth input device has a\n"
    "//               screen-space pointer (for instance, a mouse), false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_has_pointer_512_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsWindow::has_keyboard(int device) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_has_keyboard_513(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool GraphicsWindow::has_keyboard(int device) const
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasKeyboard", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasKeyboard", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsWindow*)local_this)->has_keyboard((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasKeyboard(const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_has_keyboard_513_comment =
    "C++ Interface:\n"
    "hasKeyboard(const GraphicsWindow this, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::has_keyboard\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the nth input device has a keyboard,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_has_keyboard_513_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::enable_pointer_events(int device)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_enable_pointer_events_514(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::enable_pointer_events(int device)
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:enablePointerEvents", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:enablePointerEvents", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->enable_pointer_events((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.enablePointerEvents() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enablePointerEvents(non-const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_enable_pointer_events_514_comment =
    "C++ Interface:\n"
    "enablePointerEvents(non-const GraphicsWindow this, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::enable_pointer_events\n"
    "//       Access: Published\n"
    "//  Description: Turn on the generation of pointer events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_enable_pointer_events_514_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::disable_pointer_events(int device)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_disable_pointer_events_515(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::disable_pointer_events(int device)
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:disablePointerEvents", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:disablePointerEvents", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->disable_pointer_events((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.disablePointerEvents() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disablePointerEvents(non-const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_disable_pointer_events_515_comment =
    "C++ Interface:\n"
    "disablePointerEvents(non-const GraphicsWindow this, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::disable_pointer_events\n"
    "//       Access: Published\n"
    "//  Description: Turn off the generation of pointer events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_disable_pointer_events_515_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::enable_pointer_mode(int device, double speed)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_enable_pointer_mode_516(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::enable_pointer_mode(int device, double speed)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"device", (char *)"speed", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:enablePointerMode", key_word_list, &param1, &param2))
        {
            (local_this)->enable_pointer_mode((int)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.enablePointerMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enablePointerMode(non-const GraphicsWindow this, int device, float speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_enable_pointer_mode_516_comment =
    "C++ Interface:\n"
    "enablePointerMode(non-const GraphicsWindow this, int device, float speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::enable_pointer_mode\n"
    "//       Access: Published\n"
    "//  Description: See GraphicsWindowInputDevice::enable_pointer_mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_enable_pointer_mode_516_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::disable_pointer_mode(int device)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_disable_pointer_mode_517(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::disable_pointer_mode(int device)
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:disablePointerMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:disablePointerMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->disable_pointer_mode((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.disablePointerMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disablePointerMode(non-const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_disable_pointer_mode_517_comment =
    "C++ Interface:\n"
    "disablePointerMode(non-const GraphicsWindow this, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::disable_pointer_events\n"
    "//       Access: Published\n"
    "//  Description: See GraphicsWindowInputDevice::disable_pointer_mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_disable_pointer_mode_517_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseData GraphicsWindow::get_pointer(int device) const
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_pointer_518(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-MouseData GraphicsWindow::get_pointer(int device) const
        int param1;
        static char * key_word_list[] = {(char *)"device", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPointer", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPointer", &param1));
        if(!PyErr_Occurred())
        {
            MouseData result = ((const GraphicsWindow*)local_this)->get_pointer((int)param1);
            MouseData *return_value = new MouseData(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MouseData,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointer(const GraphicsWindow this, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_pointer_518_comment =
    "C++ Interface:\n"
    "getPointer(const GraphicsWindow this, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::get_pointer\n"
    "//       Access: Published\n"
    "//  Description: Returns the MouseData associated with the nth input\n"
    "//               device's pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_pointer_518_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsWindow::move_pointer(int device, int x, int y)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_move_pointer_519(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool GraphicsWindow::move_pointer(int device, int x, int y)
        int param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"device", (char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:movePointer", key_word_list, &param1, &param2, &param3))
        {
            bool return_value = (local_this)->move_pointer((int)param1, (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.movePointer() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "movePointer(non-const GraphicsWindow this, int device, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_move_pointer_519_comment =
    "C++ Interface:\n"
    "movePointer(non-const GraphicsWindow this, int device, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::move_pointer\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Forces the pointer to the indicated position within\n"
    "//               the window, if possible.  \n"
    "//\n"
    "//               Returns true if successful, false on failure.  This\n"
    "//               may fail if the mouse is not currently within the\n"
    "//               window, or if the API doesn't support this operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_move_pointer_519_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsWindow::close_ime(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_close_ime_520(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsWindow::close_ime(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":closeIme", key_word_list));
        else
            (PyArg_Parse(args, ":closeIme"));
        if(!PyErr_Occurred())
        {
            (local_this)->close_ime();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.closeIme() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "closeIme(non-const GraphicsWindow this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_close_ime_520_comment =
    "C++ Interface:\n"
    "closeIme(non-const GraphicsWindow this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::close_ime\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Forces the ime window to close if any\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_close_ime_520_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::add_python_event_handler(PyObject *handler, PyObject *name)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_add_python_event_handler_521(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::add_python_event_handler(PyObject *handler, PyObject *name)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"handler", (char *)"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addPythonEventHandler", key_word_list, &param1, &param2))
        {
            (local_this)->add_python_event_handler(param1, param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.addPythonEventHandler() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPythonEventHandler(non-const GraphicsWindow this, any handler, any name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_add_python_event_handler_521_comment =
    "C++ Interface:\n"
    "addPythonEventHandler(non-const GraphicsWindow this, any handler, any name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::add_custom_event_handler\n"
    "//       Access: Published\n"
    "//  Description: Adds a python event handler to be called\n"
    "//               when a window event occurs.\n"
    "//               \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_add_python_event_handler_521_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsWindow::remove_python_event_handler(PyObject *name)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_remove_python_event_handler_522(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsWindow * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsWindow,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsWindow::remove_python_event_handler(PyObject *name)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:removePythonEventHandler", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:removePythonEventHandler", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_python_event_handler(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsWindow.removePythonEventHandler() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removePythonEventHandler(non-const GraphicsWindow this, any name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_remove_python_event_handler_522_comment =
    "C++ Interface:\n"
    "removePythonEventHandler(non-const GraphicsWindow this, any name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsWindow::remove_custom_event_handler\n"
    "//       Access: Published\n"
    "//  Description: Removes the specified python event handler.\n"
    "//               \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsWindow_remove_python_event_handler_522_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsWindow::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsWindow_get_class_type_523(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsWindow::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsWindow::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsWindow_get_class_type_523_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsWindow_get_class_type_523_comment = NULL;
#endif

int  Dtool_Init_GraphicsWindow(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsWindow)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_GraphicsWindow_get_input_device_names(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumInputDevices", "getInputDeviceName");
}
inline void  * Dtool_UpcastInterface_GraphicsWindow(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsWindow)
    {
        printf("GraphicsWindow ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsWindow * local_this = (GraphicsWindow *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsWindow)
        return local_this;
    if(requested_type == &Dtool_DrawableRegion)
        return ( DrawableRegion *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_GraphicsOutput)
        return ( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_GraphicsOutputBase)
        return ( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsWindow(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsWindow)
        return from_this;
    if(from_type == &Dtool_DrawableRegion)
    {
          DrawableRegion* other_this = (DrawableRegion*)from_this;
          return (GraphicsWindow*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutput)
    {
          GraphicsOutput* other_this = (GraphicsOutput*)from_this;
          return (GraphicsWindow*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutputBase)
    {
          GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
          return (GraphicsWindow*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsWindow*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsWindow*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GraphicsWindow*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GraphicsWindow*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NativeWindowHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static PointerTo< WindowHandle > NativeWindowHandle::make_int(unsigned int window)
 *******************************************************************/
static PyObject *Dtool_NativeWindowHandle_make_int_525(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< WindowHandle > NativeWindowHandle::make_int(unsigned int window)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"window", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:makeInt", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:makeInt", &param0));
        if(!PyErr_Occurred())
        {
             PyObject *param0_uint = PyNumber_Long(param0);
            if (!((param0_uint == NULL)))
            {
                PointerTo< WindowHandle > return_value = NativeWindowHandle::make_int(PyLong_AsUnsignedLong(param0_uint));
                 Py_XDECREF(param0_uint);
                if (return_value != (WindowHandle *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_WindowHandle,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeInt(unsigned int window)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NativeWindowHandle_make_int_525_comment =
    "C++ Interface:\n"
    "makeInt(unsigned int window)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NativeWindowHandle::make_int\n"
    "//       Access: Published, Static\n"
    "//  Description: Constructs a new WindowHandle with an int value,\n"
    "//               which is understood to be either an HWND or a Window,\n"
    "//               cast to int.  This method exists for the convenience\n"
    "//               of Python, which likes to deal with ints; C++ code\n"
    "//               should use one of the more specific make_x11() or\n"
    "//               make_win32() methods instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NativeWindowHandle_make_int_525_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< WindowHandle > NativeWindowHandle::make_subprocess(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_NativeWindowHandle_make_subprocess_526(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static PointerTo< WindowHandle > NativeWindowHandle::make_subprocess(Filename const &filename)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:makeSubprocess", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:makeSubprocess", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "NativeWindowHandle.makeSubprocess", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PointerTo< WindowHandle > return_value = NativeWindowHandle::make_subprocess(*param0_this);
                    if (return_value != (WindowHandle *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_WindowHandle,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeSubprocess(const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NativeWindowHandle_make_subprocess_526_comment =
    "C++ Interface:\n"
    "makeSubprocess(const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NativeWindowHandle::make_subprocess\n"
    "//       Access: Published, Static\n"
    "//  Description: Constructs a new WindowHandle that references a\n"
    "//               SubprocessWindowBuffer read in another process, with\n"
    "//               the named pipe filename that it uses for\n"
    "//               communication.\n"
    "//\n"
    "//               This is (at present, and maybe always) useful only on\n"
    "//               the OS X platform, where parenting child windows is\n"
    "//               particularly problematic.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NativeWindowHandle_make_subprocess_526_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NativeWindowHandle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NativeWindowHandle_get_class_type_527(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NativeWindowHandle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NativeWindowHandle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NativeWindowHandle_get_class_type_527_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NativeWindowHandle_get_class_type_527_comment = NULL;
#endif

int  Dtool_Init_NativeWindowHandle(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NativeWindowHandle)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NativeWindowHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NativeWindowHandle)
    {
        printf("NativeWindowHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NativeWindowHandle * local_this = (NativeWindowHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NativeWindowHandle)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( WindowHandle *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( WindowHandle *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( WindowHandle *) local_this;
    if(requested_type == &Dtool_WindowHandle)
        return ( WindowHandle *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NativeWindowHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NativeWindowHandle)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NativeWindowHandle*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NativeWindowHandle*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (NativeWindowHandle*)other_this;
    }
    if(from_type == &Dtool_WindowHandle)
    {
          WindowHandle* other_this = (WindowHandle*)from_this;
          return (NativeWindowHandle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ParasiteBuffer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ParasiteBuffer::set_size(int x, int y)
 *******************************************************************/
static PyObject *Dtool_ParasiteBuffer_set_size_530(PyObject *self, PyObject *args,PyObject *kwds) {
    ParasiteBuffer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParasiteBuffer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParasiteBuffer::set_size(int x, int y)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_size((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParasiteBuffer.setSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSize(non-const ParasiteBuffer this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParasiteBuffer_set_size_530_comment =
    "C++ Interface:\n"
    "setSize(non-const ParasiteBuffer this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParasiteBuffer::set_size\n"
    "//       Access: Public, Virtual\n"
    "//  Description: This is called by the GraphicsEngine to request that\n"
    "//               the buffer resize itself.  Although calls to get the\n"
    "//               size will return the new value, much of the actual\n"
    "//               resizing work doesn't take place until the next\n"
    "//               begin_frame.  Not all buffers are resizeable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParasiteBuffer_set_size_530_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ParasiteBuffer::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ParasiteBuffer_get_class_type_531(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ParasiteBuffer::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ParasiteBuffer::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParasiteBuffer_get_class_type_531_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ParasiteBuffer_get_class_type_531_comment = NULL;
#endif

int  Dtool_Init_ParasiteBuffer(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ParasiteBuffer)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ParasiteBuffer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ParasiteBuffer)
    {
        printf("ParasiteBuffer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ParasiteBuffer * local_this = (ParasiteBuffer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ParasiteBuffer)
        return local_this;
    if(requested_type == &Dtool_DrawableRegion)
        return ( DrawableRegion *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_GraphicsOutput)
        return ( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_GraphicsOutputBase)
        return ( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( GraphicsOutputBase *)( GraphicsOutput *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ParasiteBuffer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ParasiteBuffer)
        return from_this;
    if(from_type == &Dtool_DrawableRegion)
    {
          DrawableRegion* other_this = (DrawableRegion*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutput)
    {
          GraphicsOutput* other_this = (GraphicsOutput*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    if(from_type == &Dtool_GraphicsOutputBase)
    {
          GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (ParasiteBuffer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsEngine 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::set_threading_model(GraphicsThreadingModel const &threading_model)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_set_threading_model_535(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void GraphicsEngine::set_threading_model(GraphicsThreadingModel const &threading_model)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"threading_model", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setThreadingModel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setThreadingModel", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsThreadingModel *param1_this = (GraphicsThreadingModel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsThreadingModel, 1, "GraphicsEngine.setThreadingModel", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_threading_model(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsEngine.setThreadingModel() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThreadingModel(non-const GraphicsEngine this, const GraphicsThreadingModel threading_model)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_set_threading_model_535_comment =
    "C++ Interface:\n"
    "setThreadingModel(non-const GraphicsEngine this, const GraphicsThreadingModel threading_model)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::set_threading_model\n"
    "//       Access: Published\n"
    "//  Description: Specifies how future objects created via make_gsg(),\n"
    "//               make_buffer(), and make_window() will be threaded.\n"
    "//               This does not affect any already-created objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_set_threading_model_535_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsThreadingModel GraphicsEngine::get_threading_model(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_threading_model_536(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-GraphicsThreadingModel GraphicsEngine::get_threading_model(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThreadingModel", key_word_list));
        else
            (PyArg_Parse(args, ":getThreadingModel"));
        if(!PyErr_Occurred())
        {
            GraphicsThreadingModel result = ((const GraphicsEngine*)local_this)->get_threading_model();
            GraphicsThreadingModel *return_value = new GraphicsThreadingModel(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsThreadingModel,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThreadingModel(const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_threading_model_536_comment =
    "C++ Interface:\n"
    "getThreadingModel(const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_threading_model\n"
    "//       Access: Published\n"
    "//  Description: Returns the threading model that will be applied to\n"
    "//               future objects.  See set_threading_model().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_threading_model_536_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsEngine::set_auto_flip(bool auto_flip)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_set_auto_flip_537(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsEngine::set_auto_flip(bool auto_flip)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"auto_flip", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAutoFlip", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAutoFlip", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_flip((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.setAutoFlip() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoFlip(non-const GraphicsEngine this, bool auto_flip)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_set_auto_flip_537_comment =
    "C++ Interface:\n"
    "setAutoFlip(non-const GraphicsEngine this, bool auto_flip)\n"
    "\n"
    "// Filename: graphicsEngine.I\n"
    "// Created by:  drose (24Feb02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::set_auto_flip\n"
    "//       Access: Published\n"
    "//  Description: Set this flag true to indicate the GraphicsEngine\n"
    "//               should automatically cause windows to sync and flip\n"
    "//               as soon as they have finished drawing, rather than\n"
    "//               waiting for all of the windows to finish drawing\n"
    "//               first so they can flip together.\n"
    "//\n"
    "//               This only affects the timing of when the flip occurs.\n"
    "//               If this is true (the default), the flip occurs before\n"
    "//               render_frame() returns.  If this is false, the flip\n"
    "//               occurs whenever flip_frame() is called, or at the\n"
    "//               beginning of the next call to render_frame(), if\n"
    "//               flip_frame() is never called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_set_auto_flip_537_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsEngine::get_auto_flip(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_auto_flip_538(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsEngine::get_auto_flip(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoFlip", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoFlip"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsEngine*)local_this)->get_auto_flip();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoFlip(const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_auto_flip_538_comment =
    "C++ Interface:\n"
    "getAutoFlip(const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_auto_flip\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting for the auto-flip flag.\n"
    "//               See set_auto_flip.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_auto_flip_538_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsEngine::set_portal_cull(bool value)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_set_portal_cull_539(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GraphicsEngine::set_portal_cull(bool value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPortalCull", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPortalCull", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_portal_cull((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.setPortalCull() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPortalCull(non-const GraphicsEngine this, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_set_portal_cull_539_comment =
    "C++ Interface:\n"
    "setPortalCull(non-const GraphicsEngine this, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::set_portal_cull\n"
    "//       Access: Published\n"
    "//  Description: Set this flag true to indicate the GraphicsEngine\n"
    "//               should start portal culling\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_set_portal_cull_539_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GraphicsEngine::get_portal_cull(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_portal_cull_540(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GraphicsEngine::get_portal_cull(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPortalCull", key_word_list));
        else
            (PyArg_Parse(args, ":getPortalCull"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsEngine*)local_this)->get_portal_cull();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPortalCull(const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_portal_cull_540_comment =
    "C++ Interface:\n"
    "getPortalCull(const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_portal_cull\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting for the portal culling flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_portal_cull_540_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GraphicsEngine::set_default_loader(Loader *loader)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_set_default_loader_541(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void GraphicsEngine::set_default_loader(Loader *loader)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"loader", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDefaultLoader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDefaultLoader", &param1));
            if(!PyErr_Occurred())
            {
                Loader *param1_this = (Loader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Loader, 1, "GraphicsEngine.setDefaultLoader", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_default_loader(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsEngine.setDefaultLoader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefaultLoader(non-const GraphicsEngine this, non-const PandaLoader loader)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_set_default_loader_541_comment =
    "C++ Interface:\n"
    "setDefaultLoader(non-const GraphicsEngine this, non-const PandaLoader loader)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::set_default_loader\n"
    "//       Access: Public\n"
    "//  Description: Sets the Loader object that will be assigned to every\n"
    "//               GSG created with this GraphicsEngine.  See\n"
    "//               GraphicsStateGuardian::set_loader().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_set_default_loader_541_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Loader *GraphicsEngine::get_default_loader(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_default_loader_542(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Loader *GraphicsEngine::get_default_loader(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultLoader", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultLoader"));
        if(!PyErr_Occurred())
        {
            Loader *return_value = ((const GraphicsEngine*)local_this)->get_default_loader();
            if (return_value != (Loader *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Loader,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultLoader(const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_default_loader_542_comment =
    "C++ Interface:\n"
    "getDefaultLoader(const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_default_loader\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Returns the Loader object that will be assigned to\n"
    "//               every GSG created with this GraphicsEngine.  See\n"
    "//               GraphicsStateGuardian::set_loader().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_default_loader_542_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, basic_string< char > const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg, GraphicsOutput *host)
 * GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, basic_string< char > const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg, GraphicsOutput *host = ((void *)(0)))
 * GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, basic_string< char > const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg = ((void *)(0)), GraphicsOutput *host = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_make_output_543(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, basic_string< char > const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg = ((void *)(0)), GraphicsOutput *host = ((void *)(0)))
                PyObject *param1;
                char *param2_str; int param2_len;
                int param3;
                PyObject *param4;
                PyObject *param5;
                int param6;
                static char * key_word_list[] = {(char *)"pipe", (char *)"name", (char *)"sort", (char *)"fb_prop", (char *)"win_prop", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iOOi:makeOutput", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6))
                {
                    GraphicsPipe *param1_this = (GraphicsPipe *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsPipe, 1, "GraphicsEngine.makeOutput", 0, coerced_ptr, report_errors);
FrameBufferProperties *param4_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_FrameBufferProperties, 4, "GraphicsEngine.makeOutput", 1, coerced_ptr, report_errors);
WindowProperties *param5_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_WindowProperties, 5, "GraphicsEngine.makeOutput", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_output(param1_this, basic_string<char>(param2_str, param2_len), (int)param3, *param4_this, *param5_this, (int)param6);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsEngine.makeOutput() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, basic_string< char > const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg, GraphicsOutput *host = ((void *)(0)))
                PyObject *param1;
                char *param2_str; int param2_len;
                int param3;
                PyObject *param4;
                PyObject *param5;
                int param6;
                PyObject *param7;
                static char * key_word_list[] = {(char *)"pipe", (char *)"name", (char *)"sort", (char *)"fb_prop", (char *)"win_prop", (char *)"flags", (char *)"gsg", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iOOiO:makeOutput", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7))
                {
                    GraphicsPipe *param1_this = (GraphicsPipe *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsPipe, 1, "GraphicsEngine.makeOutput", 0, coerced_ptr, report_errors);
FrameBufferProperties *param4_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_FrameBufferProperties, 4, "GraphicsEngine.makeOutput", 1, coerced_ptr, report_errors);
WindowProperties *param5_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_WindowProperties, 5, "GraphicsEngine.makeOutput", 1, coerced_ptr, report_errors);
GraphicsStateGuardian *param7_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_GraphicsStateGuardian, 7, "GraphicsEngine.makeOutput", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param7_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_output(param1_this, basic_string<char>(param2_str, param2_len), (int)param3, *param4_this, *param5_this, (int)param6, param7_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsEngine.makeOutput() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, basic_string< char > const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg, GraphicsOutput *host)
                PyObject *param1;
                char *param2_str; int param2_len;
                int param3;
                PyObject *param4;
                PyObject *param5;
                int param6;
                PyObject *param7;
                PyObject *param8;
                static char * key_word_list[] = {(char *)"pipe", (char *)"name", (char *)"sort", (char *)"fb_prop", (char *)"win_prop", (char *)"flags", (char *)"gsg", (char *)"host", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iOOiOO:makeOutput", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7, &param8))
                {
                    GraphicsPipe *param1_this = (GraphicsPipe *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsPipe, 1, "GraphicsEngine.makeOutput", 0, coerced_ptr, report_errors);
FrameBufferProperties *param4_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_FrameBufferProperties, 4, "GraphicsEngine.makeOutput", 1, coerced_ptr, report_errors);
WindowProperties *param5_this = (WindowProperties *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_WindowProperties, 5, "GraphicsEngine.makeOutput", 1, coerced_ptr, report_errors);
GraphicsStateGuardian *param7_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_GraphicsStateGuardian, 7, "GraphicsEngine.makeOutput", 0, coerced_ptr, report_errors);
GraphicsOutput *param8_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param8, &Dtool_GraphicsOutput, 8, "GraphicsEngine.makeOutput", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param7_this == NULL)|| (param8_this == NULL)))
                    {
                        GraphicsOutput *return_value = (local_this)->make_output(param1_this, basic_string<char>(param2_str, param2_len), (int)param3, *param4_this, *param5_this, (int)param6, param7_this, param8_this);
                        if (return_value != (GraphicsOutput *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call GraphicsEngine.makeOutput() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeOutput() takes 7, 8, or 9 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeOutput(non-const GraphicsEngine this, non-const GraphicsPipe pipe, string name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags)\n"
          "makeOutput(non-const GraphicsEngine this, non-const GraphicsPipe pipe, string name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags, non-const GraphicsStateGuardian gsg)\n"
          "makeOutput(non-const GraphicsEngine this, non-const GraphicsPipe pipe, string name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags, non-const GraphicsStateGuardian gsg, non-const GraphicsOutput host)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_make_output_543_comment =
    "C++ Interface:\n"
    "makeOutput(non-const GraphicsEngine this, non-const GraphicsPipe pipe, string name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags)\n"
    "makeOutput(non-const GraphicsEngine this, non-const GraphicsPipe pipe, string name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags, non-const GraphicsStateGuardian gsg)\n"
    "makeOutput(non-const GraphicsEngine this, non-const GraphicsPipe pipe, string name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags, non-const GraphicsStateGuardian gsg, non-const GraphicsOutput host)\n"
    "\n"
    "// THIS IS THE OLD CODE FOR make_gsg\n"
    "//  PT(GraphicsStateGuardian) gsg = pipe->make_gsg(properties, share_with);\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::make_output\n"
    "//       Access: Published\n"
    "//  Description: Creates a new window (or buffer) and returns it.\n"
    "//               The GraphicsEngine becomes the owner of the window,\n"
    "//               it will persist at least until remove_window() is\n"
    "//               called later.\n"
    "//\n"
    "//               If a null pointer is supplied for the gsg, then this\n"
    "//               routine will create a new gsg.\n"
    "//               \n"
    "//               This routine is only called from the app thread.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_make_output_543_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsOutput *host, basic_string< char > const &name, int sort, int x_size, int y_size)
 * inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsStateGuardian *gsg, basic_string< char > const &name, int sort, int x_size, int y_size)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_make_buffer_544(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsOutput *host, basic_string< char > const &name, int sort, int x_size, int y_size)
            PyObject *param1;
            char *param2_str; int param2_len;
            int param3;
            int param4;
            int param5;
            static char * key_word_list[] = {(char *)"host", (char *)"name", (char *)"sort", (char *)"x_size", (char *)"y_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iii:makeBuffer", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5))
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "GraphicsEngine.makeBuffer", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    GraphicsOutput *return_value = (local_this)->make_buffer(param1_this, basic_string<char>(param2_str, param2_len), (int)param3, (int)param4, (int)param5);
                    if (return_value != (GraphicsOutput *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsStateGuardian *gsg, basic_string< char > const &name, int sort, int x_size, int y_size)
            PyObject *param1;
            char *param2_str; int param2_len;
            int param3;
            int param4;
            int param5;
            static char * key_word_list[] = {(char *)"gsg", (char *)"name", (char *)"sort", (char *)"x_size", (char *)"y_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iii:makeBuffer", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5))
            {
                GraphicsStateGuardian *param1_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsStateGuardian, 1, "GraphicsEngine.makeBuffer", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    GraphicsOutput *return_value = (local_this)->make_buffer(param1_this, basic_string<char>(param2_str, param2_len), (int)param3, (int)param4, (int)param5);
                    if (return_value != (GraphicsOutput *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeBuffer(non-const GraphicsEngine this, non-const GraphicsOutput host, string name, int sort, int x_size, int y_size)\n"
          "makeBuffer(non-const GraphicsEngine this, non-const GraphicsStateGuardian gsg, string name, int sort, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_make_buffer_544_comment =
    "C++ Interface:\n"
    "makeBuffer(non-const GraphicsEngine this, non-const GraphicsOutput host, string name, int sort, int x_size, int y_size)\n"
    "makeBuffer(non-const GraphicsEngine this, non-const GraphicsStateGuardian gsg, string name, int sort, int x_size, int y_size)\n"
    "\n"
    "// Syntactic shorthand versions of make_output\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::make_buffer\n"
    "//       Access: Published\n"
    "//  Description: Syntactic shorthand for make_output.  This is the\n"
    "//               preferred way to create an offscreen buffer, when you\n"
    "//               already have an onscreen window or another buffer to\n"
    "//               start with.  For the first parameter, pass an\n"
    "//               existing GraphicsOutput object, e.g. the main window;\n"
    "//               this allows the buffer to adapt itself to that\n"
    "//               window's framebuffer properties, and allows maximum\n"
    "//               sharing of resources.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::make_buffer\n"
    "//       Access: Published\n"
    "//  Description: Syntactic shorthand for make_output.  This flavor\n"
    "//               accepts a GSG rather than a GraphicsOutput as the\n"
    "//               first parameter, which is too limiting and disallows\n"
    "//               the possibility of creating a ParasiteBuffer if the\n"
    "//               user's graphics hardware prefers that.  It also\n"
    "//               attempts to request specific framebuffer properties\n"
    "//               and may therefore do a poorer job of sharing the GSG\n"
    "//               between the old buffer and the new.\n"
    "//\n"
    "//               For these reasons, this variant is a poor choice\n"
    "//               unless you are creating an offscreen buffer for the\n"
    "//               first time, without an onscreen window already in\n"
    "//               existence.  If you already have an onscreen window,\n"
    "//               you should use the other flavor of make_buffer()\n"
    "//               instead, which accepts a GraphicsOutput as the first\n"
    "//               parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_make_buffer_544_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput *GraphicsEngine::make_parasite(GraphicsOutput *host, basic_string< char > const &name, int sort, int x_size, int y_size)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_make_parasite_545(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline GraphicsOutput *GraphicsEngine::make_parasite(GraphicsOutput *host, basic_string< char > const &name, int sort, int x_size, int y_size)
            PyObject *param1;
            char *param2_str; int param2_len;
            int param3;
            int param4;
            int param5;
            static char * key_word_list[] = {(char *)"host", (char *)"name", (char *)"sort", (char *)"x_size", (char *)"y_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iii:makeParasite", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5))
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "GraphicsEngine.makeParasite", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    GraphicsOutput *return_value = (local_this)->make_parasite(param1_this, basic_string<char>(param2_str, param2_len), (int)param3, (int)param4, (int)param5);
                    if (return_value != (GraphicsOutput *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsEngine.makeParasite() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeParasite(non-const GraphicsEngine this, non-const GraphicsOutput host, string name, int sort, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_make_parasite_545_comment =
    "C++ Interface:\n"
    "makeParasite(non-const GraphicsEngine this, non-const GraphicsOutput host, string name, int sort, int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::make_parasite\n"
    "//       Access: Published\n"
    "//  Description: Syntactic shorthand for make_buffer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_make_parasite_545_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsEngine::remove_window(GraphicsOutput *window)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_remove_window_546(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool GraphicsEngine::remove_window(GraphicsOutput *window)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"window", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeWindow", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeWindow", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "GraphicsEngine.removeWindow", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_window(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsEngine.removeWindow() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeWindow(non-const GraphicsEngine this, non-const GraphicsOutput window)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_remove_window_546_comment =
    "C++ Interface:\n"
    "removeWindow(non-const GraphicsEngine this, non-const GraphicsOutput window)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::remove_window\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated window or offscreen buffer from\n"
    "//               the set of windows that will be processed when\n"
    "//               render_frame() is called.  This also closes the\n"
    "//               window if it is open, and removes the window from its\n"
    "//               GraphicsPipe, allowing the window to be destructed if\n"
    "//               there are no other references to it.  (However, the\n"
    "//               window may not be actually closed until next frame,\n"
    "//               if it is controlled by a sub-thread.)\n"
    "//\n"
    "//               The return value is true if the window was removed,\n"
    "//               false if it was not found.\n"
    "//\n"
    "//               Unlike remove_all_windows(), this function does not\n"
    "//               terminate any of the threads that may have been\n"
    "//               started to service this window; they are left running\n"
    "//               (since you might open a new window later on these\n"
    "//               threads).  If your intention is to clean up before\n"
    "//               shutting down, it is better to call\n"
    "//               remove_all_windows() then to call remove_window() one\n"
    "//               at a time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_remove_window_546_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::remove_all_windows(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_remove_all_windows_547(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::remove_all_windows(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAllWindows", key_word_list));
        else
            (PyArg_Parse(args, ":removeAllWindows"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_all_windows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.removeAllWindows() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAllWindows(non-const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_remove_all_windows_547_comment =
    "C++ Interface:\n"
    "removeAllWindows(non-const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::remove_all_windows\n"
    "//       Access: Published\n"
    "//  Description: Removes and closes all windows from the engine.  This\n"
    "//               also cleans up and terminates any threads that have\n"
    "//               been started to service those windows.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_remove_all_windows_547_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::reset_all_windows(bool swapchain)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_reset_all_windows_548(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::reset_all_windows(bool swapchain)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"swapchain", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:resetAllWindows", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:resetAllWindows", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_all_windows((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.resetAllWindows() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetAllWindows(non-const GraphicsEngine this, bool swapchain)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_reset_all_windows_548_comment =
    "C++ Interface:\n"
    "resetAllWindows(non-const GraphicsEngine this, bool swapchain)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::reset_all_windows\n"
    "//       Access: Published\n"
    "//  Description: Resets the framebuffer of the current window.  This\n"
    "//               is currently used by DirectX 8 only. It calls a\n"
    "//               reset_window function on each active window to \n"
    "//               release/create old/new framebuffer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_reset_all_windows_548_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsEngine::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_is_empty_549(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool GraphicsEngine::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsEngine*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_is_empty_549_comment =
    "C++ Interface:\n"
    "isEmpty(const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there are no windows or buffers\n"
    "//               managed by the engine, false if there is at least\n"
    "//               one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_is_empty_549_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int GraphicsEngine::get_num_windows(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_num_windows_550(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int GraphicsEngine::get_num_windows(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumWindows", key_word_list));
        else
            (PyArg_Parse(args, ":getNumWindows"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsEngine*)local_this)->get_num_windows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumWindows(const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_num_windows_550_comment =
    "C++ Interface:\n"
    "getNumWindows(const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_num_windows\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of windows (or buffers) managed by\n"
    "//               the engine.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_num_windows_550_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutput *GraphicsEngine::get_window(int n) const
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_window_551(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-GraphicsOutput *GraphicsEngine::get_window(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWindow", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWindow", &param1));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = ((const GraphicsEngine*)local_this)->get_window((int)param1);
            if (return_value != (GraphicsOutput *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindow(const GraphicsEngine this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_window_551_comment =
    "C++ Interface:\n"
    "getWindow(const GraphicsEngine this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_window\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth window or buffers managed by the\n"
    "//               engine, in sorted order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_window_551_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::render_frame(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_render_frame_552(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::render_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":renderFrame", key_word_list));
        else
            (PyArg_Parse(args, ":renderFrame"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->render_frame();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.renderFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "renderFrame(non-const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_render_frame_552_comment =
    "C++ Interface:\n"
    "renderFrame(non-const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::render_frame\n"
    "//       Access: Published\n"
    "//  Description: Renders the next frame in all the registered windows,\n"
    "//               and flips all of the frame buffers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_render_frame_552_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::open_windows(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_open_windows_553(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::open_windows(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":openWindows", key_word_list));
        else
            (PyArg_Parse(args, ":openWindows"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->open_windows();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.openWindows() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openWindows(non-const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_open_windows_553_comment =
    "C++ Interface:\n"
    "openWindows(non-const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::open_windows\n"
    "//       Access: Published\n"
    "//  Description: Fully opens (or closes) any windows that have\n"
    "//               recently been requested open or closed, without\n"
    "//               rendering any frames.  It is not necessary to call\n"
    "//               this explicitly, since windows will be automatically\n"
    "//               opened or closed when the next frame is rendered, but\n"
    "//               you may call this if you want your windows now\n"
    "//               without seeing a frame go by.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_open_windows_553_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::sync_frame(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_sync_frame_554(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::sync_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":syncFrame", key_word_list));
        else
            (PyArg_Parse(args, ":syncFrame"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->sync_frame();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.syncFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "syncFrame(non-const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_sync_frame_554_comment =
    "C++ Interface:\n"
    "syncFrame(non-const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::sync_frame\n"
    "//       Access: Published\n"
    "//  Description: Waits for all the threads that started drawing their\n"
    "//               last frame to finish drawing.  The windows are not\n"
    "//               yet flipped when this returns; see also flip_frame().\n"
    "//               It is not usually necessary to call this explicitly,\n"
    "//               unless you need to see the previous frame right away.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_sync_frame_554_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::ready_flip(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_ready_flip_555(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::ready_flip(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":readyFlip", key_word_list));
        else
            (PyArg_Parse(args, ":readyFlip"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->ready_flip();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.readyFlip() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readyFlip(non-const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_ready_flip_555_comment =
    "C++ Interface:\n"
    "readyFlip(non-const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::ready_flip\n"
    "//       Access: Published\n"
    "//  Description: Waits for all the threads that started drawing their\n"
    "//               last frame to finish drawing. Returns when all threads have\n"
    "//               actually finished drawing, as opposed to 'sync_frame'\n"
    "//               we seems to return once all draw calls have been submitted.\n"
    "//               Calling 'flip_frame' after this function should immediately\n"
    "//               cause a buffer flip.  This function will only work in\n"
    "//               opengl right now, for all other graphics pipelines it will \n"
    "//               simply return immediately.  In opengl it's a bit of a hack:\n"
    "//               it will attempt to read a single pixel from the frame buffer to\n"
    "//               force the graphics card to finish drawing before it returns\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_ready_flip_555_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsEngine::flip_frame(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_flip_frame_556(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsEngine::flip_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flipFrame", key_word_list));
        else
            (PyArg_Parse(args, ":flipFrame"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->flip_frame();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsEngine.flipFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flipFrame(non-const GraphicsEngine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_flip_frame_556_comment =
    "C++ Interface:\n"
    "flipFrame(non-const GraphicsEngine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::flip_frame\n"
    "//       Access: Published\n"
    "//  Description: Waits for all the threads that started drawing their\n"
    "//               last frame to finish drawing, and then flips all the\n"
    "//               windows.  It is not usually necessary to call this\n"
    "//               explicitly, unless you need to see the previous frame\n"
    "//               right away.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_flip_frame_556_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GraphicsEngine::extract_texture_data(Texture *tex, GraphicsStateGuardian *gsg)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_extract_texture_data_557(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsEngine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsEngine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool GraphicsEngine::extract_texture_data(Texture *tex, GraphicsStateGuardian *gsg)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"tex", (char *)"gsg", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:extractTextureData", key_word_list, &param1, &param2))
            {
                Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "GraphicsEngine.extractTextureData", 0, coerced_ptr, report_errors);
GraphicsStateGuardian *param2_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_GraphicsStateGuardian, 2, "GraphicsEngine.extractTextureData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->extract_texture_data(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsEngine.extractTextureData() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extractTextureData(non-const GraphicsEngine this, non-const Texture tex, non-const GraphicsStateGuardian gsg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_extract_texture_data_557_comment =
    "C++ Interface:\n"
    "extractTextureData(non-const GraphicsEngine this, non-const Texture tex, non-const GraphicsStateGuardian gsg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::extract_texture_data\n"
    "//       Access: Published\n"
    "//  Description: Asks the indicated GraphicsStateGuardian to retrieve\n"
    "//               the texture memory image of the indicated texture and\n"
    "//               store it in the texture's ram_image field.  The image\n"
    "//               can then be written to disk via Texture::write(), or\n"
    "//               otherwise manipulated on the CPU.\n"
    "//\n"
    "//               This is useful for retrieving the contents of a\n"
    "//               texture that has been somehow generated on the\n"
    "//               graphics card, instead of having been loaded the\n"
    "//               normal way via Texture::read() or Texture::load().\n"
    "//               It is particularly useful for getting the data\n"
    "//               associated with a compressed texture image.\n"
    "//\n"
    "//               Since this requires a round-trip to the draw thread,\n"
    "//               it may require waiting for the current thread to\n"
    "//               finish rendering if it is called in a multithreaded\n"
    "//               environment.  However, you can call this several\n"
    "//               consecutive times on different textures for little\n"
    "//               additional cost.\n"
    "//\n"
    "//               If the texture has not yet been loaded to the GSG in\n"
    "//               question, it will be loaded immediately.\n"
    "//\n"
    "//               The return value is true if the operation is\n"
    "//               successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_extract_texture_data_557_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static GraphicsEngine *GraphicsEngine::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsEngine_get_global_ptr_558(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static GraphicsEngine *GraphicsEngine::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            GraphicsEngine *return_value = GraphicsEngine::get_global_ptr();
            if (return_value != (GraphicsEngine *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsEngine,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsEngine_get_global_ptr_558_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsEngine::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsEngine_get_global_ptr_558_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [GraphicsEngine::GraphicsEngine(Pipeline *pipeline)]
 * GraphicsEngine::GraphicsEngine(Pipeline *pipeline = ((void *)(0)))
 *******************************************************************/
int  Dtool_Init_GraphicsEngine(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-GraphicsEngine::GraphicsEngine(Pipeline *pipeline = ((void *)(0)))
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":GraphicsEngine", key_word_list))
        {
            GraphicsEngine *return_value = new GraphicsEngine();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_GraphicsEngine,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GraphicsEngine()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_GraphicsEngine_get_windows(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumWindows", "getWindow");
}
inline void  * Dtool_UpcastInterface_GraphicsEngine(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsEngine)
    {
        printf("GraphicsEngine ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsEngine * local_this = (GraphicsEngine *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsEngine)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsEngine(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsEngine)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsEngine*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsPipeSelection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int GraphicsPipeSelection::get_num_pipe_types(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_get_num_pipe_types_560(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int GraphicsPipeSelection::get_num_pipe_types(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPipeTypes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPipeTypes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsPipeSelection*)local_this)->get_num_pipe_types();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPipeTypes(const GraphicsPipeSelection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_get_num_pipe_types_560_comment =
    "C++ Interface:\n"
    "getNumPipeTypes(const GraphicsPipeSelection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::get_num_pipe_types\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of different types of\n"
    "//               GraphicsPipes that are available to create through\n"
    "//               this interface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_get_num_pipe_types_560_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle GraphicsPipeSelection::get_pipe_type(int n) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_get_pipe_type_561(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TypeHandle GraphicsPipeSelection::get_pipe_type(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPipeType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPipeType", &param1));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const GraphicsPipeSelection*)local_this)->get_pipe_type((int)param1);
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPipeType(const GraphicsPipeSelection this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_get_pipe_type_561_comment =
    "C++ Interface:\n"
    "getPipeType(const GraphicsPipeSelection this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::get_pipe_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth type of GraphicsPipe available\n"
    "//               through this interface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_get_pipe_type_561_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsPipeSelection::print_pipe_types(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_print_pipe_types_562(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void GraphicsPipeSelection::print_pipe_types(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printPipeTypes", key_word_list));
        else
            (PyArg_Parse(args, ":printPipeTypes"));
        if(!PyErr_Occurred())
        {
            ((const GraphicsPipeSelection*)local_this)->print_pipe_types();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printPipeTypes(const GraphicsPipeSelection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_print_pipe_types_562_comment =
    "C++ Interface:\n"
    "printPipeTypes(const GraphicsPipeSelection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::print_pipe_types\n"
    "//       Access: Published\n"
    "//  Description: Writes a list of the currently known GraphicsPipe\n"
    "//               types to nout, for the user's information.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_print_pipe_types_562_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(TypeHandle type)
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(basic_string< char > const &type_name, basic_string< char > const &module_name)
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(basic_string< char > const &type_name, basic_string< char > const &module_name = ((string())))
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_make_pipe_563(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(TypeHandle type)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"type", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:makePipe", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:makePipe", &param1));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "GraphicsPipeSelection.makePipe", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< GraphicsPipe > return_value = (local_this)->make_pipe(*param1_this);
                        if (return_value != (GraphicsPipe *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GraphicsPipe,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(basic_string< char > const &type_name, basic_string< char > const &module_name = ((string())))
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"type_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makePipe", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:makePipe", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    PointerTo< GraphicsPipe > return_value = (local_this)->make_pipe(basic_string<char>(param1_str, param1_len));
                    if (return_value != (GraphicsPipe *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GraphicsPipe,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(basic_string< char > const &type_name, basic_string< char > const &module_name)
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"type_name", (char *)"module_name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:makePipe", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                PointerTo< GraphicsPipe > return_value = (local_this)->make_pipe(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (return_value != (GraphicsPipe *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GraphicsPipe,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GraphicsPipeSelection.makePipe() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makePipe() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makePipe(non-const GraphicsPipeSelection this, const TypeHandle type)\n"
          "makePipe(non-const GraphicsPipeSelection this, string type_name)\n"
          "makePipe(non-const GraphicsPipeSelection this, string type_name, string module_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_make_pipe_563_comment =
    "C++ Interface:\n"
    "makePipe(non-const GraphicsPipeSelection this, const TypeHandle type)\n"
    "makePipe(non-const GraphicsPipeSelection this, string type_name)\n"
    "makePipe(non-const GraphicsPipeSelection this, string type_name, string module_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::make_pipe\n"
    "//       Access: Published\n"
    "//  Description: Creates a new GraphicsPipe of the indicated type (or\n"
    "//               a type more specific than the indicated type, if\n"
    "//               necessary) and returns it.  Returns NULL if the type\n"
    "//               cannot be matched.\n"
    "//\n"
    "//               If the type is not already defined, this will\n"
    "//               implicitly load the named module, or if module_name\n"
    "//               is empty, it will call load_aux_modules().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::make_pipe\n"
    "//       Access: Published\n"
    "//  Description: Creates a new GraphicsPipe of the indicated type (or\n"
    "//               a type more specific than the indicated type, if\n"
    "//               necessary) and returns it.  Returns NULL if the type\n"
    "//               cannot be matched.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_make_pipe_563_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_module_pipe(basic_string< char > const &module_name)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_make_module_pipe_564(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< GraphicsPipe > GraphicsPipeSelection::make_module_pipe(basic_string< char > const &module_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"module_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makeModulePipe", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:makeModulePipe", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PointerTo< GraphicsPipe > return_value = (local_this)->make_module_pipe(basic_string<char>(param1_str, param1_len));
            if (return_value != (GraphicsPipe *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GraphicsPipe,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsPipeSelection.makeModulePipe() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeModulePipe(non-const GraphicsPipeSelection this, string module_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_make_module_pipe_564_comment =
    "C++ Interface:\n"
    "makeModulePipe(non-const GraphicsPipeSelection this, string module_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::make_module_pipe\n"
    "//       Access: Published\n"
    "//  Description: Returns a new GraphicsPipe of a type defined by the\n"
    "//               indicated module.  Returns NULL if the module is not\n"
    "//               found or does not properly recommend a GraphicsPipe.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_make_module_pipe_564_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_default_pipe(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_make_default_pipe_565(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< GraphicsPipe > GraphicsPipeSelection::make_default_pipe(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeDefaultPipe", key_word_list));
        else
            (PyArg_Parse(args, ":makeDefaultPipe"));
        if(!PyErr_Occurred())
        {
            PointerTo< GraphicsPipe > return_value = (local_this)->make_default_pipe();
            if (return_value != (GraphicsPipe *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GraphicsPipe,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsPipeSelection.makeDefaultPipe() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeDefaultPipe(non-const GraphicsPipeSelection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_make_default_pipe_565_comment =
    "C++ Interface:\n"
    "makeDefaultPipe(non-const GraphicsPipeSelection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::make_default_pipe\n"
    "//       Access: Published\n"
    "//  Description: Creates a new GraphicsPipe of some arbitrary type.\n"
    "//               The user may specify a preference using the Configrc\n"
    "//               file; otherwise, one will be chosen arbitrarily.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_make_default_pipe_565_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GraphicsPipeSelection::get_num_aux_modules(void) const
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_get_num_aux_modules_566(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int GraphicsPipeSelection::get_num_aux_modules(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAuxModules", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAuxModules"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsPipeSelection*)local_this)->get_num_aux_modules();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAuxModules(const GraphicsPipeSelection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_get_num_aux_modules_566_comment =
    "C++ Interface:\n"
    "getNumAuxModules(const GraphicsPipeSelection this)\n"
    "\n"
    "// Filename: graphicsPipeSelection.I\n"
    "// Created by:  drose (15Aug02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::get_num_aux_modules\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of display modules that are still\n"
    "//               to be loaded.  If this is nonzero, then calling\n"
    "//               load_aux_modules() will likely increase the number of\n"
    "//               GraphicsPipes available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_get_num_aux_modules_566_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GraphicsPipeSelection::load_aux_modules(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_load_aux_modules_567(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsPipeSelection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsPipeSelection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GraphicsPipeSelection::load_aux_modules(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":loadAuxModules", key_word_list));
        else
            (PyArg_Parse(args, ":loadAuxModules"));
        if(!PyErr_Occurred())
        {
            (local_this)->load_aux_modules();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsPipeSelection.loadAuxModules() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadAuxModules(non-const GraphicsPipeSelection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_load_aux_modules_567_comment =
    "C++ Interface:\n"
    "loadAuxModules(non-const GraphicsPipeSelection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::load_aux_modules\n"
    "//       Access: Published\n"
    "//  Description: Loads all the modules named in the aux-display\n"
    "//               Configrc variable, making as many graphics pipes as\n"
    "//               possible available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_load_aux_modules_567_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline GraphicsPipeSelection *GraphicsPipeSelection::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsPipeSelection_get_global_ptr_568(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline GraphicsPipeSelection *GraphicsPipeSelection::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            GraphicsPipeSelection *return_value = GraphicsPipeSelection::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsPipeSelection,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsPipeSelection_get_global_ptr_568_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsPipeSelection::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the one global\n"
    "//               GraphicsPipeSelection object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsPipeSelection_get_global_ptr_568_comment = NULL;
#endif

int  Dtool_Init_GraphicsPipeSelection(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsPipeSelection)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_GraphicsPipeSelection_get_pipe_types(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPipeTypes", "getPipeType");
}
inline void  * Dtool_UpcastInterface_GraphicsPipeSelection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsPipeSelection)
    {
        printf("GraphicsPipeSelection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsPipeSelection * local_this = (GraphicsPipeSelection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsPipeSelection)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsPipeSelection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsPipeSelection)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. WindowHandle_OSHandle | OSHandle
//********************************************************************
PyMethodDef Dtool_Methods_WindowHandle_OSHandle[]= {
  { "getIntHandle",(PyCFunction ) &Dtool_WindowHandle_OSHandle_get_int_handle_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_OSHandle_get_int_handle_10_comment},
  { "output",(PyCFunction ) &Dtool_WindowHandle_OSHandle_output_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_OSHandle_output_11_comment},
  { "getClassType",(PyCFunction ) &Dtool_WindowHandle_OSHandle_get_class_type_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_OSHandle_get_class_type_12_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     WindowHandle_OSHandle
//////////////////
static PyObject *  Dtool_Repr_WindowHandle_OSHandle(PyObject * self)
{
    WindowHandle::OSHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle_OSHandle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_WindowHandle_OSHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_doc =
          "// This internal pointer within WindowHandle stores the actual\n"
          "// OS-specific window handle type, whatever type that is.  It is\n"
          "// subclassed for each OS.";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_repr = & Dtool_Repr_WindowHandle_OSHandle;
        // __str__ Repr Proxy
        Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_str = & Dtool_Repr_WindowHandle_OSHandle;
        if(PyType_Ready(&Dtool_WindowHandle_OSHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WindowHandle_OSHandle)");
             printf(" Error In PyType_ReadyWindowHandle_OSHandle");
             return;
        }
        Py_INCREF(&Dtool_WindowHandle_OSHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_dict,"OSHandle",&Dtool_WindowHandle_OSHandle.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_WindowHandle_OSHandle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_WindowHandle_OSHandle[2],&Dtool_WindowHandle_OSHandle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WindowHandle_OSHandle,WindowHandle::OSHandle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WindowHandle_OSHandle.As_PyTypeObject());
        PyModule_AddObject(module, "OSHandle",(PyObject *)&Dtool_WindowHandle_OSHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WindowHandle | WindowHandle
//********************************************************************
PyMethodDef Dtool_Methods_WindowHandle[]= {
  { "getOsHandle",(PyCFunction ) &Dtool_WindowHandle_get_os_handle_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_get_os_handle_4_comment},
  { "setOsHandle",(PyCFunction ) &Dtool_WindowHandle_set_os_handle_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_set_os_handle_5_comment},
  { "sendWindowsMessage",(PyCFunction ) &Dtool_WindowHandle_send_windows_message_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_send_windows_message_6_comment},
  { "getIntHandle",(PyCFunction ) &Dtool_WindowHandle_get_int_handle_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_get_int_handle_7_comment},
  { "output",(PyCFunction ) &Dtool_WindowHandle_output_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_output_8_comment},
  { "getClassType",(PyCFunction ) &Dtool_WindowHandle_get_class_type_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowHandle_get_class_type_13_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     WindowHandle
//////////////////
static PyObject *  Dtool_Repr_WindowHandle(PyObject * self)
{
    WindowHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowHandle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_WindowHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WindowHandle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WindowHandle\n"
          "// Description : This object represents a window on the desktop, not\n"
          "//               necessarily a Panda window.  This structure can be\n"
          "//               assigned to a WindowProperties to indicate a parent\n"
          "//               window.\n"
          "//\n"
          "//               It also has callbacks so the Panda window can\n"
          "//               communicate with its parent window, which is\n"
          "//               particularly important when running embedded in a\n"
          "//               browser.\n"
          "//\n"
          "//               To create a WindowHandle, you would usually call one\n"
          "//               of the NativeWindowHandle::make_*() methods,\n"
          "//               depending on the kind of native window handle object\n"
          "//               you already have.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_WindowHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_WindowHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WindowHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WindowHandle.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_WindowHandle.As_PyTypeObject().tp_repr = & Dtool_Repr_WindowHandle;
        // __str__ Repr Proxy
        Dtool_WindowHandle.As_PyTypeObject().tp_str = & Dtool_Repr_WindowHandle;
        // Nested Object   WindowHandle_OSHandle;
        Dtool_WindowHandle_OSHandle._Dtool_ClassInit(NULL);
        PyDict_SetItemString(Dtool_WindowHandle.As_PyTypeObject().tp_dict,"OSHandle",(PyObject *)&Dtool_WindowHandle_OSHandle.As_PyTypeObject());
        if(PyType_Ready(&Dtool_WindowHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WindowHandle)");
             printf(" Error In PyType_ReadyWindowHandle");
             return;
        }
        Py_INCREF(&Dtool_WindowHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WindowHandle.As_PyTypeObject().tp_dict,"WindowHandle",&Dtool_WindowHandle.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_WindowHandle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_WindowHandle[5],&Dtool_WindowHandle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WindowHandle,WindowHandle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WindowHandle.As_PyTypeObject());
        PyModule_AddObject(module, "WindowHandle",(PyObject *)&Dtool_WindowHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WindowProperties | WindowProperties
//********************************************************************
PyMethodDef Dtool_Methods_WindowProperties[]= {
  { "assign",(PyCFunction ) &Dtool_WindowProperties_operator_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_operator_18_comment},
  { "getConfigProperties",(PyCFunction ) &Dtool_WindowProperties_get_config_properties_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_config_properties_20_comment},
  { "getDefault",(PyCFunction ) &Dtool_WindowProperties_get_default_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_default_21_comment},
  { "setDefault",(PyCFunction ) &Dtool_WindowProperties_set_default_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_default_22_comment},
  { "clearDefault",(PyCFunction ) &Dtool_WindowProperties_clear_default_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_default_23_comment},
  { "size",(PyCFunction ) &Dtool_WindowProperties_size_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_size_24_comment},
  { "eq",(PyCFunction ) &Dtool_WindowProperties_operator_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_operator_25_comment},
  { "ne",(PyCFunction ) &Dtool_WindowProperties_operator_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_operator_26_comment},
  { "clear",(PyCFunction ) &Dtool_WindowProperties_clear_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_27_comment},
  { "isAnySpecified",(PyCFunction ) &Dtool_WindowProperties_is_any_specified_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_is_any_specified_28_comment},
  { "setOrigin",(PyCFunction ) &Dtool_WindowProperties_set_origin_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_origin_29_comment},
  { "getXOrigin",(PyCFunction ) &Dtool_WindowProperties_get_x_origin_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_x_origin_30_comment},
  { "getYOrigin",(PyCFunction ) &Dtool_WindowProperties_get_y_origin_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_y_origin_31_comment},
  { "hasOrigin",(PyCFunction ) &Dtool_WindowProperties_has_origin_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_origin_32_comment},
  { "clearOrigin",(PyCFunction ) &Dtool_WindowProperties_clear_origin_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_origin_33_comment},
  { "setSize",(PyCFunction ) &Dtool_WindowProperties_set_size_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_size_34_comment},
  { "getXSize",(PyCFunction ) &Dtool_WindowProperties_get_x_size_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_x_size_35_comment},
  { "getYSize",(PyCFunction ) &Dtool_WindowProperties_get_y_size_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_y_size_36_comment},
  { "hasSize",(PyCFunction ) &Dtool_WindowProperties_has_size_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_size_37_comment},
  { "clearSize",(PyCFunction ) &Dtool_WindowProperties_clear_size_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_size_38_comment},
  { "hasMouseMode",(PyCFunction ) &Dtool_WindowProperties_has_mouse_mode_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_mouse_mode_39_comment},
  { "setMouseMode",(PyCFunction ) &Dtool_WindowProperties_set_mouse_mode_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_mouse_mode_40_comment},
  { "getMouseMode",(PyCFunction ) &Dtool_WindowProperties_get_mouse_mode_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_mouse_mode_41_comment},
  { "clearMouseMode",(PyCFunction ) &Dtool_WindowProperties_clear_mouse_mode_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_mouse_mode_42_comment},
  { "setTitle",(PyCFunction ) &Dtool_WindowProperties_set_title_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_title_43_comment},
  { "getTitle",(PyCFunction ) &Dtool_WindowProperties_get_title_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_title_44_comment},
  { "hasTitle",(PyCFunction ) &Dtool_WindowProperties_has_title_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_title_45_comment},
  { "clearTitle",(PyCFunction ) &Dtool_WindowProperties_clear_title_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_title_46_comment},
  { "setUndecorated",(PyCFunction ) &Dtool_WindowProperties_set_undecorated_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_undecorated_47_comment},
  { "getUndecorated",(PyCFunction ) &Dtool_WindowProperties_get_undecorated_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_undecorated_48_comment},
  { "hasUndecorated",(PyCFunction ) &Dtool_WindowProperties_has_undecorated_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_undecorated_49_comment},
  { "clearUndecorated",(PyCFunction ) &Dtool_WindowProperties_clear_undecorated_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_undecorated_50_comment},
  { "setFixedSize",(PyCFunction ) &Dtool_WindowProperties_set_fixed_size_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_fixed_size_51_comment},
  { "getFixedSize",(PyCFunction ) &Dtool_WindowProperties_get_fixed_size_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_fixed_size_52_comment},
  { "hasFixedSize",(PyCFunction ) &Dtool_WindowProperties_has_fixed_size_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_fixed_size_53_comment},
  { "clearFixedSize",(PyCFunction ) &Dtool_WindowProperties_clear_fixed_size_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_fixed_size_54_comment},
  { "setFullscreen",(PyCFunction ) &Dtool_WindowProperties_set_fullscreen_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_fullscreen_55_comment},
  { "getFullscreen",(PyCFunction ) &Dtool_WindowProperties_get_fullscreen_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_fullscreen_56_comment},
  { "hasFullscreen",(PyCFunction ) &Dtool_WindowProperties_has_fullscreen_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_fullscreen_57_comment},
  { "clearFullscreen",(PyCFunction ) &Dtool_WindowProperties_clear_fullscreen_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_fullscreen_58_comment},
  { "setForeground",(PyCFunction ) &Dtool_WindowProperties_set_foreground_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_foreground_59_comment},
  { "getForeground",(PyCFunction ) &Dtool_WindowProperties_get_foreground_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_foreground_60_comment},
  { "hasForeground",(PyCFunction ) &Dtool_WindowProperties_has_foreground_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_foreground_61_comment},
  { "clearForeground",(PyCFunction ) &Dtool_WindowProperties_clear_foreground_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_foreground_62_comment},
  { "setMinimized",(PyCFunction ) &Dtool_WindowProperties_set_minimized_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_minimized_63_comment},
  { "getMinimized",(PyCFunction ) &Dtool_WindowProperties_get_minimized_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_minimized_64_comment},
  { "hasMinimized",(PyCFunction ) &Dtool_WindowProperties_has_minimized_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_minimized_65_comment},
  { "clearMinimized",(PyCFunction ) &Dtool_WindowProperties_clear_minimized_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_minimized_66_comment},
  { "setRawMice",(PyCFunction ) &Dtool_WindowProperties_set_raw_mice_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_raw_mice_67_comment},
  { "getRawMice",(PyCFunction ) &Dtool_WindowProperties_get_raw_mice_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_raw_mice_68_comment},
  { "hasRawMice",(PyCFunction ) &Dtool_WindowProperties_has_raw_mice_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_raw_mice_69_comment},
  { "clearRawMice",(PyCFunction ) &Dtool_WindowProperties_clear_raw_mice_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_raw_mice_70_comment},
  { "setOpen",(PyCFunction ) &Dtool_WindowProperties_set_open_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_open_71_comment},
  { "getOpen",(PyCFunction ) &Dtool_WindowProperties_get_open_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_open_72_comment},
  { "hasOpen",(PyCFunction ) &Dtool_WindowProperties_has_open_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_open_73_comment},
  { "clearOpen",(PyCFunction ) &Dtool_WindowProperties_clear_open_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_open_74_comment},
  { "setCursorHidden",(PyCFunction ) &Dtool_WindowProperties_set_cursor_hidden_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_cursor_hidden_75_comment},
  { "getCursorHidden",(PyCFunction ) &Dtool_WindowProperties_get_cursor_hidden_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_cursor_hidden_76_comment},
  { "hasCursorHidden",(PyCFunction ) &Dtool_WindowProperties_has_cursor_hidden_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_cursor_hidden_77_comment},
  { "clearCursorHidden",(PyCFunction ) &Dtool_WindowProperties_clear_cursor_hidden_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_cursor_hidden_78_comment},
  { "setIconFilename",(PyCFunction ) &Dtool_WindowProperties_set_icon_filename_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_icon_filename_79_comment},
  { "getIconFilename",(PyCFunction ) &Dtool_WindowProperties_get_icon_filename_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_icon_filename_80_comment},
  { "hasIconFilename",(PyCFunction ) &Dtool_WindowProperties_has_icon_filename_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_icon_filename_81_comment},
  { "clearIconFilename",(PyCFunction ) &Dtool_WindowProperties_clear_icon_filename_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_icon_filename_82_comment},
  { "setCursorFilename",(PyCFunction ) &Dtool_WindowProperties_set_cursor_filename_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_cursor_filename_83_comment},
  { "getCursorFilename",(PyCFunction ) &Dtool_WindowProperties_get_cursor_filename_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_cursor_filename_84_comment},
  { "hasCursorFilename",(PyCFunction ) &Dtool_WindowProperties_has_cursor_filename_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_cursor_filename_85_comment},
  { "clearCursorFilename",(PyCFunction ) &Dtool_WindowProperties_clear_cursor_filename_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_cursor_filename_86_comment},
  { "setZOrder",(PyCFunction ) &Dtool_WindowProperties_set_z_order_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_z_order_87_comment},
  { "getZOrder",(PyCFunction ) &Dtool_WindowProperties_get_z_order_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_z_order_88_comment},
  { "hasZOrder",(PyCFunction ) &Dtool_WindowProperties_has_z_order_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_z_order_89_comment},
  { "clearZOrder",(PyCFunction ) &Dtool_WindowProperties_clear_z_order_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_z_order_90_comment},
  { "setParentWindow",(PyCFunction ) &Dtool_WindowProperties_set_parent_window_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_set_parent_window_91_comment},
  { "getParentWindow",(PyCFunction ) &Dtool_WindowProperties_get_parent_window_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_get_parent_window_92_comment},
  { "hasParentWindow",(PyCFunction ) &Dtool_WindowProperties_has_parent_window_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_has_parent_window_93_comment},
  { "clearParentWindow",(PyCFunction ) &Dtool_WindowProperties_clear_parent_window_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_clear_parent_window_94_comment},
  { "addProperties",(PyCFunction ) &Dtool_WindowProperties_add_properties_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_add_properties_95_comment},
  { "output",(PyCFunction ) &Dtool_WindowProperties_output_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowProperties_output_96_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     WindowProperties
//////////////////
static PyObject *  Dtool_Repr_WindowProperties(PyObject * self)
{
    WindowProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WindowProperties,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_WindowProperties(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WindowProperties.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WindowProperties\n"
          "// Description : A container for the various kinds of properties we\n"
          "//               might ask to have on a graphics window before we open\n"
          "//               it.  This also serves to hold the current properties\n"
          "//               for a window after it has been opened.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_WindowProperties.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_WindowProperties.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WindowProperties.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_WindowProperties.As_PyTypeObject().tp_repr = & Dtool_Repr_WindowProperties;
        // __str__ Repr Proxy
        Dtool_WindowProperties.As_PyTypeObject().tp_str = & Dtool_Repr_WindowProperties;
        // Enum  WindowProperties::ZOrder;
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"ZBottom",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"ZNormal",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"ZTop",PyInt_FromLong(2));
        // Enum  WindowProperties::MouseMode;
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"MAbsolute",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"MRelative",PyInt_FromLong(1));
        if(PyType_Ready(&Dtool_WindowProperties.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WindowProperties)");
             printf(" Error In PyType_ReadyWindowProperties");
             return;
        }
        Py_INCREF(&Dtool_WindowProperties.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"WindowProperties",&Dtool_WindowProperties.As_PyObject());
        //  Static Method getConfigProperties
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"getConfigProperties",PyCFunction_New(&Dtool_Methods_WindowProperties[1],&Dtool_WindowProperties.As_PyObject()));
        //  Static Method getDefault
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"getDefault",PyCFunction_New(&Dtool_Methods_WindowProperties[2],&Dtool_WindowProperties.As_PyObject()));
        //  Static Method setDefault
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"setDefault",PyCFunction_New(&Dtool_Methods_WindowProperties[3],&Dtool_WindowProperties.As_PyObject()));
        //  Static Method clearDefault
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"clearDefault",PyCFunction_New(&Dtool_Methods_WindowProperties[4],&Dtool_WindowProperties.As_PyObject()));
        //  Static Method size
        PyDict_SetItemString(Dtool_WindowProperties.As_PyTypeObject().tp_dict,"size",PyCFunction_New(&Dtool_Methods_WindowProperties[5],&Dtool_WindowProperties.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WindowProperties,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WindowProperties.As_PyTypeObject());
        PyModule_AddObject(module, "WindowProperties",(PyObject *)&Dtool_WindowProperties.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DisplayInformation | DisplayInformation
//********************************************************************
PyMethodDef Dtool_Methods_DisplayInformation[]= {
  { "getDisplayState",(PyCFunction ) &Dtool_DisplayInformation_get_display_state_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_display_state_101_comment},
  { "getMaximumWindowWidth",(PyCFunction ) &Dtool_DisplayInformation_get_maximum_window_width_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_maximum_window_width_102_comment},
  { "getMaximumWindowHeight",(PyCFunction ) &Dtool_DisplayInformation_get_maximum_window_height_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_maximum_window_height_103_comment},
  { "getWindowBitsPerPixel",(PyCFunction ) &Dtool_DisplayInformation_get_window_bits_per_pixel_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_window_bits_per_pixel_104_comment},
  { "getTotalDisplayModes",(PyCFunction ) &Dtool_DisplayInformation_get_total_display_modes_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_total_display_modes_105_comment},
  { "getDisplayModeWidth",(PyCFunction ) &Dtool_DisplayInformation_get_display_mode_width_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_display_mode_width_106_comment},
  { "getDisplayModeHeight",(PyCFunction ) &Dtool_DisplayInformation_get_display_mode_height_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_display_mode_height_107_comment},
  { "getDisplayModeBitsPerPixel",(PyCFunction ) &Dtool_DisplayInformation_get_display_mode_bits_per_pixel_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_display_mode_bits_per_pixel_108_comment},
  { "getDisplayModeRefreshRate",(PyCFunction ) &Dtool_DisplayInformation_get_display_mode_refresh_rate_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_display_mode_refresh_rate_109_comment},
  { "getDisplayModeFullscreenOnly",(PyCFunction ) &Dtool_DisplayInformation_get_display_mode_fullscreen_only_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_display_mode_fullscreen_only_110_comment},
  { "getShaderModel",(PyCFunction ) &Dtool_DisplayInformation_get_shader_model_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_shader_model_111_comment},
  { "getVideoMemory",(PyCFunction ) &Dtool_DisplayInformation_get_video_memory_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_video_memory_112_comment},
  { "getTextureMemory",(PyCFunction ) &Dtool_DisplayInformation_get_texture_memory_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_texture_memory_113_comment},
  { "updateMemoryInformation",(PyCFunction ) &Dtool_DisplayInformation_update_memory_information_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_update_memory_information_114_comment},
  { "getPhysicalMemory",(PyCFunction ) &Dtool_DisplayInformation_get_physical_memory_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_physical_memory_115_comment},
  { "getAvailablePhysicalMemory",(PyCFunction ) &Dtool_DisplayInformation_get_available_physical_memory_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_available_physical_memory_116_comment},
  { "getPageFileSize",(PyCFunction ) &Dtool_DisplayInformation_get_page_file_size_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_page_file_size_117_comment},
  { "getAvailablePageFileSize",(PyCFunction ) &Dtool_DisplayInformation_get_available_page_file_size_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_available_page_file_size_118_comment},
  { "getProcessVirtualMemory",(PyCFunction ) &Dtool_DisplayInformation_get_process_virtual_memory_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_process_virtual_memory_119_comment},
  { "getAvailableProcessVirtualMemory",(PyCFunction ) &Dtool_DisplayInformation_get_available_process_virtual_memory_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_available_process_virtual_memory_120_comment},
  { "getMemoryLoad",(PyCFunction ) &Dtool_DisplayInformation_get_memory_load_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_memory_load_121_comment},
  { "getPageFaultCount",(PyCFunction ) &Dtool_DisplayInformation_get_page_fault_count_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_page_fault_count_122_comment},
  { "getProcessMemory",(PyCFunction ) &Dtool_DisplayInformation_get_process_memory_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_process_memory_123_comment},
  { "getPeakProcessMemory",(PyCFunction ) &Dtool_DisplayInformation_get_peak_process_memory_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_peak_process_memory_124_comment},
  { "getPageFileUsage",(PyCFunction ) &Dtool_DisplayInformation_get_page_file_usage_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_page_file_usage_125_comment},
  { "getPeakPageFileUsage",(PyCFunction ) &Dtool_DisplayInformation_get_peak_page_file_usage_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_peak_page_file_usage_126_comment},
  { "getVendorId",(PyCFunction ) &Dtool_DisplayInformation_get_vendor_id_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_vendor_id_127_comment},
  { "getDeviceId",(PyCFunction ) &Dtool_DisplayInformation_get_device_id_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_device_id_128_comment},
  { "getDriverProduct",(PyCFunction ) &Dtool_DisplayInformation_get_driver_product_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_product_129_comment},
  { "getDriverVersion",(PyCFunction ) &Dtool_DisplayInformation_get_driver_version_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_version_130_comment},
  { "getDriverSubVersion",(PyCFunction ) &Dtool_DisplayInformation_get_driver_sub_version_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_sub_version_131_comment},
  { "getDriverBuild",(PyCFunction ) &Dtool_DisplayInformation_get_driver_build_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_build_132_comment},
  { "getDriverDateMonth",(PyCFunction ) &Dtool_DisplayInformation_get_driver_date_month_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_date_month_133_comment},
  { "getDriverDateDay",(PyCFunction ) &Dtool_DisplayInformation_get_driver_date_day_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_date_day_134_comment},
  { "getDriverDateYear",(PyCFunction ) &Dtool_DisplayInformation_get_driver_date_year_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_driver_date_year_135_comment},
  { "getCpuIdVersion",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_id_version_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_id_version_136_comment},
  { "getCpuIdSize",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_id_size_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_id_size_137_comment},
  { "getCpuIdData",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_id_data_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_id_data_138_comment},
  { "getCpuVendorString",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_vendor_string_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_vendor_string_139_comment},
  { "getCpuBrandString",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_brand_string_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_brand_string_140_comment},
  { "getCpuVersionInformation",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_version_information_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_version_information_141_comment},
  { "getCpuBrandIndex",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_brand_index_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_brand_index_142_comment},
  { "getCpuFrequency",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_frequency_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_frequency_143_comment},
  { "getCpuTime",(PyCFunction ) &Dtool_DisplayInformation_get_cpu_time_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_cpu_time_144_comment},
  { "getMaximumCpuFrequency",(PyCFunction ) &Dtool_DisplayInformation_get_maximum_cpu_frequency_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_maximum_cpu_frequency_145_comment},
  { "getCurrentCpuFrequency",(PyCFunction ) &Dtool_DisplayInformation_get_current_cpu_frequency_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_current_cpu_frequency_146_comment},
  { "updateCpuFrequency",(PyCFunction ) &Dtool_DisplayInformation_update_cpu_frequency_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_update_cpu_frequency_147_comment},
  { "getNumCpuCores",(PyCFunction ) &Dtool_DisplayInformation_get_num_cpu_cores_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_num_cpu_cores_148_comment},
  { "getNumLogicalCpus",(PyCFunction ) &Dtool_DisplayInformation_get_num_logical_cpus_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_num_logical_cpus_149_comment},
  { "getOsVersionMajor",(PyCFunction ) &Dtool_DisplayInformation_get_os_version_major_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_os_version_major_150_comment},
  { "getOsVersionMinor",(PyCFunction ) &Dtool_DisplayInformation_get_os_version_minor_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_os_version_minor_151_comment},
  { "getOsVersionBuild",(PyCFunction ) &Dtool_DisplayInformation_get_os_version_build_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_os_version_build_152_comment},
  { "getOsPlatformId",(PyCFunction ) &Dtool_DisplayInformation_get_os_platform_id_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayInformation_get_os_platform_id_153_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DisplayInformation(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DisplayInformation.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DisplayInformation\n"
          "// Description : This class contains various display information.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DisplayInformation.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DisplayInformation.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DisplayInformation.As_PyTypeObject().tp_dict);
        // Enum  DisplayInformation::DetectionState;
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DSUnknown",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DSSuccess",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DSDirect3dCreateError",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DSCreateWindowError",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DSCreateDeviceError",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_DisplayInformation.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DisplayInformation)");
             printf(" Error In PyType_ReadyDisplayInformation");
             return;
        }
        Py_INCREF(&Dtool_DisplayInformation.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DisplayInformation.As_PyTypeObject().tp_dict,"DisplayInformation",&Dtool_DisplayInformation.As_PyObject());
        RegisterRuntimeClass(&Dtool_DisplayInformation,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DisplayInformation.As_PyTypeObject());
        PyModule_AddObject(module, "DisplayInformation",(PyObject *)&Dtool_DisplayInformation.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DrawableRegion | DrawableRegion
//********************************************************************
PyMethodDef Dtool_Methods_DrawableRegion[]= {
  { "setClearColorActive",(PyCFunction ) &Dtool_DrawableRegion_set_clear_color_active_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_color_active_157_comment},
  { "getClearColorActive",(PyCFunction ) &Dtool_DrawableRegion_get_clear_color_active_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_color_active_158_comment},
  { "setClearDepthActive",(PyCFunction ) &Dtool_DrawableRegion_set_clear_depth_active_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_depth_active_159_comment},
  { "getClearDepthActive",(PyCFunction ) &Dtool_DrawableRegion_get_clear_depth_active_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_depth_active_160_comment},
  { "setClearStencilActive",(PyCFunction ) &Dtool_DrawableRegion_set_clear_stencil_active_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_stencil_active_161_comment},
  { "getClearStencilActive",(PyCFunction ) &Dtool_DrawableRegion_get_clear_stencil_active_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_stencil_active_162_comment},
  { "setClearColor",(PyCFunction ) &Dtool_DrawableRegion_set_clear_color_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_color_163_comment},
  { "getClearColor",(PyCFunction ) &Dtool_DrawableRegion_get_clear_color_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_color_164_comment},
  { "setClearDepth",(PyCFunction ) &Dtool_DrawableRegion_set_clear_depth_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_depth_165_comment},
  { "getClearDepth",(PyCFunction ) &Dtool_DrawableRegion_get_clear_depth_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_depth_166_comment},
  { "setClearStencil",(PyCFunction ) &Dtool_DrawableRegion_set_clear_stencil_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_stencil_167_comment},
  { "getClearStencil",(PyCFunction ) &Dtool_DrawableRegion_get_clear_stencil_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_stencil_168_comment},
  { "setClearActive",(PyCFunction ) &Dtool_DrawableRegion_set_clear_active_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_active_169_comment},
  { "getClearActive",(PyCFunction ) &Dtool_DrawableRegion_get_clear_active_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_active_170_comment},
  { "setClearValue",(PyCFunction ) &Dtool_DrawableRegion_set_clear_value_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_clear_value_171_comment},
  { "getClearValue",(PyCFunction ) &Dtool_DrawableRegion_get_clear_value_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_clear_value_172_comment},
  { "disableClears",(PyCFunction ) &Dtool_DrawableRegion_disable_clears_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_disable_clears_173_comment},
  { "isAnyClearActive",(PyCFunction ) &Dtool_DrawableRegion_is_any_clear_active_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_is_any_clear_active_174_comment},
  { "setPixelZoom",(PyCFunction ) &Dtool_DrawableRegion_set_pixel_zoom_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_set_pixel_zoom_175_comment},
  { "getPixelZoom",(PyCFunction ) &Dtool_DrawableRegion_get_pixel_zoom_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_pixel_zoom_176_comment},
  { "getPixelFactor",(PyCFunction ) &Dtool_DrawableRegion_get_pixel_factor_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_pixel_factor_177_comment},
  { "supportsPixelZoom",(PyCFunction ) &Dtool_DrawableRegion_supports_pixel_zoom_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_supports_pixel_zoom_178_comment},
  { "getRenderbufferType",(PyCFunction ) &Dtool_DrawableRegion_get_renderbuffer_type_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_get_renderbuffer_type_179_comment},
  { "downcastToDisplayRegion",(PyCFunction ) &Dtool_DrawableRegion_downcast_to_DisplayRegion_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_downcast_to_DisplayRegion_185_comment},
  { "downcastToGraphicsOutput",(PyCFunction ) &Dtool_DrawableRegion_downcast_to_GraphicsOutput_416, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DrawableRegion_downcast_to_GraphicsOutput_416_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DrawableRegion(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DrawableRegion.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DrawableRegion\n"
          "// Description : This is a base class for GraphicsWindow (actually,\n"
          "//               GraphicsOutput) and DisplayRegion, both of which are\n"
          "//               conceptually rectangular regions into which drawing\n"
          "//               commands may be issued.  Sometimes you want to deal\n"
          "//               with a single display region, and sometimes you want\n"
          "//               to deal with the whole window at once, particularly\n"
          "//               for issuing clear commands and capturing screenshots.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DrawableRegion.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DrawableRegion.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DrawableRegion.As_PyTypeObject().tp_dict);
        // Enum  DrawableRegion::RenderTexturePlane;
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPStencil",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPDepthStencil",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPColor",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxRgba0",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxRgba1",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxRgba2",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxRgba3",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxHrgba0",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxHrgba1",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxHrgba2",PyInt_FromLong(9));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxHrgba3",PyInt_FromLong(10));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxFloat0",PyInt_FromLong(11));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxFloat1",PyInt_FromLong(12));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxFloat2",PyInt_FromLong(13));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPAuxFloat3",PyInt_FromLong(14));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPDepth",PyInt_FromLong(15));
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"RTPCOUNT",PyInt_FromLong(16));
        if(PyType_Ready(&Dtool_DrawableRegion.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DrawableRegion)");
             printf(" Error In PyType_ReadyDrawableRegion");
             return;
        }
        Py_INCREF(&Dtool_DrawableRegion.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"DrawableRegion",&Dtool_DrawableRegion.As_PyObject());
        //  Static Method getRenderbufferType
        PyDict_SetItemString(Dtool_DrawableRegion.As_PyTypeObject().tp_dict,"getRenderbufferType",PyCFunction_New(&Dtool_Methods_DrawableRegion[22],&Dtool_DrawableRegion.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DrawableRegion,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DrawableRegion.As_PyTypeObject());
        PyModule_AddObject(module, "DrawableRegion",(PyObject *)&Dtool_DrawableRegion.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DisplayRegion | DisplayRegion
//********************************************************************
PyMethodDef Dtool_Methods_DisplayRegion[]= {
  { "getLeft",(PyCFunction ) &Dtool_DisplayRegion_get_left_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_left_188_comment},
  { "getRight",(PyCFunction ) &Dtool_DisplayRegion_get_right_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_right_189_comment},
  { "getBottom",(PyCFunction ) &Dtool_DisplayRegion_get_bottom_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_bottom_190_comment},
  { "getTop",(PyCFunction ) &Dtool_DisplayRegion_get_top_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_top_191_comment},
  { "setDimensions",(PyCFunction ) &Dtool_DisplayRegion_set_dimensions_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_dimensions_192_comment},
  { "getWindow",(PyCFunction ) &Dtool_DisplayRegion_get_window_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_window_193_comment},
  { "getPipe",(PyCFunction ) &Dtool_DisplayRegion_get_pipe_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_pipe_194_comment},
  { "isStereo",(PyCFunction ) &Dtool_DisplayRegion_is_stereo_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_is_stereo_195_comment},
  { "setCamera",(PyCFunction ) &Dtool_DisplayRegion_set_camera_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_camera_196_comment},
  { "getCamera",(PyCFunction ) &Dtool_DisplayRegion_get_camera_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_camera_197_comment},
  { "setActive",(PyCFunction ) &Dtool_DisplayRegion_set_active_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_active_198_comment},
  { "isActive",(PyCFunction ) &Dtool_DisplayRegion_is_active_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_is_active_199_comment},
  { "setSort",(PyCFunction ) &Dtool_DisplayRegion_set_sort_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_sort_200_comment},
  { "getSort",(PyCFunction ) &Dtool_DisplayRegion_get_sort_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_sort_201_comment},
  { "setStereoChannel",(PyCFunction ) &Dtool_DisplayRegion_set_stereo_channel_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_stereo_channel_202_comment},
  { "getStereoChannel",(PyCFunction ) &Dtool_DisplayRegion_get_stereo_channel_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_stereo_channel_203_comment},
  { "setIncompleteRender",(PyCFunction ) &Dtool_DisplayRegion_set_incomplete_render_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_incomplete_render_204_comment},
  { "getIncompleteRender",(PyCFunction ) &Dtool_DisplayRegion_get_incomplete_render_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_incomplete_render_205_comment},
  { "setTextureReloadPriority",(PyCFunction ) &Dtool_DisplayRegion_set_texture_reload_priority_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_texture_reload_priority_206_comment},
  { "getTextureReloadPriority",(PyCFunction ) &Dtool_DisplayRegion_get_texture_reload_priority_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_texture_reload_priority_207_comment},
  { "setLensIndex",(PyCFunction ) &Dtool_DisplayRegion_set_lens_index_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_lens_index_208_comment},
  { "getLensIndex",(PyCFunction ) &Dtool_DisplayRegion_get_lens_index_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_lens_index_209_comment},
  { "setCullTraverser",(PyCFunction ) &Dtool_DisplayRegion_set_cull_traverser_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_cull_traverser_210_comment},
  { "getCullTraverser",(PyCFunction ) &Dtool_DisplayRegion_get_cull_traverser_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_cull_traverser_211_comment},
  { "setCubeMapIndex",(PyCFunction ) &Dtool_DisplayRegion_set_cube_map_index_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_cube_map_index_212_comment},
  { "getCubeMapIndex",(PyCFunction ) &Dtool_DisplayRegion_get_cube_map_index_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_cube_map_index_213_comment},
  { "setCullCallback",(PyCFunction ) &Dtool_DisplayRegion_set_cull_callback_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_cull_callback_214_comment},
  { "clearCullCallback",(PyCFunction ) &Dtool_DisplayRegion_clear_cull_callback_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_clear_cull_callback_215_comment},
  { "getCullCallback",(PyCFunction ) &Dtool_DisplayRegion_get_cull_callback_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_cull_callback_216_comment},
  { "setDrawCallback",(PyCFunction ) &Dtool_DisplayRegion_set_draw_callback_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_set_draw_callback_217_comment},
  { "clearDrawCallback",(PyCFunction ) &Dtool_DisplayRegion_clear_draw_callback_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_clear_draw_callback_218_comment},
  { "getDrawCallback",(PyCFunction ) &Dtool_DisplayRegion_get_draw_callback_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_draw_callback_219_comment},
  { "getPixelWidth",(PyCFunction ) &Dtool_DisplayRegion_get_pixel_width_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_pixel_width_220_comment},
  { "getPixelHeight",(PyCFunction ) &Dtool_DisplayRegion_get_pixel_height_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_pixel_height_221_comment},
  { "output",(PyCFunction ) &Dtool_DisplayRegion_output_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_output_222_comment},
  { "makeScreenshotFilename",(PyCFunction ) &Dtool_DisplayRegion_make_screenshot_filename_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_make_screenshot_filename_223_comment},
  { "saveScreenshotDefault",(PyCFunction ) &Dtool_DisplayRegion_save_screenshot_default_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_save_screenshot_default_224_comment},
  { "saveScreenshot",(PyCFunction ) &Dtool_DisplayRegion_save_screenshot_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_save_screenshot_225_comment},
  { "getScreenshot",(PyCFunction ) &Dtool_DisplayRegion_get_screenshot_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_screenshot_226_comment},
  { "makeCullResultGraph",(PyCFunction ) &Dtool_DisplayRegion_make_cull_result_graph_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_make_cull_result_graph_227_comment},
  { "getClassType",(PyCFunction ) &Dtool_DisplayRegion_get_class_type_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_get_class_type_228_comment},
  { "upcastToDisplayRegionBase",(PyCFunction ) &Dtool_DisplayRegion_upcast_to_DisplayRegionBase_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_upcast_to_DisplayRegionBase_182_comment},
  { "upcastToDrawableRegion",(PyCFunction ) &Dtool_DisplayRegion_upcast_to_DrawableRegion_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegion_upcast_to_DrawableRegion_184_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DisplayRegion
//////////////////
static PyObject *  Dtool_Repr_DisplayRegion(PyObject * self)
{
    DisplayRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegion,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DisplayRegion(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DisplayRegion.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DisplayRegion\n"
          "// Description : A rectangular subregion within a window for rendering\n"
          "//               into.  Typically, there is one DisplayRegion that\n"
          "//               covers the whole window, but you may also create\n"
          "//               smaller DisplayRegions for having different regions\n"
          "//               within the window that represent different scenes.\n"
          "//               You may also stack up DisplayRegions like panes of\n"
          "//               glass, usually for layering 2-d interfaces on top of\n"
          "//               a 3-d scene.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DisplayRegionBase._Dtool_ClassInit(NULL);
        Dtool_DrawableRegion._Dtool_ClassInit(NULL);
        Dtool_DisplayRegion.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_DisplayRegionBase.As_PyTypeObject(),&Dtool_DrawableRegion.As_PyTypeObject());
        Dtool_DisplayRegion.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DisplayRegion.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DisplayRegion.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DisplayRegion.As_PyTypeObject().tp_repr = & Dtool_Repr_DisplayRegion;
        // __str__ Repr Proxy
        Dtool_DisplayRegion.As_PyTypeObject().tp_str = & Dtool_Repr_DisplayRegion;
        if(PyType_Ready(&Dtool_DisplayRegion.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DisplayRegion)");
             printf(" Error In PyType_ReadyDisplayRegion");
             return;
        }
        Py_INCREF(&Dtool_DisplayRegion.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DisplayRegion.As_PyTypeObject().tp_dict,"DisplayRegion",&Dtool_DisplayRegion.As_PyObject());
        //  Static Method makeScreenshotFilename
        PyDict_SetItemString(Dtool_DisplayRegion.As_PyTypeObject().tp_dict,"makeScreenshotFilename",PyCFunction_New(&Dtool_Methods_DisplayRegion[35],&Dtool_DisplayRegion.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DisplayRegion.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DisplayRegion[40],&Dtool_DisplayRegion.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DisplayRegion,DisplayRegion::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DisplayRegion.As_PyTypeObject());
        PyModule_AddObject(module, "DisplayRegion",(PyObject *)&Dtool_DisplayRegion.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DisplayRegionCullCallbackData | DisplayRegionCullCallbackData
//********************************************************************
PyMethodDef Dtool_Methods_DisplayRegionCullCallbackData[]= {
  { "getSceneSetup",(PyCFunction ) &Dtool_DisplayRegionCullCallbackData_get_scene_setup_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionCullCallbackData_get_scene_setup_232_comment},
  { "getClassType",(PyCFunction ) &Dtool_DisplayRegionCullCallbackData_get_class_type_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionCullCallbackData_get_class_type_233_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DisplayRegionCullCallbackData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DisplayRegionCullCallbackData\n"
          "// Description : This specialization on CallbackData is passed when\n"
          "//               the callback is initiated from the cull traversal,\n"
          "//               for a DisplayRegion.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CallbackData._Dtool_ClassInit(NULL);
        Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CallbackData.As_PyTypeObject());
        Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DisplayRegionCullCallbackData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DisplayRegionCullCallbackData)");
             printf(" Error In PyType_ReadyDisplayRegionCullCallbackData");
             return;
        }
        Py_INCREF(&Dtool_DisplayRegionCullCallbackData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_dict,"DisplayRegionCullCallbackData",&Dtool_DisplayRegionCullCallbackData.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DisplayRegionCullCallbackData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DisplayRegionCullCallbackData[1],&Dtool_DisplayRegionCullCallbackData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DisplayRegionCullCallbackData,DisplayRegionCullCallbackData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DisplayRegionCullCallbackData.As_PyTypeObject());
        PyModule_AddObject(module, "DisplayRegionCullCallbackData",(PyObject *)&Dtool_DisplayRegionCullCallbackData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DisplayRegionDrawCallbackData | DisplayRegionDrawCallbackData
//********************************************************************
PyMethodDef Dtool_Methods_DisplayRegionDrawCallbackData[]= {
  { "getCullResult",(PyCFunction ) &Dtool_DisplayRegionDrawCallbackData_get_cull_result_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionDrawCallbackData_get_cull_result_236_comment},
  { "getSceneSetup",(PyCFunction ) &Dtool_DisplayRegionDrawCallbackData_get_scene_setup_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionDrawCallbackData_get_scene_setup_237_comment},
  { "getClassType",(PyCFunction ) &Dtool_DisplayRegionDrawCallbackData_get_class_type_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionDrawCallbackData_get_class_type_238_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DisplayRegionDrawCallbackData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DisplayRegionDrawCallbackData\n"
          "// Description : This specialization on CallbackData is passed when\n"
          "//               the callback is initiated from the draw traversal,\n"
          "//               for a DisplayRegion.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CallbackData._Dtool_ClassInit(NULL);
        Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CallbackData.As_PyTypeObject());
        Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DisplayRegionDrawCallbackData)");
             printf(" Error In PyType_ReadyDisplayRegionDrawCallbackData");
             return;
        }
        Py_INCREF(&Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_dict,"DisplayRegionDrawCallbackData",&Dtool_DisplayRegionDrawCallbackData.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DisplayRegionDrawCallbackData[2],&Dtool_DisplayRegionDrawCallbackData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DisplayRegionDrawCallbackData,DisplayRegionDrawCallbackData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject());
        PyModule_AddObject(module, "DisplayRegionDrawCallbackData",(PyObject *)&Dtool_DisplayRegionDrawCallbackData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DisplaySearchParameters | DisplaySearchParameters
//********************************************************************
PyMethodDef Dtool_Methods_DisplaySearchParameters[]= {
  { "setMinimumWidth",(PyCFunction ) &Dtool_DisplaySearchParameters_set_minimum_width_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplaySearchParameters_set_minimum_width_243_comment},
  { "setMaximumWidth",(PyCFunction ) &Dtool_DisplaySearchParameters_set_maximum_width_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplaySearchParameters_set_maximum_width_244_comment},
  { "setMinimumHeight",(PyCFunction ) &Dtool_DisplaySearchParameters_set_minimum_height_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplaySearchParameters_set_minimum_height_245_comment},
  { "setMaximumHeight",(PyCFunction ) &Dtool_DisplaySearchParameters_set_maximum_height_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplaySearchParameters_set_maximum_height_246_comment},
  { "setMinimumBitsPerPixel",(PyCFunction ) &Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_247_comment},
  { "setMaximumBitsPerPixel",(PyCFunction ) &Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_248_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DisplaySearchParameters(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DisplaySearchParameters.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DisplaySearchParameters\n"
          "// Description : Parameters used for searching display capabilities.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DisplaySearchParameters.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DisplaySearchParameters.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DisplaySearchParameters.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DisplaySearchParameters.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DisplaySearchParameters.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DisplaySearchParameters)");
             printf(" Error In PyType_ReadyDisplaySearchParameters");
             return;
        }
        Py_INCREF(&Dtool_DisplaySearchParameters.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DisplaySearchParameters.As_PyTypeObject().tp_dict,"DisplaySearchParameters",&Dtool_DisplaySearchParameters.As_PyObject());
        RegisterRuntimeClass(&Dtool_DisplaySearchParameters,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DisplaySearchParameters.As_PyTypeObject());
        PyModule_AddObject(module, "DisplaySearchParameters",(PyObject *)&Dtool_DisplaySearchParameters.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FrameBufferProperties | FrameBufferProperties
//********************************************************************
PyMethodDef Dtool_Methods_FrameBufferProperties[]= {
  { "getDepthBits",(PyCFunction ) &Dtool_FrameBufferProperties_get_depth_bits_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_depth_bits_250_comment},
  { "getColorBits",(PyCFunction ) &Dtool_FrameBufferProperties_get_color_bits_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_color_bits_251_comment},
  { "getAlphaBits",(PyCFunction ) &Dtool_FrameBufferProperties_get_alpha_bits_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_alpha_bits_252_comment},
  { "getStencilBits",(PyCFunction ) &Dtool_FrameBufferProperties_get_stencil_bits_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_stencil_bits_253_comment},
  { "getAccumBits",(PyCFunction ) &Dtool_FrameBufferProperties_get_accum_bits_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_accum_bits_254_comment},
  { "getAuxRgba",(PyCFunction ) &Dtool_FrameBufferProperties_get_aux_rgba_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_aux_rgba_255_comment},
  { "getAuxHrgba",(PyCFunction ) &Dtool_FrameBufferProperties_get_aux_hrgba_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_aux_hrgba_256_comment},
  { "getAuxFloat",(PyCFunction ) &Dtool_FrameBufferProperties_get_aux_float_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_aux_float_257_comment},
  { "getMultisamples",(PyCFunction ) &Dtool_FrameBufferProperties_get_multisamples_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_multisamples_258_comment},
  { "getCoverageSamples",(PyCFunction ) &Dtool_FrameBufferProperties_get_coverage_samples_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_coverage_samples_259_comment},
  { "getBackBuffers",(PyCFunction ) &Dtool_FrameBufferProperties_get_back_buffers_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_back_buffers_260_comment},
  { "getIndexedColor",(PyCFunction ) &Dtool_FrameBufferProperties_get_indexed_color_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_indexed_color_261_comment},
  { "getRgbColor",(PyCFunction ) &Dtool_FrameBufferProperties_get_rgb_color_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_rgb_color_262_comment},
  { "getStereo",(PyCFunction ) &Dtool_FrameBufferProperties_get_stereo_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_stereo_263_comment},
  { "getForceHardware",(PyCFunction ) &Dtool_FrameBufferProperties_get_force_hardware_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_force_hardware_264_comment},
  { "getForceSoftware",(PyCFunction ) &Dtool_FrameBufferProperties_get_force_software_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_force_software_265_comment},
  { "setDepthBits",(PyCFunction ) &Dtool_FrameBufferProperties_set_depth_bits_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_depth_bits_266_comment},
  { "setColorBits",(PyCFunction ) &Dtool_FrameBufferProperties_set_color_bits_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_color_bits_267_comment},
  { "setAlphaBits",(PyCFunction ) &Dtool_FrameBufferProperties_set_alpha_bits_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_alpha_bits_268_comment},
  { "setStencilBits",(PyCFunction ) &Dtool_FrameBufferProperties_set_stencil_bits_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_stencil_bits_269_comment},
  { "setAccumBits",(PyCFunction ) &Dtool_FrameBufferProperties_set_accum_bits_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_accum_bits_270_comment},
  { "setAuxRgba",(PyCFunction ) &Dtool_FrameBufferProperties_set_aux_rgba_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_aux_rgba_271_comment},
  { "setAuxHrgba",(PyCFunction ) &Dtool_FrameBufferProperties_set_aux_hrgba_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_aux_hrgba_272_comment},
  { "setAuxFloat",(PyCFunction ) &Dtool_FrameBufferProperties_set_aux_float_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_aux_float_273_comment},
  { "setMultisamples",(PyCFunction ) &Dtool_FrameBufferProperties_set_multisamples_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_multisamples_274_comment},
  { "setCoverageSamples",(PyCFunction ) &Dtool_FrameBufferProperties_set_coverage_samples_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_coverage_samples_275_comment},
  { "setBackBuffers",(PyCFunction ) &Dtool_FrameBufferProperties_set_back_buffers_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_back_buffers_276_comment},
  { "setIndexedColor",(PyCFunction ) &Dtool_FrameBufferProperties_set_indexed_color_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_indexed_color_277_comment},
  { "setRgbColor",(PyCFunction ) &Dtool_FrameBufferProperties_set_rgb_color_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_rgb_color_278_comment},
  { "setStereo",(PyCFunction ) &Dtool_FrameBufferProperties_set_stereo_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_stereo_279_comment},
  { "setForceHardware",(PyCFunction ) &Dtool_FrameBufferProperties_set_force_hardware_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_force_hardware_280_comment},
  { "setForceSoftware",(PyCFunction ) &Dtool_FrameBufferProperties_set_force_software_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_force_software_281_comment},
  { "assign",(PyCFunction ) &Dtool_FrameBufferProperties_operator_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_operator_284_comment},
  { "getDefault",(PyCFunction ) &Dtool_FrameBufferProperties_get_default_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_default_285_comment},
  { "eq",(PyCFunction ) &Dtool_FrameBufferProperties_operator_286, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_operator_286_comment},
  { "ne",(PyCFunction ) &Dtool_FrameBufferProperties_operator_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_operator_287_comment},
  { "clear",(PyCFunction ) &Dtool_FrameBufferProperties_clear_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_clear_288_comment},
  { "setAllSpecified",(PyCFunction ) &Dtool_FrameBufferProperties_set_all_specified_289, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_all_specified_289_comment},
  { "subsumes",(PyCFunction ) &Dtool_FrameBufferProperties_subsumes_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_subsumes_290_comment},
  { "addProperties",(PyCFunction ) &Dtool_FrameBufferProperties_add_properties_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_add_properties_291_comment},
  { "output",(PyCFunction ) &Dtool_FrameBufferProperties_output_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_output_292_comment},
  { "setOneBitPerChannel",(PyCFunction ) &Dtool_FrameBufferProperties_set_one_bit_per_channel_293, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_set_one_bit_per_channel_293_comment},
  { "isStereo",(PyCFunction ) &Dtool_FrameBufferProperties_is_stereo_294, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_is_stereo_294_comment},
  { "isSingleBuffered",(PyCFunction ) &Dtool_FrameBufferProperties_is_single_buffered_295, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_is_single_buffered_295_comment},
  { "getQuality",(PyCFunction ) &Dtool_FrameBufferProperties_get_quality_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_quality_296_comment},
  { "isAnySpecified",(PyCFunction ) &Dtool_FrameBufferProperties_is_any_specified_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_is_any_specified_297_comment},
  { "isBasic",(PyCFunction ) &Dtool_FrameBufferProperties_is_basic_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_is_basic_298_comment},
  { "getAuxMask",(PyCFunction ) &Dtool_FrameBufferProperties_get_aux_mask_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_aux_mask_299_comment},
  { "getBufferMask",(PyCFunction ) &Dtool_FrameBufferProperties_get_buffer_mask_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_get_buffer_mask_300_comment},
  { "verifyHardwareSoftware",(PyCFunction ) &Dtool_FrameBufferProperties_verify_hardware_software_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameBufferProperties_verify_hardware_software_301_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     FrameBufferProperties
//////////////////
static PyObject *  Dtool_Repr_FrameBufferProperties(PyObject * self)
{
    FrameBufferProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameBufferProperties,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_FrameBufferProperties(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FrameBufferProperties.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FrameBufferProperties\n"
          "// Description : A container for the various kinds of properties we\n"
          "//               might ask to have on a graphics frameBuffer before we\n"
          "//               create a GSG.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_FrameBufferProperties.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_FrameBufferProperties.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FrameBufferProperties.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FrameBufferProperties.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_FrameBufferProperties.As_PyTypeObject().tp_repr = & Dtool_Repr_FrameBufferProperties;
        // __str__ Repr Proxy
        Dtool_FrameBufferProperties.As_PyTypeObject().tp_str = & Dtool_Repr_FrameBufferProperties;
        if(PyType_Ready(&Dtool_FrameBufferProperties.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FrameBufferProperties)");
             printf(" Error In PyType_ReadyFrameBufferProperties");
             return;
        }
        Py_INCREF(&Dtool_FrameBufferProperties.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FrameBufferProperties.As_PyTypeObject().tp_dict,"FrameBufferProperties",&Dtool_FrameBufferProperties.As_PyObject());
        //  Static Method getDefault
        PyDict_SetItemString(Dtool_FrameBufferProperties.As_PyTypeObject().tp_dict,"getDefault",PyCFunction_New(&Dtool_Methods_FrameBufferProperties[33],&Dtool_FrameBufferProperties.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FrameBufferProperties,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FrameBufferProperties.As_PyTypeObject());
        PyModule_AddObject(module, "FrameBufferProperties",(PyObject *)&Dtool_FrameBufferProperties.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsThreadingModel | GraphicsThreadingModel
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsThreadingModel[]= {
  { "assign",(PyCFunction ) &Dtool_GraphicsThreadingModel_operator_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_operator_304_comment},
  { "getModel",(PyCFunction ) &Dtool_GraphicsThreadingModel_get_model_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_get_model_305_comment},
  { "getCullName",(PyCFunction ) &Dtool_GraphicsThreadingModel_get_cull_name_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_get_cull_name_306_comment},
  { "setCullName",(PyCFunction ) &Dtool_GraphicsThreadingModel_set_cull_name_307, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_set_cull_name_307_comment},
  { "getCullStage",(PyCFunction ) &Dtool_GraphicsThreadingModel_get_cull_stage_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_get_cull_stage_308_comment},
  { "getDrawName",(PyCFunction ) &Dtool_GraphicsThreadingModel_get_draw_name_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_get_draw_name_309_comment},
  { "setDrawName",(PyCFunction ) &Dtool_GraphicsThreadingModel_set_draw_name_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_set_draw_name_310_comment},
  { "getDrawStage",(PyCFunction ) &Dtool_GraphicsThreadingModel_get_draw_stage_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_get_draw_stage_311_comment},
  { "getCullSorting",(PyCFunction ) &Dtool_GraphicsThreadingModel_get_cull_sorting_312, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_get_cull_sorting_312_comment},
  { "setCullSorting",(PyCFunction ) &Dtool_GraphicsThreadingModel_set_cull_sorting_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_set_cull_sorting_313_comment},
  { "isSingleThreaded",(PyCFunction ) &Dtool_GraphicsThreadingModel_is_single_threaded_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_is_single_threaded_314_comment},
  { "isDefault",(PyCFunction ) &Dtool_GraphicsThreadingModel_is_default_315, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_is_default_315_comment},
  { "output",(PyCFunction ) &Dtool_GraphicsThreadingModel_output_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsThreadingModel_output_316_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     GraphicsThreadingModel
//////////////////
static PyObject *  Dtool_Repr_GraphicsThreadingModel(PyObject * self)
{
    GraphicsThreadingModel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsThreadingModel,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_GraphicsThreadingModel(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsThreadingModel\n"
          "// Description : This represents the user's specification of how a\n"
          "//               particular frame is handled by the various threads.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_repr = & Dtool_Repr_GraphicsThreadingModel;
        // __str__ Repr Proxy
        Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_str = & Dtool_Repr_GraphicsThreadingModel;
        if(PyType_Ready(&Dtool_GraphicsThreadingModel.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsThreadingModel)");
             printf(" Error In PyType_ReadyGraphicsThreadingModel");
             return;
        }
        Py_INCREF(&Dtool_GraphicsThreadingModel.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsThreadingModel.As_PyTypeObject().tp_dict,"GraphicsThreadingModel",&Dtool_GraphicsThreadingModel.As_PyObject());
        RegisterRuntimeClass(&Dtool_GraphicsThreadingModel,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsThreadingModel.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsThreadingModel",(PyObject *)&Dtool_GraphicsThreadingModel.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsDevice | GraphicsDevice
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsDevice[]= {
  { "getPipe",(PyCFunction ) &Dtool_GraphicsDevice_get_pipe_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsDevice_get_pipe_319_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsDevice_get_class_type_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsDevice_get_class_type_320_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsDevice(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsDevice.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsDevice\n"
          "// Description : An abstract device object that is part of Graphics\n"
          "//               Pipe. This device is set to NULL for OpenGL. But \n"
          "//               DirectX uses it to take control of multiple windows\n"
          "//               under single device or multiple devices (i.e. more\n"
          "//               than one adapters in the machine).   \n"
          "//\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_GraphicsDevice.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_GraphicsDevice.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsDevice.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsDevice.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsDevice.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsDevice)");
             printf(" Error In PyType_ReadyGraphicsDevice");
             return;
        }
        Py_INCREF(&Dtool_GraphicsDevice.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsDevice.As_PyTypeObject().tp_dict,"GraphicsDevice",&Dtool_GraphicsDevice.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsDevice.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsDevice[1],&Dtool_GraphicsDevice.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsDevice,GraphicsDevice::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsDevice.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsDevice",(PyObject *)&Dtool_GraphicsDevice.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsPipe | GraphicsPipe
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsPipe[]= {
  { "isValid",(PyCFunction ) &Dtool_GraphicsPipe_is_valid_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_is_valid_324_comment},
  { "getSupportedTypes",(PyCFunction ) &Dtool_GraphicsPipe_get_supported_types_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_get_supported_types_325_comment},
  { "supportsType",(PyCFunction ) &Dtool_GraphicsPipe_supports_type_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_supports_type_326_comment},
  { "getDisplayWidth",(PyCFunction ) &Dtool_GraphicsPipe_get_display_width_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_get_display_width_327_comment},
  { "getDisplayHeight",(PyCFunction ) &Dtool_GraphicsPipe_get_display_height_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_get_display_height_328_comment},
  { "getDisplayInformation",(PyCFunction ) &Dtool_GraphicsPipe_get_display_information_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_get_display_information_329_comment},
  { "lookupCpuData",(PyCFunction ) &Dtool_GraphicsPipe_lookup_cpu_data_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_lookup_cpu_data_330_comment},
  { "getInterfaceName",(PyCFunction ) &Dtool_GraphicsPipe_get_interface_name_331, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_get_interface_name_331_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsPipe_get_class_type_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipe_get_class_type_332_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsPipe(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsPipe.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsPipe\n"
          "// Description : An object to create GraphicsOutputs that share a\n"
          "//               particular 3-D API.  Normally, there will only be one\n"
          "//               GraphicsPipe in an application, although it is\n"
          "//               possible to have multiple of these at once if there\n"
          "//               are multiple different API's available in the same\n"
          "//               machine.\n"
          "//\n"
          "//               Often, the GraphicsPipe corresponds to a physical\n"
          "//               output device, hence the term \"pipe\", but this is not\n"
          "//               necessarily the case.\n"
          "//\n"
          "//               The GraphicsPipe is used by the GraphicsEngine object\n"
          "//               to create and destroy windows; it keeps ownership of\n"
          "//               the windows it creates.\n"
          "//\n"
          "//               M. Asad added new/interim functionality where GraphicsPipe\n"
          "//               now contains a device interface to directx/opengl which\n"
          "//               will be used to handle multiple windows from same device.\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_GraphicsPipe.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_GraphicsPipe.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsPipe.As_PyTypeObject().tp_dict);
        // Enum  GraphicsPipe::OutputTypes;
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"OTWindow",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"OTFullscreenWindow",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"OTBuffer",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"OTTextureBuffer",PyInt_FromLong(8));
        // Enum  GraphicsPipe::BufferCreationFlags;
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFRefuseParasite",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFRequireParasite",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFRefuseWindow",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFRequireWindow",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFCanBindColor",PyInt_FromLong(64));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFCanBindEvery",PyInt_FromLong(128));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFResizeable",PyInt_FromLong(256));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFSizeTrackHost",PyInt_FromLong(512));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFRttCumulative",PyInt_FromLong(1024));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFFbPropsOptional",PyInt_FromLong(2048));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFSizeSquare",PyInt_FromLong(4096));
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"BFSizePower2",PyInt_FromLong(8192));
        if(PyType_Ready(&Dtool_GraphicsPipe.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsPipe)");
             printf(" Error In PyType_ReadyGraphicsPipe");
             return;
        }
        Py_INCREF(&Dtool_GraphicsPipe.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"GraphicsPipe",&Dtool_GraphicsPipe.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsPipe.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsPipe[8],&Dtool_GraphicsPipe.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsPipe,GraphicsPipe::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsPipe.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsPipe",(PyObject *)&Dtool_GraphicsPipe.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StencilRenderStates | StencilRenderStates
//********************************************************************
PyMethodDef Dtool_Methods_StencilRenderStates[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StencilRenderStates(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StencilRenderStates.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StencilRenderStates\n"
          "// Description : An abstract cross-platform class for setting stencil\n"
          "//               buffer render states.  Each gsg needs to create its\n"
          "//               own low-level API specific functions on how to set\n"
          "//               each render state. The \"set_stencil_render_state\"\n"
          "//               function can be used in an immediate-mode fashion.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_StencilRenderStates.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_StencilRenderStates.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StencilRenderStates.As_PyTypeObject().tp_dict);
        // Enum  StencilRenderStates::StencilRenderState;
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSFrontEnable",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSBackEnable",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSFrontComparisonFunction",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSFrontStencilFailOperation",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSFrontStencilPassZFailOperation",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSFrontStencilPassZPassOperation",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSReference",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSReadMask",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSWriteMask",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSBackComparisonFunction",PyInt_FromLong(9));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSBackStencilFailOperation",PyInt_FromLong(10));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSBackStencilPassZFailOperation",PyInt_FromLong(11));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSBackStencilPassZPassOperation",PyInt_FromLong(12));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSClear",PyInt_FromLong(13));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSClearValue",PyInt_FromLong(14));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSTotal",PyInt_FromLong(15));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SRSFirst",PyInt_FromLong(0));
        // Enum  StencilRenderStates::StencilComparisonFunction;
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFNever",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFLessThan",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFEqual",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFLessThanOrEqual",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFGreaterThan",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFNotEqual",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFGreaterThanOrEqual",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SCFAlways",PyInt_FromLong(7));
        // Enum  StencilRenderStates::StencilOperation;
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SOKeep",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SOZero",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SOReplace",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SOIncrement",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SODecrement",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SOInvert",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SOIncrementSaturate",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"SODecrementSaturate",PyInt_FromLong(7));
        if(PyType_Ready(&Dtool_StencilRenderStates.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StencilRenderStates)");
             printf(" Error In PyType_ReadyStencilRenderStates");
             return;
        }
        Py_INCREF(&Dtool_StencilRenderStates.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StencilRenderStates.As_PyTypeObject().tp_dict,"StencilRenderStates",&Dtool_StencilRenderStates.As_PyObject());
        RegisterRuntimeClass(&Dtool_StencilRenderStates,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StencilRenderStates.As_PyTypeObject());
        PyModule_AddObject(module, "StencilRenderStates",(PyObject *)&Dtool_StencilRenderStates.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsStateGuardian | GraphicsStateGuardian
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsStateGuardian[]= {
  { "releaseAll",(PyCFunction ) &Dtool_GraphicsStateGuardian_release_all_341, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_release_all_341_comment},
  { "releaseAllTextures",(PyCFunction ) &Dtool_GraphicsStateGuardian_release_all_textures_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_release_all_textures_342_comment},
  { "releaseAllGeoms",(PyCFunction ) &Dtool_GraphicsStateGuardian_release_all_geoms_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_release_all_geoms_343_comment},
  { "releaseAllVertexBuffers",(PyCFunction ) &Dtool_GraphicsStateGuardian_release_all_vertex_buffers_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_release_all_vertex_buffers_344_comment},
  { "releaseAllIndexBuffers",(PyCFunction ) &Dtool_GraphicsStateGuardian_release_all_index_buffers_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_release_all_index_buffers_345_comment},
  { "setActive",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_active_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_active_346_comment},
  { "isActive",(PyCFunction ) &Dtool_GraphicsStateGuardian_is_active_347, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_is_active_347_comment},
  { "isValid",(PyCFunction ) &Dtool_GraphicsStateGuardian_is_valid_348, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_is_valid_348_comment},
  { "needsReset",(PyCFunction ) &Dtool_GraphicsStateGuardian_needs_reset_349, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_needs_reset_349_comment},
  { "setIncompleteRender",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_incomplete_render_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_incomplete_render_350_comment},
  { "setLoader",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_loader_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_loader_351_comment},
  { "getLoader",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_loader_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_loader_352_comment},
  { "getPipe",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_pipe_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_pipe_353_comment},
  { "getEngine",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_engine_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_engine_354_comment},
  { "getThreadingModel",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_threading_model_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_threading_model_355_comment},
  { "isHardware",(PyCFunction ) &Dtool_GraphicsStateGuardian_is_hardware_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_is_hardware_356_comment},
  { "getMaxTextureStages",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_texture_stages_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_texture_stages_357_comment},
  { "getMax3dTextureDimension",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_358_comment},
  { "getMax2dTextureArrayLayers",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_359_comment},
  { "getMaxCubeMapDimension",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_360_comment},
  { "getSupportsTextureCombine",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_texture_combine_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_texture_combine_361_comment},
  { "getSupportsTextureSavedResult",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_362_comment},
  { "getSupportsTextureDot3",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_texture_dot3_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_texture_dot3_363_comment},
  { "getSupports3dTexture",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_3d_texture_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_3d_texture_364_comment},
  { "getSupports2dTextureArray",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_365_comment},
  { "getSupportsCubeMap",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_cube_map_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_cube_map_366_comment},
  { "getSupportsTexNonPow2",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_367_comment},
  { "getSupportsCompressedTexture",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_compressed_texture_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_compressed_texture_368_comment},
  { "getMaxLights",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_lights_369, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_lights_369_comment},
  { "getMaxClipPlanes",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_clip_planes_370, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_clip_planes_370_comment},
  { "getMaxVertexTransforms",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_vertex_transforms_371, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_vertex_transforms_371_comment},
  { "getMaxVertexTransformIndices",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_372, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_372_comment},
  { "getCopyTextureInverted",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_copy_texture_inverted_373, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_copy_texture_inverted_373_comment},
  { "getSupportsGenerateMipmap",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_374, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_374_comment},
  { "getSupportsRenderTexture",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_render_texture_375, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_render_texture_375_comment},
  { "getSupportsDepthTexture",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_depth_texture_376, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_depth_texture_376_comment},
  { "getSupportsDepthStencil",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_depth_stencil_377, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_depth_stencil_377_comment},
  { "getSupportsBasicShaders",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_basic_shaders_378, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_basic_shaders_378_comment},
  { "getSupportsGlsl",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_glsl_379, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_glsl_379_comment},
  { "getSupportsStencil",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_stencil_380, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_stencil_380_comment},
  { "getSupportsTwoSidedStencil",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_381, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_381_comment},
  { "getSupportsGeometryInstancing",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_382, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_382_comment},
  { "getMaximumSimultaneousRenderTargets",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_383, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_383_comment},
  { "getShaderModel",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_shader_model_384, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_shader_model_384_comment},
  { "setShaderModel",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_shader_model_385, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_shader_model_385_comment},
  { "getSupportsCgProfile",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_supports_cg_profile_386, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_supports_cg_profile_386_comment},
  { "getColorScaleViaLighting",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_387, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_387_comment},
  { "getAlphaScaleViaTexture",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_388, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_388_comment},
  { "getRuntimeColorScale",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_runtime_color_scale_389, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_runtime_color_scale_389_comment},
  { "getAlphaScaleTextureStage",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_390, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_390_comment},
  { "setCoordinateSystem",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_coordinate_system_391, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_coordinate_system_391_comment},
  { "getCoordinateSystem",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_coordinate_system_392, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_coordinate_system_392_comment},
  { "getInternalCoordinateSystem",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_internal_coordinate_system_393, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_internal_coordinate_system_393_comment},
  { "getPreparedObjects",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_prepared_objects_394, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_prepared_objects_394_comment},
  { "setGamma",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_gamma_395, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_gamma_395_comment},
  { "getGamma",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_gamma_396, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_gamma_396_comment},
  { "restoreGamma",(PyCFunction ) &Dtool_GraphicsStateGuardian_restore_gamma_397, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_restore_gamma_397_comment},
  { "setTextureQualityOverride",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_texture_quality_override_398, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_texture_quality_override_398_comment},
  { "getTextureQualityOverride",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_texture_quality_override_399, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_texture_quality_override_399_comment},
  { "getPreparedTextures",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_prepared_textures_400, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_prepared_textures_400_comment},
  { "setScene",(PyCFunction ) &Dtool_GraphicsStateGuardian_set_scene_402, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_set_scene_402_comment},
  { "getScene",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_scene_403, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_scene_403_comment},
  { "beginScene",(PyCFunction ) &Dtool_GraphicsStateGuardian_begin_scene_404, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_begin_scene_404_comment},
  { "endScene",(PyCFunction ) &Dtool_GraphicsStateGuardian_end_scene_405, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_end_scene_405_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsStateGuardian_get_class_type_406, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardian_get_class_type_406_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsStateGuardian(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsStateGuardian\n"
          "// Description : Encapsulates all the communication with a particular\n"
          "//               instance of a given rendering backend.  Tries to\n"
          "//               guarantee that redundant state-change requests are\n"
          "//               not issued (hence \"state guardian\").\n"
          "//\n"
          "//               There will be one of these objects for each different\n"
          "//               graphics context active in the system.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GraphicsStateGuardianBase._Dtool_ClassInit(NULL);
        Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GraphicsStateGuardianBase.As_PyTypeObject());
        Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict);
        // Enum  GraphicsStateGuardian::ShaderModel;
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"SM00",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"SM11",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"SM20",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"SM2X",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"SM30",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"SM40",PyInt_FromLong(5));
        if(PyType_Ready(&Dtool_GraphicsStateGuardian.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsStateGuardian)");
             printf(" Error In PyType_ReadyGraphicsStateGuardian");
             return;
        }
        Py_INCREF(&Dtool_GraphicsStateGuardian.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"GraphicsStateGuardian",&Dtool_GraphicsStateGuardian.As_PyObject());
        //  Static Method getAlphaScaleTextureStage
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"getAlphaScaleTextureStage",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardian[49],&Dtool_GraphicsStateGuardian.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsStateGuardian.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardian[64],&Dtool_GraphicsStateGuardian.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsStateGuardian,GraphicsStateGuardian::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsStateGuardian.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsStateGuardian",(PyObject *)&Dtool_GraphicsStateGuardian.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StereoDisplayRegion | StereoDisplayRegion
//********************************************************************
PyMethodDef Dtool_Methods_StereoDisplayRegion[]= {
  { "getLeftEye",(PyCFunction ) &Dtool_StereoDisplayRegion_get_left_eye_408, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StereoDisplayRegion_get_left_eye_408_comment},
  { "getRightEye",(PyCFunction ) &Dtool_StereoDisplayRegion_get_right_eye_409, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StereoDisplayRegion_get_right_eye_409_comment},
  { "getClassType",(PyCFunction ) &Dtool_StereoDisplayRegion_get_class_type_410, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StereoDisplayRegion_get_class_type_410_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StereoDisplayRegion(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StereoDisplayRegion.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StereoDisplayRegion\n"
          "// Description : This is a special DisplayRegion wrapper that actually\n"
          "//               includes a pair of DisplayRegions internally: the\n"
          "//               left and right eyes.  The DisplayRegion represented\n"
          "//               here does not have a physical association with the\n"
          "//               window, but it pretends it does.  Instead, it\n"
          "//               maintains a pointer to the left and right\n"
          "//               DisplayRegions separately.\n"
          "//\n"
          "//               Operations on the StereoDisplayRegion object affect\n"
          "//               both left and right eyes together.  To access the\n"
          "//               left or right eyes independently, use get_left_eye()\n"
          "//               and get_right_eye().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DisplayRegion._Dtool_ClassInit(NULL);
        Dtool_StereoDisplayRegion.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DisplayRegion.As_PyTypeObject());
        Dtool_StereoDisplayRegion.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StereoDisplayRegion.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StereoDisplayRegion.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StereoDisplayRegion.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StereoDisplayRegion)");
             printf(" Error In PyType_ReadyStereoDisplayRegion");
             return;
        }
        Py_INCREF(&Dtool_StereoDisplayRegion.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StereoDisplayRegion.As_PyTypeObject().tp_dict,"StereoDisplayRegion",&Dtool_StereoDisplayRegion.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_StereoDisplayRegion.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_StereoDisplayRegion[2],&Dtool_StereoDisplayRegion.As_PyObject()));
        RegisterRuntimeClass(&Dtool_StereoDisplayRegion,StereoDisplayRegion::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StereoDisplayRegion.As_PyTypeObject());
        PyModule_AddObject(module, "StereoDisplayRegion",(PyObject *)&Dtool_StereoDisplayRegion.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsOutput | GraphicsOutput
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsOutput[]= {
  { "getGsg",(PyCFunction ) &Dtool_GraphicsOutput_get_gsg_420, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_gsg_420_comment},
  { "getPipe",(PyCFunction ) &Dtool_GraphicsOutput_get_pipe_421, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_pipe_421_comment},
  { "getEngine",(PyCFunction ) &Dtool_GraphicsOutput_get_engine_422, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_engine_422_comment},
  { "getName",(PyCFunction ) &Dtool_GraphicsOutput_get_name_423, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_name_423_comment},
  { "countTextures",(PyCFunction ) &Dtool_GraphicsOutput_count_textures_424, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_count_textures_424_comment},
  { "hasTexture",(PyCFunction ) &Dtool_GraphicsOutput_has_texture_425, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_has_texture_425_comment},
  { "getTexture",(PyCFunction ) &Dtool_GraphicsOutput_get_texture_426, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_texture_426_comment},
  { "getTexturePlane",(PyCFunction ) &Dtool_GraphicsOutput_get_texture_plane_427, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_texture_plane_427_comment},
  { "getRtmMode",(PyCFunction ) &Dtool_GraphicsOutput_get_rtm_mode_428, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_rtm_mode_428_comment},
  { "clearRenderTextures",(PyCFunction ) &Dtool_GraphicsOutput_clear_render_textures_429, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_clear_render_textures_429_comment},
  { "addRenderTexture",(PyCFunction ) &Dtool_GraphicsOutput_add_render_texture_430, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_add_render_texture_430_comment},
  { "setupRenderTexture",(PyCFunction ) &Dtool_GraphicsOutput_setup_render_texture_431, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_setup_render_texture_431_comment},
  { "getXSize",(PyCFunction ) &Dtool_GraphicsOutput_get_x_size_432, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_x_size_432_comment},
  { "getYSize",(PyCFunction ) &Dtool_GraphicsOutput_get_y_size_433, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_y_size_433_comment},
  { "getFbXSize",(PyCFunction ) &Dtool_GraphicsOutput_get_fb_x_size_434, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_fb_x_size_434_comment},
  { "getFbYSize",(PyCFunction ) &Dtool_GraphicsOutput_get_fb_y_size_435, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_fb_y_size_435_comment},
  { "hasSize",(PyCFunction ) &Dtool_GraphicsOutput_has_size_436, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_has_size_436_comment},
  { "isValid",(PyCFunction ) &Dtool_GraphicsOutput_is_valid_437, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_is_valid_437_comment},
  { "setActive",(PyCFunction ) &Dtool_GraphicsOutput_set_active_438, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_set_active_438_comment},
  { "isActive",(PyCFunction ) &Dtool_GraphicsOutput_is_active_439, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_is_active_439_comment},
  { "setOneShot",(PyCFunction ) &Dtool_GraphicsOutput_set_one_shot_440, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_set_one_shot_440_comment},
  { "getOneShot",(PyCFunction ) &Dtool_GraphicsOutput_get_one_shot_441, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_one_shot_441_comment},
  { "setInverted",(PyCFunction ) &Dtool_GraphicsOutput_set_inverted_442, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_set_inverted_442_comment},
  { "getInverted",(PyCFunction ) &Dtool_GraphicsOutput_get_inverted_443, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_inverted_443_comment},
  { "setRedBlueStereo",(PyCFunction ) &Dtool_GraphicsOutput_set_red_blue_stereo_444, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_set_red_blue_stereo_444_comment},
  { "getRedBlueStereo",(PyCFunction ) &Dtool_GraphicsOutput_get_red_blue_stereo_445, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_red_blue_stereo_445_comment},
  { "getLeftEyeColorMask",(PyCFunction ) &Dtool_GraphicsOutput_get_left_eye_color_mask_446, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_left_eye_color_mask_446_comment},
  { "getRightEyeColorMask",(PyCFunction ) &Dtool_GraphicsOutput_get_right_eye_color_mask_447, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_right_eye_color_mask_447_comment},
  { "getFbProperties",(PyCFunction ) &Dtool_GraphicsOutput_get_fb_properties_448, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_fb_properties_448_comment},
  { "isStereo",(PyCFunction ) &Dtool_GraphicsOutput_is_stereo_449, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_is_stereo_449_comment},
  { "clearDeleteFlag",(PyCFunction ) &Dtool_GraphicsOutput_clear_delete_flag_450, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_clear_delete_flag_450_comment},
  { "getDeleteFlag",(PyCFunction ) &Dtool_GraphicsOutput_get_delete_flag_451, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_delete_flag_451_comment},
  { "setSort",(PyCFunction ) &Dtool_GraphicsOutput_set_sort_452, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_set_sort_452_comment},
  { "getSort",(PyCFunction ) &Dtool_GraphicsOutput_get_sort_453, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_sort_453_comment},
  { "setChildSort",(PyCFunction ) &Dtool_GraphicsOutput_set_child_sort_454, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_set_child_sort_454_comment},
  { "clearChildSort",(PyCFunction ) &Dtool_GraphicsOutput_clear_child_sort_455, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_clear_child_sort_455_comment},
  { "getChildSort",(PyCFunction ) &Dtool_GraphicsOutput_get_child_sort_456, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_child_sort_456_comment},
  { "triggerCopy",(PyCFunction ) &Dtool_GraphicsOutput_trigger_copy_457, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_trigger_copy_457_comment},
  { "makeDisplayRegion",(PyCFunction ) &Dtool_GraphicsOutput_make_display_region_458, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_make_display_region_458_comment},
  { "makeMonoDisplayRegion",(PyCFunction ) &Dtool_GraphicsOutput_make_mono_display_region_459, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_make_mono_display_region_459_comment},
  { "makeStereoDisplayRegion",(PyCFunction ) &Dtool_GraphicsOutput_make_stereo_display_region_460, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_make_stereo_display_region_460_comment},
  { "removeDisplayRegion",(PyCFunction ) &Dtool_GraphicsOutput_remove_display_region_461, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_remove_display_region_461_comment},
  { "removeAllDisplayRegions",(PyCFunction ) &Dtool_GraphicsOutput_remove_all_display_regions_462, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_remove_all_display_regions_462_comment},
  { "getNumDisplayRegions",(PyCFunction ) &Dtool_GraphicsOutput_get_num_display_regions_463, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_num_display_regions_463_comment},
  { "getDisplayRegion",(PyCFunction ) &Dtool_GraphicsOutput_get_display_region_464, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_display_region_464_comment},
  { "getNumActiveDisplayRegions",(PyCFunction ) &Dtool_GraphicsOutput_get_num_active_display_regions_465, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_num_active_display_regions_465_comment},
  { "getActiveDisplayRegion",(PyCFunction ) &Dtool_GraphicsOutput_get_active_display_region_466, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_active_display_region_466_comment},
  { "makeTextureBuffer",(PyCFunction ) &Dtool_GraphicsOutput_make_texture_buffer_467, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_make_texture_buffer_467_comment},
  { "makeCubeMap",(PyCFunction ) &Dtool_GraphicsOutput_make_cube_map_468, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_make_cube_map_468_comment},
  { "makeScreenshotFilename",(PyCFunction ) &Dtool_GraphicsOutput_make_screenshot_filename_469, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_make_screenshot_filename_469_comment},
  { "saveScreenshotDefault",(PyCFunction ) &Dtool_GraphicsOutput_save_screenshot_default_470, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_save_screenshot_default_470_comment},
  { "saveScreenshot",(PyCFunction ) &Dtool_GraphicsOutput_save_screenshot_471, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_save_screenshot_471_comment},
  { "getScreenshot",(PyCFunction ) &Dtool_GraphicsOutput_get_screenshot_472, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_screenshot_472_comment},
  { "getTextureCard",(PyCFunction ) &Dtool_GraphicsOutput_get_texture_card_473, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_texture_card_473_comment},
  { "shareDepthBuffer",(PyCFunction ) &Dtool_GraphicsOutput_share_depth_buffer_474, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_share_depth_buffer_474_comment},
  { "unshareDepthBuffer",(PyCFunction ) &Dtool_GraphicsOutput_unshare_depth_buffer_475, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_unshare_depth_buffer_475_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsOutput_get_class_type_476, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_get_class_type_476_comment},
  { "upcastToGraphicsOutputBase",(PyCFunction ) &Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_413, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_413_comment},
  { "upcastToDrawableRegion",(PyCFunction ) &Dtool_GraphicsOutput_upcast_to_DrawableRegion_415, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutput_upcast_to_DrawableRegion_415_comment},
  { "getDisplayRegions",(PyCFunction) &MakeSeq_GraphicsOutput_get_display_regions, METH_NOARGS, NULL},
  { "getActiveDisplayRegions",(PyCFunction) &MakeSeq_GraphicsOutput_get_active_display_regions, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsOutput(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsOutput.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsOutput\n"
          "// Description : This is a base class for the various different\n"
          "//               classes that represent the result of a frame of\n"
          "//               rendering.  The most common kind of GraphicsOutput is\n"
          "//               a GraphicsWindow, which is a real-time window on the\n"
          "//               desktop, but another example is GraphicsBuffer, which\n"
          "//               is an offscreen buffer.\n"
          "//\n"
          "//               The actual rendering, and anything associated with\n"
          "//               the graphics context itself, is managed by the\n"
          "//               associated GraphicsStateGuardian (which might output\n"
          "//               to multiple GraphicsOutput objects).\n"
          "//\n"
          "//               GraphicsOutputs are not actually writable to bam\n"
          "//               files, of course, but they may be passed as event\n"
          "//               parameters, so they inherit from\n"
          "//               TypedWritableReferenceCount instead of\n"
          "//               TypedReferenceCount for that convenience.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GraphicsOutputBase._Dtool_ClassInit(NULL);
        Dtool_DrawableRegion._Dtool_ClassInit(NULL);
        Dtool_GraphicsOutput.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_GraphicsOutputBase.As_PyTypeObject(),&Dtool_DrawableRegion.As_PyTypeObject());
        Dtool_GraphicsOutput.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsOutput.As_PyTypeObject().tp_dict);
        // Enum  GraphicsOutput::RenderTextureMode;
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"RTMNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"RTMBindOrCopy",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"RTMCopyTexture",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"RTMCopyRam",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"RTMTriggeredCopyTexture",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"RTMTriggeredCopyRam",PyInt_FromLong(5));
        // Enum  GraphicsOutput::FrameMode;
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"FMRender",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"FMParasite",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"FMRefresh",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_GraphicsOutput.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsOutput)");
             printf(" Error In PyType_ReadyGraphicsOutput");
             return;
        }
        Py_INCREF(&Dtool_GraphicsOutput.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"GraphicsOutput",&Dtool_GraphicsOutput.As_PyObject());
        //  Static Method makeScreenshotFilename
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"makeScreenshotFilename",PyCFunction_New(&Dtool_Methods_GraphicsOutput[49],&Dtool_GraphicsOutput.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsOutput.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsOutput[56],&Dtool_GraphicsOutput.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsOutput,GraphicsOutput::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsOutput.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsOutput",(PyObject *)&Dtool_GraphicsOutput.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsBuffer | GraphicsBuffer
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsBuffer[]= {
  { "setSize",(PyCFunction ) &Dtool_GraphicsBuffer_set_size_478, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsBuffer_set_size_478_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsBuffer_get_class_type_479, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsBuffer_get_class_type_479_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsBuffer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsBuffer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsBuffer\n"
          "// Description : An offscreen buffer for rendering into.  This is\n"
          "//               similar in function to a GraphicsWindow, except that\n"
          "//               the output is not visible to the user.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GraphicsOutput._Dtool_ClassInit(NULL);
        Dtool_GraphicsBuffer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GraphicsOutput.As_PyTypeObject());
        Dtool_GraphicsBuffer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsBuffer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsBuffer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsBuffer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsBuffer)");
             printf(" Error In PyType_ReadyGraphicsBuffer");
             return;
        }
        Py_INCREF(&Dtool_GraphicsBuffer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsBuffer.As_PyTypeObject().tp_dict,"GraphicsBuffer",&Dtool_GraphicsBuffer.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsBuffer.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsBuffer[1],&Dtool_GraphicsBuffer.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsBuffer,GraphicsBuffer::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsBuffer.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsBuffer",(PyObject *)&Dtool_GraphicsBuffer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TouchInfo | TouchInfo
//********************************************************************
PyMethodDef Dtool_Methods_TouchInfo[]= {
  { "getX",(PyCFunction ) &Dtool_TouchInfo_get_x_482, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TouchInfo_get_x_482_comment},
  { "getY",(PyCFunction ) &Dtool_TouchInfo_get_y_483, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TouchInfo_get_y_483_comment},
  { "getId",(PyCFunction ) &Dtool_TouchInfo_get_id_484, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TouchInfo_get_id_484_comment},
  { "getFlags",(PyCFunction ) &Dtool_TouchInfo_get_flags_485, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TouchInfo_get_flags_485_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TouchInfo(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TouchInfo.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TouchInfo\n"
          "// Description : Stores information for a single touch event.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TouchInfo.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TouchInfo.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TouchInfo.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TouchInfo.As_PyTypeObject().tp_dict);
        // Enum  TouchInfo::TouchInfoFlags;
        PyDict_SetItemString(Dtool_TouchInfo.As_PyTypeObject().tp_dict,"TIFMove",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TouchInfo.As_PyTypeObject().tp_dict,"TIFDown",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TouchInfo.As_PyTypeObject().tp_dict,"TIFUp",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_TouchInfo.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TouchInfo)");
             printf(" Error In PyType_ReadyTouchInfo");
             return;
        }
        Py_INCREF(&Dtool_TouchInfo.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TouchInfo.As_PyTypeObject().tp_dict,"TouchInfo",&Dtool_TouchInfo.As_PyObject());
        RegisterRuntimeClass(&Dtool_TouchInfo,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TouchInfo.As_PyTypeObject());
        PyModule_AddObject(module, "TouchInfo",(PyObject *)&Dtool_TouchInfo.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsWindowProcCallbackData | GraphicsWindowProcCallbackData
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsWindowProcCallbackData[]= {
  { "getHwnd",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_hwnd_488, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_hwnd_488_comment},
  { "getMsg",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_msg_489, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_msg_489_comment},
  { "getWparam",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_wparam_490, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_wparam_490_comment},
  { "getLparam",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_lparam_491, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_lparam_491_comment},
  { "isTouchEvent",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_is_touch_event_492, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_is_touch_event_492_comment},
  { "getNumTouches",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_num_touches_493, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_num_touches_493_comment},
  { "getTouchInfo",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_touch_info_494, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_touch_info_494_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsWindowProcCallbackData_get_class_type_495, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindowProcCallbackData_get_class_type_495_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsWindowProcCallbackData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsWindowProcCallbackData\n"
          "// Description : This specialization on CallbackData is passed when\n"
          "//               the callback is initiated from from an implementation\n"
          "//               of the GraphicsWindowProc class, such as PythonGraphicsWindowProc.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CallbackData._Dtool_ClassInit(NULL);
        Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CallbackData.As_PyTypeObject());
        Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsWindowProcCallbackData)");
             printf(" Error In PyType_ReadyGraphicsWindowProcCallbackData");
             return;
        }
        Py_INCREF(&Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_dict,"GraphicsWindowProcCallbackData",&Dtool_GraphicsWindowProcCallbackData.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsWindowProcCallbackData[7],&Dtool_GraphicsWindowProcCallbackData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsWindowProcCallbackData,GraphicsWindowProcCallbackData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsWindowProcCallbackData",(PyObject *)&Dtool_GraphicsWindowProcCallbackData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsWindow | GraphicsWindow
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsWindow[]= {
  { "getProperties",(PyCFunction ) &Dtool_GraphicsWindow_get_properties_498, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_properties_498_comment},
  { "getRequestedProperties",(PyCFunction ) &Dtool_GraphicsWindow_get_requested_properties_499, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_requested_properties_499_comment},
  { "clearRejectedProperties",(PyCFunction ) &Dtool_GraphicsWindow_clear_rejected_properties_500, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_clear_rejected_properties_500_comment},
  { "getRejectedProperties",(PyCFunction ) &Dtool_GraphicsWindow_get_rejected_properties_501, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_rejected_properties_501_comment},
  { "requestProperties",(PyCFunction ) &Dtool_GraphicsWindow_request_properties_502, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_request_properties_502_comment},
  { "isClosed",(PyCFunction ) &Dtool_GraphicsWindow_is_closed_503, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_is_closed_503_comment},
  { "isFullscreen",(PyCFunction ) &Dtool_GraphicsWindow_is_fullscreen_504, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_is_fullscreen_504_comment},
  { "setWindowEvent",(PyCFunction ) &Dtool_GraphicsWindow_set_window_event_505, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_set_window_event_505_comment},
  { "getWindowEvent",(PyCFunction ) &Dtool_GraphicsWindow_get_window_event_506, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_window_event_506_comment},
  { "setCloseRequestEvent",(PyCFunction ) &Dtool_GraphicsWindow_set_close_request_event_507, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_set_close_request_event_507_comment},
  { "getCloseRequestEvent",(PyCFunction ) &Dtool_GraphicsWindow_get_close_request_event_508, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_close_request_event_508_comment},
  { "getWindowHandle",(PyCFunction ) &Dtool_GraphicsWindow_get_window_handle_509, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_window_handle_509_comment},
  { "getNumInputDevices",(PyCFunction ) &Dtool_GraphicsWindow_get_num_input_devices_510, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_num_input_devices_510_comment},
  { "getInputDeviceName",(PyCFunction ) &Dtool_GraphicsWindow_get_input_device_name_511, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_input_device_name_511_comment},
  { "hasPointer",(PyCFunction ) &Dtool_GraphicsWindow_has_pointer_512, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_has_pointer_512_comment},
  { "hasKeyboard",(PyCFunction ) &Dtool_GraphicsWindow_has_keyboard_513, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_has_keyboard_513_comment},
  { "enablePointerEvents",(PyCFunction ) &Dtool_GraphicsWindow_enable_pointer_events_514, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_enable_pointer_events_514_comment},
  { "disablePointerEvents",(PyCFunction ) &Dtool_GraphicsWindow_disable_pointer_events_515, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_disable_pointer_events_515_comment},
  { "enablePointerMode",(PyCFunction ) &Dtool_GraphicsWindow_enable_pointer_mode_516, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_enable_pointer_mode_516_comment},
  { "disablePointerMode",(PyCFunction ) &Dtool_GraphicsWindow_disable_pointer_mode_517, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_disable_pointer_mode_517_comment},
  { "getPointer",(PyCFunction ) &Dtool_GraphicsWindow_get_pointer_518, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_pointer_518_comment},
  { "movePointer",(PyCFunction ) &Dtool_GraphicsWindow_move_pointer_519, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_move_pointer_519_comment},
  { "closeIme",(PyCFunction ) &Dtool_GraphicsWindow_close_ime_520, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_close_ime_520_comment},
  { "addPythonEventHandler",(PyCFunction ) &Dtool_GraphicsWindow_add_python_event_handler_521, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_add_python_event_handler_521_comment},
  { "removePythonEventHandler",(PyCFunction ) &Dtool_GraphicsWindow_remove_python_event_handler_522, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_remove_python_event_handler_522_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsWindow_get_class_type_523, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsWindow_get_class_type_523_comment},
  { "getInputDeviceNames",(PyCFunction) &MakeSeq_GraphicsWindow_get_input_device_names, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsWindow(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsWindow.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsWindow\n"
          "// Description : A window, fullscreen or on a desktop, into which a\n"
          "//               graphics device sends its output for interactive\n"
          "//               display.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GraphicsOutput._Dtool_ClassInit(NULL);
        Dtool_GraphicsWindow.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GraphicsOutput.As_PyTypeObject());
        Dtool_GraphicsWindow.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsWindow.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsWindow.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsWindow.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsWindow)");
             printf(" Error In PyType_ReadyGraphicsWindow");
             return;
        }
        Py_INCREF(&Dtool_GraphicsWindow.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsWindow.As_PyTypeObject().tp_dict,"GraphicsWindow",&Dtool_GraphicsWindow.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsWindow.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsWindow[25],&Dtool_GraphicsWindow.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsWindow,GraphicsWindow::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsWindow.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsWindow",(PyObject *)&Dtool_GraphicsWindow.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NativeWindowHandle | NativeWindowHandle
//********************************************************************
PyMethodDef Dtool_Methods_NativeWindowHandle[]= {
  { "makeInt",(PyCFunction ) &Dtool_NativeWindowHandle_make_int_525, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NativeWindowHandle_make_int_525_comment},
  { "makeSubprocess",(PyCFunction ) &Dtool_NativeWindowHandle_make_subprocess_526, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NativeWindowHandle_make_subprocess_526_comment},
  { "getClassType",(PyCFunction ) &Dtool_NativeWindowHandle_get_class_type_527, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NativeWindowHandle_get_class_type_527_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NativeWindowHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NativeWindowHandle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NativeWindowHandle\n"
          "// Description : This subclass of WindowHandle exists to allow simple\n"
          "//               creation of a WindowHandle of the appropriate type to\n"
          "//               the current OS.\n"
          "//\n"
          "//               This class exists for name scoping only.  Don't use\n"
          "//               the constructor directly; use one of the make_*\n"
          "//               methods.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_WindowHandle._Dtool_ClassInit(NULL);
        Dtool_NativeWindowHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_WindowHandle.As_PyTypeObject());
        Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NativeWindowHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NativeWindowHandle)");
             printf(" Error In PyType_ReadyNativeWindowHandle");
             return;
        }
        Py_INCREF(&Dtool_NativeWindowHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict,"NativeWindowHandle",&Dtool_NativeWindowHandle.As_PyObject());
        //  Static Method makeInt
        PyDict_SetItemString(Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict,"makeInt",PyCFunction_New(&Dtool_Methods_NativeWindowHandle[0],&Dtool_NativeWindowHandle.As_PyObject()));
        //  Static Method makeSubprocess
        PyDict_SetItemString(Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict,"makeSubprocess",PyCFunction_New(&Dtool_Methods_NativeWindowHandle[1],&Dtool_NativeWindowHandle.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NativeWindowHandle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NativeWindowHandle[2],&Dtool_NativeWindowHandle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NativeWindowHandle,NativeWindowHandle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NativeWindowHandle.As_PyTypeObject());
        PyModule_AddObject(module, "NativeWindowHandle",(PyObject *)&Dtool_NativeWindowHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ParasiteBuffer | ParasiteBuffer
//********************************************************************
PyMethodDef Dtool_Methods_ParasiteBuffer[]= {
  { "setSize",(PyCFunction ) &Dtool_ParasiteBuffer_set_size_530, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParasiteBuffer_set_size_530_comment},
  { "getClassType",(PyCFunction ) &Dtool_ParasiteBuffer_get_class_type_531, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParasiteBuffer_get_class_type_531_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ParasiteBuffer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ParasiteBuffer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ParasiteBuffer\n"
          "// Description : This is a special GraphicsOutput type that acts a lot\n"
          "//               like a GraphicsBuffer, effectively allowing rendering\n"
          "//               to an offscreen buffer, except it does not create any\n"
          "//               framebuffer space for itself.  Instead, it renders\n"
          "//               into the framebuffer owned by some other\n"
          "//               GraphicsOutput.\n"
          "//\n"
          "//               The x_size and y_size must therefore fit within the\n"
          "//               bounds of the source GraphicsOutput.\n"
          "//\n"
          "//               Since the framebuffer will be subsequently cleared\n"
          "//               when the actual owner draws in it later, this only\n"
          "//               makes sense if we are going to copy the contents of\n"
          "//               the framebuffer to a texture immediately after we\n"
          "//               draw it.  Thus, has_texture() is implicitly true for\n"
          "//               a ParasiteBuffer.\n"
          "//\n"
          "//               This class is useful to render offscreen to a texture\n"
          "//               while preventing the waste of framebuffer memory for\n"
          "//               API's that are unable to render directly into a\n"
          "//               texture (and must render into a separate framebuffer\n"
          "//               first and then copy to texture).  It is also the only\n"
          "//               way to render to a texture on API's that do not\n"
          "//               support offscreen rendering.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GraphicsOutput._Dtool_ClassInit(NULL);
        Dtool_ParasiteBuffer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GraphicsOutput.As_PyTypeObject());
        Dtool_ParasiteBuffer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ParasiteBuffer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ParasiteBuffer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ParasiteBuffer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ParasiteBuffer)");
             printf(" Error In PyType_ReadyParasiteBuffer");
             return;
        }
        Py_INCREF(&Dtool_ParasiteBuffer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ParasiteBuffer.As_PyTypeObject().tp_dict,"ParasiteBuffer",&Dtool_ParasiteBuffer.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ParasiteBuffer.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ParasiteBuffer[1],&Dtool_ParasiteBuffer.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ParasiteBuffer,ParasiteBuffer::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ParasiteBuffer.As_PyTypeObject());
        PyModule_AddObject(module, "ParasiteBuffer",(PyObject *)&Dtool_ParasiteBuffer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsEngine | GraphicsEngine
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsEngine[]= {
  { "setThreadingModel",(PyCFunction ) &Dtool_GraphicsEngine_set_threading_model_535, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_set_threading_model_535_comment},
  { "getThreadingModel",(PyCFunction ) &Dtool_GraphicsEngine_get_threading_model_536, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_threading_model_536_comment},
  { "setAutoFlip",(PyCFunction ) &Dtool_GraphicsEngine_set_auto_flip_537, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_set_auto_flip_537_comment},
  { "getAutoFlip",(PyCFunction ) &Dtool_GraphicsEngine_get_auto_flip_538, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_auto_flip_538_comment},
  { "setPortalCull",(PyCFunction ) &Dtool_GraphicsEngine_set_portal_cull_539, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_set_portal_cull_539_comment},
  { "getPortalCull",(PyCFunction ) &Dtool_GraphicsEngine_get_portal_cull_540, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_portal_cull_540_comment},
  { "setDefaultLoader",(PyCFunction ) &Dtool_GraphicsEngine_set_default_loader_541, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_set_default_loader_541_comment},
  { "getDefaultLoader",(PyCFunction ) &Dtool_GraphicsEngine_get_default_loader_542, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_default_loader_542_comment},
  { "makeOutput",(PyCFunction ) &Dtool_GraphicsEngine_make_output_543, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_make_output_543_comment},
  { "makeBuffer",(PyCFunction ) &Dtool_GraphicsEngine_make_buffer_544, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_make_buffer_544_comment},
  { "makeParasite",(PyCFunction ) &Dtool_GraphicsEngine_make_parasite_545, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_make_parasite_545_comment},
  { "removeWindow",(PyCFunction ) &Dtool_GraphicsEngine_remove_window_546, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_remove_window_546_comment},
  { "removeAllWindows",(PyCFunction ) &Dtool_GraphicsEngine_remove_all_windows_547, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_remove_all_windows_547_comment},
  { "resetAllWindows",(PyCFunction ) &Dtool_GraphicsEngine_reset_all_windows_548, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_reset_all_windows_548_comment},
  { "isEmpty",(PyCFunction ) &Dtool_GraphicsEngine_is_empty_549, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_is_empty_549_comment},
  { "getNumWindows",(PyCFunction ) &Dtool_GraphicsEngine_get_num_windows_550, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_num_windows_550_comment},
  { "getWindow",(PyCFunction ) &Dtool_GraphicsEngine_get_window_551, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_window_551_comment},
  { "renderFrame",(PyCFunction ) &Dtool_GraphicsEngine_render_frame_552, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_render_frame_552_comment},
  { "openWindows",(PyCFunction ) &Dtool_GraphicsEngine_open_windows_553, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_open_windows_553_comment},
  { "syncFrame",(PyCFunction ) &Dtool_GraphicsEngine_sync_frame_554, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_sync_frame_554_comment},
  { "readyFlip",(PyCFunction ) &Dtool_GraphicsEngine_ready_flip_555, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_ready_flip_555_comment},
  { "flipFrame",(PyCFunction ) &Dtool_GraphicsEngine_flip_frame_556, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_flip_frame_556_comment},
  { "extractTextureData",(PyCFunction ) &Dtool_GraphicsEngine_extract_texture_data_557, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_extract_texture_data_557_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_GraphicsEngine_get_global_ptr_558, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsEngine_get_global_ptr_558_comment},
  { "getWindows",(PyCFunction) &MakeSeq_GraphicsEngine_get_windows, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsEngine(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsEngine.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsEngine\n"
          "// Description : This class is the main interface to controlling the\n"
          "//               render process.  There is typically only one\n"
          "//               GraphicsEngine in an application, and it synchronizes\n"
          "//               rendering to all all of the active windows; although\n"
          "//               it is possible to have multiple GraphicsEngine\n"
          "//               objects if multiple synchronicity groups are\n"
          "//               required.\n"
          "//\n"
          "//               The GraphicsEngine is responsible for managing the\n"
          "//               various cull and draw threads.  The application\n"
          "//               simply calls engine->render_frame() and considers it\n"
          "//               done.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_GraphicsEngine.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_GraphicsEngine.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsEngine.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsEngine.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsEngine.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsEngine)");
             printf(" Error In PyType_ReadyGraphicsEngine");
             return;
        }
        Py_INCREF(&Dtool_GraphicsEngine.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsEngine.As_PyTypeObject().tp_dict,"GraphicsEngine",&Dtool_GraphicsEngine.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_GraphicsEngine.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_GraphicsEngine[23],&Dtool_GraphicsEngine.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsEngine,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsEngine.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsEngine",(PyObject *)&Dtool_GraphicsEngine.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsPipeSelection | GraphicsPipeSelection
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsPipeSelection[]= {
  { "getNumPipeTypes",(PyCFunction ) &Dtool_GraphicsPipeSelection_get_num_pipe_types_560, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_get_num_pipe_types_560_comment},
  { "getPipeType",(PyCFunction ) &Dtool_GraphicsPipeSelection_get_pipe_type_561, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_get_pipe_type_561_comment},
  { "printPipeTypes",(PyCFunction ) &Dtool_GraphicsPipeSelection_print_pipe_types_562, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_print_pipe_types_562_comment},
  { "makePipe",(PyCFunction ) &Dtool_GraphicsPipeSelection_make_pipe_563, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_make_pipe_563_comment},
  { "makeModulePipe",(PyCFunction ) &Dtool_GraphicsPipeSelection_make_module_pipe_564, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_make_module_pipe_564_comment},
  { "makeDefaultPipe",(PyCFunction ) &Dtool_GraphicsPipeSelection_make_default_pipe_565, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_make_default_pipe_565_comment},
  { "getNumAuxModules",(PyCFunction ) &Dtool_GraphicsPipeSelection_get_num_aux_modules_566, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_get_num_aux_modules_566_comment},
  { "loadAuxModules",(PyCFunction ) &Dtool_GraphicsPipeSelection_load_aux_modules_567, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_load_aux_modules_567_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_GraphicsPipeSelection_get_global_ptr_568, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsPipeSelection_get_global_ptr_568_comment},
  { "getPipeTypes",(PyCFunction) &MakeSeq_GraphicsPipeSelection_get_pipe_types, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsPipeSelection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsPipeSelection\n"
          "// Description : This maintains a list of GraphicsPipes by type that\n"
          "//               are available for creation.  Normally there is one\n"
          "//               default interactive GraphicsPipe, and possibly other\n"
          "//               types available as well.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsPipeSelection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsPipeSelection)");
             printf(" Error In PyType_ReadyGraphicsPipeSelection");
             return;
        }
        Py_INCREF(&Dtool_GraphicsPipeSelection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_dict,"GraphicsPipeSelection",&Dtool_GraphicsPipeSelection.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_GraphicsPipeSelection.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_GraphicsPipeSelection[8],&Dtool_GraphicsPipeSelection.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsPipeSelection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsPipeSelection.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsPipeSelection",(PyObject *)&Dtool_GraphicsPipeSelection.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
//********************************************************************
//*** Module Init Updcall ..WindowHandle
//********************************************************************
   Dtool_PyModuleClassInit_WindowHandle(module);
//********************************************************************
//*** Module Init Updcall ..WindowProperties
//********************************************************************
   Dtool_PyModuleClassInit_WindowProperties(module);
//********************************************************************
//*** Module Init Updcall ..DisplayInformation
//********************************************************************
   Dtool_PyModuleClassInit_DisplayInformation(module);
//********************************************************************
//*** Module Init Updcall ..DrawableRegion
//********************************************************************
   Dtool_PyModuleClassInit_DrawableRegion(module);
//********************************************************************
//*** Module Init Updcall ..DisplayRegion
//********************************************************************
   Dtool_PyModuleClassInit_DisplayRegion(module);
//********************************************************************
//*** Module Init Updcall ..DisplayRegionCullCallbackData
//********************************************************************
   Dtool_PyModuleClassInit_DisplayRegionCullCallbackData(module);
//********************************************************************
//*** Module Init Updcall ..DisplayRegionDrawCallbackData
//********************************************************************
   Dtool_PyModuleClassInit_DisplayRegionDrawCallbackData(module);
//********************************************************************
//*** Module Init Updcall ..DisplaySearchParameters
//********************************************************************
   Dtool_PyModuleClassInit_DisplaySearchParameters(module);
//********************************************************************
//*** Module Init Updcall ..FrameBufferProperties
//********************************************************************
   Dtool_PyModuleClassInit_FrameBufferProperties(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsThreadingModel
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsThreadingModel(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsDevice
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsDevice(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsPipe
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsPipe(module);
//********************************************************************
//*** Module Init Updcall ..StencilRenderStates
//********************************************************************
   Dtool_PyModuleClassInit_StencilRenderStates(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsStateGuardian
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsStateGuardian(module);
//********************************************************************
//*** Module Init Updcall ..StereoDisplayRegion
//********************************************************************
   Dtool_PyModuleClassInit_StereoDisplayRegion(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsOutput
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsOutput(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsBuffer
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsBuffer(module);
//********************************************************************
//*** Module Init Updcall ..TouchInfo
//********************************************************************
   Dtool_PyModuleClassInit_TouchInfo(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsWindowProcCallbackData
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsWindowProcCallbackData(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsWindow
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsWindow(module);
//********************************************************************
//*** Module Init Updcall ..NativeWindowHandle
//********************************************************************
   Dtool_PyModuleClassInit_NativeWindowHandle(module);
//********************************************************************
//*** Module Init Updcall ..ParasiteBuffer
//********************************************************************
   Dtool_PyModuleClassInit_ParasiteBuffer(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsEngine
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsEngine(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsPipeSelection
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsPipeSelection(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdisplay_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212876,  /* file_identifier */
  "libdisplay",  /* library_name */
  "O9cY",  /* library_hash_name */
  "panda",  /* module_name */
  "libdisplay.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1241  /* next_index */
};

Configure(_in_configure_libdisplay);
ConfigureFn(_in_configure_libdisplay) {
  interrogate_request_module(&_in_module_def);
}

