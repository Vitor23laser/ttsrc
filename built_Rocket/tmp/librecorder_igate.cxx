/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/recorder -Ipanda/src/recorder -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/librecorder_igate.cxx -od built_Rocket/pandac/input/librecorder.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/recorder -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library librecorder config_recorder.h mouseRecorder.h recorderBase.h recorderController.h recorderFrame.h recorderHeader.h recorderTable.h recorder_composite.cxx socketStreamRecorder.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_librecorder
#include "py_panda.h"  

#include "buttonEventList.h"
#include "config_recorder.h"
#include "dataNode.h"
#include "dataNodeTransmit.h"
#include "datagram.h"
#include "datagramInputFile.h"
#include "datagramOutputFile.h"
#include "dconfig.h"
#include "factory.h"
#include "linmath_events.h"
#include "mouseRecorder.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "recorderBase.h"
#include "recorderController.h"
#include "recorderFrame.h"
#include "recorderHeader.h"
#include "recorderTable.h"
#include "socketStreamRecorder.h"
#include "typedReferenceCount.h"
#include "typedWritable.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. RecorderBase
//********************************************************************
typedef  RecorderBase  RecorderBase_localtype;
Define_Module_ClassRef(panda,RecorderBase,RecorderBase_localtype,RecorderBase);
//********************************************************************
//*** prototypes for .. MouseRecorder
//********************************************************************
typedef  MouseRecorder  MouseRecorder_localtype;
Define_Module_ClassRef(panda,MouseRecorder,MouseRecorder_localtype,MouseRecorder);
//********************************************************************
//*** prototypes for .. RecorderController
//********************************************************************
typedef  RecorderController  RecorderController_localtype;
Define_Module_ClassRef(panda,RecorderController,RecorderController_localtype,RecorderController);
//********************************************************************
//*** prototypes for .. SocketStreamRecorder
//********************************************************************
typedef  SocketStreamRecorder  SocketStreamRecorder_localtype;
Define_Module_ClassRef(panda,SocketStreamRecorder,SocketStreamRecorder_localtype,SocketStreamRecorder);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DataNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_SocketStream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. RecorderBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderBase::is_recording(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderBase_is_recording_5(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderBase::is_recording(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isRecording", key_word_list));
        else
            (PyArg_Parse(args, ":isRecording"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderBase*)local_this)->is_recording();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRecording(const RecorderBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderBase_is_recording_5_comment =
    "C++ Interface:\n"
    "isRecording(const RecorderBase this)\n"
    "\n"
    "// Filename: recorderBase.I\n"
    "// Created by:  drose (24Jan04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderBase::is_recording\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this recorder is presently recording\n"
    "//               data for saving to a session file, false otherwise.\n"
    "//               If this is true, record_data() will be called from\n"
    "//               time to time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderBase_is_recording_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderBase::is_playing(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderBase_is_playing_6(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderBase::is_playing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPlaying", key_word_list));
        else
            (PyArg_Parse(args, ":isPlaying"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderBase*)local_this)->is_playing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPlaying(const RecorderBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderBase_is_playing_6_comment =
    "C++ Interface:\n"
    "isPlaying(const RecorderBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderBase::is_playing\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this recorder is presently playing back\n"
    "//               data from session file, false otherwise.  If this is\n"
    "//               true, play_data() will be called from time to time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderBase_is_playing_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle RecorderBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_RecorderBase_get_class_type_7(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle RecorderBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = RecorderBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderBase_get_class_type_7_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_RecorderBase_get_class_type_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ReferenceCount *RecorderBase::upcast_to_ReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_RecorderBase_upcast_to_ReferenceCount_3(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ReferenceCount *RecorderBase::upcast_to_ReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToReferenceCount"));
        if(!PyErr_Occurred())
        {
            ReferenceCount *return_value = (ReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ReferenceCount,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderBase.upcastToReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToReferenceCount(non-const RecorderBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderBase_upcast_to_ReferenceCount_3_comment =
    "C++ Interface:\n"
    "upcastToReferenceCount(non-const RecorderBase this)\n"
    "\n"
    "upcast from RecorderBase to ReferenceCount\n"
    "";
#else
static const char * Dtool_RecorderBase_upcast_to_ReferenceCount_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseRecorder *RecorderBase::downcast_to_MouseRecorder(void)
 *******************************************************************/
static PyObject *Dtool_RecorderBase_downcast_to_MouseRecorder_13(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-MouseRecorder *RecorderBase::downcast_to_MouseRecorder(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToMouseRecorder", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToMouseRecorder"));
        if(!PyErr_Occurred())
        {
            MouseRecorder *return_value = (MouseRecorder *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseRecorder,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderBase.downcastToMouseRecorder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToMouseRecorder(non-const RecorderBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderBase_downcast_to_MouseRecorder_13_comment =
    "C++ Interface:\n"
    "downcastToMouseRecorder(non-const RecorderBase this)\n"
    "\n"
    "downcast from RecorderBase to MouseRecorder\n"
    "";
#else
static const char * Dtool_RecorderBase_downcast_to_MouseRecorder_13_comment = NULL;
#endif

int  Dtool_Init_RecorderBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (RecorderBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_RecorderBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RecorderBase)
    {
        printf("RecorderBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RecorderBase * local_this = (RecorderBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RecorderBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RecorderBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RecorderBase)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseRecorder 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseRecorder::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseRecorder_get_class_type_16(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseRecorder::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseRecorder::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseRecorder_get_class_type_16_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseRecorder_get_class_type_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DataNode *MouseRecorder::upcast_to_DataNode(void)
 *******************************************************************/
static PyObject *Dtool_MouseRecorder_upcast_to_DataNode_10(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DataNode *MouseRecorder::upcast_to_DataNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDataNode", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDataNode"));
        if(!PyErr_Occurred())
        {
            DataNode *return_value = (DataNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DataNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseRecorder.upcastToDataNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDataNode(non-const MouseRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseRecorder_upcast_to_DataNode_10_comment =
    "C++ Interface:\n"
    "upcastToDataNode(non-const MouseRecorder this)\n"
    "\n"
    "upcast from MouseRecorder to DataNode\n"
    "";
#else
static const char * Dtool_MouseRecorder_upcast_to_DataNode_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RecorderBase *MouseRecorder::upcast_to_RecorderBase(void)
 *******************************************************************/
static PyObject *Dtool_MouseRecorder_upcast_to_RecorderBase_12(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-RecorderBase *MouseRecorder::upcast_to_RecorderBase(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToRecorderBase", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToRecorderBase"));
        if(!PyErr_Occurred())
        {
            RecorderBase *return_value = (RecorderBase *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_RecorderBase,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseRecorder.upcastToRecorderBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToRecorderBase(non-const MouseRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseRecorder_upcast_to_RecorderBase_12_comment =
    "C++ Interface:\n"
    "upcastToRecorderBase(non-const MouseRecorder this)\n"
    "\n"
    "upcast from MouseRecorder to RecorderBase\n"
    "";
#else
static const char * Dtool_MouseRecorder_upcast_to_RecorderBase_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseRecorder::MouseRecorder(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_MouseRecorder(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-MouseRecorder::MouseRecorder(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:MouseRecorder", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:MouseRecorder", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            MouseRecorder *return_value = new MouseRecorder(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseRecorder,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MouseRecorder(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MouseRecorder(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseRecorder)
    {
        printf("MouseRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseRecorder * local_this = (MouseRecorder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseRecorder)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_RecorderBase)
        return ( RecorderBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseRecorder(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseRecorder)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (MouseRecorder*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MouseRecorder*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MouseRecorder*)other_this;
    }
    if(from_type == &Dtool_RecorderBase)
    {
          RecorderBase* other_this = (RecorderBase*)from_this;
          return (MouseRecorder*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MouseRecorder*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MouseRecorder*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. RecorderController 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool RecorderController::begin_record(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_RecorderController_begin_record_20(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool RecorderController::begin_record(Filename const &filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginRecord", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginRecord", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "RecorderController.beginRecord", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->begin_record(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RecorderController.beginRecord() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginRecord(non-const RecorderController this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_begin_record_20_comment =
    "C++ Interface:\n"
    "beginRecord(non-const RecorderController this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::begin_record\n"
    "//       Access: Published\n"
    "//  Description: Begins recording data to the indicated filename.  All\n"
    "//               of the recorders in use should already have been\n"
    "//               added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_begin_record_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool RecorderController::begin_playback(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_RecorderController_begin_playback_21(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool RecorderController::begin_playback(Filename const &filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginPlayback", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginPlayback", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "RecorderController.beginPlayback", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->begin_playback(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RecorderController.beginPlayback() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginPlayback(non-const RecorderController this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_begin_playback_21_comment =
    "C++ Interface:\n"
    "beginPlayback(non-const RecorderController this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::begin_playback\n"
    "//       Access: Published\n"
    "//  Description: Begins playing back data from the indicated filename.\n"
    "//               All of the recorders in use should already have been\n"
    "//               added, although this may define additional recorders\n"
    "//               if they are present in the file (these new recorders\n"
    "//               will not be used).  This may also undefine recorders\n"
    "//               that were previously added but are not present in the\n"
    "//               file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_begin_playback_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void RecorderController::close(void)
 *******************************************************************/
static PyObject *Dtool_RecorderController_close_22(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void RecorderController::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_close_22_comment =
    "C++ Interface:\n"
    "close(non-const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::close\n"
    "//       Access: Published\n"
    "//  Description: Finishes recording data to the indicated filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_close_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int RecorderController::get_start_time(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_start_time_23(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int RecorderController::get_start_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartTime", key_word_list));
        else
            (PyArg_Parse(args, ":getStartTime"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const RecorderController*)local_this)->get_start_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartTime(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_start_time_23_comment =
    "C++ Interface:\n"
    "getStartTime(const RecorderController this)\n"
    "\n"
    "// Filename: recorderController.I\n"
    "// Created by:  drose (24Jan04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_start_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time (and date) at which the current\n"
    "//               session was originally recorded (or, in recording\n"
    "//               mode, the time at which the current session began).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_start_time_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RecorderController::set_random_seed(int random_seed)
 *******************************************************************/
static PyObject *Dtool_RecorderController_set_random_seed_24(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RecorderController::set_random_seed(int random_seed)
        int param1;
        static char * key_word_list[] = {(char *)"random_seed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRandomSeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRandomSeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_random_seed((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.setRandomSeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRandomSeed(non-const RecorderController this, int random_seed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_set_random_seed_24_comment =
    "C++ Interface:\n"
    "setRandomSeed(non-const RecorderController this, int random_seed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::set_random_seed\n"
    "//       Access: Published\n"
    "//  Description: Indicates an arbitrary number to be recorded in the\n"
    "//               session file as a random seed, should the application\n"
    "//               wish to take advantage of it.  This must be set\n"
    "//               before begin_record() is called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_set_random_seed_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int RecorderController::get_random_seed(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_random_seed_25(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int RecorderController::get_random_seed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRandomSeed", key_word_list));
        else
            (PyArg_Parse(args, ":getRandomSeed"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const RecorderController*)local_this)->get_random_seed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRandomSeed(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_random_seed_25_comment =
    "C++ Interface:\n"
    "getRandomSeed(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_random_seed\n"
    "//       Access: Published\n"
    "//  Description: Returns the random seed that was set by a previous\n"
    "//               call to set_random_seed(), or the number read from\n"
    "//               the session file after begin_playback() has been\n"
    "//               called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_random_seed_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::is_recording(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_is_recording_26(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderController::is_recording(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isRecording", key_word_list));
        else
            (PyArg_Parse(args, ":isRecording"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderController*)local_this)->is_recording();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRecording(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_is_recording_26_comment =
    "C++ Interface:\n"
    "isRecording(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::is_recording\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the controller has been opened for\n"
    "//               output, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_is_recording_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::is_playing(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_is_playing_27(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderController::is_playing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPlaying", key_word_list));
        else
            (PyArg_Parse(args, ":isPlaying"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderController*)local_this)->is_playing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPlaying(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_is_playing_27_comment =
    "C++ Interface:\n"
    "isPlaying(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::is_playing\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the controller has been opened for\n"
    "//               input, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_is_playing_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::is_open(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_is_open_28(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderController::is_open(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOpen", key_word_list));
        else
            (PyArg_Parse(args, ":isOpen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderController*)local_this)->is_open();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOpen(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_is_open_28_comment =
    "C++ Interface:\n"
    "isOpen(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::is_open\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the controller has been opened for\n"
    "//               either input or output, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_is_open_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &RecorderController::get_filename(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_filename_29(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &RecorderController::get_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const RecorderController*)local_this)->get_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilename(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_filename_29_comment =
    "C++ Interface:\n"
    "getFilename(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the filename that was passed to the most\n"
    "//               recent call to begin_record() or begin_playback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_filename_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::is_error(void)
 *******************************************************************/
static PyObject *Dtool_RecorderController_is_error_30(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool RecorderController::is_error(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isError", key_word_list));
        else
            (PyArg_Parse(args, ":isError"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.isError() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isError(non-const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_is_error_30_comment =
    "C++ Interface:\n"
    "isError(non-const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::is_error\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the controller has been opened for\n"
    "//               input or output output and there is an error on the\n"
    "//               stream, or false if the controller is closed or if\n"
    "//               there is no problem.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_is_error_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double RecorderController::get_clock_offset(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_clock_offset_31(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double RecorderController::get_clock_offset(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClockOffset", key_word_list));
        else
            (PyArg_Parse(args, ":getClockOffset"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const RecorderController*)local_this)->get_clock_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClockOffset(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_clock_offset_31_comment =
    "C++ Interface:\n"
    "getClockOffset(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_clock_offset\n"
    "//       Access: Published\n"
    "//  Description: Returns the delta offset between the actual frame\n"
    "//               time and the frame time written to the log.  This is\n"
    "//               essentially the time at which the recording (or\n"
    "//               playback) started.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_clock_offset_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int RecorderController::get_frame_offset(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_frame_offset_32(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int RecorderController::get_frame_offset(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameOffset", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameOffset"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const RecorderController*)local_this)->get_frame_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameOffset(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_frame_offset_32_comment =
    "C++ Interface:\n"
    "getFrameOffset(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_frame_offset\n"
    "//       Access: Published\n"
    "//  Description: Returns the delta offset between the actual frame\n"
    "//               count and the frame count written to the log.  This is\n"
    "//               essentially the frame number at which the recording\n"
    "//               (or playback) started.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_frame_offset_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RecorderController::add_recorder(basic_string< char > const &name, RecorderBase *recorder)
 *******************************************************************/
static PyObject *Dtool_RecorderController_add_recorder_33(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void RecorderController::add_recorder(basic_string< char > const &name, RecorderBase *recorder)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"recorder", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addRecorder", key_word_list, &param1_str, &param1_len, &param2))
            {
                RecorderBase *param2_this = (RecorderBase *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_RecorderBase, 2, "RecorderController.addRecorder", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->add_recorder(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RecorderController.addRecorder() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addRecorder(non-const RecorderController this, string name, non-const RecorderBase recorder)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_add_recorder_33_comment =
    "C++ Interface:\n"
    "addRecorder(non-const RecorderController this, string name, non-const RecorderBase recorder)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::add_recorder\n"
    "//       Access: Published\n"
    "//  Description: Adds the named recorder to the set of recorders that\n"
    "//               are in use.\n"
    "//\n"
    "//               If the controller is in recording mode, the named\n"
    "//               recorder will begin recording its status to the\n"
    "//               session file.  If the controller is in playback mode\n"
    "//               and the name and type matches a recorder in the\n"
    "//               session file, the recorder will begin receiving data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_add_recorder_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::has_recorder(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_has_recorder_34(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderController::has_recorder(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasRecorder", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hasRecorder", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderController*)local_this)->has_recorder(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasRecorder(const RecorderController this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_has_recorder_34_comment =
    "C++ Interface:\n"
    "hasRecorder(const RecorderController this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::has_recorder\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the named recorder has been added to\n"
    "//               the table by a previous call to add_recorder(), false\n"
    "//               otherwise. \n"
    "//\n"
    "//               If the controller is in playback mode, this will also\n"
    "//               return false for a recorder that was found in the\n"
    "//               session file but was never explicitly added via\n"
    "//               add_recorder(); see get_recorder().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_has_recorder_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline RecorderBase *RecorderController::get_recorder(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_recorder_35(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline RecorderBase *RecorderController::get_recorder(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getRecorder", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getRecorder", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            RecorderBase *return_value = ((const RecorderController*)local_this)->get_recorder(basic_string<char>(param1_str, param1_len));
            if (return_value != (RecorderBase *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_RecorderBase,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRecorder(const RecorderController this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_recorder_35_comment =
    "C++ Interface:\n"
    "getRecorder(const RecorderController this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_recorder\n"
    "//       Access: Published\n"
    "//  Description: Returns the recorder with the indicated name, or NULL\n"
    "//               if there is no such recorder.\n"
    "//\n"
    "//               If the controller is in playback mode, this may\n"
    "//               return the recorder matching the indicated name as\n"
    "//               read from the session file, even if it was never\n"
    "//               added to the table by the user.  In this case,\n"
    "//               has_recorder() may return false, but get_recorder()\n"
    "//               will return a non-NULL value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_recorder_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::remove_recorder(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_RecorderController_remove_recorder_36(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool RecorderController::remove_recorder(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:removeRecorder", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:removeRecorder", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->remove_recorder(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.removeRecorder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeRecorder(non-const RecorderController this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_remove_recorder_36_comment =
    "C++ Interface:\n"
    "removeRecorder(non-const RecorderController this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::remove_recorder\n"
    "//       Access: Published\n"
    "//  Description: Removes the named recorder from the table.  Returns\n"
    "//               true if successful, false if there was no such\n"
    "//               recorder.\n"
    "//\n"
    "//               If the controller is in recording mode, the named\n"
    "//               recorder will stop recording.  If the controller is\n"
    "//               in playback mode, the named recorder will\n"
    "//               disassociate itself from the session file (but if the\n"
    "//               session file still has data for this name, a default\n"
    "//               recorder will take its place to decode the data from\n"
    "//               the session file).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_remove_recorder_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RecorderController::set_frame_tie(bool frame_tie)
 *******************************************************************/
static PyObject *Dtool_RecorderController_set_frame_tie_37(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RecorderController::set_frame_tie(bool frame_tie)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"frame_tie", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrameTie", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFrameTie", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_tie((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.setFrameTie() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameTie(non-const RecorderController this, bool frame_tie)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_set_frame_tie_37_comment =
    "C++ Interface:\n"
    "setFrameTie(non-const RecorderController this, bool frame_tie)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::set_frame_tie\n"
    "//       Access: Published\n"
    "//  Description: Sets the frame_tie flag.\n"
    "//\n"
    "//               When this is true, sessions are played back\n"
    "//               frame-for-frame, based on the frame count of the\n"
    "//               recorded session.  This gives the most accurate\n"
    "//               playback, but the playback rate will vary according\n"
    "//               to the frame rate of the playback machine.\n"
    "//\n"
    "//               When this is false, sessions are played back at real\n"
    "//               time, based on the clock of the recorded session.\n"
    "//               This may introduce playback discrepencies if the\n"
    "//               frames do not fall at exactly the same times as they\n"
    "//               did in the original.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_set_frame_tie_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RecorderController::get_frame_tie(void) const
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_frame_tie_38(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RecorderController::get_frame_tie(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameTie", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameTie"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RecorderController*)local_this)->get_frame_tie();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameTie(const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_frame_tie_38_comment =
    "C++ Interface:\n"
    "getFrameTie(const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::get_frame_tie\n"
    "//       Access: Published\n"
    "//  Description: See set_frame_tie().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_get_frame_tie_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void RecorderController::record_frame(void)
 *******************************************************************/
static PyObject *Dtool_RecorderController_record_frame_39(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void RecorderController::record_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recordFrame", key_word_list));
        else
            (PyArg_Parse(args, ":recordFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->record_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.recordFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recordFrame(non-const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_record_frame_39_comment =
    "C++ Interface:\n"
    "recordFrame(non-const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::record_frame\n"
    "//       Access: Published\n"
    "//  Description: Gets the next frame of data from all of the active\n"
    "//               recorders and adds it to the output file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_record_frame_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void RecorderController::play_frame(void)
 *******************************************************************/
static PyObject *Dtool_RecorderController_play_frame_40(PyObject *self, PyObject *args,PyObject *kwds) {
    RecorderController * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecorderController,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void RecorderController::play_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":playFrame", key_word_list));
        else
            (PyArg_Parse(args, ":playFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->play_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecorderController.playFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "playFrame(non-const RecorderController this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_play_frame_40_comment =
    "C++ Interface:\n"
    "playFrame(non-const RecorderController this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecorderController::play_frame\n"
    "//       Access: Published\n"
    "//  Description: Gets the next frame of data from all of the active\n"
    "//               recorders and adds it to the output file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecorderController_play_frame_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle RecorderController::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_RecorderController_get_class_type_41(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle RecorderController::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = RecorderController::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecorderController_get_class_type_41_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_RecorderController_get_class_type_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RecorderController::RecorderController(void)
 *******************************************************************/
int  Dtool_Init_RecorderController(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-RecorderController::RecorderController(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":RecorderController", key_word_list))
        {
            RecorderController *return_value = new RecorderController();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_RecorderController,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RecorderController()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_RecorderController(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RecorderController)
    {
        printf("RecorderController ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RecorderController * local_this = (RecorderController *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RecorderController)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RecorderController(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RecorderController)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (RecorderController*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (RecorderController*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (RecorderController*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SocketStreamRecorder 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool SocketStreamRecorder::receive_datagram(Datagram &dg)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_receive_datagram_44(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool SocketStreamRecorder::receive_datagram(Datagram &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:receiveDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:receiveDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "SocketStreamRecorder.receiveDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->receive_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketStreamRecorder.receiveDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveDatagram(non-const SocketStreamRecorder this, non-const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_receive_datagram_44_comment =
    "C++ Interface:\n"
    "receiveDatagram(non-const SocketStreamRecorder this, non-const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::receive_datagram\n"
    "//       Access: Public\n"
    "//  Description: Receives a datagram over the socket by expecting a\n"
    "//               little-endian 16-bit byte count as a prefix.  If the\n"
    "//               socket stream is non-blocking, may return false if\n"
    "//               the data is not available; otherwise, returns false\n"
    "//               only if the socket closes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_receive_datagram_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SocketStreamRecorder::send_datagram(Datagram const &dg)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_send_datagram_45(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool SocketStreamRecorder::send_datagram(Datagram const &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:sendDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:sendDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "SocketStreamRecorder.sendDatagram", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->send_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketStreamRecorder.sendDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendDatagram(non-const SocketStreamRecorder this, const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_send_datagram_45_comment =
    "C++ Interface:\n"
    "sendDatagram(non-const SocketStreamRecorder this, const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::send_datagram\n"
    "//       Access: Public\n"
    "//  Description: See SocketStream::send_datagram().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_send_datagram_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SocketStreamRecorder::is_closed(void)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_is_closed_46(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SocketStreamRecorder::is_closed(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStreamRecorder.isClosed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(non-const SocketStreamRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_is_closed_46_comment =
    "C++ Interface:\n"
    "isClosed(non-const SocketStreamRecorder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::is_closed\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::is_closed().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_is_closed_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SocketStreamRecorder::close(void)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_close_47(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SocketStreamRecorder::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStreamRecorder.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const SocketStreamRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_close_47_comment =
    "C++ Interface:\n"
    "close(non-const SocketStreamRecorder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::close\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::close().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_close_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_set_collect_tcp_48(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"collect_tcp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCollectTcp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCollectTcp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collect_tcp((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStreamRecorder.setCollectTcp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollectTcp(non-const SocketStreamRecorder this, bool collect_tcp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_set_collect_tcp_48_comment =
    "C++ Interface:\n"
    "setCollectTcp(non-const SocketStreamRecorder this, bool collect_tcp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::set_collect_tcp\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_set_collect_tcp_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SocketStreamRecorder::get_collect_tcp(void) const
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_get_collect_tcp_49(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SocketStreamRecorder::get_collect_tcp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollectTcp", key_word_list));
        else
            (PyArg_Parse(args, ":getCollectTcp"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SocketStreamRecorder*)local_this)->get_collect_tcp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollectTcp(const SocketStreamRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_get_collect_tcp_49_comment =
    "C++ Interface:\n"
    "getCollectTcp(const SocketStreamRecorder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::get_collect_tcp\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::get_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_get_collect_tcp_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SocketStreamRecorder::set_collect_tcp_interval(double interval)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_set_collect_tcp_interval_50(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SocketStreamRecorder::set_collect_tcp_interval(double interval)
        double param1;
        static char * key_word_list[] = {(char *)"interval", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setCollectTcpInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setCollectTcpInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collect_tcp_interval((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStreamRecorder.setCollectTcpInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollectTcpInterval(non-const SocketStreamRecorder this, float interval)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_set_collect_tcp_interval_50_comment =
    "C++ Interface:\n"
    "setCollectTcpInterval(non-const SocketStreamRecorder this, float interval)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::set_collect_tcp_interval\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::set_collect_tcp_interval().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_set_collect_tcp_interval_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SocketStreamRecorder::get_collect_tcp_interval(void) const
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_get_collect_tcp_interval_51(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SocketStreamRecorder::get_collect_tcp_interval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollectTcpInterval", key_word_list));
        else
            (PyArg_Parse(args, ":getCollectTcpInterval"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SocketStreamRecorder*)local_this)->get_collect_tcp_interval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollectTcpInterval(const SocketStreamRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_get_collect_tcp_interval_51_comment =
    "C++ Interface:\n"
    "getCollectTcpInterval(const SocketStreamRecorder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::get_collect_tcp_interval\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::get_collect_tcp_interval().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_get_collect_tcp_interval_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SocketStreamRecorder::consider_flush(void)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_consider_flush_52(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SocketStreamRecorder::consider_flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":considerFlush", key_word_list));
        else
            (PyArg_Parse(args, ":considerFlush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->consider_flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStreamRecorder.considerFlush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "considerFlush(non-const SocketStreamRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_consider_flush_52_comment =
    "C++ Interface:\n"
    "considerFlush(non-const SocketStreamRecorder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::consider_flush\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::consider_flush()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_consider_flush_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SocketStreamRecorder::flush(void)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_flush_53(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStreamRecorder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStreamRecorder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SocketStreamRecorder::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStreamRecorder.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const SocketStreamRecorder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_flush_53_comment =
    "C++ Interface:\n"
    "flush(non-const SocketStreamRecorder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStreamRecorder::flush\n"
    "//       Access: Published\n"
    "//  Description: See SocketStream::flush()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_flush_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SocketStreamRecorder::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SocketStreamRecorder_get_class_type_54(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SocketStreamRecorder::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SocketStreamRecorder::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStreamRecorder_get_class_type_54_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SocketStreamRecorder_get_class_type_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SocketStreamRecorder::SocketStreamRecorder(void)
 * inline SocketStreamRecorder::SocketStreamRecorder(SocketStream *stream, bool owns_stream)
 *******************************************************************/
int  Dtool_Init_SocketStreamRecorder(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline SocketStreamRecorder::SocketStreamRecorder(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketStreamRecorder", key_word_list))
            {
                SocketStreamRecorder *return_value = new SocketStreamRecorder();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_SocketStreamRecorder,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline SocketStreamRecorder::SocketStreamRecorder(SocketStream *stream, bool owns_stream)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"stream", (char *)"owns_stream", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:SocketStreamRecorder", key_word_list, &param0, &param1))
                {
                    SocketStream *param0_this = (SocketStream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SocketStream, 0, "SocketStreamRecorder.SocketStreamRecorder", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        SocketStreamRecorder *return_value = new SocketStreamRecorder(param0_this, (PyObject_IsTrue(param1)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SocketStreamRecorder,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SocketStreamRecorder() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SocketStreamRecorder()\n"
          "SocketStreamRecorder(non-const SocketStream stream, bool owns_stream)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SocketStreamRecorder(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SocketStreamRecorder)
    {
        printf("SocketStreamRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SocketStreamRecorder * local_this = (SocketStreamRecorder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SocketStreamRecorder)
        return local_this;
    if(requested_type == &Dtool_RecorderBase)
        return ( RecorderBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( RecorderBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SocketStreamRecorder(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SocketStreamRecorder)
        return from_this;
    if(from_type == &Dtool_RecorderBase)
    {
          RecorderBase* other_this = (RecorderBase*)from_this;
          return (SocketStreamRecorder*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. RecorderBase | RecorderBase
//********************************************************************
PyMethodDef Dtool_Methods_RecorderBase[]= {
  { "isRecording",(PyCFunction ) &Dtool_RecorderBase_is_recording_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderBase_is_recording_5_comment},
  { "isPlaying",(PyCFunction ) &Dtool_RecorderBase_is_playing_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderBase_is_playing_6_comment},
  { "getClassType",(PyCFunction ) &Dtool_RecorderBase_get_class_type_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderBase_get_class_type_7_comment},
  { "upcastToReferenceCount",(PyCFunction ) &Dtool_RecorderBase_upcast_to_ReferenceCount_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderBase_upcast_to_ReferenceCount_3_comment},
  { "downcastToMouseRecorder",(PyCFunction ) &Dtool_RecorderBase_downcast_to_MouseRecorder_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderBase_downcast_to_MouseRecorder_13_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RecorderBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_RecorderBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : RecorderBase\n"
          "// Description : This is the base class to a number of objects that\n"
          "//               record particular kinds of user input (like a\n"
          "//               MouseRecorder) to use in conjunction with a\n"
          "//               RecorderController to record the user's inputs\n"
          "//               for a session.\n"
          "//\n"
          "//               Note that RecorderBase does not actually inherit from\n"
          "//               TypedObject, even though it defines get_type().  The\n"
          "//               assumption is that the classes that derive from\n"
          "//               RecorderBase might also inherit independently from\n"
          "//               TypedObject.\n"
          "//\n"
          "//               It also does not inherit from TypedWritable, but it\n"
          "//               defines a method called write_recorder() which is\n"
          "//               very similar to a TypedWritable's write_datagram().\n"
          "//               Classes that derive from RecorderBase and also\n"
          "//               inherit from TypedWritable may choose to remap\n"
          "//               write_recorder() to do exactly the same thing as\n"
          "//               write_datagram(), or they may choose to write\n"
          "//               something slightly different.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_RecorderBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_RecorderBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RecorderBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RecorderBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_RecorderBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RecorderBase)");
             printf(" Error In PyType_ReadyRecorderBase");
             return;
        }
        Py_INCREF(&Dtool_RecorderBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RecorderBase.As_PyTypeObject().tp_dict,"RecorderBase",&Dtool_RecorderBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_RecorderBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_RecorderBase[2],&Dtool_RecorderBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_RecorderBase,RecorderBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RecorderBase.As_PyTypeObject());
        PyModule_AddObject(module, "RecorderBase",(PyObject *)&Dtool_RecorderBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseRecorder | MouseRecorder
//********************************************************************
PyMethodDef Dtool_Methods_MouseRecorder[]= {
  { "getClassType",(PyCFunction ) &Dtool_MouseRecorder_get_class_type_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseRecorder_get_class_type_16_comment},
  { "upcastToDataNode",(PyCFunction ) &Dtool_MouseRecorder_upcast_to_DataNode_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseRecorder_upcast_to_DataNode_10_comment},
  { "upcastToRecorderBase",(PyCFunction ) &Dtool_MouseRecorder_upcast_to_RecorderBase_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseRecorder_upcast_to_RecorderBase_12_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MouseRecorder(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseRecorder.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseRecorder\n"
          "// Description : This object records any data generated by a\n"
          "//               particular MouseAndKeyboard node on the datagraph for\n"
          "//               a session for eventual playback via a\n"
          "//               DataGraphPlayback (and a PlaybackController).  To use\n"
          "//               it, make it a child of the node you wish to record.\n"
          "//               It also serves as a pass-through, so that additional\n"
          "//               child nodes may be parented directly to it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_RecorderBase._Dtool_ClassInit(NULL);
        Dtool_MouseRecorder.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_DataNode.As_PyTypeObject(),&Dtool_RecorderBase.As_PyTypeObject());
        Dtool_MouseRecorder.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseRecorder.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseRecorder.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MouseRecorder.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseRecorder)");
             printf(" Error In PyType_ReadyMouseRecorder");
             return;
        }
        Py_INCREF(&Dtool_MouseRecorder.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseRecorder.As_PyTypeObject().tp_dict,"MouseRecorder",&Dtool_MouseRecorder.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseRecorder.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseRecorder[0],&Dtool_MouseRecorder.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseRecorder,MouseRecorder::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseRecorder.As_PyTypeObject());
        PyModule_AddObject(module, "MouseRecorder",(PyObject *)&Dtool_MouseRecorder.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. RecorderController | RecorderController
//********************************************************************
PyMethodDef Dtool_Methods_RecorderController[]= {
  { "beginRecord",(PyCFunction ) &Dtool_RecorderController_begin_record_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_begin_record_20_comment},
  { "beginPlayback",(PyCFunction ) &Dtool_RecorderController_begin_playback_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_begin_playback_21_comment},
  { "close",(PyCFunction ) &Dtool_RecorderController_close_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_close_22_comment},
  { "getStartTime",(PyCFunction ) &Dtool_RecorderController_get_start_time_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_start_time_23_comment},
  { "setRandomSeed",(PyCFunction ) &Dtool_RecorderController_set_random_seed_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_set_random_seed_24_comment},
  { "getRandomSeed",(PyCFunction ) &Dtool_RecorderController_get_random_seed_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_random_seed_25_comment},
  { "isRecording",(PyCFunction ) &Dtool_RecorderController_is_recording_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_is_recording_26_comment},
  { "isPlaying",(PyCFunction ) &Dtool_RecorderController_is_playing_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_is_playing_27_comment},
  { "isOpen",(PyCFunction ) &Dtool_RecorderController_is_open_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_is_open_28_comment},
  { "getFilename",(PyCFunction ) &Dtool_RecorderController_get_filename_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_filename_29_comment},
  { "isError",(PyCFunction ) &Dtool_RecorderController_is_error_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_is_error_30_comment},
  { "getClockOffset",(PyCFunction ) &Dtool_RecorderController_get_clock_offset_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_clock_offset_31_comment},
  { "getFrameOffset",(PyCFunction ) &Dtool_RecorderController_get_frame_offset_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_frame_offset_32_comment},
  { "addRecorder",(PyCFunction ) &Dtool_RecorderController_add_recorder_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_add_recorder_33_comment},
  { "hasRecorder",(PyCFunction ) &Dtool_RecorderController_has_recorder_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_has_recorder_34_comment},
  { "getRecorder",(PyCFunction ) &Dtool_RecorderController_get_recorder_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_recorder_35_comment},
  { "removeRecorder",(PyCFunction ) &Dtool_RecorderController_remove_recorder_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_remove_recorder_36_comment},
  { "setFrameTie",(PyCFunction ) &Dtool_RecorderController_set_frame_tie_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_set_frame_tie_37_comment},
  { "getFrameTie",(PyCFunction ) &Dtool_RecorderController_get_frame_tie_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_frame_tie_38_comment},
  { "recordFrame",(PyCFunction ) &Dtool_RecorderController_record_frame_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_record_frame_39_comment},
  { "playFrame",(PyCFunction ) &Dtool_RecorderController_play_frame_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_play_frame_40_comment},
  { "getClassType",(PyCFunction ) &Dtool_RecorderController_get_class_type_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecorderController_get_class_type_41_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RecorderController(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_RecorderController.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : RecorderController\n"
          "// Description : This object manages the process of recording the\n"
          "//               user's runtime inputs to a bam file so that the\n"
          "//               session can be recreated later.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_RecorderController.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_RecorderController.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RecorderController.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RecorderController.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_RecorderController.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RecorderController)");
             printf(" Error In PyType_ReadyRecorderController");
             return;
        }
        Py_INCREF(&Dtool_RecorderController.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RecorderController.As_PyTypeObject().tp_dict,"RecorderController",&Dtool_RecorderController.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_RecorderController.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_RecorderController[21],&Dtool_RecorderController.As_PyObject()));
        RegisterRuntimeClass(&Dtool_RecorderController,RecorderController::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RecorderController.As_PyTypeObject());
        PyModule_AddObject(module, "RecorderController",(PyObject *)&Dtool_RecorderController.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SocketStreamRecorder | SocketStreamRecorder
//********************************************************************
PyMethodDef Dtool_Methods_SocketStreamRecorder[]= {
  { "receiveDatagram",(PyCFunction ) &Dtool_SocketStreamRecorder_receive_datagram_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_receive_datagram_44_comment},
  { "sendDatagram",(PyCFunction ) &Dtool_SocketStreamRecorder_send_datagram_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_send_datagram_45_comment},
  { "isClosed",(PyCFunction ) &Dtool_SocketStreamRecorder_is_closed_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_is_closed_46_comment},
  { "close",(PyCFunction ) &Dtool_SocketStreamRecorder_close_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_close_47_comment},
  { "setCollectTcp",(PyCFunction ) &Dtool_SocketStreamRecorder_set_collect_tcp_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_set_collect_tcp_48_comment},
  { "getCollectTcp",(PyCFunction ) &Dtool_SocketStreamRecorder_get_collect_tcp_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_get_collect_tcp_49_comment},
  { "setCollectTcpInterval",(PyCFunction ) &Dtool_SocketStreamRecorder_set_collect_tcp_interval_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_set_collect_tcp_interval_50_comment},
  { "getCollectTcpInterval",(PyCFunction ) &Dtool_SocketStreamRecorder_get_collect_tcp_interval_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_get_collect_tcp_interval_51_comment},
  { "considerFlush",(PyCFunction ) &Dtool_SocketStreamRecorder_consider_flush_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_consider_flush_52_comment},
  { "flush",(PyCFunction ) &Dtool_SocketStreamRecorder_flush_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_flush_53_comment},
  { "getClassType",(PyCFunction ) &Dtool_SocketStreamRecorder_get_class_type_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStreamRecorder_get_class_type_54_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SocketStreamRecorder(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SocketStreamRecorder.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SocketStreamRecorder\n"
          "// Description : Records any data received from the indicated socket\n"
          "//               stream.  On playback, it will act as if the incoming\n"
          "//               data is coming over the wire again even if an actual\n"
          "//               connection is not available.\n"
          "//\n"
          "//               Outbound data will not be recorded, but will be sent\n"
          "//               straight through to the socket if it is connected, or\n"
          "//               silently ignored if it is not.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_RecorderBase._Dtool_ClassInit(NULL);
        Dtool_SocketStreamRecorder.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_RecorderBase.As_PyTypeObject());
        Dtool_SocketStreamRecorder.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SocketStreamRecorder.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SocketStreamRecorder.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SocketStreamRecorder.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SocketStreamRecorder)");
             printf(" Error In PyType_ReadySocketStreamRecorder");
             return;
        }
        Py_INCREF(&Dtool_SocketStreamRecorder.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SocketStreamRecorder.As_PyTypeObject().tp_dict,"SocketStreamRecorder",&Dtool_SocketStreamRecorder.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SocketStreamRecorder.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SocketStreamRecorder[10],&Dtool_SocketStreamRecorder.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SocketStreamRecorder,SocketStreamRecorder::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SocketStreamRecorder.As_PyTypeObject());
        PyModule_AddObject(module, "SocketStreamRecorder",(PyObject *)&Dtool_SocketStreamRecorder.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..RecorderBase
//********************************************************************
   Dtool_PyModuleClassInit_RecorderBase(module);
//********************************************************************
//*** Module Init Updcall ..MouseRecorder
//********************************************************************
   Dtool_PyModuleClassInit_MouseRecorder(module);
//********************************************************************
//*** Module Init Updcall ..RecorderController
//********************************************************************
   Dtool_PyModuleClassInit_RecorderController(module);
//********************************************************************
//*** Module Init Updcall ..SocketStreamRecorder
//********************************************************************
   Dtool_PyModuleClassInit_SocketStreamRecorder(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef librecorder_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212923,  /* file_identifier */
  "librecorder",  /* library_name */
  "c5FL",  /* library_hash_name */
  "panda",  /* module_name */
  "librecorder.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  130  /* next_index */
};

Configure(_in_configure_librecorder);
ConfigureFn(_in_configure_librecorder) {
  interrogate_request_module(&_in_module_def);
}

