/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir toontown/suit -Itoontown/suit -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libsuit_igate.cxx -od built_Rocket/pandac/input/libsuit.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Itoontown/suit -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_TOONTOWN -module toontown -library libsuit suitLeg.h suitLegList.h suit_composite1.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libsuit
#include "py_panda.h"  

#include "dnaSuitPoint.h"
#include "luse.h"
#include "pvector.h"
#include "suitLeg.h"
#include "suitLegList.h"
#include "toontownbase.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. SuitLeg
//********************************************************************
typedef  SuitLeg  SuitLeg_localtype;
Define_Module_Class(toontown,SuitLeg,SuitLeg_localtype,SuitLeg);
//********************************************************************
//*** prototypes for .. SuitLegList
//********************************************************************
typedef  SuitLegList  SuitLegList_localtype;
Define_Module_Class(toontown,SuitLegList,SuitLegList_localtype,SuitLegList);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DNAStorage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DNASuitPath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DNASuitPoint;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. SuitLeg 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline SuitLeg::Type SuitLeg::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_type_3(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SuitLeg::Type SuitLeg::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            SuitLeg::Type return_value = ((const SuitLeg*)local_this)->get_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_type_3_comment =
    "C++ Interface:\n"
    "getType(const SuitLeg this)\n"
    "\n"
    "// Filename: suitLeg.I\n"
    "// Created by:  drose (08Nov01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type of this leg.  Most legs are of type\n"
    "//               T_bellicose, which corresponds to just plain walking\n"
    "//               down the street, but other legs particularly at both\n"
    "//               ends of the path may represent other modes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_type_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SuitLeg::get_start_time(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_start_time_4(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SuitLeg::get_start_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartTime", key_word_list));
        else
            (PyArg_Parse(args, ":getStartTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SuitLeg*)local_this)->get_start_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartTime(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_start_time_4_comment =
    "C++ Interface:\n"
    "getStartTime(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_start_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time (in seconds elapsed since the\n"
    "//               beginning of the path) at which this leg begins.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_start_time_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SuitLeg::get_leg_time(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_leg_time_5(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SuitLeg::get_leg_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLegTime", key_word_list));
        else
            (PyArg_Parse(args, ":getLegTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SuitLeg*)local_this)->get_leg_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLegTime(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_leg_time_5_comment =
    "C++ Interface:\n"
    "getLegTime(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_leg_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the total length of time, in seconds, which\n"
    "//               this leg represents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_leg_time_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLeg::get_zone_id(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_zone_id_6(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLeg::get_zone_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZoneId", key_word_list));
        else
            (PyArg_Parse(args, ":getZoneId"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLeg*)local_this)->get_zone_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZoneId(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_zone_id_6_comment =
    "C++ Interface:\n"
    "getZoneId(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_zone_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the Zone ID associated with this leg.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_zone_id_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLeg::get_block_number(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_block_number_7(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLeg::get_block_number(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlockNumber", key_word_list));
        else
            (PyArg_Parse(args, ":getBlockNumber"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLeg*)local_this)->get_block_number();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockNumber(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_block_number_7_comment =
    "C++ Interface:\n"
    "getBlockNumber(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_block_number\n"
    "//       Access: Published\n"
    "//  Description: Returns the block number associated with this leg, if\n"
    "//               any.  Normally this is only relevant for CogHQ door\n"
    "//               type legs, in which it represents the particular door\n"
    "//               index we're going through.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_block_number_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLeg::get_point_a(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_point_a_8(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLeg::get_point_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointA", key_word_list));
        else
            (PyArg_Parse(args, ":getPointA"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLeg*)local_this)->get_point_a();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointA(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_point_a_8_comment =
    "C++ Interface:\n"
    "getPointA(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_point_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the first DNASuitPoint associated with this\n"
    "//               leg.  In most cases, the leg represents the path\n"
    "//               between point A and point B.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_point_a_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLeg::get_point_b(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_point_b_9(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLeg::get_point_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointB", key_word_list));
        else
            (PyArg_Parse(args, ":getPointB"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLeg*)local_this)->get_point_b();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointB(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_point_b_9_comment =
    "C++ Interface:\n"
    "getPointB(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_point_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the second DNASuitPoint associated with this\n"
    "//               leg.  In most cases, the leg represents the path\n"
    "//               between point A and point B.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_point_b_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f SuitLeg::get_pos_a(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_pos_a_10(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f SuitLeg::get_pos_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPosA", key_word_list));
        else
            (PyArg_Parse(args, ":getPosA"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const SuitLeg*)local_this)->get_pos_a();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosA(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_pos_a_10_comment =
    "C++ Interface:\n"
    "getPosA(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_pos_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the point in space associated with point A.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_pos_a_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f SuitLeg::get_pos_b(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_pos_b_11(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f SuitLeg::get_pos_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPosB", key_word_list));
        else
            (PyArg_Parse(args, ":getPosB"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const SuitLeg*)local_this)->get_pos_b();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosB(const SuitLeg this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_pos_b_11_comment =
    "C++ Interface:\n"
    "getPosB(const SuitLeg this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_pos_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the point in space associated with point B.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_pos_b_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f SuitLeg::get_pos_at_time(double time) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_pos_at_time_12(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f SuitLeg::get_pos_at_time(double time) const
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:getPosAtTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:getPosAtTime", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const SuitLeg*)local_this)->get_pos_at_time((double)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosAtTime(const SuitLeg this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_pos_at_time_12_comment =
    "C++ Interface:\n"
    "getPosAtTime(const SuitLeg this, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_pos_at_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the expected position of the suit at the\n"
    "//               indicated time, in seconds elapsed since the start of\n"
    "//               this leg.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_pos_at_time_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > SuitLeg::get_type_name(SuitLeg::Type type)
 *******************************************************************/
static PyObject *Dtool_SuitLeg_get_type_name_13(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > SuitLeg::get_type_name(SuitLeg::Type type)
        int param0;
        static char * key_word_list[] = {(char *)"type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTypeName", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getTypeName", &param0));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = SuitLeg::get_type_name((SuitLeg::Type)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypeName(int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_get_type_name_13_comment =
    "C++ Interface:\n"
    "getTypeName(int type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::get_type_name\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the string name associated with the indicated\n"
    "//               type.  This is also the name that corresponds to a\n"
    "//               state in DistributedSuit.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_get_type_name_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SuitLeg::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_SuitLeg_output_14(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void SuitLeg::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SuitLeg.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SuitLeg*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const SuitLeg this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLeg_output_14_comment =
    "C++ Interface:\n"
    "output(const SuitLeg this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLeg::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLeg_output_14_comment = NULL;
#endif

int  Dtool_Init_SuitLeg(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SuitLeg)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SuitLeg(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SuitLeg)
    {
        printf("SuitLeg ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SuitLeg * local_this = (SuitLeg *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SuitLeg)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SuitLeg(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SuitLeg)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SuitLegList 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int SuitLegList::get_num_legs(void) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_num_legs_19(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SuitLegList::get_num_legs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLegs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLegs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLegList*)local_this)->get_num_legs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLegs(const SuitLegList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_num_legs_19_comment =
    "C++ Interface:\n"
    "getNumLegs(const SuitLegList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_num_legs\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_num_legs_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLeg const &SuitLegList::get_leg(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_leg_20(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-SuitLeg const &SuitLegList::get_leg(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getLeg", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getLeg", &param1));
        if(!PyErr_Occurred())
        {
            SuitLeg const *return_value = &(((const SuitLegList*)local_this)->get_leg((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SuitLeg,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeg(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_leg_20_comment =
    "C++ Interface:\n"
    "getLeg(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_leg\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_leg_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SuitLeg const &SuitLegList::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_operator_21(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SuitLeg const &SuitLegList::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            SuitLeg const *return_value = &(((const SuitLegList*)local_this)->operator []((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SuitLeg,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_operator_21_comment =
    "C++ Interface:\n"
    "__getitem__(const SuitLegList this, int n)\n"
    "\n"
    "// Filename: suitLegList.I\n"
    "// Created by:  drose (08Nov01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::Indexing Operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth leg of the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_operator_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SuitLegList::get_leg_index_at_time(double time, int start) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_leg_index_at_time_22(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SuitLegList::get_leg_index_at_time(double time, int start) const
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"time", (char *)"start", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "di:getLegIndexAtTime", key_word_list, &param1, &param2))
        {
            int return_value = ((const SuitLegList*)local_this)->get_leg_index_at_time((double)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLegIndexAtTime(const SuitLegList this, float time, int start)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_leg_index_at_time_22_comment =
    "C++ Interface:\n"
    "getLegIndexAtTime(const SuitLegList this, float time, int start)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_leg_index_at_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the leg within the list that\n"
    "//               covers the indicated elapsed time from the beginning\n"
    "//               of the path.\n"
    "//\n"
    "//               start is a hint, the index at which to start\n"
    "//               searching.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_leg_index_at_time_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SuitLeg::Type SuitLegList::get_type(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_type_23(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SuitLeg::Type SuitLegList::get_type(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getType", &param1));
        if(!PyErr_Occurred())
        {
            SuitLeg::Type return_value = ((const SuitLegList*)local_this)->get_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_type_23_comment =
    "C++ Interface:\n"
    "getType(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type of this leg.  Most legs are of type\n"
    "//               T_bellicose, which corresponds to just plain walking\n"
    "//               down the street, but other legs particularly at both\n"
    "//               ends of the path may represent other modes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_type_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SuitLegList::get_start_time(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_start_time_24(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SuitLegList::get_start_time(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getStartTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getStartTime", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SuitLegList*)local_this)->get_start_time((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartTime(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_start_time_24_comment =
    "C++ Interface:\n"
    "getStartTime(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_start_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time (in seconds elapsed since the\n"
    "//               beginning of the path) at which this leg begins.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_start_time_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SuitLegList::get_leg_time(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_leg_time_25(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SuitLegList::get_leg_time(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getLegTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getLegTime", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SuitLegList*)local_this)->get_leg_time((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLegTime(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_leg_time_25_comment =
    "C++ Interface:\n"
    "getLegTime(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_leg_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the total length of time, in seconds, which\n"
    "//               this leg represents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_leg_time_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLegList::get_zone_id(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_zone_id_26(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLegList::get_zone_id(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getZoneId", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getZoneId", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLegList*)local_this)->get_zone_id((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZoneId(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_zone_id_26_comment =
    "C++ Interface:\n"
    "getZoneId(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_zone_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the Zone ID associated with this leg.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_zone_id\n"
    "//       Access: Private, Static\n"
    "//  Description: Returns the Zone ID associated with the edge defined\n"
    "//               by the two suit points.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_zone_id_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLegList::get_block_number(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_block_number_27(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLegList::get_block_number(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBlockNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBlockNumber", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLegList*)local_this)->get_block_number((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockNumber(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_block_number_27_comment =
    "C++ Interface:\n"
    "getBlockNumber(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_block_number\n"
    "//       Access: Published\n"
    "//  Description: Returns the block number associated with this leg, if\n"
    "//               any.  Normally this is only relevant for CogHQ door\n"
    "//               type legs, in which it represents the particular door\n"
    "//               index we're going through.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_block_number_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLegList::get_point_a(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_point_a_28(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLegList::get_point_a(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPointA", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPointA", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLegList*)local_this)->get_point_a((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointA(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_point_a_28_comment =
    "C++ Interface:\n"
    "getPointA(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_point_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the first DNASuitPoint associated with this\n"
    "//               leg.  In most cases, the leg represents the path\n"
    "//               between point A and point B.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_point_a_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SuitLegList::get_point_b(int n) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_get_point_b_29(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SuitLegList::get_point_b(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPointB", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPointB", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SuitLegList*)local_this)->get_point_b((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointB(const SuitLegList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_get_point_b_29_comment =
    "C++ Interface:\n"
    "getPointB(const SuitLegList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::get_point_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the first DNASuitPoint associated with this\n"
    "//               leg.  In most cases, the leg represents the path\n"
    "//               between point A and point B.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_get_point_b_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool SuitLegList::is_point_in_range(DNASuitPoint const *point, double begin, double end) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_is_point_in_range_30(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool SuitLegList::is_point_in_range(DNASuitPoint const *point, double begin, double end) const
            PyObject *param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"point", (char *)"begin", (char *)"end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:isPointInRange", key_word_list, &param1, &param2, &param3))
            {
                DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "SuitLegList.isPointInRange", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const SuitLegList*)local_this)->is_point_in_range(param1_this, (double)param2, (double)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPointInRange(const SuitLegList this, const DNASuitPoint point, float begin, float end)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_is_point_in_range_30_comment =
    "C++ Interface:\n"
    "isPointInRange(const SuitLegList this, const DNASuitPoint point, float begin, float end)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::is_point_in_range\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated point lies on this\n"
    "//               path, between times begin and end, or false\n"
    "//               otherwise.  This is useful for ensuring two suits\n"
    "//               aren't assigned paths too close to each other.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_is_point_in_range_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SuitLegList::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_output_31(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void SuitLegList::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SuitLegList.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SuitLegList*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const SuitLegList this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_output_31_comment =
    "C++ Interface:\n"
    "output(const SuitLegList this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_output_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SuitLegList::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_SuitLegList_write_32(PyObject *self, PyObject *args,PyObject *kwds) {
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void SuitLegList::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SuitLegList.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SuitLegList*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const SuitLegList this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SuitLegList_write_32_comment =
    "C++ Interface:\n"
    "write(const SuitLegList this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SuitLegList::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SuitLegList_write_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SuitLegList::SuitLegList(DNASuitPath const *path, DNAStorage const &storage, double suit_walk_speed, double from_sky_time, double to_sky_time, double from_suit_building_time, double to_suit_building_time, double to_toon_building_time)
 *******************************************************************/
int  Dtool_Init_SuitLegList(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-SuitLegList::SuitLegList(DNASuitPath const *path, DNAStorage const &storage, double suit_walk_speed, double from_sky_time, double to_sky_time, double from_suit_building_time, double to_suit_building_time, double to_toon_building_time)
            PyObject *param0;
            PyObject *param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            static char * key_word_list[] = {(char *)"path", (char *)"storage", (char *)"suit_walk_speed", (char *)"from_sky_time", (char *)"to_sky_time", (char *)"from_suit_building_time", (char *)"to_suit_building_time", (char *)"to_toon_building_time", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOdddddd:SuitLegList", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                DNASuitPath *param0_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPath, 0, "SuitLegList.SuitLegList", 1, coerced_ptr, report_errors);
DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "SuitLegList.SuitLegList", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    SuitLegList *return_value = new SuitLegList(param0_this, *param1_this, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_SuitLegList,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SuitLegList(const DNASuitPath path, const DNAStorage storage, float suit_walk_speed, float from_sky_time, float to_sky_time, float from_suit_building_time, float to_suit_building_time, float to_toon_building_time)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SuitLegList(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SuitLegList)
    {
        printf("SuitLegList ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SuitLegList * local_this = (SuitLegList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SuitLegList)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SuitLegList(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SuitLegList)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. SuitLeg | SuitLeg
//********************************************************************
PyMethodDef Dtool_Methods_SuitLeg[]= {
  { "getType",(PyCFunction ) &Dtool_SuitLeg_get_type_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_type_3_comment},
  { "getStartTime",(PyCFunction ) &Dtool_SuitLeg_get_start_time_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_start_time_4_comment},
  { "getLegTime",(PyCFunction ) &Dtool_SuitLeg_get_leg_time_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_leg_time_5_comment},
  { "getZoneId",(PyCFunction ) &Dtool_SuitLeg_get_zone_id_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_zone_id_6_comment},
  { "getBlockNumber",(PyCFunction ) &Dtool_SuitLeg_get_block_number_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_block_number_7_comment},
  { "getPointA",(PyCFunction ) &Dtool_SuitLeg_get_point_a_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_point_a_8_comment},
  { "getPointB",(PyCFunction ) &Dtool_SuitLeg_get_point_b_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_point_b_9_comment},
  { "getPosA",(PyCFunction ) &Dtool_SuitLeg_get_pos_a_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_pos_a_10_comment},
  { "getPosB",(PyCFunction ) &Dtool_SuitLeg_get_pos_b_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_pos_b_11_comment},
  { "getPosAtTime",(PyCFunction ) &Dtool_SuitLeg_get_pos_at_time_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_pos_at_time_12_comment},
  { "getTypeName",(PyCFunction ) &Dtool_SuitLeg_get_type_name_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_get_type_name_13_comment},
  { "output",(PyCFunction ) &Dtool_SuitLeg_output_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLeg_output_14_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     SuitLeg
//////////////////
static PyObject *  Dtool_Repr_SuitLeg(PyObject * self)
{
    SuitLeg * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLeg,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_SuitLeg(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SuitLeg.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SuitLeg\n"
          "// Description : This class is used by SuitBase, which is the base for\n"
          "//               both DistributedSuit and DistributedSuitAI, to build\n"
          "//               up a list of legs along the suit's path.\n"
          "//\n"
          "//               Each leg corresponds to a small segment of the suit's\n"
          "//               path as it walks along the street.  Generally, there\n"
          "//               is one leg between each two DNASuitPoints that make\n"
          "//               up the path, with some additional legs at both ends\n"
          "//               to manage the transitions in and out of the world.\n"
          "//\n"
          "//               The client-side DistributedSuit object uses these\n"
          "//               legs to define intervals to lerp it from place to\n"
          "//               place, while the AI side is mainly concerned about\n"
          "//               setting the zone properly each time.\n"
          "//\n"
          "//               This class is defined in C++ instead of in Python\n"
          "//               because we have to create a long list of SuitLegs\n"
          "//               every time we encounter a new suit, a process which\n"
          "//               takes substantial time in Python but is negligible in\n"
          "//               C++.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SuitLeg.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SuitLeg.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SuitLeg.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_SuitLeg.As_PyTypeObject().tp_repr = & Dtool_Repr_SuitLeg;
        // __str__ Repr Proxy
        Dtool_SuitLeg.As_PyTypeObject().tp_str = & Dtool_Repr_SuitLeg;
        // Enum  SuitLeg::Type;
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TWalkFromStreet",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TWalkToStreet",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TWalk",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TFromSky",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TToSky",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TFromSuitBuilding",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TToSuitBuilding",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TToToonBuilding",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TFromCoghq",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TToCoghq",PyInt_FromLong(9));
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"TOff",PyInt_FromLong(10));
        if(PyType_Ready(&Dtool_SuitLeg.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SuitLeg)");
             printf(" Error In PyType_ReadySuitLeg");
             return;
        }
        Py_INCREF(&Dtool_SuitLeg.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"SuitLeg",&Dtool_SuitLeg.As_PyObject());
        //  Static Method getTypeName
        PyDict_SetItemString(Dtool_SuitLeg.As_PyTypeObject().tp_dict,"getTypeName",PyCFunction_New(&Dtool_Methods_SuitLeg[10],&Dtool_SuitLeg.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SuitLeg,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SuitLeg.As_PyTypeObject());
        PyModule_AddObject(module, "SuitLeg",(PyObject *)&Dtool_SuitLeg.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SuitLegList | SuitLegList
//********************************************************************
PyMethodDef Dtool_Methods_SuitLegList[]= {
  { "getNumLegs",(PyCFunction ) &Dtool_SuitLegList_get_num_legs_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_num_legs_19_comment},
  { "getLeg",(PyCFunction ) &Dtool_SuitLegList_get_leg_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_leg_20_comment},
  { "__getitem__",(PyCFunction ) &Dtool_SuitLegList_operator_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_operator_21_comment},
  { "getLegIndexAtTime",(PyCFunction ) &Dtool_SuitLegList_get_leg_index_at_time_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_leg_index_at_time_22_comment},
  { "getType",(PyCFunction ) &Dtool_SuitLegList_get_type_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_type_23_comment},
  { "getStartTime",(PyCFunction ) &Dtool_SuitLegList_get_start_time_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_start_time_24_comment},
  { "getLegTime",(PyCFunction ) &Dtool_SuitLegList_get_leg_time_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_leg_time_25_comment},
  { "getZoneId",(PyCFunction ) &Dtool_SuitLegList_get_zone_id_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_zone_id_26_comment},
  { "getBlockNumber",(PyCFunction ) &Dtool_SuitLegList_get_block_number_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_block_number_27_comment},
  { "getPointA",(PyCFunction ) &Dtool_SuitLegList_get_point_a_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_point_a_28_comment},
  { "getPointB",(PyCFunction ) &Dtool_SuitLegList_get_point_b_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_get_point_b_29_comment},
  { "isPointInRange",(PyCFunction ) &Dtool_SuitLegList_is_point_in_range_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_is_point_in_range_30_comment},
  { "output",(PyCFunction ) &Dtool_SuitLegList_output_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_output_31_comment},
  { "write",(PyCFunction ) &Dtool_SuitLegList_write_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SuitLegList_write_32_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SuitLegList ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_SuitLegList_operator_21__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SuitLegList_operator_21(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     SuitLegList
//////////////////
static PyObject *  Dtool_Repr_SuitLegList(PyObject * self)
{
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     SuitLegList
//////////////////
static PyObject *  Dtool_Str_SuitLegList(PyObject * self)
{
    SuitLegList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SuitLegList,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_SuitLegList(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SuitLegList.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SuitLegList\n"
          "// Description : This is a list of SuitLegs.  See SuitLeg for a more\n"
          "//               detailed explanation of its purpose.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SuitLegList.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SuitLegList.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SuitLegList.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SuitLegList.As_PyTypeObject().tp_dict);
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_SuitLegList.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_SuitLegList_operator_21__getitem__;
        // __repr__
        Dtool_SuitLegList.As_PyTypeObject().tp_repr = & Dtool_Repr_SuitLegList;
        // __str__
        Dtool_SuitLegList.As_PyTypeObject().tp_str = & Dtool_Str_SuitLegList;
        if(PyType_Ready(&Dtool_SuitLegList.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SuitLegList)");
             printf(" Error In PyType_ReadySuitLegList");
             return;
        }
        Py_INCREF(&Dtool_SuitLegList.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SuitLegList.As_PyTypeObject().tp_dict,"SuitLegList",&Dtool_SuitLegList.As_PyObject());
        RegisterRuntimeClass(&Dtool_SuitLegList,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SuitLegList.As_PyTypeObject());
        PyModule_AddObject(module, "SuitLegList",(PyObject *)&Dtool_SuitLegList.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..SuitLeg
//********************************************************************
   Dtool_PyModuleClassInit_SuitLeg(module);
//********************************************************************
//*** Module Init Updcall ..SuitLegList
//********************************************************************
   Dtool_PyModuleClassInit_SuitLegList(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libsuit_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687214018,  /* file_identifier */
  "libsuit",  /* library_name */
  "dPJO",  /* library_hash_name */
  "toontown",  /* module_name */
  "libsuit.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  83  /* next_index */
};

Configure(_in_configure_libsuit);
ConfigureFn(_in_configure_libsuit) {
  interrogate_request_module(&_in_module_def);
}

