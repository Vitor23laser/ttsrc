/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir otp/configrc -Iotp/configrc -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libsettings_igate.cxx -od built_Rocket/pandac/input/libsettings.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Iotp/configrc -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_OTP -module otp -library libsettings settingsFile.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libsettings
#include "py_panda.h"  

#include "dtoolbase.h"
#include "filename.h"
#include "settingsFile.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. Settings
//********************************************************************
typedef  Settings  Settings_localtype;
Define_Module_Class(otp,Settings,Settings_localtype,Settings);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. Settings 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_sfx(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_sfx_6(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_sfx(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getSfx", key_word_list))
        {
            bool return_value = Settings::get_sfx();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSfx()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_sfx_6_comment =
    "C++ Interface:\n"
    "getSfx()\n"
    "\n"
    "// Filename: settingsFile.I\n"
    "// Created by:  cary (14Dec00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Settings_get_sfx_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_toon_chat_sounds(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_toon_chat_sounds_7(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_toon_chat_sounds(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getToonChatSounds", key_word_list))
        {
            bool return_value = Settings::get_toon_chat_sounds();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getToonChatSounds()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_toon_chat_sounds_7_comment =
    "C++ Interface:\n"
    "getToonChatSounds()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_toon_chat_sounds_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_music(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_music_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_music(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMusic", key_word_list))
        {
            bool return_value = Settings::get_music();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMusic()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_music_8_comment =
    "C++ Interface:\n"
    "getMusic()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_music_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_force_sw_midi(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_force_sw_midi_9(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_force_sw_midi(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceSwMidi", key_word_list))
        {
            bool return_value = Settings::get_force_sw_midi();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceSwMidi()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_force_sw_midi_9_comment =
    "C++ Interface:\n"
    "getForceSwMidi()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_force_sw_midi_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_windowed_mode(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_windowed_mode_10(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_windowed_mode(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindowedMode", key_word_list))
        {
            bool return_value = Settings::get_windowed_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindowedMode()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_windowed_mode_10_comment =
    "C++ Interface:\n"
    "getWindowedMode()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_windowed_mode_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::want_chat_log(void)
 *******************************************************************/
static PyObject *Dtool_Settings_want_chat_log_11(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::want_chat_log(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":wantChatLog", key_word_list))
        {
            bool return_value = Settings::want_chat_log();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wantChatLog()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_want_chat_log_11_comment =
    "C++ Interface:\n"
    "wantChatLog()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_want_chat_log_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_show_fpsmeter(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_show_fpsmeter_12(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_show_fpsmeter(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getShowFpsmeter", key_word_list))
        {
            bool return_value = Settings::get_show_fpsmeter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShowFpsmeter()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_show_fpsmeter_12_comment =
    "C++ Interface:\n"
    "getShowFpsmeter()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_show_fpsmeter_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::want_custom_mouse_cursor(void)
 *******************************************************************/
static PyObject *Dtool_Settings_want_custom_mouse_cursor_13(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::want_custom_mouse_cursor(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":wantCustomMouseCursor", key_word_list))
        {
            bool return_value = Settings::want_custom_mouse_cursor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wantCustomMouseCursor()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_want_custom_mouse_cursor_13_comment =
    "C++ Interface:\n"
    "wantCustomMouseCursor()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_want_custom_mouse_cursor_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float Settings::get_sfx_volume(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_sfx_volume_14(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float Settings::get_sfx_volume(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getSfxVolume", key_word_list))
        {
            float return_value = Settings::get_sfx_volume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSfxVolume()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_sfx_volume_14_comment =
    "C++ Interface:\n"
    "getSfxVolume()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_sfx_volume_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float Settings::get_music_volume(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_music_volume_15(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float Settings::get_music_volume(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMusicVolume", key_word_list))
        {
            float return_value = Settings::get_music_volume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMusicVolume()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_music_volume_15_comment =
    "C++ Interface:\n"
    "getMusicVolume()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_music_volume_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Settings::DisplayDriver Settings::display_driver(void)
 *******************************************************************/
static PyObject *Dtool_Settings_display_driver_16(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Settings::DisplayDriver Settings::display_driver(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":displayDriver", key_word_list))
        {
            Settings::DisplayDriver return_value = Settings::display_driver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "displayDriver()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_display_driver_16_comment =
    "C++ Interface:\n"
    "displayDriver()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_display_driver_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Settings::Resolution Settings::get_resolution(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_resolution_17(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Settings::Resolution Settings::get_resolution(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getResolution", key_word_list))
        {
            Settings::Resolution return_value = Settings::get_resolution();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getResolution()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_resolution_17_comment =
    "C++ Interface:\n"
    "getResolution()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_resolution_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Settings::ServerType Settings::server_type(void)
 *******************************************************************/
static PyObject *Dtool_Settings_server_type_18(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Settings::ServerType Settings::server_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":serverType", key_word_list))
        {
            Settings::ServerType return_value = Settings::server_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "serverType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_server_type_18_comment =
    "C++ Interface:\n"
    "serverType()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_server_type_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_accepting_new_friends(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_accepting_new_friends_19(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_accepting_new_friends(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getAcceptingNewFriends", key_word_list))
        {
            bool return_value = Settings::get_accepting_new_friends();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptingNewFriends()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_accepting_new_friends_19_comment =
    "C++ Interface:\n"
    "getAcceptingNewFriends()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_accepting_new_friends_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_embedded_mode(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_embedded_mode_20(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_embedded_mode(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getEmbeddedMode", key_word_list))
        {
            bool return_value = Settings::get_embedded_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEmbeddedMode()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_embedded_mode_20_comment =
    "C++ Interface:\n"
    "getEmbeddedMode()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_embedded_mode_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::get_accepting_non_friend_whispers(void)
 *******************************************************************/
static PyObject *Dtool_Settings_get_accepting_non_friend_whispers_21(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::get_accepting_non_friend_whispers(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getAcceptingNonFriendWhispers", key_word_list))
        {
            bool return_value = Settings::get_accepting_non_friend_whispers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptingNonFriendWhispers()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_get_accepting_non_friend_whispers_21_comment =
    "C++ Interface:\n"
    "getAcceptingNonFriendWhispers()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_get_accepting_non_friend_whispers_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_sfx(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_sfx_22(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_sfx(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSfx", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setSfx", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_sfx((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSfx(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_sfx_22_comment =
    "C++ Interface:\n"
    "setSfx(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_sfx_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_toon_chat_sounds(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_toon_chat_sounds_23(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_toon_chat_sounds(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setToonChatSounds", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setToonChatSounds", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_toon_chat_sounds((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setToonChatSounds(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_toon_chat_sounds_23_comment =
    "C++ Interface:\n"
    "setToonChatSounds(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_toon_chat_sounds_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_music(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_music_24(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_music(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMusic", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setMusic", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_music((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMusic(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_music_24_comment =
    "C++ Interface:\n"
    "setMusic(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_music_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_force_sw_midi(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_force_sw_midi_25(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_force_sw_midi(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setForceSwMidi", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setForceSwMidi", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_force_sw_midi((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForceSwMidi(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_force_sw_midi_25_comment =
    "C++ Interface:\n"
    "setForceSwMidi(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_force_sw_midi_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_custom_mouse_cursor(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_custom_mouse_cursor_26(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_custom_mouse_cursor(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCustomMouseCursor", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setCustomMouseCursor", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_custom_mouse_cursor((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCustomMouseCursor(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_custom_mouse_cursor_26_comment =
    "C++ Interface:\n"
    "setCustomMouseCursor(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_custom_mouse_cursor_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_chat_log(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_chat_log_27(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_chat_log(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setChatLog", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setChatLog", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_chat_log((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChatLog(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_chat_log_27_comment =
    "C++ Interface:\n"
    "setChatLog(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_chat_log_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_windowed_mode(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_windowed_mode_28(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_windowed_mode(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWindowedMode", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setWindowedMode", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_windowed_mode((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWindowedMode(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_windowed_mode_28_comment =
    "C++ Interface:\n"
    "setWindowedMode(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_windowed_mode_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_sfx_volume(float )
 *******************************************************************/
static PyObject *Dtool_Settings_set_sfx_volume_29(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_sfx_volume(float )
        double param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSfxVolume", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:setSfxVolume", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_sfx_volume((float)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSfxVolume(float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_sfx_volume_29_comment =
    "C++ Interface:\n"
    "setSfxVolume(float)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_sfx_volume_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_music_volume(float )
 *******************************************************************/
static PyObject *Dtool_Settings_set_music_volume_30(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_music_volume(float )
        double param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMusicVolume", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:setMusicVolume", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_music_volume((float)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMusicVolume(float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_music_volume_30_comment =
    "C++ Interface:\n"
    "setMusicVolume(float)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_music_volume_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_display_driver(Settings::DisplayDriver )
 *******************************************************************/
static PyObject *Dtool_Settings_set_display_driver_31(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_display_driver(Settings::DisplayDriver )
        int param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setDisplayDriver", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:setDisplayDriver", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_display_driver((Settings::DisplayDriver)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDisplayDriver(int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_display_driver_31_comment =
    "C++ Interface:\n"
    "setDisplayDriver(int)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_display_driver_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_resolution(Settings::Resolution )
 *******************************************************************/
static PyObject *Dtool_Settings_set_resolution_32(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_resolution(Settings::Resolution )
        int param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setResolution", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:setResolution", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_resolution((Settings::Resolution)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setResolution(int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_resolution_32_comment =
    "C++ Interface:\n"
    "setResolution(int)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_resolution_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void Settings::set_resolution_dimensions(unsigned int xsize, unsigned int ysize)
 *******************************************************************/
static PyObject *Dtool_Settings_set_resolution_dimensions_33(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void Settings::set_resolution_dimensions(unsigned int xsize, unsigned int ysize)
        PyObject *param0;
        PyObject *param1;
        static char * key_word_list[] = {(char *)"xsize", (char *)"ysize", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setResolutionDimensions", key_word_list, &param0, &param1))
        {
             PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param0_uint == NULL)|| (param1_uint == NULL)))
            {
                Settings::set_resolution_dimensions(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param0_uint); Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setResolutionDimensions(unsigned int xsize, unsigned int ysize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_resolution_dimensions_33_comment =
    "C++ Interface:\n"
    "setResolutionDimensions(unsigned int xsize, unsigned int ysize)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_resolution_dimensions_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_server_type(Settings::ServerType )
 *******************************************************************/
static PyObject *Dtool_Settings_set_server_type_34(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_server_type(Settings::ServerType )
        int param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setServerType", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:setServerType", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_server_type((Settings::ServerType)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setServerType(int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_server_type_34_comment =
    "C++ Interface:\n"
    "setServerType(int)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_server_type_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_accepting_new_friends(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_accepting_new_friends_35(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_accepting_new_friends(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAcceptingNewFriends", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setAcceptingNewFriends", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_accepting_new_friends((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAcceptingNewFriends(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_accepting_new_friends_35_comment =
    "C++ Interface:\n"
    "setAcceptingNewFriends(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_accepting_new_friends_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_embedded_mode(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_embedded_mode_36(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_embedded_mode(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEmbeddedMode", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setEmbeddedMode", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_embedded_mode((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEmbeddedMode(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_embedded_mode_36_comment =
    "C++ Interface:\n"
    "setEmbeddedMode(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_embedded_mode_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_accepting_non_friend_whispers(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_accepting_non_friend_whispers_37(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_accepting_non_friend_whispers(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAcceptingNonFriendWhispers", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setAcceptingNonFriendWhispers", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_accepting_non_friend_whispers((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAcceptingNonFriendWhispers(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_accepting_non_friend_whispers_37_comment =
    "C++ Interface:\n"
    "setAcceptingNonFriendWhispers(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_accepting_non_friend_whispers_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::set_show_fpsmeter(bool )
 *******************************************************************/
static PyObject *Dtool_Settings_set_show_fpsmeter_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::set_show_fpsmeter(bool )
        PyObject *param0;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setShowFpsmeter", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setShowFpsmeter", &param0));
        if(!PyErr_Occurred())
        {
            Settings::set_show_fpsmeter((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setShowFpsmeter(bool)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_set_show_fpsmeter_38_comment =
    "C++ Interface:\n"
    "setShowFpsmeter(bool)\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_set_show_fpsmeter_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Settings::doSavedSettingsExist(void)
 *******************************************************************/
static PyObject *Dtool_Settings_doSavedSettingsExist_39(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Settings::doSavedSettingsExist(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":doSavedSettingsExist", key_word_list))
        {
            bool return_value = Settings::doSavedSettingsExist();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "doSavedSettingsExist()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_doSavedSettingsExist_39_comment =
    "C++ Interface:\n"
    "doSavedSettingsExist()\n"
    "\n"
    "";
#else
static const char * Dtool_Settings_doSavedSettingsExist_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::write_settings(void)
 *******************************************************************/
static PyObject *Dtool_Settings_write_settings_40(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::write_settings(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":writeSettings", key_word_list))
        {
            Settings::write_settings();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeSettings()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_write_settings_40_comment =
    "C++ Interface:\n"
    "writeSettings()\n"
    "\n"
    "// does the saved settings file exist?\n"
    "";
#else
static const char * Dtool_Settings_write_settings_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Settings::read_settings(void)
 *******************************************************************/
static PyObject *Dtool_Settings_read_settings_41(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Settings::read_settings(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":readSettings", key_word_list))
        {
            Settings::read_settings();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readSettings()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Settings_read_settings_41_comment =
    "C++ Interface:\n"
    "readSettings()\n"
    "\n"
    "// does the saved settings file exist?\n"
    "";
#else
static const char * Dtool_Settings_read_settings_41_comment = NULL;
#endif

int  Dtool_Init_Settings(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Settings)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Settings(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Settings)
    {
        printf("Settings ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Settings * local_this = (Settings *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Settings)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Settings(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Settings)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. Settings | Settings
//********************************************************************
PyMethodDef Dtool_Methods_Settings[]= {
  { "getSfx",(PyCFunction ) &Dtool_Settings_get_sfx_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_sfx_6_comment},
  { "getToonChatSounds",(PyCFunction ) &Dtool_Settings_get_toon_chat_sounds_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_toon_chat_sounds_7_comment},
  { "getMusic",(PyCFunction ) &Dtool_Settings_get_music_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_music_8_comment},
  { "getForceSwMidi",(PyCFunction ) &Dtool_Settings_get_force_sw_midi_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_force_sw_midi_9_comment},
  { "getWindowedMode",(PyCFunction ) &Dtool_Settings_get_windowed_mode_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_windowed_mode_10_comment},
  { "wantChatLog",(PyCFunction ) &Dtool_Settings_want_chat_log_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_want_chat_log_11_comment},
  { "getShowFpsmeter",(PyCFunction ) &Dtool_Settings_get_show_fpsmeter_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_show_fpsmeter_12_comment},
  { "wantCustomMouseCursor",(PyCFunction ) &Dtool_Settings_want_custom_mouse_cursor_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_want_custom_mouse_cursor_13_comment},
  { "getSfxVolume",(PyCFunction ) &Dtool_Settings_get_sfx_volume_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_sfx_volume_14_comment},
  { "getMusicVolume",(PyCFunction ) &Dtool_Settings_get_music_volume_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_music_volume_15_comment},
  { "displayDriver",(PyCFunction ) &Dtool_Settings_display_driver_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_display_driver_16_comment},
  { "getResolution",(PyCFunction ) &Dtool_Settings_get_resolution_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_resolution_17_comment},
  { "serverType",(PyCFunction ) &Dtool_Settings_server_type_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_server_type_18_comment},
  { "getAcceptingNewFriends",(PyCFunction ) &Dtool_Settings_get_accepting_new_friends_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_accepting_new_friends_19_comment},
  { "getEmbeddedMode",(PyCFunction ) &Dtool_Settings_get_embedded_mode_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_embedded_mode_20_comment},
  { "getAcceptingNonFriendWhispers",(PyCFunction ) &Dtool_Settings_get_accepting_non_friend_whispers_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_get_accepting_non_friend_whispers_21_comment},
  { "setSfx",(PyCFunction ) &Dtool_Settings_set_sfx_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_sfx_22_comment},
  { "setToonChatSounds",(PyCFunction ) &Dtool_Settings_set_toon_chat_sounds_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_toon_chat_sounds_23_comment},
  { "setMusic",(PyCFunction ) &Dtool_Settings_set_music_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_music_24_comment},
  { "setForceSwMidi",(PyCFunction ) &Dtool_Settings_set_force_sw_midi_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_force_sw_midi_25_comment},
  { "setCustomMouseCursor",(PyCFunction ) &Dtool_Settings_set_custom_mouse_cursor_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_custom_mouse_cursor_26_comment},
  { "setChatLog",(PyCFunction ) &Dtool_Settings_set_chat_log_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_chat_log_27_comment},
  { "setWindowedMode",(PyCFunction ) &Dtool_Settings_set_windowed_mode_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_windowed_mode_28_comment},
  { "setSfxVolume",(PyCFunction ) &Dtool_Settings_set_sfx_volume_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_sfx_volume_29_comment},
  { "setMusicVolume",(PyCFunction ) &Dtool_Settings_set_music_volume_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_music_volume_30_comment},
  { "setDisplayDriver",(PyCFunction ) &Dtool_Settings_set_display_driver_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_display_driver_31_comment},
  { "setResolution",(PyCFunction ) &Dtool_Settings_set_resolution_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_resolution_32_comment},
  { "setResolutionDimensions",(PyCFunction ) &Dtool_Settings_set_resolution_dimensions_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_resolution_dimensions_33_comment},
  { "setServerType",(PyCFunction ) &Dtool_Settings_set_server_type_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_server_type_34_comment},
  { "setAcceptingNewFriends",(PyCFunction ) &Dtool_Settings_set_accepting_new_friends_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_accepting_new_friends_35_comment},
  { "setEmbeddedMode",(PyCFunction ) &Dtool_Settings_set_embedded_mode_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_embedded_mode_36_comment},
  { "setAcceptingNonFriendWhispers",(PyCFunction ) &Dtool_Settings_set_accepting_non_friend_whispers_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_accepting_non_friend_whispers_37_comment},
  { "setShowFpsmeter",(PyCFunction ) &Dtool_Settings_set_show_fpsmeter_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_set_show_fpsmeter_38_comment},
  { "doSavedSettingsExist",(PyCFunction ) &Dtool_Settings_doSavedSettingsExist_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_doSavedSettingsExist_39_comment},
  { "writeSettings",(PyCFunction ) &Dtool_Settings_write_settings_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_write_settings_40_comment},
  { "readSettings",(PyCFunction ) &Dtool_Settings_read_settings_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Settings_read_settings_41_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Settings(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Settings.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Settings.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Settings.As_PyTypeObject().tp_dict);
        // Enum  Settings::DisplayDriver;
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"GL",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DX7",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DDEFAULT",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DX9",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DNONE",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DX8",PyInt_FromLong(5));
        // Enum  Settings::ServerType;
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"PRODUCTION",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DEVELOPMENT",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"DEBUG",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"SNONE",PyInt_FromLong(3));
        // Enum  Settings::Resolution;
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"R640x480",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"R800x600",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"R1024x768",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"R1280x1024",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"R1600x1200",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"R1280x720",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"RNONE",PyInt_FromLong(6));
        if(PyType_Ready(&Dtool_Settings.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Settings)");
             printf(" Error In PyType_ReadySettings");
             return;
        }
        Py_INCREF(&Dtool_Settings.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"Settings",&Dtool_Settings.As_PyObject());
        //  Static Method getSfx
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getSfx",PyCFunction_New(&Dtool_Methods_Settings[0],&Dtool_Settings.As_PyObject()));
        //  Static Method getToonChatSounds
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getToonChatSounds",PyCFunction_New(&Dtool_Methods_Settings[1],&Dtool_Settings.As_PyObject()));
        //  Static Method getMusic
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getMusic",PyCFunction_New(&Dtool_Methods_Settings[2],&Dtool_Settings.As_PyObject()));
        //  Static Method getForceSwMidi
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getForceSwMidi",PyCFunction_New(&Dtool_Methods_Settings[3],&Dtool_Settings.As_PyObject()));
        //  Static Method getWindowedMode
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getWindowedMode",PyCFunction_New(&Dtool_Methods_Settings[4],&Dtool_Settings.As_PyObject()));
        //  Static Method wantChatLog
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"wantChatLog",PyCFunction_New(&Dtool_Methods_Settings[5],&Dtool_Settings.As_PyObject()));
        //  Static Method getShowFpsmeter
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getShowFpsmeter",PyCFunction_New(&Dtool_Methods_Settings[6],&Dtool_Settings.As_PyObject()));
        //  Static Method wantCustomMouseCursor
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"wantCustomMouseCursor",PyCFunction_New(&Dtool_Methods_Settings[7],&Dtool_Settings.As_PyObject()));
        //  Static Method getSfxVolume
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getSfxVolume",PyCFunction_New(&Dtool_Methods_Settings[8],&Dtool_Settings.As_PyObject()));
        //  Static Method getMusicVolume
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getMusicVolume",PyCFunction_New(&Dtool_Methods_Settings[9],&Dtool_Settings.As_PyObject()));
        //  Static Method displayDriver
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"displayDriver",PyCFunction_New(&Dtool_Methods_Settings[10],&Dtool_Settings.As_PyObject()));
        //  Static Method getResolution
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getResolution",PyCFunction_New(&Dtool_Methods_Settings[11],&Dtool_Settings.As_PyObject()));
        //  Static Method serverType
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"serverType",PyCFunction_New(&Dtool_Methods_Settings[12],&Dtool_Settings.As_PyObject()));
        //  Static Method getAcceptingNewFriends
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getAcceptingNewFriends",PyCFunction_New(&Dtool_Methods_Settings[13],&Dtool_Settings.As_PyObject()));
        //  Static Method getEmbeddedMode
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getEmbeddedMode",PyCFunction_New(&Dtool_Methods_Settings[14],&Dtool_Settings.As_PyObject()));
        //  Static Method getAcceptingNonFriendWhispers
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"getAcceptingNonFriendWhispers",PyCFunction_New(&Dtool_Methods_Settings[15],&Dtool_Settings.As_PyObject()));
        //  Static Method setSfx
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setSfx",PyCFunction_New(&Dtool_Methods_Settings[16],&Dtool_Settings.As_PyObject()));
        //  Static Method setToonChatSounds
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setToonChatSounds",PyCFunction_New(&Dtool_Methods_Settings[17],&Dtool_Settings.As_PyObject()));
        //  Static Method setMusic
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setMusic",PyCFunction_New(&Dtool_Methods_Settings[18],&Dtool_Settings.As_PyObject()));
        //  Static Method setForceSwMidi
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setForceSwMidi",PyCFunction_New(&Dtool_Methods_Settings[19],&Dtool_Settings.As_PyObject()));
        //  Static Method setCustomMouseCursor
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setCustomMouseCursor",PyCFunction_New(&Dtool_Methods_Settings[20],&Dtool_Settings.As_PyObject()));
        //  Static Method setChatLog
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setChatLog",PyCFunction_New(&Dtool_Methods_Settings[21],&Dtool_Settings.As_PyObject()));
        //  Static Method setWindowedMode
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setWindowedMode",PyCFunction_New(&Dtool_Methods_Settings[22],&Dtool_Settings.As_PyObject()));
        //  Static Method setSfxVolume
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setSfxVolume",PyCFunction_New(&Dtool_Methods_Settings[23],&Dtool_Settings.As_PyObject()));
        //  Static Method setMusicVolume
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setMusicVolume",PyCFunction_New(&Dtool_Methods_Settings[24],&Dtool_Settings.As_PyObject()));
        //  Static Method setDisplayDriver
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setDisplayDriver",PyCFunction_New(&Dtool_Methods_Settings[25],&Dtool_Settings.As_PyObject()));
        //  Static Method setResolution
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setResolution",PyCFunction_New(&Dtool_Methods_Settings[26],&Dtool_Settings.As_PyObject()));
        //  Static Method setResolutionDimensions
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setResolutionDimensions",PyCFunction_New(&Dtool_Methods_Settings[27],&Dtool_Settings.As_PyObject()));
        //  Static Method setServerType
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setServerType",PyCFunction_New(&Dtool_Methods_Settings[28],&Dtool_Settings.As_PyObject()));
        //  Static Method setAcceptingNewFriends
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setAcceptingNewFriends",PyCFunction_New(&Dtool_Methods_Settings[29],&Dtool_Settings.As_PyObject()));
        //  Static Method setEmbeddedMode
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setEmbeddedMode",PyCFunction_New(&Dtool_Methods_Settings[30],&Dtool_Settings.As_PyObject()));
        //  Static Method setAcceptingNonFriendWhispers
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setAcceptingNonFriendWhispers",PyCFunction_New(&Dtool_Methods_Settings[31],&Dtool_Settings.As_PyObject()));
        //  Static Method setShowFpsmeter
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"setShowFpsmeter",PyCFunction_New(&Dtool_Methods_Settings[32],&Dtool_Settings.As_PyObject()));
        //  Static Method doSavedSettingsExist
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"doSavedSettingsExist",PyCFunction_New(&Dtool_Methods_Settings[33],&Dtool_Settings.As_PyObject()));
        //  Static Method writeSettings
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"writeSettings",PyCFunction_New(&Dtool_Methods_Settings[34],&Dtool_Settings.As_PyObject()));
        //  Static Method readSettings
        PyDict_SetItemString(Dtool_Settings.As_PyTypeObject().tp_dict,"readSettings",PyCFunction_New(&Dtool_Methods_Settings[35],&Dtool_Settings.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Settings,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Settings.As_PyTypeObject());
        PyModule_AddObject(module, "Settings",(PyObject *)&Dtool_Settings.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..Settings
//********************************************************************
   Dtool_PyModuleClassInit_Settings(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libsettings_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213941,  /* file_identifier */
  "libsettings",  /* library_name */
  "vzzk",  /* library_hash_name */
  "otp",  /* module_name */
  "libsettings.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  82  /* next_index */
};

Configure(_in_configure_libsettings);
ConfigureFn(_in_configure_libsettings) {
  interrogate_request_module(&_in_module_def);
}

