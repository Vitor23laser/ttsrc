/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/vision -Ipanda/src/vision -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libvision_igate.cxx -od built_Rocket/pandac/input/libvision.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/vision -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/jpeg/include -Sthirdparty/win-libs-vc9/artoolkit/include -Sthirdparty/win-libs-vc9/opencv/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_VISION -module p3vision -library libvision arToolKit.h config_vision.h openCVTexture.h webcamVideo.h webcamVideoCursorV4L.h webcamVideoV4L.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libvision
#include "py_panda.h"  

#include "arToolKit.h"
#include "config_vision.h"
#include <cv.h>
#include <cxcore.h>
#include "movieVideo.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "openCVTexture.h"
#include "pandabase.h"
#include "texture.h"
#include "videoTexture.h"
#include "webcamVideo.h"
#include "webcamVideoCursorV4L.h"
#include "webcamVideoV4L.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ARToolKit
//********************************************************************
typedef  ARToolKit  ARToolKit_localtype;
Define_Module_Class(p3vision,ARToolKit,ARToolKit_localtype,ARToolKit);
//********************************************************************
//*** prototypes for .. OpenCVTexture
//********************************************************************
typedef  OpenCVTexture  OpenCVTexture_localtype;
Define_Module_ClassRef(p3vision,OpenCVTexture,OpenCVTexture_localtype,OpenCVTexture);
//********************************************************************
//*** prototypes for .. WebcamVideo
//********************************************************************
typedef  WebcamVideo  WebcamVideo_localtype;
Define_Module_ClassRef(p3vision,WebcamVideo,WebcamVideo_localtype,WebcamVideo);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AnimInterface;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LoaderOptions;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovieVideo;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovieVideoCursor;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VideoTexture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. ARToolKit 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static ARToolKit *ARToolKit::make(NodePath camera, Filename const &paramfile, double markersize)
 *******************************************************************/
static PyObject *Dtool_ARToolKit_make_2(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static ARToolKit *ARToolKit::make(NodePath camera, Filename const &paramfile, double markersize)
            PyObject *param0;
            PyObject *param1;
            double param2;
            static char * key_word_list[] = {(char *)"camera", (char *)"paramfile", (char *)"markersize", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOd:make", key_word_list, &param0, &param1, &param2))
            {
                NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "ARToolKit.make", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ARToolKit.make", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    ARToolKit *return_value = ARToolKit::make(*param0_this, *param1_this, (double)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ARToolKit,false, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "make(const NodePath camera, const Filename paramfile, float markersize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ARToolKit_make_2_comment =
    "C++ Interface:\n"
    "make(const NodePath camera, const Filename paramfile, float markersize)\n"
    "\n"
    "";
#else
static const char * Dtool_ARToolKit_make_2_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ARToolKit::set_threshold(double n)
 *******************************************************************/
static PyObject *Dtool_ARToolKit_set_threshold_4(PyObject *self, PyObject *args,PyObject *kwds) {
    ARToolKit * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ARToolKit,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ARToolKit::set_threshold(double n)
        double param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setThreshold", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setThreshold", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_threshold((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ARToolKit.setThreshold() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThreshold(non-const ARToolKit this, float n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ARToolKit_set_threshold_4_comment =
    "C++ Interface:\n"
    "setThreshold(non-const ARToolKit this, float n)\n"
    "\n"
    "// Filename: arToolKit.I\n"
    "// Created by: jyelon (01Nov2007)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ARToolKit::set_threshold\n"
    "//       Access: private\n"
    "//  Description: As part of its analysis, the ARToolKit occasionally\n"
    "//               converts images to black and white by thresholding\n"
    "//               them.  The threshold is set to 0.5 by default, but\n"
    "//               you can tweak it here.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ARToolKit_set_threshold_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ARToolKit::attach_pattern(Filename const &pattern, NodePath path)
 *******************************************************************/
static PyObject *Dtool_ARToolKit_attach_pattern_5(PyObject *self, PyObject *args,PyObject *kwds) {
    ARToolKit * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ARToolKit,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ARToolKit::attach_pattern(Filename const &pattern, NodePath path)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"pattern", (char *)"path", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:attachPattern", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ARToolKit.attachPattern", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "ARToolKit.attachPattern", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->attach_pattern(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ARToolKit.attachPattern() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachPattern(non-const ARToolKit this, const Filename pattern, const NodePath path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ARToolKit_attach_pattern_5_comment =
    "C++ Interface:\n"
    "attachPattern(non-const ARToolKit this, const Filename pattern, const NodePath path)\n"
    "\n"
    "";
#else
static const char * Dtool_ARToolKit_attach_pattern_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ARToolKit::detach_patterns(void)
 *******************************************************************/
static PyObject *Dtool_ARToolKit_detach_patterns_6(PyObject *self, PyObject *args,PyObject *kwds) {
    ARToolKit * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ARToolKit,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ARToolKit::detach_patterns(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":detachPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":detachPatterns"));
        if(!PyErr_Occurred())
        {
            (local_this)->detach_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ARToolKit.detachPatterns() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "detachPatterns(non-const ARToolKit this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ARToolKit_detach_patterns_6_comment =
    "C++ Interface:\n"
    "detachPatterns(non-const ARToolKit this)\n"
    "\n"
    "";
#else
static const char * Dtool_ARToolKit_detach_patterns_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ARToolKit::analyze(Texture *tex, bool do_flip_texture)
 * void ARToolKit::analyze(Texture *tex, bool do_flip_texture = (1))
 *******************************************************************/
static PyObject *Dtool_ARToolKit_analyze_7(PyObject *self, PyObject *args,PyObject *kwds) {
    ARToolKit * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ARToolKit,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ARToolKit::analyze(Texture *tex, bool do_flip_texture = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"tex", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:analyze", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:analyze", &param1));
                if(!PyErr_Occurred())
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "ARToolKit.analyze", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->analyze(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ARToolKit.analyze() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ARToolKit::analyze(Texture *tex, bool do_flip_texture)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"tex", (char *)"do_flip_texture", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:analyze", key_word_list, &param1, &param2))
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "ARToolKit.analyze", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->analyze(param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ARToolKit.analyze() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "analyze() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "analyze(non-const ARToolKit this, non-const Texture tex)\n"
          "analyze(non-const ARToolKit this, non-const Texture tex, bool do_flip_texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ARToolKit_analyze_7_comment =
    "C++ Interface:\n"
    "analyze(non-const ARToolKit this, non-const Texture tex)\n"
    "analyze(non-const ARToolKit this, non-const Texture tex, bool do_flip_texture)\n"
    "\n"
    "";
#else
static const char * Dtool_ARToolKit_analyze_7_comment = NULL;
#endif

int  Dtool_Init_ARToolKit(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ARToolKit)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ARToolKit(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ARToolKit)
    {
        printf("ARToolKit ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ARToolKit * local_this = (ARToolKit *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ARToolKit)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ARToolKit(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ARToolKit)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OpenCVTexture 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool OpenCVTexture::from_camera(int camera_index, int z, LoaderOptions const &options)
 * bool OpenCVTexture::from_camera(int camera_index, int z, LoaderOptions const &options = ((())))
 * bool OpenCVTexture::from_camera(int camera_index, int z = (0), LoaderOptions const &options = ((())))
 * bool OpenCVTexture::from_camera(int camera_index = (-1), int z = (0), LoaderOptions const &options = ((())))
 *******************************************************************/
static PyObject *Dtool_OpenCVTexture_from_camera_11(PyObject *self, PyObject *args,PyObject *kwds) {
    OpenCVTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OpenCVTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool OpenCVTexture::from_camera(int camera_index = (-1), int z = (0), LoaderOptions const &options = ((())))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":fromCamera", key_word_list));
            else
                (PyArg_Parse(args, ":fromCamera"));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->from_camera();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OpenCVTexture.fromCamera() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool OpenCVTexture::from_camera(int camera_index, int z = (0), LoaderOptions const &options = ((())))
            int param1;
            static char * key_word_list[] = {(char *)"camera_index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:fromCamera", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:fromCamera", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->from_camera((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OpenCVTexture.fromCamera() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool OpenCVTexture::from_camera(int camera_index, int z, LoaderOptions const &options = ((())))
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"camera_index", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:fromCamera", key_word_list, &param1, &param2))
            {
                bool return_value = (local_this)->from_camera((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OpenCVTexture.fromCamera() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool OpenCVTexture::from_camera(int camera_index, int z, LoaderOptions const &options)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"camera_index", (char *)"z", (char *)"options", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:fromCamera", key_word_list, &param1, &param2, &param3))
                {
                    LoaderOptions *param3_this = (LoaderOptions *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LoaderOptions, 3, "OpenCVTexture.fromCamera", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        bool return_value = (local_this)->from_camera((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OpenCVTexture.fromCamera() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "fromCamera() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "fromCamera(non-const OpenCVTexture this)\n"
          "fromCamera(non-const OpenCVTexture this, int camera_index)\n"
          "fromCamera(non-const OpenCVTexture this, int camera_index, int z)\n"
          "fromCamera(non-const OpenCVTexture this, int camera_index, int z, const LoaderOptions options)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OpenCVTexture_from_camera_11_comment =
    "C++ Interface:\n"
    "fromCamera(non-const OpenCVTexture this)\n"
    "fromCamera(non-const OpenCVTexture this, int camera_index)\n"
    "fromCamera(non-const OpenCVTexture this, int camera_index, int z)\n"
    "fromCamera(non-const OpenCVTexture this, int camera_index, int z, const LoaderOptions options)\n"
    "\n"
    "";
#else
static const char * Dtool_OpenCVTexture_from_camera_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OpenCVTexture::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OpenCVTexture_get_class_type_12(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OpenCVTexture::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OpenCVTexture::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OpenCVTexture_get_class_type_12_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OpenCVTexture_get_class_type_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OpenCVTexture::OpenCVTexture(basic_string< char > const &name)
 * OpenCVTexture::OpenCVTexture(basic_string< char > const &name = ((string())))
 *******************************************************************/
int  Dtool_Init_OpenCVTexture(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OpenCVTexture::OpenCVTexture(basic_string< char > const &name = ((string())))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OpenCVTexture", key_word_list))
            {
                OpenCVTexture *return_value = new OpenCVTexture();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OpenCVTexture,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-OpenCVTexture::OpenCVTexture(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:OpenCVTexture", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:OpenCVTexture", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                OpenCVTexture *return_value = new OpenCVTexture(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OpenCVTexture,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OpenCVTexture() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OpenCVTexture()\n"
          "OpenCVTexture(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OpenCVTexture(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OpenCVTexture)
    {
        printf("OpenCVTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OpenCVTexture * local_this = (OpenCVTexture *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OpenCVTexture)
        return local_this;
    if(requested_type == &Dtool_AnimInterface)
        return ( AnimInterface *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_Texture)
        return ( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_VideoTexture)
        return ( VideoTexture *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OpenCVTexture(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OpenCVTexture)
        return from_this;
    if(from_type == &Dtool_AnimInterface)
    {
          AnimInterface* other_this = (AnimInterface*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_Texture)
    {
          Texture* other_this = (Texture*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (OpenCVTexture*)other_this;
    }
    if(from_type == &Dtool_VideoTexture)
    {
          VideoTexture* other_this = (VideoTexture*)from_this;
          return (OpenCVTexture*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WebcamVideo 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static int WebcamVideo::get_num_options(void)
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_get_num_options_15(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int WebcamVideo::get_num_options(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOptions", key_word_list))
        {
            int return_value = WebcamVideo::get_num_options();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOptions()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_get_num_options_15_comment =
    "C++ Interface:\n"
    "getNumOptions()\n"
    "\n"
    "";
#else
static const char * Dtool_WebcamVideo_get_num_options_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_get_option_16(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
        int param0;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getOption", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getOption", &param0));
        if(!PyErr_Occurred())
        {
            PointerTo< WebcamVideo > return_value = WebcamVideo::get_option((int)param0);
            if (return_value != (WebcamVideo *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_WebcamVideo,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOption(int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_get_option_16_comment =
    "C++ Interface:\n"
    "getOption(int n)\n"
    "\n"
    "";
#else
static const char * Dtool_WebcamVideo_get_option_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WebcamVideo::get_size_x(void) const
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_get_size_x_17(PyObject *self, PyObject *args,PyObject *kwds) {
    WebcamVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WebcamVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WebcamVideo::get_size_x(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSizeX", key_word_list));
        else
            (PyArg_Parse(args, ":getSizeX"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WebcamVideo*)local_this)->get_size_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSizeX(const WebcamVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_get_size_x_17_comment =
    "C++ Interface:\n"
    "getSizeX(const WebcamVideo this)\n"
    "\n"
    "// Filename: webcamVideo.I\n"
    "// Created by: jyelon (01Nov2007)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WebcamVideo::get_size_x\n"
    "//       Access: Published\n"
    "//  Description: Returns the camera's size_x.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WebcamVideo_get_size_x_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WebcamVideo::get_size_y(void) const
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_get_size_y_18(PyObject *self, PyObject *args,PyObject *kwds) {
    WebcamVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WebcamVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WebcamVideo::get_size_y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSizeY", key_word_list));
        else
            (PyArg_Parse(args, ":getSizeY"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WebcamVideo*)local_this)->get_size_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSizeY(const WebcamVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_get_size_y_18_comment =
    "C++ Interface:\n"
    "getSizeY(const WebcamVideo this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WebcamVideo::get_size_y\n"
    "//       Access: Published\n"
    "//  Description: Returns the camera's size_y.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WebcamVideo_get_size_y_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int WebcamVideo::get_fps(void) const
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_get_fps_19(PyObject *self, PyObject *args,PyObject *kwds) {
    WebcamVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WebcamVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int WebcamVideo::get_fps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFps", key_word_list));
        else
            (PyArg_Parse(args, ":getFps"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const WebcamVideo*)local_this)->get_fps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFps(const WebcamVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_get_fps_19_comment =
    "C++ Interface:\n"
    "getFps(const WebcamVideo this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WebcamVideo::get_fps\n"
    "//       Access: Published\n"
    "//  Description: Returns the camera's framerate.  This\n"
    "//               is a maximum theoretical: the actual performance\n"
    "//               will depend on the speed of the hardware.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WebcamVideo_get_fps_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieVideoCursor > WebcamVideo::open(void) = 0
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_open_20(PyObject *self, PyObject *args,PyObject *kwds) {
    WebcamVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WebcamVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieVideoCursor > WebcamVideo::open(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieVideoCursor > return_value = (local_this)->open();
            if (return_value != (MovieVideoCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieVideoCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WebcamVideo.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const WebcamVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_open_20_comment =
    "C++ Interface:\n"
    "open(non-const WebcamVideo this)\n"
    "\n"
    "";
#else
static const char * Dtool_WebcamVideo_open_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void WebcamVideo::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_output_21(PyObject *self, PyObject *args,PyObject *kwds) {
    WebcamVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WebcamVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void WebcamVideo::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "WebcamVideo.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const WebcamVideo*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const WebcamVideo this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_output_21_comment =
    "C++ Interface:\n"
    "output(const WebcamVideo this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WebcamVideo::output\n"
    "//       Access: Public\n"
    "//  Description: Outputs the WebcamVideo.  This function simply\n"
    "//               writes the name, size and FPS to the output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WebcamVideo_output_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle WebcamVideo::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_WebcamVideo_get_class_type_22(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle WebcamVideo::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = WebcamVideo::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WebcamVideo_get_class_type_22_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_WebcamVideo_get_class_type_22_comment = NULL;
#endif

int  Dtool_Init_WebcamVideo(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (WebcamVideo)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_WebcamVideo_get_options(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumOptions", "getOption");
}
inline void  * Dtool_UpcastInterface_WebcamVideo(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WebcamVideo)
    {
        printf("WebcamVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WebcamVideo * local_this = (WebcamVideo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WebcamVideo)
        return local_this;
    if(requested_type == &Dtool_MovieVideo)
        return ( MovieVideo *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WebcamVideo(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WebcamVideo)
        return from_this;
    if(from_type == &Dtool_MovieVideo)
    {
          MovieVideo* other_this = (MovieVideo*)from_this;
          return (WebcamVideo*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (WebcamVideo*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (WebcamVideo*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (WebcamVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (WebcamVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (WebcamVideo*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ARToolKit | ARToolKit
//********************************************************************
PyMethodDef Dtool_Methods_ARToolKit[]= {
  { "make",(PyCFunction ) &Dtool_ARToolKit_make_2, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ARToolKit_make_2_comment},
  { "setThreshold",(PyCFunction ) &Dtool_ARToolKit_set_threshold_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ARToolKit_set_threshold_4_comment},
  { "attachPattern",(PyCFunction ) &Dtool_ARToolKit_attach_pattern_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ARToolKit_attach_pattern_5_comment},
  { "detachPatterns",(PyCFunction ) &Dtool_ARToolKit_detach_patterns_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ARToolKit_detach_patterns_6_comment},
  { "analyze",(PyCFunction ) &Dtool_ARToolKit_analyze_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ARToolKit_analyze_7_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ARToolKit(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ARToolKit.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ARToolKit\n"
          "// Description : ARToolKit is a software library for building\n"
          "//               Augmented Reality (AR) applications. These are\n"
          "//               applications that involve the overlay of virtual\n"
          "//               imagery on the real world.  It was developed by\n"
          "//               Dr. Hirokazu Kato.  Its ongoing development is\n"
          "//               being supported by the Human Interface Technology\n"
          "//               Laboratory (HIT Lab) at the University of\n"
          "//               Washington, HIT Lab NZ at the University of\n"
          "//               Canterbury, New Zealand, and ARToolworks, Inc,\n"
          "//               Seattle.  It is available under a GPL license.\n"
          "//               It is also possible to negotiate other licenses\n"
          "//               with the copyright holders.\n"
          "//\n"
          "//               This class is a wrapper around the ARToolKit\n"
          "//               library.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ARToolKit.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ARToolKit.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ARToolKit.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ARToolKit.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ARToolKit.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ARToolKit)");
             printf(" Error In PyType_ReadyARToolKit");
             return;
        }
        Py_INCREF(&Dtool_ARToolKit.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ARToolKit.As_PyTypeObject().tp_dict,"ARToolKit",&Dtool_ARToolKit.As_PyObject());
        //  Static Method make
        PyDict_SetItemString(Dtool_ARToolKit.As_PyTypeObject().tp_dict,"make",PyCFunction_New(&Dtool_Methods_ARToolKit[0],&Dtool_ARToolKit.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ARToolKit,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ARToolKit.As_PyTypeObject());
        PyModule_AddObject(module, "ARToolKit",(PyObject *)&Dtool_ARToolKit.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OpenCVTexture | OpenCVTexture
//********************************************************************
PyMethodDef Dtool_Methods_OpenCVTexture[]= {
  { "fromCamera",(PyCFunction ) &Dtool_OpenCVTexture_from_camera_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OpenCVTexture_from_camera_11_comment},
  { "getClassType",(PyCFunction ) &Dtool_OpenCVTexture_get_class_type_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OpenCVTexture_get_class_type_12_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OpenCVTexture(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OpenCVTexture.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OpenCVTexture\n"
          "// Description : A specialization on VideoTexture that takes its input\n"
          "//               using the CV library, to produce an animated texture,\n"
          "//               with its source taken from an .avi file or from a\n"
          "//               camera input.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VideoTexture._Dtool_ClassInit(NULL);
        Dtool_OpenCVTexture.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VideoTexture.As_PyTypeObject());
        Dtool_OpenCVTexture.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OpenCVTexture.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OpenCVTexture.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OpenCVTexture.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OpenCVTexture)");
             printf(" Error In PyType_ReadyOpenCVTexture");
             return;
        }
        Py_INCREF(&Dtool_OpenCVTexture.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OpenCVTexture.As_PyTypeObject().tp_dict,"OpenCVTexture",&Dtool_OpenCVTexture.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OpenCVTexture.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OpenCVTexture[1],&Dtool_OpenCVTexture.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OpenCVTexture,OpenCVTexture::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OpenCVTexture.As_PyTypeObject());
        PyModule_AddObject(module, "OpenCVTexture",(PyObject *)&Dtool_OpenCVTexture.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WebcamVideo | WebcamVideo
//********************************************************************
PyMethodDef Dtool_Methods_WebcamVideo[]= {
  { "getNumOptions",(PyCFunction ) &Dtool_WebcamVideo_get_num_options_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_get_num_options_15_comment},
  { "getOption",(PyCFunction ) &Dtool_WebcamVideo_get_option_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_get_option_16_comment},
  { "getSizeX",(PyCFunction ) &Dtool_WebcamVideo_get_size_x_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_get_size_x_17_comment},
  { "getSizeY",(PyCFunction ) &Dtool_WebcamVideo_get_size_y_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_get_size_y_18_comment},
  { "getFps",(PyCFunction ) &Dtool_WebcamVideo_get_fps_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_get_fps_19_comment},
  { "open",(PyCFunction ) &Dtool_WebcamVideo_open_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_open_20_comment},
  { "output",(PyCFunction ) &Dtool_WebcamVideo_output_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_output_21_comment},
  { "getClassType",(PyCFunction ) &Dtool_WebcamVideo_get_class_type_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WebcamVideo_get_class_type_22_comment},
  { "getOptions",(PyCFunction) &MakeSeq_WebcamVideo_get_options, METH_NOARGS|METH_CLASS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     WebcamVideo
//////////////////
static PyObject *  Dtool_Repr_WebcamVideo(PyObject * self)
{
    WebcamVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WebcamVideo,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_WebcamVideo(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WebcamVideo.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WebcamVideo\n"
          "// Description : Allows you to open a webcam or other video capture\n"
          "//               device as a video stream.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieVideo._Dtool_ClassInit(NULL);
        Dtool_WebcamVideo.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieVideo.As_PyTypeObject());
        Dtool_WebcamVideo.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WebcamVideo.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WebcamVideo.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_WebcamVideo.As_PyTypeObject().tp_repr = & Dtool_Repr_WebcamVideo;
        // __str__ Repr Proxy
        Dtool_WebcamVideo.As_PyTypeObject().tp_str = & Dtool_Repr_WebcamVideo;
        if(PyType_Ready(&Dtool_WebcamVideo.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WebcamVideo)");
             printf(" Error In PyType_ReadyWebcamVideo");
             return;
        }
        Py_INCREF(&Dtool_WebcamVideo.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WebcamVideo.As_PyTypeObject().tp_dict,"WebcamVideo",&Dtool_WebcamVideo.As_PyObject());
        //  Static Method getNumOptions
        PyDict_SetItemString(Dtool_WebcamVideo.As_PyTypeObject().tp_dict,"getNumOptions",PyCFunction_New(&Dtool_Methods_WebcamVideo[0],&Dtool_WebcamVideo.As_PyObject()));
        //  Static Method getOption
        PyDict_SetItemString(Dtool_WebcamVideo.As_PyTypeObject().tp_dict,"getOption",PyCFunction_New(&Dtool_Methods_WebcamVideo[1],&Dtool_WebcamVideo.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_WebcamVideo.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_WebcamVideo[7],&Dtool_WebcamVideo.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WebcamVideo,WebcamVideo::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WebcamVideo.As_PyTypeObject());
        PyModule_AddObject(module, "WebcamVideo",(PyObject *)&Dtool_WebcamVideo.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..ARToolKit
//********************************************************************
   Dtool_PyModuleClassInit_ARToolKit(module);
//********************************************************************
//*** Module Init Updcall ..OpenCVTexture
//********************************************************************
   Dtool_PyModuleClassInit_OpenCVTexture(module);
//********************************************************************
//*** Module Init Updcall ..WebcamVideo
//********************************************************************
   Dtool_PyModuleClassInit_WebcamVideo(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libvision_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212932,  /* file_identifier */
  "libvision",  /* library_name */
  "1WSz",  /* library_hash_name */
  "p3vision",  /* module_name */
  "libvision.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  73  /* next_index */
};

Configure(_in_configure_libvision);
ConfigureFn(_in_configure_libvision) {
  interrogate_request_module(&_in_module_def);
}

