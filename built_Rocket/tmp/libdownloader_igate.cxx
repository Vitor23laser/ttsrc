/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/downloader -Ipanda/src/downloader -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdownloader_igate.cxx -od built_Rocket/pandac/input/libdownloader.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/downloader -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/zlib/include -Sthirdparty/win-libs-vc9/openssl/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDAEXPRESS -module pandaexpress -library libdownloader bioPtr.h bioStream.h bioStreamBuf.h bioStreamPtr.h chunkedStream.h chunkedStreamBuf.h config_downloader.h decompressor.h documentSpec.h downloadDb.h download_utils.h downloader_composite.cxx extractor.h httpAuthorization.h httpBasicAuthorization.h httpChannel.h httpClient.h httpCookie.h httpDate.h httpDigestAuthorization.h httpEntityTag.h httpEnum.h identityStream.h identityStreamBuf.h multiplexStream.h multiplexStreamBuf.h patcher.h socketStream.h stringStream.h stringStreamBuf.h urlSpec.h virtualFileHTTP.h virtualFileMountHTTP.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdownloader
#include "py_panda.h"  

#include "bioPtr.h"
#include "bioStream.h"
#include "bioStreamBuf.h"
#include "bioStreamPtr.h"
#include "chunkedStream.h"
#include "chunkedStreamBuf.h"
#include "config_downloader.h"
#include "datagram.h"
#include "datagramIterator.h"
#include "decompressor.h"
#include "documentSpec.h"
#include "downloadDb.h"
#include "download_utils.h"
#include "extractor.h"
#include "filename.h"
#include "hashVal.h"
#include "httpAuthorization.h"
#include "httpBasicAuthorization.h"
#include "httpChannel.h"
#include "httpClient.h"
#include "httpCookie.h"
#include "httpDate.h"
#include "httpDigestAuthorization.h"
#include "httpEntityTag.h"
#include "httpEnum.h"
#include "identityStream.h"
#include "identityStreamBuf.h"
#include "multifile.h"
#include "multiplexStream.h"
#include "multiplexStreamBuf.h"
#include "openssl/ssl.h"
#include "pandabase.h"
#include "patcher.h"
#include "pmap.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pvector.h"
#include "referenceCount.h"
#include "socketStream.h"
#include "stringStream.h"
#include "stringStreamBuf.h"
#include "urlSpec.h"
#include "virtualFileHTTP.h"
#include "virtualFileMountHTTP.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. SSReader
//********************************************************************
typedef  SSReader  SSReader_localtype;
Define_Module_Class(pandaexpress,SSReader,SSReader_localtype,SSReader);
//********************************************************************
//*** prototypes for .. SSWriter
//********************************************************************
typedef  SSWriter  SSWriter_localtype;
Define_Module_Class(pandaexpress,SSWriter,SSWriter_localtype,SSWriter);
//********************************************************************
//*** prototypes for .. ISocketStream
//********************************************************************
typedef  ISocketStream  ISocketStream_localtype;
Define_Module_Class(pandaexpress,ISocketStream,ISocketStream_localtype,ISocketStream);
//********************************************************************
//*** prototypes for .. OSocketStream
//********************************************************************
typedef  OSocketStream  OSocketStream_localtype;
Define_Module_Class(pandaexpress,OSocketStream,OSocketStream_localtype,OSocketStream);
//********************************************************************
//*** prototypes for .. SocketStream
//********************************************************************
typedef  SocketStream  SocketStream_localtype;
Define_Module_Class(pandaexpress,SocketStream,SocketStream_localtype,SocketStream);
//********************************************************************
//*** prototypes for .. URLSpec
//********************************************************************
typedef  URLSpec  URLSpec_localtype;
Define_Module_Class(pandaexpress,URLSpec,URLSpec_localtype,URLSpec);
//********************************************************************
//*** prototypes for .. HTTPEnum
//********************************************************************
typedef  HTTPEnum  HTTPEnum_localtype;
Define_Module_Class(pandaexpress,HTTPEnum,HTTPEnum_localtype,HTTPEnum);
//********************************************************************
//*** prototypes for .. HTTPDate
//********************************************************************
typedef  HTTPDate  HTTPDate_localtype;
Define_Module_Class(pandaexpress,HTTPDate,HTTPDate_localtype,HTTPDate);
//********************************************************************
//*** prototypes for .. HTTPCookie
//********************************************************************
typedef  HTTPCookie  HTTPCookie_localtype;
Define_Module_Class(pandaexpress,HTTPCookie,HTTPCookie_localtype,HTTPCookie);
//********************************************************************
//*** prototypes for .. HTTPClient
//********************************************************************
typedef  HTTPClient  HTTPClient_localtype;
Define_Module_ClassRef(pandaexpress,HTTPClient,HTTPClient_localtype,HTTPClient);
//********************************************************************
//*** prototypes for .. HTTPEntityTag
//********************************************************************
typedef  HTTPEntityTag  HTTPEntityTag_localtype;
Define_Module_Class(pandaexpress,HTTPEntityTag,HTTPEntityTag_localtype,HTTPEntityTag);
//********************************************************************
//*** prototypes for .. DocumentSpec
//********************************************************************
typedef  DocumentSpec  DocumentSpec_localtype;
Define_Module_Class(pandaexpress,DocumentSpec,DocumentSpec_localtype,DocumentSpec);
//********************************************************************
//*** prototypes for .. HTTPChannel
//********************************************************************
typedef  HTTPChannel  HTTPChannel_localtype;
Define_Module_ClassRef(pandaexpress,HTTPChannel,HTTPChannel_localtype,HTTPChannel);
//********************************************************************
//*** prototypes for .. Decompressor
//********************************************************************
typedef  Decompressor  Decompressor_localtype;
Define_Module_Class(pandaexpress,Decompressor,Decompressor_localtype,Decompressor);
//********************************************************************
//*** prototypes for .. DownloadDb
//********************************************************************
typedef  DownloadDb  DownloadDb_localtype;
Define_Module_Class(pandaexpress,DownloadDb,DownloadDb_localtype,DownloadDb);
//********************************************************************
//*** prototypes for .. VirtualFileHTTP
//********************************************************************
typedef  VirtualFileHTTP  VirtualFileHTTP_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileHTTP,VirtualFileHTTP_localtype,VirtualFileHTTP);
//********************************************************************
//*** prototypes for .. VirtualFileMountHTTP
//********************************************************************
typedef  VirtualFileMountHTTP  VirtualFileMountHTTP_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileMountHTTP,VirtualFileMountHTTP_localtype,VirtualFileMountHTTP);
//********************************************************************
//*** prototypes for .. Extractor
//********************************************************************
typedef  Extractor  Extractor_localtype;
Define_Module_Class(pandaexpress,Extractor,Extractor_localtype,Extractor);
//********************************************************************
//*** prototypes for .. MultiplexStream
//********************************************************************
typedef  MultiplexStream  MultiplexStream_localtype;
Define_Module_Class(pandaexpress,MultiplexStream,MultiplexStream_localtype,MultiplexStream);
//********************************************************************
//*** prototypes for .. Patcher
//********************************************************************
typedef  Patcher  Patcher_localtype;
Define_Module_Class(pandaexpress,Patcher,Patcher_localtype,Patcher);
//********************************************************************
//*** prototypes for .. StringStream
//********************************************************************
typedef  StringStream  StringStream_localtype;
Define_Module_Class(pandaexpress,StringStream,StringStream_localtype,StringStream);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Buffer;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_HashVal;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Ramfile;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VirtualFile;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VirtualFileMount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ios;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ios_base;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_iostream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_istream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * unsigned long int check_crc(Filename name)
 *******************************************************************/
static PyObject *Dtool_check_crc_378(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-unsigned long int check_crc(Filename name)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:checkCrc", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:checkCrc", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "checkCrc", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    unsigned long int return_value = check_crc(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyLongOrInt_FromUnsignedLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "checkCrc(const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_check_crc_378_comment =
    "C++ Interface:\n"
    "checkCrc(const Filename name)\n"
    "\n"
    "";
#else
static const char * Dtool_check_crc_378_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned long int check_adler(Filename name)
 *******************************************************************/
static PyObject *Dtool_check_adler_379(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-unsigned long int check_adler(Filename name)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:checkAdler", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:checkAdler", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "checkAdler", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    unsigned long int return_value = check_adler(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyLongOrInt_FromUnsignedLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "checkAdler(const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_check_adler_379_comment =
    "C++ Interface:\n"
    "checkAdler(const Filename name)\n"
    "\n"
    "";
#else
static const char * Dtool_check_adler_379_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. SSReader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool SSReader::receive_datagram(Datagram &dg)
 *******************************************************************/
static PyObject *Dtool_SSReader_receive_datagram_3(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool SSReader::receive_datagram(Datagram &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:receiveDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:receiveDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "SSReader.receiveDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->receive_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SSReader.receiveDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveDatagram(non-const SSReader this, non-const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_receive_datagram_3_comment =
    "C++ Interface:\n"
    "receiveDatagram(non-const SSReader this, non-const Datagram dg)\n"
    "\n"
    "// Filename: socketStream.I\n"
    "// Created by:  drose (15Oct02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSReader::receive_datagram\n"
    "//       Access: Published\n"
    "//  Description: Receives a datagram over the socket by expecting a\n"
    "//               little-endian 16-bit byte count as a prefix.  If the\n"
    "//               socket stream is non-blocking, may return false if\n"
    "//               the data is not available; otherwise, returns false\n"
    "//               only if the socket closes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSReader_receive_datagram_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool SSReader::is_closed(void) = 0
 *******************************************************************/
static PyObject *Dtool_SSReader_is_closed_4(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool SSReader::is_closed(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSReader.isClosed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(non-const SSReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_is_closed_4_comment =
    "C++ Interface:\n"
    "isClosed(non-const SSReader this)\n"
    "\n"
    "";
#else
static const char * Dtool_SSReader_is_closed_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void SSReader::close(void) = 0
 *******************************************************************/
static PyObject *Dtool_SSReader_close_5(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void SSReader::close(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSReader.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const SSReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_close_5_comment =
    "C++ Interface:\n"
    "close(non-const SSReader this)\n"
    "\n"
    "";
#else
static const char * Dtool_SSReader_close_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SSReader::set_tcp_header_size(int tcp_header_size)
 *******************************************************************/
static PyObject *Dtool_SSReader_set_tcp_header_size_6(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SSReader::set_tcp_header_size(int tcp_header_size)
        int param1;
        static char * key_word_list[] = {(char *)"tcp_header_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTcpHeaderSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTcpHeaderSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tcp_header_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSReader.setTcpHeaderSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTcpHeaderSize(non-const SSReader this, int tcp_header_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_set_tcp_header_size_6_comment =
    "C++ Interface:\n"
    "setTcpHeaderSize(non-const SSReader this, int tcp_header_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSReader::set_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the header size for datagrams.  At the present,\n"
    "//               legal values for this are 0, 2, or 4; this specifies\n"
    "//               the number of bytes to use encode the datagram length\n"
    "//               at the start of each TCP datagram.  Sender and\n"
    "//               receiver must independently agree on this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSReader_set_tcp_header_size_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SSReader::get_tcp_header_size(void) const
 *******************************************************************/
static PyObject *Dtool_SSReader_get_tcp_header_size_7(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SSReader::get_tcp_header_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTcpHeaderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getTcpHeaderSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SSReader*)local_this)->get_tcp_header_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTcpHeaderSize(const SSReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_get_tcp_header_size_7_comment =
    "C++ Interface:\n"
    "getTcpHeaderSize(const SSReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSReader::get_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the header size for datagrams.  See\n"
    "//               set_tcp_header_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSReader_get_tcp_header_size_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ISocketStream *SSReader::downcast_to_ISocketStream(void)
 *******************************************************************/
static PyObject *Dtool_SSReader_downcast_to_ISocketStream_26(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ISocketStream *SSReader::downcast_to_ISocketStream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToISocketStream", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToISocketStream"));
        if(!PyErr_Occurred())
        {
            ISocketStream *return_value = (ISocketStream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ISocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSReader.downcastToISocketStream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToISocketStream(non-const SSReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_downcast_to_ISocketStream_26_comment =
    "C++ Interface:\n"
    "downcastToISocketStream(non-const SSReader this)\n"
    "\n"
    "downcast from SSReader to ISocketStream\n"
    "";
#else
static const char * Dtool_SSReader_downcast_to_ISocketStream_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SocketStream *SSReader::downcast_to_SocketStream(void)
 *******************************************************************/
static PyObject *Dtool_SSReader_downcast_to_SocketStream_47(PyObject *self, PyObject *args,PyObject *kwds) {
    SSReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SocketStream *SSReader::downcast_to_SocketStream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToSocketStream", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToSocketStream"));
        if(!PyErr_Occurred())
        {
            SocketStream *return_value = (SocketStream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSReader.downcastToSocketStream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToSocketStream(non-const SSReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSReader_downcast_to_SocketStream_47_comment =
    "C++ Interface:\n"
    "downcastToSocketStream(non-const SSReader this)\n"
    "\n"
    "downcast from SSReader to SocketStream\n"
    "";
#else
static const char * Dtool_SSReader_downcast_to_SocketStream_47_comment = NULL;
#endif

int  Dtool_Init_SSReader(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SSReader)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SSReader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SSReader)
    {
        printf("SSReader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SSReader * local_this = (SSReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SSReader)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SSReader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SSReader)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SSWriter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool SSWriter::send_datagram(Datagram const &dg)
 *******************************************************************/
static PyObject *Dtool_SSWriter_send_datagram_10(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool SSWriter::send_datagram(Datagram const &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:sendDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:sendDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "SSWriter.sendDatagram", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->send_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SSWriter.sendDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendDatagram(non-const SSWriter this, const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_send_datagram_10_comment =
    "C++ Interface:\n"
    "sendDatagram(non-const SSWriter this, const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::send_datagram\n"
    "//       Access: Public\n"
    "//  Description: Transmits the indicated datagram over the socket by\n"
    "//               prepending it with a little-endian 16-bit byte count.\n"
    "//               Does not return until the data is sent or the\n"
    "//               connection is closed, even if the socket stream is\n"
    "//               non-blocking.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_send_datagram_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool SSWriter::is_closed(void) = 0
 *******************************************************************/
static PyObject *Dtool_SSWriter_is_closed_11(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool SSWriter::is_closed(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.isClosed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(non-const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_is_closed_11_comment =
    "C++ Interface:\n"
    "isClosed(non-const SSWriter this)\n"
    "\n"
    "";
#else
static const char * Dtool_SSWriter_is_closed_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void SSWriter::close(void) = 0
 *******************************************************************/
static PyObject *Dtool_SSWriter_close_12(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void SSWriter::close(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_close_12_comment =
    "C++ Interface:\n"
    "close(non-const SSWriter this)\n"
    "\n"
    "";
#else
static const char * Dtool_SSWriter_close_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SSWriter::set_collect_tcp(bool collect_tcp)
 *******************************************************************/
static PyObject *Dtool_SSWriter_set_collect_tcp_13(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SSWriter::set_collect_tcp(bool collect_tcp)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"collect_tcp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCollectTcp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCollectTcp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collect_tcp((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.setCollectTcp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollectTcp(non-const SSWriter this, bool collect_tcp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_set_collect_tcp_13_comment =
    "C++ Interface:\n"
    "setCollectTcp(non-const SSWriter this, bool collect_tcp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::set_collect_tcp\n"
    "//       Access: Published\n"
    "//  Description: Enables or disables \"collect-tcp\" mode.  In this\n"
    "//               mode, individual TCP packets are not sent\n"
    "//               immediately, but rather they are collected together\n"
    "//               and accumulated to be sent periodically as one larger\n"
    "//               TCP packet.  This cuts down on overhead from the\n"
    "//               TCP/IP protocol, especially if many small packets\n"
    "//               need to be sent on the same connection, but it\n"
    "//               introduces additional latency (since packets must be\n"
    "//               held before they can be sent).\n"
    "//\n"
    "//               See set_collect_tcp_interval() to specify the\n"
    "//               interval of time for which to hold packets before\n"
    "//               sending them.\n"
    "//\n"
    "//               If you enable this mode, you may also need to\n"
    "//               periodically call consider_flush() to flush the queue\n"
    "//               if no packets have been sent recently.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_set_collect_tcp_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SSWriter::get_collect_tcp(void) const
 *******************************************************************/
static PyObject *Dtool_SSWriter_get_collect_tcp_14(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SSWriter::get_collect_tcp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollectTcp", key_word_list));
        else
            (PyArg_Parse(args, ":getCollectTcp"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SSWriter*)local_this)->get_collect_tcp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollectTcp(const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_get_collect_tcp_14_comment =
    "C++ Interface:\n"
    "getCollectTcp(const SSWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::get_collect_tcp\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of \"collect-tcp\" mode.\n"
    "//               See set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_get_collect_tcp_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SSWriter::set_collect_tcp_interval(double interval)
 *******************************************************************/
static PyObject *Dtool_SSWriter_set_collect_tcp_interval_15(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SSWriter::set_collect_tcp_interval(double interval)
        double param1;
        static char * key_word_list[] = {(char *)"interval", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setCollectTcpInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setCollectTcpInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collect_tcp_interval((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.setCollectTcpInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollectTcpInterval(non-const SSWriter this, float interval)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_set_collect_tcp_interval_15_comment =
    "C++ Interface:\n"
    "setCollectTcpInterval(non-const SSWriter this, float interval)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::set_collect_tcp_interval\n"
    "//       Access: Published\n"
    "//  Description: Specifies the interval in time, in seconds, for which\n"
    "//               to hold TCP packets before sending all of the\n"
    "//               recently received packets at once.  This only has\n"
    "//               meaning if \"collect-tcp\" mode is enabled; see\n"
    "//               set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_set_collect_tcp_interval_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SSWriter::get_collect_tcp_interval(void) const
 *******************************************************************/
static PyObject *Dtool_SSWriter_get_collect_tcp_interval_16(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SSWriter::get_collect_tcp_interval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollectTcpInterval", key_word_list));
        else
            (PyArg_Parse(args, ":getCollectTcpInterval"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SSWriter*)local_this)->get_collect_tcp_interval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollectTcpInterval(const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_get_collect_tcp_interval_16_comment =
    "C++ Interface:\n"
    "getCollectTcpInterval(const SSWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::get_collect_tcp_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the interval in time, in seconds, for which\n"
    "//               to hold TCP packets before sending all of the\n"
    "//               recently received packets at once.  This only has\n"
    "//               meaning if \"collect-tcp\" mode is enabled; see\n"
    "//               set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_get_collect_tcp_interval_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SSWriter::set_tcp_header_size(int tcp_header_size)
 *******************************************************************/
static PyObject *Dtool_SSWriter_set_tcp_header_size_17(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SSWriter::set_tcp_header_size(int tcp_header_size)
        int param1;
        static char * key_word_list[] = {(char *)"tcp_header_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTcpHeaderSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTcpHeaderSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tcp_header_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.setTcpHeaderSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTcpHeaderSize(non-const SSWriter this, int tcp_header_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_set_tcp_header_size_17_comment =
    "C++ Interface:\n"
    "setTcpHeaderSize(non-const SSWriter this, int tcp_header_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::set_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the header size for datagrams.  At the present,\n"
    "//               legal values for this are 0, 2, or 4; this specifies\n"
    "//               the number of bytes to use encode the datagram length\n"
    "//               at the start of each TCP datagram.  Sender and\n"
    "//               receiver must independently agree on this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_set_tcp_header_size_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SSWriter::get_tcp_header_size(void) const
 *******************************************************************/
static PyObject *Dtool_SSWriter_get_tcp_header_size_18(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SSWriter::get_tcp_header_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTcpHeaderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getTcpHeaderSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SSWriter*)local_this)->get_tcp_header_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTcpHeaderSize(const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_get_tcp_header_size_18_comment =
    "C++ Interface:\n"
    "getTcpHeaderSize(const SSWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::get_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the header size for datagrams.  See\n"
    "//               set_tcp_header_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_get_tcp_header_size_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SSWriter::consider_flush(void)
 *******************************************************************/
static PyObject *Dtool_SSWriter_consider_flush_19(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SSWriter::consider_flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":considerFlush", key_word_list));
        else
            (PyArg_Parse(args, ":considerFlush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->consider_flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.considerFlush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "considerFlush(non-const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_consider_flush_19_comment =
    "C++ Interface:\n"
    "considerFlush(non-const SSWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::consider_flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued data if enough time\n"
    "//               has elapsed.  This only has meaning if\n"
    "//               set_collect_tcp() has been set to true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_consider_flush_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SSWriter::flush(void)
 *******************************************************************/
static PyObject *Dtool_SSWriter_flush_20(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SSWriter::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_flush_20_comment =
    "C++ Interface:\n"
    "flush(non-const SSWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SSWriter::flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued data now.  This only\n"
    "//               has meaning if set_collect_tcp() has been set to\n"
    "//               true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SSWriter_flush_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OSocketStream *SSWriter::downcast_to_OSocketStream(void)
 *******************************************************************/
static PyObject *Dtool_SSWriter_downcast_to_OSocketStream_37(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-OSocketStream *SSWriter::downcast_to_OSocketStream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToOSocketStream", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToOSocketStream"));
        if(!PyErr_Occurred())
        {
            OSocketStream *return_value = (OSocketStream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_OSocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.downcastToOSocketStream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToOSocketStream(non-const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_downcast_to_OSocketStream_37_comment =
    "C++ Interface:\n"
    "downcastToOSocketStream(non-const SSWriter this)\n"
    "\n"
    "downcast from SSWriter to OSocketStream\n"
    "";
#else
static const char * Dtool_SSWriter_downcast_to_OSocketStream_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SocketStream *SSWriter::downcast_to_SocketStream(void)
 *******************************************************************/
static PyObject *Dtool_SSWriter_downcast_to_SocketStream_49(PyObject *self, PyObject *args,PyObject *kwds) {
    SSWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SSWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SocketStream *SSWriter::downcast_to_SocketStream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToSocketStream", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToSocketStream"));
        if(!PyErr_Occurred())
        {
            SocketStream *return_value = (SocketStream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SSWriter.downcastToSocketStream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToSocketStream(non-const SSWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SSWriter_downcast_to_SocketStream_49_comment =
    "C++ Interface:\n"
    "downcastToSocketStream(non-const SSWriter this)\n"
    "\n"
    "downcast from SSWriter to SocketStream\n"
    "";
#else
static const char * Dtool_SSWriter_downcast_to_SocketStream_49_comment = NULL;
#endif

int  Dtool_Init_SSWriter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SSWriter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SSWriter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SSWriter)
    {
        printf("SSWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SSWriter * local_this = (SSWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SSWriter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SSWriter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SSWriter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ISocketStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool ISocketStream::is_closed(void) = 0
 *******************************************************************/
static PyObject *Dtool_ISocketStream_is_closed_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ISocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool ISocketStream::is_closed(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ISocketStream.isClosed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(non-const ISocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISocketStream_is_closed_29_comment =
    "C++ Interface:\n"
    "isClosed(non-const ISocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ISocketStream_is_closed_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ISocketStream::close(void) = 0
 *******************************************************************/
static PyObject *Dtool_ISocketStream_close_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ISocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void ISocketStream::close(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ISocketStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const ISocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISocketStream_close_30_comment =
    "C++ Interface:\n"
    "close(non-const ISocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ISocketStream_close_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual ISocketStream::ReadState ISocketStream::get_read_state(void) = 0
 *******************************************************************/
static PyObject *Dtool_ISocketStream_get_read_state_31(PyObject *self, PyObject *args,PyObject *kwds) {
    ISocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual ISocketStream::ReadState ISocketStream::get_read_state(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReadState", key_word_list));
        else
            (PyArg_Parse(args, ":getReadState"));
        if(!PyErr_Occurred())
        {
            ISocketStream::ReadState return_value = (local_this)->get_read_state();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ISocketStream.getReadState() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReadState(non-const ISocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISocketStream_get_read_state_31_comment =
    "C++ Interface:\n"
    "getReadState(non-const ISocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ISocketStream_get_read_state_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * istream *ISocketStream::upcast_to_istream(void)
 *******************************************************************/
static PyObject *Dtool_ISocketStream_upcast_to_istream_23(PyObject *self, PyObject *args,PyObject *kwds) {
    ISocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-istream *ISocketStream::upcast_to_istream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToIstream", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToIstream"));
        if(!PyErr_Occurred())
        {
            istream *return_value = (istream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ISocketStream.upcastToIstream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToIstream(non-const ISocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISocketStream_upcast_to_istream_23_comment =
    "C++ Interface:\n"
    "upcastToIstream(non-const ISocketStream this)\n"
    "\n"
    "upcast from ISocketStream to istream\n"
    "";
#else
static const char * Dtool_ISocketStream_upcast_to_istream_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SSReader *ISocketStream::upcast_to_SSReader(void)
 *******************************************************************/
static PyObject *Dtool_ISocketStream_upcast_to_SSReader_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ISocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SSReader *ISocketStream::upcast_to_SSReader(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToSSReader", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToSSReader"));
        if(!PyErr_Occurred())
        {
            SSReader *return_value = (SSReader *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SSReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ISocketStream.upcastToSSReader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToSSReader(non-const ISocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISocketStream_upcast_to_SSReader_25_comment =
    "C++ Interface:\n"
    "upcastToSSReader(non-const ISocketStream this)\n"
    "\n"
    "upcast from ISocketStream to SSReader\n"
    "";
#else
static const char * Dtool_ISocketStream_upcast_to_SSReader_25_comment = NULL;
#endif

int  Dtool_Init_ISocketStream(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ISocketStream)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ISocketStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ISocketStream)
    {
        printf("ISocketStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ISocketStream * local_this = (ISocketStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ISocketStream)
        return local_this;
    if(requested_type == &Dtool_SSReader)
        return ( SSReader *) local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ISocketStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ISocketStream)
        return from_this;
    if(from_type == &Dtool_SSReader)
    {
          SSReader* other_this = (SSReader*)from_this;
          return (ISocketStream*)other_this;
    }
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (ISocketStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OSocketStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool OSocketStream::is_closed(void) = 0
 *******************************************************************/
static PyObject *Dtool_OSocketStream_is_closed_38(PyObject *self, PyObject *args,PyObject *kwds) {
    OSocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OSocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool OSocketStream::is_closed(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OSocketStream.isClosed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(non-const OSocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OSocketStream_is_closed_38_comment =
    "C++ Interface:\n"
    "isClosed(non-const OSocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_OSocketStream_is_closed_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OSocketStream::close(void) = 0
 *******************************************************************/
static PyObject *Dtool_OSocketStream_close_39(PyObject *self, PyObject *args,PyObject *kwds) {
    OSocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OSocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void OSocketStream::close(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OSocketStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const OSocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OSocketStream_close_39_comment =
    "C++ Interface:\n"
    "close(non-const OSocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_OSocketStream_close_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OSocketStream::flush(void)
 *******************************************************************/
static PyObject *Dtool_OSocketStream_flush_40(PyObject *self, PyObject *args,PyObject *kwds) {
    OSocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OSocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool OSocketStream::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OSocketStream.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const OSocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OSocketStream_flush_40_comment =
    "C++ Interface:\n"
    "flush(non-const OSocketStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OSocketStream::flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued data now.  This only\n"
    "//               has meaning if set_collect_tcp() has been set to\n"
    "//               true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OSocketStream_flush_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ostream *OSocketStream::upcast_to_ostream(void)
 *******************************************************************/
static PyObject *Dtool_OSocketStream_upcast_to_ostream_34(PyObject *self, PyObject *args,PyObject *kwds) {
    OSocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OSocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ostream *OSocketStream::upcast_to_ostream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToOstream", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToOstream"));
        if(!PyErr_Occurred())
        {
            ostream *return_value = (ostream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OSocketStream.upcastToOstream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToOstream(non-const OSocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OSocketStream_upcast_to_ostream_34_comment =
    "C++ Interface:\n"
    "upcastToOstream(non-const OSocketStream this)\n"
    "\n"
    "upcast from OSocketStream to ostream\n"
    "";
#else
static const char * Dtool_OSocketStream_upcast_to_ostream_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SSWriter *OSocketStream::upcast_to_SSWriter(void)
 *******************************************************************/
static PyObject *Dtool_OSocketStream_upcast_to_SSWriter_36(PyObject *self, PyObject *args,PyObject *kwds) {
    OSocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OSocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SSWriter *OSocketStream::upcast_to_SSWriter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToSSWriter", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToSSWriter"));
        if(!PyErr_Occurred())
        {
            SSWriter *return_value = (SSWriter *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SSWriter,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OSocketStream.upcastToSSWriter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToSSWriter(non-const OSocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OSocketStream_upcast_to_SSWriter_36_comment =
    "C++ Interface:\n"
    "upcastToSSWriter(non-const OSocketStream this)\n"
    "\n"
    "upcast from OSocketStream to SSWriter\n"
    "";
#else
static const char * Dtool_OSocketStream_upcast_to_SSWriter_36_comment = NULL;
#endif

int  Dtool_Init_OSocketStream(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OSocketStream)");
       return -1;
}
inline void  * Dtool_UpcastInterface_OSocketStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OSocketStream)
    {
        printf("OSocketStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OSocketStream * local_this = (OSocketStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OSocketStream)
        return local_this;
    if(requested_type == &Dtool_SSWriter)
        return ( SSWriter *) local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OSocketStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OSocketStream)
        return from_this;
    if(from_type == &Dtool_SSWriter)
    {
          SSWriter* other_this = (SSWriter*)from_this;
          return (OSocketStream*)other_this;
    }
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (OSocketStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SocketStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool SocketStream::is_closed(void) = 0
 *******************************************************************/
static PyObject *Dtool_SocketStream_is_closed_50(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool SocketStream::is_closed(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.isClosed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(non-const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_is_closed_50_comment =
    "C++ Interface:\n"
    "isClosed(non-const SocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_SocketStream_is_closed_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void SocketStream::close(void) = 0
 *******************************************************************/
static PyObject *Dtool_SocketStream_close_51(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void SocketStream::close(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_close_51_comment =
    "C++ Interface:\n"
    "close(non-const SocketStream this)\n"
    "\n"
    "";
#else
static const char * Dtool_SocketStream_close_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SocketStream::set_tcp_header_size(int tcp_header_size)
 *******************************************************************/
static PyObject *Dtool_SocketStream_set_tcp_header_size_52(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SocketStream::set_tcp_header_size(int tcp_header_size)
        int param1;
        static char * key_word_list[] = {(char *)"tcp_header_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTcpHeaderSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTcpHeaderSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tcp_header_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.setTcpHeaderSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTcpHeaderSize(non-const SocketStream this, int tcp_header_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_set_tcp_header_size_52_comment =
    "C++ Interface:\n"
    "setTcpHeaderSize(non-const SocketStream this, int tcp_header_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStream::set_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the header size for datagrams.  At the present,\n"
    "//               legal values for this are 0, 2, or 4; this specifies\n"
    "//               the number of bytes to use encode the datagram length\n"
    "//               at the start of each TCP datagram.  Sender and\n"
    "//               receiver must independently agree on this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStream_set_tcp_header_size_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SocketStream::get_tcp_header_size(void) const
 *******************************************************************/
static PyObject *Dtool_SocketStream_get_tcp_header_size_53(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SocketStream::get_tcp_header_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTcpHeaderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getTcpHeaderSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SocketStream*)local_this)->get_tcp_header_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTcpHeaderSize(const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_get_tcp_header_size_53_comment =
    "C++ Interface:\n"
    "getTcpHeaderSize(const SocketStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStream::get_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the header size for datagrams.  See\n"
    "//               set_tcp_header_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStream_get_tcp_header_size_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SocketStream::flush(void)
 *******************************************************************/
static PyObject *Dtool_SocketStream_flush_54(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SocketStream::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_flush_54_comment =
    "C++ Interface:\n"
    "flush(non-const SocketStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SocketStream::flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued data now.  This only\n"
    "//               has meaning if set_collect_tcp() has been set to\n"
    "//               true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SocketStream_flush_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * iostream *SocketStream::upcast_to_iostream(void)
 *******************************************************************/
static PyObject *Dtool_SocketStream_upcast_to_iostream_44(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-iostream *SocketStream::upcast_to_iostream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToIostream", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToIostream"));
        if(!PyErr_Occurred())
        {
            iostream *return_value = (iostream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_iostream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.upcastToIostream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToIostream(non-const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_upcast_to_iostream_44_comment =
    "C++ Interface:\n"
    "upcastToIostream(non-const SocketStream this)\n"
    "\n"
    "upcast from SocketStream to iostream\n"
    "";
#else
static const char * Dtool_SocketStream_upcast_to_iostream_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SSReader *SocketStream::upcast_to_SSReader(void)
 *******************************************************************/
static PyObject *Dtool_SocketStream_upcast_to_SSReader_46(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SSReader *SocketStream::upcast_to_SSReader(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToSSReader", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToSSReader"));
        if(!PyErr_Occurred())
        {
            SSReader *return_value = (SSReader *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SSReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.upcastToSSReader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToSSReader(non-const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_upcast_to_SSReader_46_comment =
    "C++ Interface:\n"
    "upcastToSSReader(non-const SocketStream this)\n"
    "\n"
    "upcast from SocketStream to SSReader\n"
    "";
#else
static const char * Dtool_SocketStream_upcast_to_SSReader_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SSWriter *SocketStream::upcast_to_SSWriter(void)
 *******************************************************************/
static PyObject *Dtool_SocketStream_upcast_to_SSWriter_48(PyObject *self, PyObject *args,PyObject *kwds) {
    SocketStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SocketStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SSWriter *SocketStream::upcast_to_SSWriter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToSSWriter", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToSSWriter"));
        if(!PyErr_Occurred())
        {
            SSWriter *return_value = (SSWriter *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SSWriter,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketStream.upcastToSSWriter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToSSWriter(non-const SocketStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SocketStream_upcast_to_SSWriter_48_comment =
    "C++ Interface:\n"
    "upcastToSSWriter(non-const SocketStream this)\n"
    "\n"
    "upcast from SocketStream to SSWriter\n"
    "";
#else
static const char * Dtool_SocketStream_upcast_to_SSWriter_48_comment = NULL;
#endif

int  Dtool_Init_SocketStream(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SocketStream)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SocketStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SocketStream)
    {
        printf("SocketStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SocketStream * local_this = (SocketStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SocketStream)
        return local_this;
    if(requested_type == &Dtool_SSReader)
        return ( SSReader *) local_this;
    if(requested_type == &Dtool_SSWriter)
        return ( SSWriter *) local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_iostream)
        return ( iostream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *)( iostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SocketStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SocketStream)
        return from_this;
    if(from_type == &Dtool_SSReader)
    {
          SSReader* other_this = (SSReader*)from_this;
          return (SocketStream*)other_this;
    }
    if(from_type == &Dtool_SSWriter)
    {
          SSWriter* other_this = (SSWriter*)from_this;
          return (SocketStream*)other_this;
    }
    if(from_type == &Dtool_iostream)
    {
          iostream* other_this = (iostream*)from_this;
          return (SocketStream*)other_this;
    }
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (SocketStream*)other_this;
    }
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (SocketStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. URLSpec 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void URLSpec::operator =(URLSpec const &copy)
 * inline void URLSpec::operator =(basic_string< char > const &url)
 *******************************************************************/
static PyObject *Dtool_URLSpec_operator_58(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void URLSpec::operator =(basic_string< char > const &url)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:assign", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:assign", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                (local_this)->operator =(basic_string<char>(param1_str, param1_len));
                URLSpec *return_value = local_this;
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, false);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void URLSpec::operator =(URLSpec const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "URLSpec.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    URLSpec *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const URLSpec this, string url)\n"
          "assign(non-const URLSpec this, const URLSpec copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_operator_58_comment =
    "C++ Interface:\n"
    "assign(non-const URLSpec this, string url)\n"
    "assign(non-const URLSpec this, const URLSpec copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_operator_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::operator ==(URLSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_operator_59(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool URLSpec::operator ==(URLSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "URLSpec.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const URLSpec*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const URLSpec this, const URLSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_operator_59_comment =
    "C++ Interface:\n"
    "eq(const URLSpec this, const URLSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::Operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_operator_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::operator !=(URLSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_operator_60(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool URLSpec::operator !=(URLSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "URLSpec.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const URLSpec*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const URLSpec this, const URLSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_operator_60_comment =
    "C++ Interface:\n"
    "ne(const URLSpec this, const URLSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::Operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_operator_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::operator <(URLSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_operator_61(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool URLSpec::operator <(URLSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "URLSpec.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const URLSpec*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const URLSpec this, const URLSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_operator_61_comment =
    "C++ Interface:\n"
    "lessThan(const URLSpec this, const URLSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::Operator <\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_operator_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int URLSpec::compare_to(URLSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_compare_to_62(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int URLSpec::compare_to(URLSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "URLSpec.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const URLSpec*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const URLSpec this, const URLSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_compare_to_62_comment =
    "C++ Interface:\n"
    "compareTo(const URLSpec this, const URLSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::compare_to\n"
    "//       Access: Published\n"
    "//  Description: Returns a number less than zero if this URLSpec\n"
    "//               sorts before the other one, greater than zero if it\n"
    "//               sorts after, or zero if they are equivalent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_compare_to_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_scheme(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_scheme_63(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_scheme(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasScheme", key_word_list));
        else
            (PyArg_Parse(args, ":hasScheme"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_scheme();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasScheme(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_scheme_63_comment =
    "C++ Interface:\n"
    "hasScheme(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_scheme\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL specifies a scheme\n"
    "//               (e.g. \"http:\"), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_scheme_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_authority(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_authority_64(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_authority(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAuthority", key_word_list));
        else
            (PyArg_Parse(args, ":hasAuthority"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_authority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAuthority(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_authority_64_comment =
    "C++ Interface:\n"
    "hasAuthority(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_authority\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL specifies an authority\n"
    "//               (this includes username, server, and/or port), false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_authority_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_username(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_username_65(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_username(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasUsername", key_word_list));
        else
            (PyArg_Parse(args, ":hasUsername"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_username();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasUsername(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_username_65_comment =
    "C++ Interface:\n"
    "hasUsername(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_username\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL specifies a username\n"
    "//               (and/or password), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_username_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_server(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_server_66(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_server(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasServer", key_word_list));
        else
            (PyArg_Parse(args, ":hasServer"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_server();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasServer(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_server_66_comment =
    "C++ Interface:\n"
    "hasServer(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_server\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL specifies a server name,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_server_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_port(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_port_67(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasPort", key_word_list));
        else
            (PyArg_Parse(args, ":hasPort"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasPort(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_port_67_comment =
    "C++ Interface:\n"
    "hasPort(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_port\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL specifies a port number,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_port_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_path(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_path_68(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasPath", key_word_list));
        else
            (PyArg_Parse(args, ":hasPath"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_path();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasPath(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_path_68_comment =
    "C++ Interface:\n"
    "hasPath(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_path\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL includes a path specification\n"
    "//               (that is, the particular filename on the server to\n"
    "//               retrieve), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_path_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::has_query(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_has_query_69(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::has_query(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasQuery", key_word_list));
        else
            (PyArg_Parse(args, ":hasQuery"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->has_query();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasQuery(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_has_query_69_comment =
    "C++ Interface:\n"
    "hasQuery(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::has_query\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL includes a query\n"
    "//               specification, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_has_query_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > URLSpec::get_scheme(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_scheme_70(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > URLSpec::get_scheme(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScheme", key_word_list));
        else
            (PyArg_Parse(args, ":getScheme"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_scheme();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScheme(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_scheme_70_comment =
    "C++ Interface:\n"
    "getScheme(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_scheme\n"
    "//       Access: Published\n"
    "//  Description: Returns the scheme specified by the URL, or empty\n"
    "//               string if no scheme is specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_scheme_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > URLSpec::get_authority(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_authority_71(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > URLSpec::get_authority(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAuthority", key_word_list));
        else
            (PyArg_Parse(args, ":getAuthority"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_authority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAuthority(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_authority_71_comment =
    "C++ Interface:\n"
    "getAuthority(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_authority\n"
    "//       Access: Published\n"
    "//  Description: Returns the authority specified by the URL (this\n"
    "//               includes username, server, and/or port), or empty\n"
    "//               string if no authority is specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_authority_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > URLSpec::get_username(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_username_72(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > URLSpec::get_username(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUsername", key_word_list));
        else
            (PyArg_Parse(args, ":getUsername"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_username();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUsername(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_username_72_comment =
    "C++ Interface:\n"
    "getUsername(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_username\n"
    "//       Access: Published\n"
    "//  Description: Returns the username specified by the URL, if any.\n"
    "//               This might also include a password,\n"
    "//               e.g. \"username:password\", although putting a password\n"
    "//               on the URL is probably a bad idea.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_username_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > URLSpec::get_server(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_server_73(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > URLSpec::get_server(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getServer", key_word_list));
        else
            (PyArg_Parse(args, ":getServer"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_server();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServer(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_server_73_comment =
    "C++ Interface:\n"
    "getServer(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_server\n"
    "//       Access: Published\n"
    "//  Description: Returns the server name specified by the URL, if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_server_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > URLSpec::get_port_str(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_port_str_74(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > URLSpec::get_port_str(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPortStr", key_word_list));
        else
            (PyArg_Parse(args, ":getPortStr"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_port_str();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPortStr(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_port_str_74_comment =
    "C++ Interface:\n"
    "getPortStr(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_port_str\n"
    "//       Access: Published\n"
    "//  Description: Returns the port specified by the URL as a string, or\n"
    "//               the empty string if no port is specified.  Compare\n"
    "//               this with get_port(), which returns a default port\n"
    "//               number if no port is specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_port_str_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int URLSpec::get_port(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_port_75(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int URLSpec::get_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPort", key_word_list));
        else
            (PyArg_Parse(args, ":getPort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const URLSpec*)local_this)->get_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPort(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_port_75_comment =
    "C++ Interface:\n"
    "getPort(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_port\n"
    "//       Access: Published\n"
    "//  Description: Returns the port number specified by the URL, or the\n"
    "//               default port if not specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_port_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > URLSpec::get_server_and_port(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_server_and_port_76(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > URLSpec::get_server_and_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getServerAndPort", key_word_list));
        else
            (PyArg_Parse(args, ":getServerAndPort"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_server_and_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerAndPort(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_server_and_port_76_comment =
    "C++ Interface:\n"
    "getServerAndPort(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_server_and_port\n"
    "//       Access: Published\n"
    "//  Description: Returns a string consisting of the server name,\n"
    "//               followed by a colon, followed by the port number.  If\n"
    "//               the port number is not explicitly given in the URL,\n"
    "//               this string will include the implicit port number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_server_and_port_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool URLSpec::is_default_port(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_is_default_port_77(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool URLSpec::is_default_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDefaultPort", key_word_list));
        else
            (PyArg_Parse(args, ":isDefaultPort"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->is_default_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDefaultPort(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_is_default_port_77_comment =
    "C++ Interface:\n"
    "isDefaultPort(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::is_default_port\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the port number encoded in this URL\n"
    "//               is the default port number for the scheme (or if\n"
    "//               there is no port number), or false if it is a\n"
    "//               nonstandard port.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_is_default_port_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int URLSpec::get_default_port_for_scheme(basic_string< char > const &scheme)
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_default_port_for_scheme_78(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int URLSpec::get_default_port_for_scheme(basic_string< char > const &scheme)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"scheme", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getDefaultPortForScheme", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:getDefaultPortForScheme", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            int return_value = URLSpec::get_default_port_for_scheme(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultPortForScheme(string scheme)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_default_port_for_scheme_78_comment =
    "C++ Interface:\n"
    "getDefaultPortForScheme(string scheme)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_default_port_for_scheme\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the default port number for the indicated\n"
    "//               scheme, or 0 if there is no known default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_default_port_for_scheme_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > URLSpec::get_path(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_path_79(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > URLSpec::get_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPath", key_word_list));
        else
            (PyArg_Parse(args, ":getPath"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_path();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPath(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_path_79_comment =
    "C++ Interface:\n"
    "getPath(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_path\n"
    "//       Access: Published\n"
    "//  Description: Returns the path specified by the URL, or \"/\" if no\n"
    "//               path is specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_path_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > URLSpec::get_query(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_query_80(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > URLSpec::get_query(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQuery", key_word_list));
        else
            (PyArg_Parse(args, ":getQuery"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_query();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuery(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_query_80_comment =
    "C++ Interface:\n"
    "getQuery(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_query\n"
    "//       Access: Published\n"
    "//  Description: Returns the query specified by the URL, or empty\n"
    "//               string if no query is specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_query_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > URLSpec::get_path_and_query(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_path_and_query_81(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > URLSpec::get_path_and_query(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPathAndQuery", key_word_list));
        else
            (PyArg_Parse(args, ":getPathAndQuery"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const URLSpec*)local_this)->get_path_and_query();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPathAndQuery(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_path_and_query_81_comment =
    "C++ Interface:\n"
    "getPathAndQuery(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_path_and_query\n"
    "//       Access: Published\n"
    "//  Description: Returns the path (or \"/\" if no path is specified),\n"
    "//               followed by the query if it is specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_path_and_query_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::is_ssl(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_is_ssl_82(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::is_ssl(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSsl", key_word_list));
        else
            (PyArg_Parse(args, ":isSsl"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->is_ssl();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSsl(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_is_ssl_82_comment =
    "C++ Interface:\n"
    "isSsl(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::is_ssl\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the URL's scheme specifies an\n"
    "//               SSL-secured protocol such as https, or false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_is_ssl_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &URLSpec::get_url(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_get_url_83(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &URLSpec::get_url(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUrl", key_word_list));
        else
            (PyArg_Parse(args, ":getUrl"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const URLSpec*)local_this)->get_url();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUrl(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_get_url_83_comment =
    "C++ Interface:\n"
    "getUrl(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::get_url\n"
    "//       Access: Published\n"
    "//  Description: Returns the complete URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_get_url_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_scheme(basic_string< char > const &scheme)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_scheme_84(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_scheme(basic_string< char > const &scheme)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"scheme", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setScheme", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setScheme", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_scheme(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setScheme() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScheme(non-const URLSpec this, string scheme)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_scheme_84_comment =
    "C++ Interface:\n"
    "setScheme(non-const URLSpec this, string scheme)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_scheme\n"
    "//       Access: Published\n"
    "//  Description: Replaces the scheme part of the URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_scheme_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_authority(basic_string< char > const &authority)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_authority_85(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_authority(basic_string< char > const &authority)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"authority", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setAuthority", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setAuthority", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_authority(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setAuthority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAuthority(non-const URLSpec this, string authority)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_authority_85_comment =
    "C++ Interface:\n"
    "setAuthority(non-const URLSpec this, string authority)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_authority\n"
    "//       Access: Published\n"
    "//  Description: Replaces the authority part of the URL specification.\n"
    "//               This includes the username, server, and port.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_authority_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_username(basic_string< char > const &username)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_username_86(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_username(basic_string< char > const &username)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"username", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setUsername", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setUsername", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_username(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setUsername() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUsername(non-const URLSpec this, string username)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_username_86_comment =
    "C++ Interface:\n"
    "setUsername(non-const URLSpec this, string username)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_username\n"
    "//       Access: Published\n"
    "//  Description: Replaces the username part of the URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_username_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_server(basic_string< char > const &server)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_server_87(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_server(basic_string< char > const &server)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"server", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setServer", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setServer", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_server(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setServer() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setServer(non-const URLSpec this, string server)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_server_87_comment =
    "C++ Interface:\n"
    "setServer(non-const URLSpec this, string server)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_server\n"
    "//       Access: Published\n"
    "//  Description: Replaces the server part of the URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_server_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_port(basic_string< char > const &port)
 * void URLSpec::set_port(int port)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_port_88(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void URLSpec::set_port(basic_string< char > const &port)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setPort", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setPort", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_port(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void URLSpec::set_port(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_port((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPort(non-const URLSpec this, string port)\n"
          "setPort(non-const URLSpec this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_port_88_comment =
    "C++ Interface:\n"
    "setPort(non-const URLSpec this, string port)\n"
    "setPort(non-const URLSpec this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_port\n"
    "//       Access: Published\n"
    "//  Description: Replaces the port part of the URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_port\n"
    "//       Access: Published\n"
    "//  Description: Replaces the port part of the URL specification,\n"
    "//               given a numeric port number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_port_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_server_and_port(basic_string< char > const &server_and_port)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_server_and_port_89(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_server_and_port(basic_string< char > const &server_and_port)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"server_and_port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setServerAndPort", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setServerAndPort", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_server_and_port(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setServerAndPort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setServerAndPort(non-const URLSpec this, string server_and_port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_server_and_port_89_comment =
    "C++ Interface:\n"
    "setServerAndPort(non-const URLSpec this, string server_and_port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_server_and_port\n"
    "//       Access: Published\n"
    "//  Description: Replaces the server and port parts of the URL\n"
    "//               specification simultaneously.  The input string\n"
    "//               should be of the form \"server:port\", or just\n"
    "//               \"server\" to make the port number implicit.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_server_and_port_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_path(basic_string< char > const &path)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_path_90(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_path(basic_string< char > const &path)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"path", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setPath", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setPath", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_path(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setPath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPath(non-const URLSpec this, string path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_path_90_comment =
    "C++ Interface:\n"
    "setPath(non-const URLSpec this, string path)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_path\n"
    "//       Access: Published\n"
    "//  Description: Replaces the path part of the URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_path_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_query(basic_string< char > const &query)
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_query_91(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void URLSpec::set_query(basic_string< char > const &query)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"query", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setQuery", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setQuery", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_query(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call URLSpec.setQuery() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuery(non-const URLSpec this, string query)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_query_91_comment =
    "C++ Interface:\n"
    "setQuery(non-const URLSpec this, string query)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_query\n"
    "//       Access: Published\n"
    "//  Description: Replaces the query part of the URL specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_query_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::set_url(basic_string< char > const &url, bool server_name_expected)
 * void URLSpec::set_url(basic_string< char > const &url, bool server_name_expected = (0))
 *******************************************************************/
static PyObject *Dtool_URLSpec_set_url_92(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void URLSpec::set_url(basic_string< char > const &url, bool server_name_expected = (0))
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setUrl", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setUrl", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                (local_this)->set_url(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call URLSpec.setUrl() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void URLSpec::set_url(basic_string< char > const &url, bool server_name_expected)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"url", (char *)"server_name_expected", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setUrl", key_word_list, &param1_str, &param1_len, &param2))
            {
                (local_this)->set_url(basic_string<char>(param1_str, param1_len), (PyObject_IsTrue(param2)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call URLSpec.setUrl() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setUrl() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setUrl(non-const URLSpec this, string url)\n"
          "setUrl(non-const URLSpec this, string url, bool server_name_expected)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_set_url_92_comment =
    "C++ Interface:\n"
    "setUrl(non-const URLSpec this, string url)\n"
    "setUrl(non-const URLSpec this, string url, bool server_name_expected)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::set_url\n"
    "//       Access: Published\n"
    "//  Description: Completely replaces the URL with the indicated\n"
    "//               string.  If server_name_expected is true, it is a\n"
    "//               hint that an undecorated URL is probably a server\n"
    "//               name, not a local filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_set_url_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char const *URLSpec::c_str(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_c_str_94(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char const *URLSpec::c_str(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cStr", key_word_list));
        else
            (PyArg_Parse(args, ":cStr"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const URLSpec*)local_this)->c_str();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cStr(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_c_str_94_comment =
    "C++ Interface:\n"
    "cStr(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::c_str\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_c_str_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool URLSpec::empty(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_empty_95(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool URLSpec::empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":empty", key_word_list));
        else
            (PyArg_Parse(args, ":empty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const URLSpec*)local_this)->empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "empty(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_empty_95_comment =
    "C++ Interface:\n"
    "empty(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::empty\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_empty_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int URLSpec::length(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_length_96(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int URLSpec::length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const URLSpec*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_length_96_comment =
    "C++ Interface:\n"
    "length(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::length\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_length_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char URLSpec::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_operator_97(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char URLSpec::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            char return_value = ((const URLSpec*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const URLSpec this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_operator_97_comment =
    "C++ Interface:\n"
    "__getitem__(const URLSpec this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::Indexing operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_operator_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool URLSpec::input(istream &in)
 *******************************************************************/
static PyObject *Dtool_URLSpec_input_98(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool URLSpec::input(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:input", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:input", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "URLSpec.input", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->input(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call URLSpec.input() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "input(non-const URLSpec this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_input_98_comment =
    "C++ Interface:\n"
    "input(non-const URLSpec this, non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::input\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_input_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void URLSpec::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_output_99(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void URLSpec::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "URLSpec.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const URLSpec*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const URLSpec this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_output_99_comment =
    "C++ Interface:\n"
    "output(const URLSpec this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_output_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > URLSpec::quote(basic_string< char > const &source, basic_string< char > const &safe)
 * static basic_string< char > URLSpec::quote(basic_string< char > const &source, basic_string< char > const &safe = ("/"))
 *******************************************************************/
static PyObject *Dtool_URLSpec_quote_100(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static basic_string< char > URLSpec::quote(basic_string< char > const &source, basic_string< char > const &safe = ("/"))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:quote", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:quote", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = URLSpec::quote(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static basic_string< char > URLSpec::quote(basic_string< char > const &source, basic_string< char > const &safe)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"source", (char *)"safe", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:quote", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                basic_string< char > return_value = URLSpec::quote(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "quote() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "quote(string source)\n"
          "quote(string source, string safe)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_quote_100_comment =
    "C++ Interface:\n"
    "quote(string source)\n"
    "quote(string source, string safe)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::quote\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the source string with all \"unsafe\"\n"
    "//               characters quoted, making a string suitable for\n"
    "//               placing in a URL.  Letters, digits, and the\n"
    "//               underscore, comma, period, and hyphen characters, as\n"
    "//               well as any included in the safe string, are left\n"
    "//               alone; all others are converted to hex\n"
    "//               representation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_quote_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > URLSpec::quote_plus(basic_string< char > const &source, basic_string< char > const &safe)
 * static basic_string< char > URLSpec::quote_plus(basic_string< char > const &source, basic_string< char > const &safe = ("/"))
 *******************************************************************/
static PyObject *Dtool_URLSpec_quote_plus_101(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static basic_string< char > URLSpec::quote_plus(basic_string< char > const &source, basic_string< char > const &safe = ("/"))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:quotePlus", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:quotePlus", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = URLSpec::quote_plus(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static basic_string< char > URLSpec::quote_plus(basic_string< char > const &source, basic_string< char > const &safe)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"source", (char *)"safe", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:quotePlus", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                basic_string< char > return_value = URLSpec::quote_plus(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "quotePlus() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "quotePlus(string source)\n"
          "quotePlus(string source, string safe)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_quote_plus_101_comment =
    "C++ Interface:\n"
    "quotePlus(string source)\n"
    "quotePlus(string source, string safe)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::quote_plus\n"
    "//       Access: Published, Static\n"
    "//  Description: Behaves like quote() with the additional behavior of\n"
    "//               replacing spaces with plus signs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_quote_plus_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > URLSpec::unquote(basic_string< char > const &source)
 *******************************************************************/
static PyObject *Dtool_URLSpec_unquote_102(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > URLSpec::unquote(basic_string< char > const &source)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"source", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:unquote", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:unquote", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = URLSpec::unquote(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unquote(string source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_unquote_102_comment =
    "C++ Interface:\n"
    "unquote(string source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::unquote\n"
    "//       Access: Published, Static\n"
    "//  Description: Reverses the operation of quote(): converts escaped\n"
    "//               characters of the form \"%xx\" to their ascii\n"
    "//               equivalent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_unquote_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > URLSpec::unquote_plus(basic_string< char > const &source)
 *******************************************************************/
static PyObject *Dtool_URLSpec_unquote_plus_103(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > URLSpec::unquote_plus(basic_string< char > const &source)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"source", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:unquotePlus", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:unquotePlus", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = URLSpec::unquote_plus(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unquotePlus(string source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_unquote_plus_103_comment =
    "C++ Interface:\n"
    "unquotePlus(string source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::unquote_plus\n"
    "//       Access: Published, Static\n"
    "//  Description: Reverses the operation of quote_plus(): converts escaped\n"
    "//               characters of the form \"%xx\" to their ascii\n"
    "//               equivalent, and also converts plus signs to spaces.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_unquote_plus_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &URLSpec::operator typecast(void) const
 *******************************************************************/
static PyObject *Dtool_URLSpec_operator_typecast_93(PyObject *self, PyObject *args,PyObject *kwds) {
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &URLSpec::operator typecast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecast", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecast"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = (basic_string< char > const &)(*(const URLSpec*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecast(const URLSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_URLSpec_operator_typecast_93_comment =
    "C++ Interface:\n"
    "operatorTypecast(const URLSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: URLSpec::string typecast operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_URLSpec_operator_typecast_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * URLSpec::URLSpec(void)
 * inline URLSpec::URLSpec(URLSpec const &copy)
 * inline URLSpec::URLSpec(basic_string< char > const &url, bool server_name_expected)
 * inline URLSpec::URLSpec(basic_string< char > const &url, bool server_name_expected = (0))
 *******************************************************************/
int  Dtool_Init_URLSpec(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-URLSpec::URLSpec(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":URLSpec", key_word_list))
            {
                URLSpec *return_value = new URLSpec();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_URLSpec,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline URLSpec::URLSpec(URLSpec const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:URLSpec", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:URLSpec", &param0));
                if(!PyErr_Occurred())
                {
                    URLSpec *param0_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_URLSpec, 0, "URLSpec.URLSpec", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        URLSpec *return_value = new URLSpec(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_URLSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline URLSpec::URLSpec(basic_string< char > const &url, bool server_name_expected = (0))
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"url", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:URLSpec", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:URLSpec", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    URLSpec *return_value = new URLSpec(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_URLSpec,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline URLSpec::URLSpec(basic_string< char > const &url, bool server_name_expected)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", (char *)"server_name_expected", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:URLSpec", key_word_list, &param0_str, &param0_len, &param1))
            {
                URLSpec *return_value = new URLSpec(basic_string<char>(param0_str, param0_len), (PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_URLSpec,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "URLSpec() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "URLSpec()\n"
          "URLSpec(const URLSpec copy)\n"
          "URLSpec(string url)\n"
          "URLSpec(string url, bool server_name_expected)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_URLSpec(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_URLSpec)
    {
        printf("URLSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    URLSpec * local_this = (URLSpec *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_URLSpec)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_URLSpec(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_URLSpec)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HTTPEnum 
//********************************************************************
int  Dtool_Init_HTTPEnum(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (HTTPEnum)");
       return -1;
}
inline void  * Dtool_UpcastInterface_HTTPEnum(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HTTPEnum)
    {
        printf("HTTPEnum ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HTTPEnum * local_this = (HTTPEnum *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HTTPEnum)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HTTPEnum(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HTTPEnum)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HTTPDate 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void HTTPDate::operator =(HTTPDate const &copy)
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_111(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPDate::operator =(HTTPDate const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    HTTPDate *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPDate,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPDate.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const HTTPDate this, const HTTPDate copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_111_comment =
    "C++ Interface:\n"
    "assign(non-const HTTPDate this, const HTTPDate copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline HTTPDate HTTPDate::now(void)
 *******************************************************************/
static PyObject *Dtool_HTTPDate_now_112(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline HTTPDate HTTPDate::now(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":now", key_word_list))
        {
            HTTPDate result = HTTPDate::now();
            HTTPDate *return_value = new HTTPDate(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPDate,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "now()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_now_112_comment =
    "C++ Interface:\n"
    "now()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::now (named constructor)\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns an HTTPDate that represents the current time\n"
    "//               and date.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_now_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPDate::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_is_valid_113(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPDate::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPDate*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const HTTPDate this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_is_valid_113_comment =
    "C++ Interface:\n"
    "isValid(const HTTPDate this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the date is meaningful, or false if\n"
    "//               it is -1 (which generally indicates the source string\n"
    "//               could not be parsed.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_is_valid_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPDate::get_string(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_get_string_114(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPDate::get_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString", key_word_list));
        else
            (PyArg_Parse(args, ":getString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPDate*)local_this)->get_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString(const HTTPDate this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_get_string_114_comment =
    "C++ Interface:\n"
    "getString(const HTTPDate this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::get_string\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_get_string_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPDate::get_time(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_get_time_115(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPDate::get_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTime", key_word_list));
        else
            (PyArg_Parse(args, ":getTime"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPDate*)local_this)->get_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTime(const HTTPDate this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_get_time_115_comment =
    "C++ Interface:\n"
    "getTime(const HTTPDate this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::get_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the date as a C time_t value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_get_time_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPDate::operator ==(HTTPDate const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_116(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPDate::operator ==(HTTPDate const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPDate*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const HTTPDate this, const HTTPDate other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_116_comment =
    "C++ Interface:\n"
    "eq(const HTTPDate this, const HTTPDate other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::Operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPDate::operator !=(HTTPDate const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_117(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPDate::operator !=(HTTPDate const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPDate*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const HTTPDate this, const HTTPDate other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_117_comment =
    "C++ Interface:\n"
    "ne(const HTTPDate this, const HTTPDate other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::Operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPDate::operator <(HTTPDate const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_118(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPDate::operator <(HTTPDate const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPDate*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const HTTPDate this, const HTTPDate other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_118_comment =
    "C++ Interface:\n"
    "lessThan(const HTTPDate this, const HTTPDate other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::Operator <\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPDate::operator >(HTTPDate const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_119(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPDate::operator >(HTTPDate const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:greaterThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:greaterThan", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.greaterThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPDate*)local_this)->operator >(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "greaterThan(const HTTPDate this, const HTTPDate other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_119_comment =
    "C++ Interface:\n"
    "greaterThan(const HTTPDate this, const HTTPDate other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::Operator >\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HTTPDate::compare_to(HTTPDate const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_compare_to_120(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int HTTPDate::compare_to(HTTPDate const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const HTTPDate*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const HTTPDate this, const HTTPDate other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_compare_to_120_comment =
    "C++ Interface:\n"
    "compareTo(const HTTPDate this, const HTTPDate other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::compare_to\n"
    "//       Access: Published\n"
    "//  Description: Returns a number less than zero if this HTTPDate\n"
    "//               sorts before the other one, greater than zero if it\n"
    "//               sorts after, or zero if they are equivalent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_compare_to_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPDate::operator +=(int seconds)
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_121(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPDate::operator +=(int seconds)
        int param1;
        static char * key_word_list[] = {(char *)"seconds", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__iadd__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__iadd__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator +=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPDate.__iadd__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const HTTPDate this, int seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_121_comment =
    "C++ Interface:\n"
    "__iadd__(non-const HTTPDate this, int seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::operator +=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPDate::operator -=(int seconds)
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_122(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPDate::operator -=(int seconds)
        int param1;
        static char * key_word_list[] = {(char *)"seconds", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__isub__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__isub__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator -=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPDate.__isub__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__isub__(non-const HTTPDate this, int seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_122_comment =
    "C++ Interface:\n"
    "__isub__(non-const HTTPDate this, int seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::operator -=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPDate HTTPDate::operator +(int seconds) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_123(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline HTTPDate HTTPDate::operator +(int seconds) const
        int param1;
        static char * key_word_list[] = {(char *)"seconds", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__add__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__add__", &param1));
        if(!PyErr_Occurred())
        {
            HTTPDate result = ((const HTTPDate*)local_this)->operator +((int)param1);
            HTTPDate *return_value = new HTTPDate(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPDate,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const HTTPDate this, int seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_123_comment =
    "C++ Interface:\n"
    "__add__(const HTTPDate this, int seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::operator +\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HTTPDate::operator -(HTTPDate const &other) const
 * inline HTTPDate HTTPDate::operator -(int seconds) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_operator_124(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline int HTTPDate::operator -(HTTPDate const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__sub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__sub__", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPDate.__sub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const HTTPDate*)local_this)->operator -(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline HTTPDate HTTPDate::operator -(int seconds) const
            int param1;
            static char * key_word_list[] = {(char *)"seconds", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:__sub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:__sub__", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate result = ((const HTTPDate*)local_this)->operator -((int)param1);
                HTTPDate *return_value = new HTTPDate(result);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPDate,true, false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__sub__(const HTTPDate this, const HTTPDate other)\n"
          "__sub__(const HTTPDate this, int seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_operator_124_comment =
    "C++ Interface:\n"
    "__sub__(const HTTPDate this, const HTTPDate other)\n"
    "__sub__(const HTTPDate this, int seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::operator -\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::operator -\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_operator_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPDate::input(istream &in)
 *******************************************************************/
static PyObject *Dtool_HTTPDate_input_125(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPDate::input(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:input", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:input", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "HTTPDate.input", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->input(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPDate.input() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "input(non-const HTTPDate this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_input_125_comment =
    "C++ Interface:\n"
    "input(non-const HTTPDate this, non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::input\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_input_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPDate::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HTTPDate_output_126(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HTTPDate::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPDate.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HTTPDate*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const HTTPDate this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPDate_output_126_comment =
    "C++ Interface:\n"
    "output(const HTTPDate this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPDate::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPDate_output_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPDate::HTTPDate(void)
 * inline HTTPDate::HTTPDate(HTTPDate const &copy)
 * HTTPDate::HTTPDate(basic_string< char > const &format)
 * inline HTTPDate::HTTPDate(unsigned int time)
 *******************************************************************/
int  Dtool_Init_HTTPDate(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline HTTPDate::HTTPDate(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":HTTPDate", key_word_list))
            {
                HTTPDate *return_value = new HTTPDate();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPDate,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 HTTPDate::HTTPDate(basic_string< char > const &format)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"format", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:HTTPDate", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:HTTPDate", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    HTTPDate *return_value = new HTTPDate(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPDate,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline HTTPDate::HTTPDate(HTTPDate const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HTTPDate", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HTTPDate", &param0));
                if(!PyErr_Occurred())
                {
                    HTTPDate *param0_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_HTTPDate, 0, "HTTPDate.HTTPDate", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        HTTPDate *return_value = new HTTPDate(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPDate,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline HTTPDate::HTTPDate(unsigned int time)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"time", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HTTPDate", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HTTPDate", &param0));
                if(!PyErr_Occurred())
                {
                     PyObject *param0_uint = PyNumber_Long(param0);
                    if (!((param0_uint == NULL)))
                    {
                        HTTPDate *return_value = new HTTPDate(PyLong_AsUnsignedLong(param0_uint));
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPDate,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HTTPDate() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HTTPDate()\n"
          "HTTPDate(string format)\n"
          "HTTPDate(const HTTPDate copy)\n"
          "HTTPDate(unsigned int time)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HTTPDate(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HTTPDate)
    {
        printf("HTTPDate ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HTTPDate * local_this = (HTTPDate *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HTTPDate)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HTTPDate(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HTTPDate)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HTTPCookie 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_set_name_131(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPCookie::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPCookie.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const HTTPCookie this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_set_name_131_comment =
    "C++ Interface:\n"
    "setName(non-const HTTPCookie this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::set_name\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_set_name_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPCookie::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_get_name_132(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPCookie::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPCookie*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_get_name_132_comment =
    "C++ Interface:\n"
    "getName(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the cookie.  This is the key\n"
    "//               value specified by the server.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_get_name_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::set_value(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_set_value_133(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPCookie::set_value(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPCookie.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const HTTPCookie this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_set_value_133_comment =
    "C++ Interface:\n"
    "setValue(non-const HTTPCookie this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::set_value\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_set_value_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPCookie::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_get_value_134(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPCookie::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPCookie*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_get_value_134_comment =
    "C++ Interface:\n"
    "getValue(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the cookie.  This is the\n"
    "//               arbitrary string associated with the cookie's name,\n"
    "//               as specified by the server.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_get_value_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::set_domain(basic_string< char > const &domain)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_set_domain_135(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPCookie::set_domain(basic_string< char > const &domain)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"domain", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDomain", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDomain", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_domain(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPCookie.setDomain() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDomain(non-const HTTPCookie this, string domain)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_set_domain_135_comment =
    "C++ Interface:\n"
    "setDomain(non-const HTTPCookie this, string domain)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::set_domain\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_set_domain_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPCookie::get_domain(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_get_domain_136(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPCookie::get_domain(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDomain", key_word_list));
        else
            (PyArg_Parse(args, ":getDomain"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPCookie*)local_this)->get_domain();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDomain(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_get_domain_136_comment =
    "C++ Interface:\n"
    "getDomain(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::get_domain\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_get_domain_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::set_path(basic_string< char > const &path)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_set_path_137(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPCookie::set_path(basic_string< char > const &path)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"path", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setPath", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setPath", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_path(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPCookie.setPath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPath(non-const HTTPCookie this, string path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_set_path_137_comment =
    "C++ Interface:\n"
    "setPath(non-const HTTPCookie this, string path)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::set_path\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_set_path_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPCookie::get_path(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_get_path_138(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPCookie::get_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPath", key_word_list));
        else
            (PyArg_Parse(args, ":getPath"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPCookie*)local_this)->get_path();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPath(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_get_path_138_comment =
    "C++ Interface:\n"
    "getPath(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::get_path\n"
    "//       Access: Published\n"
    "//  Description: Returns the prefix of the URL paths on the server for\n"
    "//               which this cookie will be sent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_get_path_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::set_expires(HTTPDate const &expires)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_set_expires_139(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPCookie::set_expires(HTTPDate const &expires)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"expires", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setExpires", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setExpires", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPCookie.setExpires", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_expires(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPCookie.setExpires() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExpires(non-const HTTPCookie this, const HTTPDate expires)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_set_expires_139_comment =
    "C++ Interface:\n"
    "setExpires(non-const HTTPCookie this, const HTTPDate expires)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::set_expires\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_set_expires_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::clear_expires(void)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_clear_expires_140(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPCookie::clear_expires(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearExpires", key_word_list));
        else
            (PyArg_Parse(args, ":clearExpires"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_expires();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPCookie.clearExpires() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearExpires(non-const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_clear_expires_140_comment =
    "C++ Interface:\n"
    "clearExpires(non-const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::clear_expires\n"
    "//       Access: Published\n"
    "//  Description: Removes the expiration date on the cookie.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_clear_expires_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPCookie::has_expires(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_has_expires_141(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPCookie::has_expires(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasExpires", key_word_list));
        else
            (PyArg_Parse(args, ":hasExpires"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPCookie*)local_this)->has_expires();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasExpires(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_has_expires_141_comment =
    "C++ Interface:\n"
    "hasExpires(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::has_expires\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the cookie has an expiration date,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_has_expires_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPDate HTTPCookie::get_expires(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_get_expires_142(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPDate HTTPCookie::get_expires(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExpires", key_word_list));
        else
            (PyArg_Parse(args, ":getExpires"));
        if(!PyErr_Occurred())
        {
            HTTPDate result = ((const HTTPCookie*)local_this)->get_expires();
            HTTPDate *return_value = new HTTPDate(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPDate,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExpires(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_get_expires_142_comment =
    "C++ Interface:\n"
    "getExpires(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::get_expires\n"
    "//       Access: Published\n"
    "//  Description: Returns the expiration date of the cookie if it is\n"
    "//               set, or an invalid date if it is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_get_expires_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPCookie::set_secure(bool flag)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_set_secure_143(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPCookie::set_secure(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSecure", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSecure", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_secure((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPCookie.setSecure() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSecure(non-const HTTPCookie this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_set_secure_143_comment =
    "C++ Interface:\n"
    "setSecure(non-const HTTPCookie this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::set_secure\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_set_secure_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPCookie::get_secure(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_get_secure_144(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPCookie::get_secure(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSecure", key_word_list));
        else
            (PyArg_Parse(args, ":getSecure"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPCookie*)local_this)->get_secure();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSecure(const HTTPCookie this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_get_secure_144_comment =
    "C++ Interface:\n"
    "getSecure(const HTTPCookie this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::get_secure\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the server has indicated this is a\n"
    "//               \"secure\" cookie which should only be sent over an\n"
    "//               HTTPS channel.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_get_secure_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPCookie::operator <(HTTPCookie const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_operator_145(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool HTTPCookie::operator <(HTTPCookie const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                HTTPCookie *param1_this = (HTTPCookie *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPCookie, 1, "HTTPCookie.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPCookie*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const HTTPCookie this, const HTTPCookie other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_operator_145_comment =
    "C++ Interface:\n"
    "lessThan(const HTTPCookie this, const HTTPCookie other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::operator <\n"
    "//       Access: Published\n"
    "//  Description: The sorting operator allows the cookies to be stored\n"
    "//               in a single dictionary; it returns nonequal only if\n"
    "//               the cookies are different in name, path, or domain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_operator_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPCookie::update_from(HTTPCookie const &other)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_update_from_146(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPCookie::update_from(HTTPCookie const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:updateFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:updateFrom", &param1));
            if(!PyErr_Occurred())
            {
                HTTPCookie *param1_this = (HTTPCookie *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPCookie, 1, "HTTPCookie.updateFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->update_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPCookie.updateFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateFrom(non-const HTTPCookie this, const HTTPCookie other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_update_from_146_comment =
    "C++ Interface:\n"
    "updateFrom(non-const HTTPCookie this, const HTTPCookie other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::update_from\n"
    "//       Access: Published\n"
    "//  Description: Assuming the operator < method, above, has already\n"
    "//               evaluated these two cookies as equal, then assign the\n"
    "//               remaining values (value, expiration date, secure\n"
    "//               flag) from the indicated cookie.  This is guaranteed\n"
    "//               not to change the ordering of the cookie in a set,\n"
    "//               and so can be used to update an existing cookie\n"
    "//               within a set with new values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_update_from_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPCookie::parse_set_cookie(basic_string< char > const &format, URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_parse_set_cookie_147(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPCookie::parse_set_cookie(basic_string< char > const &format, URLSpec const &url)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"format", (char *)"url", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:parseSetCookie", key_word_list, &param1_str, &param1_len, &param2))
            {
                URLSpec *param2_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_URLSpec, 2, "HTTPCookie.parseSetCookie", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->parse_set_cookie(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPCookie.parseSetCookie() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "parseSetCookie(non-const HTTPCookie this, string format, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_parse_set_cookie_147_comment =
    "C++ Interface:\n"
    "parseSetCookie(non-const HTTPCookie this, string format, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::parse_set_cookie\n"
    "//       Access: Published\n"
    "//  Description: Separates out the parameter/value pairs of the\n"
    "//               Set-Cookie header and assigns the values of the\n"
    "//               cookie appropriate.  Returns true if the header is\n"
    "//               parsed correctly, false if something is not\n"
    "//               understood.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_parse_set_cookie_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPCookie::is_expired(HTTPDate const &now) const
 * inline bool HTTPCookie::is_expired(HTTPDate const &now = ((now()))) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_is_expired_148(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool HTTPCookie::is_expired(HTTPDate const &now = ((now()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":isExpired", key_word_list));
            else
                (PyArg_Parse(args, ":isExpired"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const HTTPCookie*)local_this)->is_expired();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline bool HTTPCookie::is_expired(HTTPDate const &now) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"now", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:isExpired", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:isExpired", &param1));
                if(!PyErr_Occurred())
                {
                    HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "HTTPCookie.isExpired", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const HTTPCookie*)local_this)->is_expired(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "isExpired() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "isExpired(const HTTPCookie this)\n"
          "isExpired(const HTTPCookie this, const HTTPDate now)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_is_expired_148_comment =
    "C++ Interface:\n"
    "isExpired(const HTTPCookie this)\n"
    "isExpired(const HTTPCookie this, const HTTPDate now)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::is_expired\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the cookie's expiration date is\n"
    "//               before the indicated date, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_is_expired_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPCookie::matches_url(URLSpec const &url) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_matches_url_149(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool HTTPCookie::matches_url(URLSpec const &url) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:matchesUrl", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:matchesUrl", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPCookie.matchesUrl", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPCookie*)local_this)->matches_url(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matchesUrl(const HTTPCookie this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_matches_url_149_comment =
    "C++ Interface:\n"
    "matchesUrl(const HTTPCookie this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::matches_url\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the cookie is appropriate to send\n"
    "//               with the indicated URL request, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_matches_url_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPCookie::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HTTPCookie_output_150(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HTTPCookie::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPCookie.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HTTPCookie*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const HTTPCookie this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPCookie_output_150_comment =
    "C++ Interface:\n"
    "output(const HTTPCookie this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPCookie::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPCookie_output_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPCookie::HTTPCookie(void)
 * inline HTTPCookie::HTTPCookie(basic_string< char > const &format, URLSpec const &url)
 * inline HTTPCookie::HTTPCookie(basic_string< char > const &name, basic_string< char > const &path, basic_string< char > const &domain)
 *******************************************************************/
int  Dtool_Init_HTTPCookie(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline HTTPCookie::HTTPCookie(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":HTTPCookie", key_word_list))
            {
                HTTPCookie *return_value = new HTTPCookie();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPCookie,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline HTTPCookie::HTTPCookie(basic_string< char > const &format, URLSpec const &url)
                char *param0_str; int param0_len;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"format", (char *)"url", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:HTTPCookie", key_word_list, &param0_str, &param0_len, &param1))
                {
                    URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPCookie.HTTPCookie", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        HTTPCookie *return_value = new HTTPCookie(basic_string<char>(param0_str, param0_len), *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPCookie,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline HTTPCookie::HTTPCookie(basic_string< char > const &name, basic_string< char > const &path, basic_string< char > const &domain)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"path", (char *)"domain", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:HTTPCookie", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                HTTPCookie *return_value = new HTTPCookie(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPCookie,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HTTPCookie() takes 0, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HTTPCookie()\n"
          "HTTPCookie(string format, const URLSpec url)\n"
          "HTTPCookie(string name, string path, string domain)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HTTPCookie(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HTTPCookie)
    {
        printf("HTTPCookie ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HTTPCookie * local_this = (HTTPCookie *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HTTPCookie)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HTTPCookie(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HTTPCookie)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HTTPClient 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::operator =(HTTPClient const &copy)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_operator_154(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPClient::operator =(HTTPClient const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                HTTPClient *param1_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPClient, 1, "HTTPClient.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    HTTPClient *return_value = local_this;
                    if (return_value != (HTTPClient *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPClient,true, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const HTTPClient this, const HTTPClient copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_operator_154_comment =
    "C++ Interface:\n"
    "assign(non-const HTTPClient this, const HTTPClient copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_operator_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void HTTPClient::init_random_seed(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_init_random_seed_155(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void HTTPClient::init_random_seed(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":initRandomSeed", key_word_list))
        {
            HTTPClient::init_random_seed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initRandomSeed()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_init_random_seed_155_comment =
    "C++ Interface:\n"
    "initRandomSeed()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::init_random_seed\n"
    "//       Access: Published, Static\n"
    "//  Description: This may be called once, presumably at the beginning\n"
    "//               of an application, to initialize OpenSSL's random\n"
    "//               seed.  On Windows, it is particularly important to\n"
    "//               call this at startup if you are going to be perfoming\n"
    "//               any https operations or otherwise use encryption,\n"
    "//               since the Windows algorithm for getting a random seed\n"
    "//               takes 2-3 seconds at startup, but can take 30 seconds\n"
    "//               or more after you have opened a 3-D graphics window\n"
    "//               and started rendering.\n"
    "//\n"
    "//               There is no harm in calling this method multiple\n"
    "//               times, or in not calling it at all.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_init_random_seed_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::set_proxy_spec(basic_string< char > const &proxy_spec)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_proxy_spec_156(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::set_proxy_spec(basic_string< char > const &proxy_spec)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"proxy_spec", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setProxySpec", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setProxySpec", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_proxy_spec(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setProxySpec() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setProxySpec(non-const HTTPClient this, string proxy_spec)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_proxy_spec_156_comment =
    "C++ Interface:\n"
    "setProxySpec(non-const HTTPClient this, string proxy_spec)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_proxy_spec\n"
    "//       Access: Published\n"
    "//  Description: Specifies the complete set of proxies to use for all\n"
    "//               schemes.  This is either a semicolon-delimited set of\n"
    "//               hostname:ports, or a semicolon-delimited set of pairs\n"
    "//               of the form \"scheme=hostname:port\", or a combination.\n"
    "//               Use the keyword DIRECT, or an empty string, to\n"
    "//               represent a direct connection.  A particular scheme\n"
    "//               and/or proxy host may be listed more than once.  This\n"
    "//               is a convenience function that can be used in place\n"
    "//               of explicit calls to add_proxy() for each\n"
    "//               scheme/proxy pair.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_proxy_spec_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPClient::get_proxy_spec(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_proxy_spec_157(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPClient::get_proxy_spec(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProxySpec", key_word_list));
        else
            (PyArg_Parse(args, ":getProxySpec"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPClient*)local_this)->get_proxy_spec();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProxySpec(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_proxy_spec_157_comment =
    "C++ Interface:\n"
    "getProxySpec(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_proxy_spec\n"
    "//       Access: Published\n"
    "//  Description: Returns the complete set of proxies to use for all\n"
    "//               schemes.  This is a string of the form specified by\n"
    "//               set_proxy_spec(), above.  Note that the string\n"
    "//               returned by this function may not be exactly the same\n"
    "//               as the string passed into set_proxy_spec(), since the\n"
    "//               string is regenerated from the internal storage\n"
    "//               structures and may therefore be reordered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_proxy_spec_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::set_direct_host_spec(basic_string< char > const &direct_host_spec)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_direct_host_spec_158(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::set_direct_host_spec(basic_string< char > const &direct_host_spec)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"direct_host_spec", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDirectHostSpec", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDirectHostSpec", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_direct_host_spec(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setDirectHostSpec() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDirectHostSpec(non-const HTTPClient this, string direct_host_spec)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_direct_host_spec_158_comment =
    "C++ Interface:\n"
    "setDirectHostSpec(non-const HTTPClient this, string direct_host_spec)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_direct_host_spec\n"
    "//       Access: Published\n"
    "//  Description: Specifies the set of hosts that should be connected\n"
    "//               to directly, without using a proxy.  This is a\n"
    "//               semicolon-separated list of hostnames that may\n"
    "//               contain wildcard characters (\"*\").\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_direct_host_spec_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPClient::get_direct_host_spec(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_direct_host_spec_159(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPClient::get_direct_host_spec(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirectHostSpec", key_word_list));
        else
            (PyArg_Parse(args, ":getDirectHostSpec"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPClient*)local_this)->get_direct_host_spec();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirectHostSpec(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_direct_host_spec_159_comment =
    "C++ Interface:\n"
    "getDirectHostSpec(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_direct_host_spec\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of hosts that should be connected\n"
    "//               to directly, without using a proxy, as a\n"
    "//               semicolon-separated list of hostnames that may\n"
    "//               contain wildcard characters (\"*\").\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_direct_host_spec_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_try_all_direct(bool try_all_direct)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_try_all_direct_160(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPClient::set_try_all_direct(bool try_all_direct)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"try_all_direct", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTryAllDirect", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTryAllDirect", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_try_all_direct((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setTryAllDirect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTryAllDirect(non-const HTTPClient this, bool try_all_direct)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_try_all_direct_160_comment =
    "C++ Interface:\n"
    "setTryAllDirect(non-const HTTPClient this, bool try_all_direct)\n"
    "\n"
    "// Filename: httpClient.I\n"
    "// Created by:  drose (24Sep02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_try_all_direct\n"
    "//       Access: Published\n"
    "//  Description: If this is set true, then after a connection attempt\n"
    "//               through a proxy fails, we always try a direct\n"
    "//               connection, regardless of whether the host is listed\n"
    "//               on the direct_host_spec list.  If this is false, a\n"
    "//               direct attempt is not made when we have a proxy in\n"
    "//               effect, even if the proxy fails.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_try_all_direct_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPClient::get_try_all_direct(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_try_all_direct_161(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPClient::get_try_all_direct(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTryAllDirect", key_word_list));
        else
            (PyArg_Parse(args, ":getTryAllDirect"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPClient*)local_this)->get_try_all_direct();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTryAllDirect(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_try_all_direct_161_comment =
    "C++ Interface:\n"
    "getTryAllDirect(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_try_all_direct\n"
    "//       Access: Published\n"
    "//  Description: Returns whether a failed connection through a proxy\n"
    "//               will be followed up by a direct connection attempt,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_try_all_direct_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::clear_proxy(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_clear_proxy_162(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::clear_proxy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearProxy", key_word_list));
        else
            (PyArg_Parse(args, ":clearProxy"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_proxy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.clearProxy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearProxy(non-const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_clear_proxy_162_comment =
    "C++ Interface:\n"
    "clearProxy(non-const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::clear_proxy\n"
    "//       Access: Published\n"
    "//  Description: Resets the proxy spec to empty.  Subsequent calls to\n"
    "//               add_proxy() may be made to build up the set of proxy\n"
    "//               servers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_clear_proxy_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::add_proxy(basic_string< char > const &scheme, URLSpec const &proxy)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_add_proxy_163(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPClient::add_proxy(basic_string< char > const &scheme, URLSpec const &proxy)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"scheme", (char *)"proxy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addProxy", key_word_list, &param1_str, &param1_len, &param2))
            {
                URLSpec *param2_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_URLSpec, 2, "HTTPClient.addProxy", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->add_proxy(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.addProxy() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addProxy(non-const HTTPClient this, string scheme, const URLSpec proxy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_add_proxy_163_comment =
    "C++ Interface:\n"
    "addProxy(non-const HTTPClient this, string scheme, const URLSpec proxy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::add_proxy\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated proxy host as a proxy for\n"
    "//               communications on the given scheme.  Usually the\n"
    "//               scheme is \"http\" or \"https\".  It may be the empty\n"
    "//               string to indicate a general proxy.  The proxy string\n"
    "//               may be the empty URL to indicate a direct connection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_add_proxy_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::clear_direct_host(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_clear_direct_host_164(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::clear_direct_host(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDirectHost", key_word_list));
        else
            (PyArg_Parse(args, ":clearDirectHost"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_direct_host();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.clearDirectHost() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDirectHost(non-const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_clear_direct_host_164_comment =
    "C++ Interface:\n"
    "clearDirectHost(non-const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::clear_direct_host\n"
    "//       Access: Published\n"
    "//  Description: Resets the set of direct hosts to empty.  Subsequent\n"
    "//               calls to add_direct_host() may be made to build up\n"
    "//               the list of hosts that do not require a proxy\n"
    "//               connection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_clear_direct_host_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::add_direct_host(basic_string< char > const &hostname)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_add_direct_host_165(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::add_direct_host(basic_string< char > const &hostname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"hostname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addDirectHost", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addDirectHost", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_direct_host(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.addDirectHost() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addDirectHost(non-const HTTPClient this, string hostname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_add_direct_host_165_comment =
    "C++ Interface:\n"
    "addDirectHost(non-const HTTPClient this, string hostname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::add_direct_host\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated name to the set of hostnames that\n"
    "//               are connected to directly, without using a proxy.\n"
    "//               This name may be either a DNS name or an IP address,\n"
    "//               and it may include the * as a wildcard character.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_add_direct_host_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPClient::get_proxies_for_url(URLSpec const &url) const
 * Rejected Remap [void HTTPClient::get_proxies_for_url(URLSpec const &url, vector< URLSpec > &proxies) const]
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_proxies_for_url_166(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-basic_string< char > HTTPClient::get_proxies_for_url(URLSpec const &url) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getProxiesForUrl", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getProxiesForUrl", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.getProxiesForUrl", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const HTTPClient*)local_this)->get_proxies_for_url(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProxiesForUrl(const HTTPClient this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_proxies_for_url_166_comment =
    "C++ Interface:\n"
    "getProxiesForUrl(const HTTPClient this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_proxies_for_url\n"
    "//       Access: Published\n"
    "//  Description: Fills up the indicated vector with the list of\n"
    "//               URLSpec objects, in the order in which they should be\n"
    "//               tried, that are appropriate proxies to try for the\n"
    "//               indicated URL.  The empty URL is returned for a\n"
    "//               direct connection.\n"
    "//\n"
    "//               It is the user's responsibility to empty this vector\n"
    "//               before calling this method; otherwise, the proxy\n"
    "//               URL's will simply be appended to the existing list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_proxies_for_url\n"
    "//       Access: Published\n"
    "//  Description: Returns a semicolon-delimited list of proxies, in the\n"
    "//               order in which they should be tried, that are\n"
    "//               appropriate for the indicated URL.  The keyword\n"
    "//               DIRECT indicates a direct connection should be tried.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_proxies_for_url_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::set_username(basic_string< char > const &server, basic_string< char > const &realm, basic_string< char > const &username)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_username_167(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::set_username(basic_string< char > const &server, basic_string< char > const &realm, basic_string< char > const &username)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"server", (char *)"realm", (char *)"username", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:setUsername", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len))
        {
            (local_this)->set_username(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setUsername() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUsername(non-const HTTPClient this, string server, string realm, string username)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_username_167_comment =
    "C++ Interface:\n"
    "setUsername(non-const HTTPClient this, string server, string realm, string username)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_username\n"
    "//       Access: Published\n"
    "//  Description: Specifies the username:password string corresponding\n"
    "//               to a particular server and/or realm, when demanded by\n"
    "//               the server.  Either or both of the server or realm\n"
    "//               may be empty; if so, they match anything.  Also, the\n"
    "//               server may be set to the special string \"*proxy\",\n"
    "//               which will match any proxy server.\n"
    "//\n"
    "//               If the username is set to the empty string, this\n"
    "//               clears the password for the particular server/realm\n"
    "//               pair.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_username_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPClient::get_username(basic_string< char > const &server, basic_string< char > const &realm) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_username_168(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPClient::get_username(basic_string< char > const &server, basic_string< char > const &realm) const
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"server", (char *)"realm", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:getUsername", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            basic_string< char > return_value = ((const HTTPClient*)local_this)->get_username(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUsername(const HTTPClient this, string server, string realm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_username_168_comment =
    "C++ Interface:\n"
    "getUsername(const HTTPClient this, string server, string realm)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_username\n"
    "//       Access: Published\n"
    "//  Description: Returns the username:password string set for this\n"
    "//               server/realm pair, or empty string if nothing has\n"
    "//               been set.  See set_username().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_username_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::set_cookie(HTTPCookie const &cookie)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_cookie_169(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPClient::set_cookie(HTTPCookie const &cookie)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cookie", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCookie", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCookie", &param1));
            if(!PyErr_Occurred())
            {
                HTTPCookie *param1_this = (HTTPCookie *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPCookie, 1, "HTTPClient.setCookie", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_cookie(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.setCookie() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCookie(non-const HTTPClient this, const HTTPCookie cookie)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_cookie_169_comment =
    "C++ Interface:\n"
    "setCookie(non-const HTTPClient this, const HTTPCookie cookie)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_cookie\n"
    "//       Access: Published\n"
    "//  Description: Stores the indicated cookie in the client's list of\n"
    "//               cookies, as if it had been received from a server.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_cookie_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::clear_cookie(HTTPCookie const &cookie)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_clear_cookie_170(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPClient::clear_cookie(HTTPCookie const &cookie)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cookie", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearCookie", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:clearCookie", &param1));
            if(!PyErr_Occurred())
            {
                HTTPCookie *param1_this = (HTTPCookie *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPCookie, 1, "HTTPClient.clearCookie", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->clear_cookie(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.clearCookie() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCookie(non-const HTTPClient this, const HTTPCookie cookie)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_clear_cookie_170_comment =
    "C++ Interface:\n"
    "clearCookie(non-const HTTPClient this, const HTTPCookie cookie)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::clear_cookie\n"
    "//       Access: Published\n"
    "//  Description: Removes the cookie with the matching domain/path/name\n"
    "//               from the client's list of cookies.  Returns true if\n"
    "//               it was removed, false if the cookie was not matched.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_clear_cookie_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::clear_all_cookies(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_clear_all_cookies_171(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::clear_all_cookies(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAllCookies", key_word_list));
        else
            (PyArg_Parse(args, ":clearAllCookies"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_all_cookies();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.clearAllCookies() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAllCookies(non-const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_clear_all_cookies_171_comment =
    "C++ Interface:\n"
    "clearAllCookies(non-const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::clear_all_cookies\n"
    "//       Access: Published\n"
    "//  Description: Removes the all stored cookies from the client.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_clear_all_cookies_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::has_cookie(HTTPCookie const &cookie) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_has_cookie_172(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool HTTPClient::has_cookie(HTTPCookie const &cookie) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cookie", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasCookie", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasCookie", &param1));
            if(!PyErr_Occurred())
            {
                HTTPCookie *param1_this = (HTTPCookie *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPCookie, 1, "HTTPClient.hasCookie", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPClient*)local_this)->has_cookie(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCookie(const HTTPClient this, const HTTPCookie cookie)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_has_cookie_172_comment =
    "C++ Interface:\n"
    "hasCookie(const HTTPClient this, const HTTPCookie cookie)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::has_cookie\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there is a cookie in the client\n"
    "//               matching the given cookie's domain/path/name, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_has_cookie_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HTTPCookie HTTPClient::get_cookie(HTTPCookie const &cookie) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_cookie_173(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-HTTPCookie HTTPClient::get_cookie(HTTPCookie const &cookie) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cookie", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getCookie", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getCookie", &param1));
            if(!PyErr_Occurred())
            {
                HTTPCookie *param1_this = (HTTPCookie *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPCookie, 1, "HTTPClient.getCookie", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    HTTPCookie result = ((const HTTPClient*)local_this)->get_cookie(*param1_this);
                    HTTPCookie *return_value = new HTTPCookie(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPCookie,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCookie(const HTTPClient this, const HTTPCookie cookie)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_cookie_173_comment =
    "C++ Interface:\n"
    "getCookie(const HTTPClient this, const HTTPCookie cookie)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_cookie\n"
    "//       Access: Published\n"
    "//  Description: Looks up and returns the cookie in the client\n"
    "//               matching the given cookie's domain/path/name.  If\n"
    "//               there is no matching cookie, returns an empty cookie.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_cookie_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::copy_cookies_from(HTTPClient const &other)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_copy_cookies_from_174(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPClient::copy_cookies_from(HTTPClient const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:copyCookiesFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:copyCookiesFrom", &param1));
            if(!PyErr_Occurred())
            {
                HTTPClient *param1_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPClient, 1, "HTTPClient.copyCookiesFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->copy_cookies_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.copyCookiesFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyCookiesFrom(non-const HTTPClient this, const HTTPClient other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_copy_cookies_from_174_comment =
    "C++ Interface:\n"
    "copyCookiesFrom(non-const HTTPClient this, const HTTPClient other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::copy_cookies_from\n"
    "//       Access: Published\n"
    "//  Description: Copies all the cookies from the indicated HTTPClient\n"
    "//               into this one.  Existing cookies in this client are\n"
    "//               not affected, unless they are shadowed by the new\n"
    "//               cookies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_copy_cookies_from_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::write_cookies(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_write_cookies_175(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HTTPClient::write_cookies(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeCookies", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeCookies", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPClient.writeCookies", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HTTPClient*)local_this)->write_cookies(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeCookies(const HTTPClient this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_write_cookies_175_comment =
    "C++ Interface:\n"
    "writeCookies(const HTTPClient this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::write_cookies\n"
    "//       Access: Published\n"
    "//  Description: Outputs the complete list of cookies stored on the\n"
    "//               client, for all domains, including the expired\n"
    "//               cookies (which will normally not be sent back to a\n"
    "//               host).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_write_cookies_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::send_cookies(ostream &out, URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_send_cookies_176(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPClient::send_cookies(ostream &out, URLSpec const &url)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"out", (char *)"url", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:sendCookies", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPClient.sendCookies", 0, coerced_ptr, report_errors);
URLSpec *param2_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_URLSpec, 2, "HTTPClient.sendCookies", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->send_cookies(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.sendCookies() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendCookies(non-const HTTPClient this, non-const Ostream out, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_send_cookies_176_comment =
    "C++ Interface:\n"
    "sendCookies(non-const HTTPClient this, non-const Ostream out, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::send_cookies\n"
    "//       Access: Published\n"
    "//  Description: Writes to the indicated ostream a \"Cookie\" header\n"
    "//               line for sending the cookies appropriate to the\n"
    "//               indicated URL along with an HTTP request.  This also\n"
    "//               removes expired cookies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_send_cookies_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_client_certificate_filename(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_client_certificate_filename_177(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPClient::set_client_certificate_filename(Filename const &filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClientCertificateFilename", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setClientCertificateFilename", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "HTTPClient.setClientCertificateFilename", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_client_certificate_filename(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.setClientCertificateFilename() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientCertificateFilename(non-const HTTPClient this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_client_certificate_filename_177_comment =
    "C++ Interface:\n"
    "setClientCertificateFilename(non-const HTTPClient this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_client_certificate_filename\n"
    "//       Access: Published\n"
    "//  Description: Sets the filename of the pem-formatted file that will\n"
    "//               be read for the client public and private keys if an\n"
    "//               SSL server requests a certificate.  Either this or\n"
    "//               set_client_certificate_pem() may be used to specify a\n"
    "//               client certificate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_client_certificate_filename_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_client_certificate_pem(basic_string< char > const &pem)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_client_certificate_pem_178(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPClient::set_client_certificate_pem(basic_string< char > const &pem)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pem", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setClientCertificatePem", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setClientCertificatePem", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_certificate_pem(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setClientCertificatePem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientCertificatePem(non-const HTTPClient this, string pem)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_client_certificate_pem_178_comment =
    "C++ Interface:\n"
    "setClientCertificatePem(non-const HTTPClient this, string pem)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_client_certificate_pem\n"
    "//       Access: Published\n"
    "//  Description: Sets the pem-formatted contents of the certificate\n"
    "//               that will be parsed for the client public and private\n"
    "//               keys if an SSL server requests a certificate.  Either\n"
    "//               this or set_client_certificate_filename() may be used\n"
    "//               to specify a client certificate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_client_certificate_pem_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_client_certificate_passphrase(basic_string< char > const &passphrase)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_client_certificate_passphrase_179(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPClient::set_client_certificate_passphrase(basic_string< char > const &passphrase)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"passphrase", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setClientCertificatePassphrase", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setClientCertificatePassphrase", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_certificate_passphrase(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setClientCertificatePassphrase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientCertificatePassphrase(non-const HTTPClient this, string passphrase)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_client_certificate_passphrase_179_comment =
    "C++ Interface:\n"
    "setClientCertificatePassphrase(non-const HTTPClient this, string passphrase)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_client_certificate_passphrase\n"
    "//       Access: Published\n"
    "//  Description: Sets the passphrase used to decrypt the private key\n"
    "//               in the certificate named by\n"
    "//               set_client_certificate_filename() or\n"
    "//               set_client_certificate_pem().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_client_certificate_passphrase_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::load_client_certificate(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_load_client_certificate_180(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HTTPClient::load_client_certificate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":loadClientCertificate", key_word_list));
        else
            (PyArg_Parse(args, ":loadClientCertificate"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->load_client_certificate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.loadClientCertificate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadClientCertificate(non-const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_load_client_certificate_180_comment =
    "C++ Interface:\n"
    "loadClientCertificate(non-const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::load_client_certificate\n"
    "//       Access: Published\n"
    "//  Description: Attempts to load the certificate named by\n"
    "//               set_client_certificate_filename() immediately, and\n"
    "//               returns true if successful, false otherwise.\n"
    "//\n"
    "//               Normally this need not be explicitly called, since it\n"
    "//               will be called automatically if the server requests a\n"
    "//               certificate, but it may be useful to determine ahead\n"
    "//               of time if the certificate can be loaded correctly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_load_client_certificate_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::add_preapproved_server_certificate_filename(URLSpec const &url, Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_add_preapproved_server_certificate_filename_181(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPClient::add_preapproved_server_certificate_filename(URLSpec const &url, Filename const &filename)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"url", (char *)"filename", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addPreapprovedServerCertificateFilename", key_word_list, &param1, &param2))
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.addPreapprovedServerCertificateFilename", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "HTTPClient.addPreapprovedServerCertificateFilename", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->add_preapproved_server_certificate_filename(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.addPreapprovedServerCertificateFilename() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPreapprovedServerCertificateFilename(non-const HTTPClient this, const URLSpec url, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_add_preapproved_server_certificate_filename_181_comment =
    "C++ Interface:\n"
    "addPreapprovedServerCertificateFilename(non-const HTTPClient this, const URLSpec url, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::add_preapproved_server_certificate_filename\n"
    "//       Access: Published\n"
    "//  Description: Adds the certificate defined in the indicated PEM\n"
    "//               filename as a \"pre-approved\" certificate for the\n"
    "//               indicated server, defined by the hostname and port\n"
    "//               (only) from the given URL.\n"
    "//\n"
    "//               If the server offers this particular certificate on a\n"
    "//               secure connection, it will be accepted without\n"
    "//               question.  This is particularly useful for\n"
    "//               communicating with a server using a known self-signed\n"
    "//               certificate.\n"
    "//\n"
    "//               See also the similar\n"
    "//               add_preapproved_server_certificate_pem(), and the\n"
    "//               weaker add_preapproved_server_certificate_name().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_add_preapproved_server_certificate_filename_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::add_preapproved_server_certificate_pem(URLSpec const &url, basic_string< char > const &pem)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_add_preapproved_server_certificate_pem_182(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPClient::add_preapproved_server_certificate_pem(URLSpec const &url, basic_string< char > const &pem)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"url", (char *)"pem", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:addPreapprovedServerCertificatePem", key_word_list, &param1, &param2_str, &param2_len))
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.addPreapprovedServerCertificatePem", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_preapproved_server_certificate_pem(*param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.addPreapprovedServerCertificatePem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPreapprovedServerCertificatePem(non-const HTTPClient this, const URLSpec url, string pem)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_add_preapproved_server_certificate_pem_182_comment =
    "C++ Interface:\n"
    "addPreapprovedServerCertificatePem(non-const HTTPClient this, const URLSpec url, string pem)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::add_preapproved_server_certificate_pem\n"
    "//       Access: Published\n"
    "//  Description: Adds the certificate defined in the indicated data\n"
    "//               string, formatted as a PEM block, as a \"pre-approved\"\n"
    "//               certificate for the indicated server, defined by the\n"
    "//               hostname and port (only) from the given URL.\n"
    "//\n"
    "//               If the server offers this particular certificate on a\n"
    "//               secure connection, it will be accepted without\n"
    "//               question.  This is particularly useful for\n"
    "//               communicating with a server using a known self-signed\n"
    "//               certificate.\n"
    "//\n"
    "//               See also the similar\n"
    "//               add_preapproved_server_certificate_filename(), and\n"
    "//               the weaker add_preapproved_server_certificate_name().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_add_preapproved_server_certificate_pem_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::add_preapproved_server_certificate_name(URLSpec const &url, basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_add_preapproved_server_certificate_name_183(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPClient::add_preapproved_server_certificate_name(URLSpec const &url, basic_string< char > const &name)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"url", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:addPreapprovedServerCertificateName", key_word_list, &param1, &param2_str, &param2_len))
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.addPreapprovedServerCertificateName", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_preapproved_server_certificate_name(*param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.addPreapprovedServerCertificateName() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPreapprovedServerCertificateName(non-const HTTPClient this, const URLSpec url, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_add_preapproved_server_certificate_name_183_comment =
    "C++ Interface:\n"
    "addPreapprovedServerCertificateName(non-const HTTPClient this, const URLSpec url, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::add_preapproved_server_certificate_name\n"
    "//       Access: Published\n"
    "//  Description: Adds the certificate *name* only, as a \"pre-approved\"\n"
    "//               certificate name for the indicated server, defined by\n"
    "//               the hostname and port (only) from the given URL.\n"
    "//\n"
    "//               This is a weaker function than\n"
    "//               add_preapproved_server_certificate_filename().  This\n"
    "//               checks only the subject name of the certificate,\n"
    "//               without checking for a particular certificate by key.\n"
    "//               This means that a variety of server certificates may\n"
    "//               match the indicated name.\n"
    "//\n"
    "//               Because this is a weaker verification, it only\n"
    "//               applies to server certificates that are signed by a\n"
    "//               recognized certificate authority.  Thus, it cannot be\n"
    "//               used to pre-approve self-signed certificates, but it\n"
    "//               can be used to accept a server certificate offered by\n"
    "//               a different hostname than the one in the cert itself.\n"
    "//\n"
    "//               The certificate name should be formatted in the form\n"
    "//               /type0=value0/type1=value1/type2=...\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_add_preapproved_server_certificate_name_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::clear_preapproved_server_certificates(URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_clear_preapproved_server_certificates_184(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HTTPClient::clear_preapproved_server_certificates(URLSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearPreapprovedServerCertificates", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:clearPreapprovedServerCertificates", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.clearPreapprovedServerCertificates", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->clear_preapproved_server_certificates(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.clearPreapprovedServerCertificates() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPreapprovedServerCertificates(non-const HTTPClient this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_clear_preapproved_server_certificates_184_comment =
    "C++ Interface:\n"
    "clearPreapprovedServerCertificates(non-const HTTPClient this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::clear_preapproved_server_certificates\n"
    "//       Access: Published\n"
    "//  Description: Removes all preapproved server certificates for the\n"
    "//               indicated server and port.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_clear_preapproved_server_certificates_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPClient::clear_all_preapproved_server_certificates(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_clear_all_preapproved_server_certificates_185(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HTTPClient::clear_all_preapproved_server_certificates(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAllPreapprovedServerCertificates", key_word_list));
        else
            (PyArg_Parse(args, ":clearAllPreapprovedServerCertificates"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_all_preapproved_server_certificates();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.clearAllPreapprovedServerCertificates() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAllPreapprovedServerCertificates(non-const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_clear_all_preapproved_server_certificates_185_comment =
    "C++ Interface:\n"
    "clearAllPreapprovedServerCertificates(non-const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::clear_all_preapproved_server_certificates\n"
    "//       Access: Published\n"
    "//  Description: Removes all preapproved server certificates for all\n"
    "//               servers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_clear_all_preapproved_server_certificates_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_http_version(HTTPEnum::HTTPVersion version)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_http_version_186(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPClient::set_http_version(HTTPEnum::HTTPVersion version)
        int param1;
        static char * key_word_list[] = {(char *)"version", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setHttpVersion", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setHttpVersion", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_http_version((HTTPEnum::HTTPVersion)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setHttpVersion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHttpVersion(non-const HTTPClient this, int version)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_http_version_186_comment =
    "C++ Interface:\n"
    "setHttpVersion(non-const HTTPClient this, int version)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_http_version\n"
    "//       Access: Published\n"
    "//  Description: Specifies the version of HTTP that the client uses to\n"
    "//               identify itself to the server.  The default is HV_11,\n"
    "//               or HTTP 1.0; you can set this to HV_10 (HTTP 1.0) to\n"
    "//               request the server use the older interface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_http_version_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPEnum::HTTPVersion HTTPClient::get_http_version(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_http_version_187(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPEnum::HTTPVersion HTTPClient::get_http_version(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHttpVersion", key_word_list));
        else
            (PyArg_Parse(args, ":getHttpVersion"));
        if(!PyErr_Occurred())
        {
            HTTPEnum::HTTPVersion return_value = ((const HTTPClient*)local_this)->get_http_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHttpVersion(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_http_version_187_comment =
    "C++ Interface:\n"
    "getHttpVersion(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_http_version\n"
    "//       Access: Published\n"
    "//  Description: Returns the client's current setting for HTTP\n"
    "//               version.  See set_http_version().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_http_version_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPClient::get_http_version_string(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_http_version_string_188(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPClient::get_http_version_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHttpVersionString", key_word_list));
        else
            (PyArg_Parse(args, ":getHttpVersionString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPClient*)local_this)->get_http_version_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHttpVersionString(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_http_version_string_188_comment =
    "C++ Interface:\n"
    "getHttpVersionString(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_http_version_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the current HTTP version setting as a string,\n"
    "//               e.g. \"HTTP/1.0\" or \"HTTP/1.1\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_http_version_string_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static HTTPEnum::HTTPVersion HTTPClient::parse_http_version_string(basic_string< char > const &version)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_parse_http_version_string_189(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static HTTPEnum::HTTPVersion HTTPClient::parse_http_version_string(basic_string< char > const &version)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"version", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:parseHttpVersionString", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:parseHttpVersionString", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            HTTPEnum::HTTPVersion return_value = HTTPClient::parse_http_version_string(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "parseHttpVersionString(string version)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_parse_http_version_string_189_comment =
    "C++ Interface:\n"
    "parseHttpVersionString(string version)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::parse_http_version_string\n"
    "//       Access: Published\n"
    "//  Description: Matches the string representing a particular HTTP\n"
    "//               version against any of the known versions and returns\n"
    "//               the appropriate enumerated value, or HV_other if the\n"
    "//               version is unknown.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_parse_http_version_string_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPClient::load_certificates(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_load_certificates_190(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HTTPClient::load_certificates(Filename const &filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:loadCertificates", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:loadCertificates", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "HTTPClient.loadCertificates", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->load_certificates(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.loadCertificates() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadCertificates(non-const HTTPClient this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_load_certificates_190_comment =
    "C++ Interface:\n"
    "loadCertificates(non-const HTTPClient this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::load_certificates\n"
    "//       Access: Published\n"
    "//  Description: Reads the certificate(s) (delimited by -----BEGIN\n"
    "//               CERTIFICATE----- and -----END CERTIFICATE-----) from\n"
    "//               the indicated file and makes them known as trusted\n"
    "//               public keys for validating future connections.\n"
    "//               Returns true on success, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_load_certificates_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_verify_ssl(HTTPClient::VerifySSL verify_ssl)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_verify_ssl_192(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPClient::set_verify_ssl(HTTPClient::VerifySSL verify_ssl)
        int param1;
        static char * key_word_list[] = {(char *)"verify_ssl", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setVerifySsl", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setVerifySsl", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_verify_ssl((HTTPClient::VerifySSL)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setVerifySsl() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerifySsl(non-const HTTPClient this, int verify_ssl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_verify_ssl_192_comment =
    "C++ Interface:\n"
    "setVerifySsl(non-const HTTPClient this, int verify_ssl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_verify_ssl\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the client will insist on verifying\n"
    "//               the identity of the servers it connects to via SSL\n"
    "//               (that is, https).  \n"
    "//\n"
    "//               The parameter value is an enumerated type which\n"
    "//               indicates the level of security to which the client\n"
    "//               will insist upon.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_verify_ssl_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPClient::VerifySSL HTTPClient::get_verify_ssl(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_verify_ssl_193(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPClient::VerifySSL HTTPClient::get_verify_ssl(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVerifySsl", key_word_list));
        else
            (PyArg_Parse(args, ":getVerifySsl"));
        if(!PyErr_Occurred())
        {
            HTTPClient::VerifySSL return_value = ((const HTTPClient*)local_this)->get_verify_ssl();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVerifySsl(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_verify_ssl_193_comment =
    "C++ Interface:\n"
    "getVerifySsl(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_verify_ssl\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the client will insist on verifying\n"
    "//               the identity of the servers it connects to via SSL\n"
    "//               (that is, https).  See set_verify_ssl().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_verify_ssl_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPClient::set_cipher_list(basic_string< char > const &cipher_list)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_set_cipher_list_194(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPClient::set_cipher_list(basic_string< char > const &cipher_list)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"cipher_list", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCipherList", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCipherList", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cipher_list(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.setCipherList() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCipherList(non-const HTTPClient this, string cipher_list)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_set_cipher_list_194_comment =
    "C++ Interface:\n"
    "setCipherList(non-const HTTPClient this, string cipher_list)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::set_cipher_list\n"
    "//       Access: Published\n"
    "//  Description: Specifies the set of ciphers that are to be made\n"
    "//               available for SSL connections.  This is a string as\n"
    "//               described in the ciphers(1) man page of the OpenSSL\n"
    "//               documentation (or see\n"
    "//               http://www.openssl.org/docs/apps/ciphers.html ).  If\n"
    "//               this is not specified, the default is provided by the\n"
    "//               Config file.  You may also specify \"DEFAULT\" to use\n"
    "//               the built-in OpenSSL default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_set_cipher_list_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPClient::get_cipher_list(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_cipher_list_195(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPClient::get_cipher_list(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCipherList", key_word_list));
        else
            (PyArg_Parse(args, ":getCipherList"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPClient*)local_this)->get_cipher_list();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCipherList(const HTTPClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_cipher_list_195_comment =
    "C++ Interface:\n"
    "getCipherList(const HTTPClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_cipher_list\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of ciphers as set by\n"
    "//               set_cipher_list().  See set_cipher_list().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_cipher_list_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< HTTPChannel > HTTPClient::make_channel(bool persistent_connection)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_make_channel_196(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< HTTPChannel > HTTPClient::make_channel(bool persistent_connection)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"persistent_connection", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:makeChannel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:makeChannel", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< HTTPChannel > return_value = (local_this)->make_channel((PyObject_IsTrue(param1)!=0));
            if (return_value != (HTTPChannel *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_HTTPChannel,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPClient.makeChannel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeChannel(non-const HTTPClient this, bool persistent_connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_make_channel_196_comment =
    "C++ Interface:\n"
    "makeChannel(non-const HTTPClient this, bool persistent_connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::make_channel\n"
    "//       Access: Published\n"
    "//  Description: Returns a new HTTPChannel object that may be used\n"
    "//               for reading multiple documents using the same\n"
    "//               connection, for greater network efficiency than\n"
    "//               calling HTTPClient::get_document() repeatedly (which\n"
    "//               would force a new connection for each document).\n"
    "//\n"
    "//               Also, HTTPChannel has some additional, less common\n"
    "//               interface methods than the basic interface methods\n"
    "//               that exist on HTTPClient; if you wish to call any of\n"
    "//               these methods you must first obtain an HTTPChannel.\n"
    "//\n"
    "//               Pass true for persistent_connection to gain this\n"
    "//               network efficiency.  If, on the other hand, your\n"
    "//               intention is to use the channel to retrieve only one\n"
    "//               document, then pass false to inform the server that\n"
    "//               we will be dropping the connection after the first\n"
    "//               document.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_make_channel_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< HTTPChannel > HTTPClient::post_form(URLSpec const &url, basic_string< char > const &body)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_post_form_197(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< HTTPChannel > HTTPClient::post_form(URLSpec const &url, basic_string< char > const &body)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"url", (char *)"body", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:postForm", key_word_list, &param1, &param2_str, &param2_len))
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.postForm", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    PointerTo< HTTPChannel > return_value = (local_this)->post_form(*param1_this, basic_string<char>(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    if (return_value != (HTTPChannel *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_HTTPChannel,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.postForm() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "postForm(non-const HTTPClient this, const URLSpec url, string body)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_post_form_197_comment =
    "C++ Interface:\n"
    "postForm(non-const HTTPClient this, const URLSpec url, string body)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::post_form\n"
    "//       Access: Published\n"
    "//  Description: Posts form data to a particular URL and retrieves the\n"
    "//               response.  Returns a new HTTPChannel object whether\n"
    "//               the document is successfully read or not; you can\n"
    "//               test is_valid() and get_return_code() to determine\n"
    "//               whether the document was retrieved.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_post_form_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< HTTPChannel > HTTPClient::get_document(URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_document_198(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< HTTPChannel > HTTPClient::get_document(URLSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDocument", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getDocument", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.getDocument", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    PointerTo< HTTPChannel > return_value = (local_this)->get_document(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    if (return_value != (HTTPChannel *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_HTTPChannel,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.getDocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDocument(non-const HTTPClient this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_document_198_comment =
    "C++ Interface:\n"
    "getDocument(non-const HTTPClient this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_document\n"
    "//       Access: Published\n"
    "//  Description: Opens the named document for reading.  Returns a new\n"
    "//               HTTPChannel object whether the document is\n"
    "//               successfully read or not; you can test is_valid() and\n"
    "//               get_return_code() to determine whether the document\n"
    "//               was retrieved.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_document_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< HTTPChannel > HTTPClient::get_header(URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_header_199(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< HTTPChannel > HTTPClient::get_header(URLSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getHeader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getHeader", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "HTTPClient.getHeader", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    PointerTo< HTTPChannel > return_value = (local_this)->get_header(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    if (return_value != (HTTPChannel *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_HTTPChannel,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPClient.getHeader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeader(non-const HTTPClient this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_header_199_comment =
    "C++ Interface:\n"
    "getHeader(non-const HTTPClient this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_header\n"
    "//       Access: Published\n"
    "//  Description: Like get_document(), except only the header\n"
    "//               associated with the document is retrieved.  This may\n"
    "//               be used to test for existence of the document; it\n"
    "//               might also return the size of the document (if the\n"
    "//               server gives us this information).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_header_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > HTTPClient::base64_encode(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_base64_encode_200(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > HTTPClient::base64_encode(basic_string< char > const &s)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:base64Encode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:base64Encode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = HTTPClient::base64_encode(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "base64Encode(string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_base64_encode_200_comment =
    "C++ Interface:\n"
    "base64Encode(string s)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::base64_encode\n"
    "//       Access: Published, Static\n"
    "//  Description: Implements HTTPAuthorization::base64_encode().  This\n"
    "//               is provided here just as a convenient place to\n"
    "//               publish it for access by the scripting language; C++\n"
    "//               code should probably use HTTPAuthorization directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_base64_encode_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > HTTPClient::base64_decode(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_base64_decode_201(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > HTTPClient::base64_decode(basic_string< char > const &s)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:base64Decode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:base64Decode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = HTTPClient::base64_decode(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "base64Decode(string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_base64_decode_201_comment =
    "C++ Interface:\n"
    "base64Decode(string s)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::base64_decode\n"
    "//       Access: Published, Static\n"
    "//  Description: Implements HTTPAuthorization::base64_decode().  This\n"
    "//               is provided here just as a convenient place to\n"
    "//               publish it for access by the scripting language; C++\n"
    "//               code should probably use HTTPAuthorization directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_base64_decode_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static HTTPClient *HTTPClient::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_HTTPClient_get_global_ptr_202(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static HTTPClient *HTTPClient::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            HTTPClient *return_value = HTTPClient::get_global_ptr();
            if (return_value != (HTTPClient *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPClient,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPClient_get_global_ptr_202_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPClient::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the default global HTTPClient.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPClient_get_global_ptr_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HTTPClient::HTTPClient(void)
 * HTTPClient::HTTPClient(HTTPClient const &copy)
 *******************************************************************/
int  Dtool_Init_HTTPClient(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-HTTPClient::HTTPClient(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":HTTPClient", key_word_list))
            {
                HTTPClient *return_value = new HTTPClient();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPClient,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-HTTPClient::HTTPClient(HTTPClient const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HTTPClient", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HTTPClient", &param0));
                if(!PyErr_Occurred())
                {
                    HTTPClient *param0_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_HTTPClient, 0, "HTTPClient.HTTPClient", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        HTTPClient *return_value = new HTTPClient(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPClient,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HTTPClient() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HTTPClient()\n"
          "HTTPClient(const HTTPClient copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HTTPClient(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HTTPClient)
    {
        printf("HTTPClient ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HTTPClient * local_this = (HTTPClient *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HTTPClient)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HTTPClient(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HTTPClient)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (HTTPClient*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HTTPEntityTag 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void HTTPEntityTag::operator =(HTTPEntityTag const &copy)
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_operator_205(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPEntityTag::operator =(HTTPEntityTag const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    HTTPEntityTag *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPEntityTag,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPEntityTag.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const HTTPEntityTag this, const HTTPEntityTag copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_operator_205_comment =
    "C++ Interface:\n"
    "assign(non-const HTTPEntityTag this, const HTTPEntityTag copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_operator_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPEntityTag::is_weak(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_is_weak_206(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPEntityTag::is_weak(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isWeak", key_word_list));
        else
            (PyArg_Parse(args, ":isWeak"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPEntityTag*)local_this)->is_weak();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWeak(const HTTPEntityTag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_is_weak_206_comment =
    "C++ Interface:\n"
    "isWeak(const HTTPEntityTag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::is_weak\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the entity tag is marked as \"weak\".\n"
    "//               A consistent weak entity tag does not guarantee that\n"
    "//               its resource has not changed in any way, but it does\n"
    "//               promise that the resource has not changed in any\n"
    "//               semantically meaningful way.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_is_weak_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPEntityTag::get_tag(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_get_tag_207(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPEntityTag::get_tag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTag", key_word_list));
        else
            (PyArg_Parse(args, ":getTag"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPEntityTag*)local_this)->get_tag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTag(const HTTPEntityTag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_get_tag_207_comment =
    "C++ Interface:\n"
    "getTag(const HTTPEntityTag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::get_tag\n"
    "//       Access: Published\n"
    "//  Description: Returns the tag as a literal string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_get_tag_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPEntityTag::get_string(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_get_string_208(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPEntityTag::get_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString", key_word_list));
        else
            (PyArg_Parse(args, ":getString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPEntityTag*)local_this)->get_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString(const HTTPEntityTag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_get_string_208_comment =
    "C++ Interface:\n"
    "getString(const HTTPEntityTag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::get_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the entity tag formatted for sending to an\n"
    "//               HTTP server (the tag is quoted, with a conditional W/\n"
    "//               prefix).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_get_string_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPEntityTag::strong_equiv(HTTPEntityTag const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_strong_equiv_209(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPEntityTag::strong_equiv(HTTPEntityTag const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:strongEquiv", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:strongEquiv", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.strongEquiv", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPEntityTag*)local_this)->strong_equiv(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "strongEquiv(const HTTPEntityTag this, const HTTPEntityTag other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_strong_equiv_209_comment =
    "C++ Interface:\n"
    "strongEquiv(const HTTPEntityTag this, const HTTPEntityTag other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::strong_equiv\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the two tags have \"strong\" equivalence:\n"
    "//               they are the same tag, and both are \"strong\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_strong_equiv_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPEntityTag::weak_equiv(HTTPEntityTag const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_weak_equiv_210(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPEntityTag::weak_equiv(HTTPEntityTag const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:weakEquiv", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:weakEquiv", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.weakEquiv", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPEntityTag*)local_this)->weak_equiv(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "weakEquiv(const HTTPEntityTag this, const HTTPEntityTag other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_weak_equiv_210_comment =
    "C++ Interface:\n"
    "weakEquiv(const HTTPEntityTag this, const HTTPEntityTag other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::weak_equiv\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the two tags have \"weak\" equivalence:\n"
    "//               they are the same tag, and one or both may be \"weak\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_weak_equiv_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPEntityTag::operator ==(HTTPEntityTag const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_operator_211(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPEntityTag::operator ==(HTTPEntityTag const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPEntityTag*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const HTTPEntityTag this, const HTTPEntityTag other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_operator_211_comment =
    "C++ Interface:\n"
    "eq(const HTTPEntityTag this, const HTTPEntityTag other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::Operator ==\n"
    "//       Access: Published\n"
    "//  Description: The == operator tests object equivalence; see also\n"
    "//               strong_equiv() and weak_equiv() for the two kinds of\n"
    "//               HTTP equivalence.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_operator_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPEntityTag::operator !=(HTTPEntityTag const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_operator_212(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPEntityTag::operator !=(HTTPEntityTag const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPEntityTag*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const HTTPEntityTag this, const HTTPEntityTag other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_operator_212_comment =
    "C++ Interface:\n"
    "ne(const HTTPEntityTag this, const HTTPEntityTag other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::Operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_operator_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPEntityTag::operator <(HTTPEntityTag const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_operator_213(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HTTPEntityTag::operator <(HTTPEntityTag const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HTTPEntityTag*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const HTTPEntityTag this, const HTTPEntityTag other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_operator_213_comment =
    "C++ Interface:\n"
    "lessThan(const HTTPEntityTag this, const HTTPEntityTag other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::Operator <\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_operator_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HTTPEntityTag::compare_to(HTTPEntityTag const &other) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_compare_to_214(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int HTTPEntityTag::compare_to(HTTPEntityTag const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "HTTPEntityTag.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const HTTPEntityTag*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const HTTPEntityTag this, const HTTPEntityTag other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_compare_to_214_comment =
    "C++ Interface:\n"
    "compareTo(const HTTPEntityTag this, const HTTPEntityTag other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::compare_to\n"
    "//       Access: Published\n"
    "//  Description: Returns a number less than zero if this HTTPEntityTag\n"
    "//               sorts before the other one, greater than zero if it\n"
    "//               sorts after, or zero if they are equivalent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_compare_to_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPEntityTag::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HTTPEntityTag_output_215(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void HTTPEntityTag::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPEntityTag.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HTTPEntityTag*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const HTTPEntityTag this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPEntityTag_output_215_comment =
    "C++ Interface:\n"
    "output(const HTTPEntityTag this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPEntityTag::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPEntityTag_output_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPEntityTag::HTTPEntityTag(void)
 * inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &copy)
 * HTTPEntityTag::HTTPEntityTag(basic_string< char > const &text)
 * inline HTTPEntityTag::HTTPEntityTag(bool weak, basic_string< char > const &tag)
 *******************************************************************/
int  Dtool_Init_HTTPEntityTag(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline HTTPEntityTag::HTTPEntityTag(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":HTTPEntityTag", key_word_list))
            {
                HTTPEntityTag *return_value = new HTTPEntityTag();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPEntityTag,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HTTPEntityTag", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HTTPEntityTag", &param0));
                if(!PyErr_Occurred())
                {
                    HTTPEntityTag *param0_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_HTTPEntityTag, 0, "HTTPEntityTag.HTTPEntityTag", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        HTTPEntityTag *return_value = new HTTPEntityTag(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPEntityTag,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 HTTPEntityTag::HTTPEntityTag(basic_string< char > const &text)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"text", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:HTTPEntityTag", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:HTTPEntityTag", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    HTTPEntityTag *return_value = new HTTPEntityTag(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPEntityTag,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline HTTPEntityTag::HTTPEntityTag(bool weak, basic_string< char > const &tag)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"weak", (char *)"tag", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:HTTPEntityTag", key_word_list, &param0, &param1_str, &param1_len))
            {
                HTTPEntityTag *return_value = new HTTPEntityTag((PyObject_IsTrue(param0)!=0), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HTTPEntityTag,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HTTPEntityTag() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HTTPEntityTag()\n"
          "HTTPEntityTag(const HTTPEntityTag copy)\n"
          "HTTPEntityTag(string text)\n"
          "HTTPEntityTag(bool weak, string tag)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HTTPEntityTag(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HTTPEntityTag)
    {
        printf("HTTPEntityTag ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HTTPEntityTag * local_this = (HTTPEntityTag *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HTTPEntityTag)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HTTPEntityTag(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HTTPEntityTag)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DocumentSpec 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::operator =(DocumentSpec const &copy)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_operator_219(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DocumentSpec::operator =(DocumentSpec const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "DocumentSpec.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DocumentSpec *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DocumentSpec,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DocumentSpec.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const DocumentSpec this, const DocumentSpec copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_operator_219_comment =
    "C++ Interface:\n"
    "assign(non-const DocumentSpec this, const DocumentSpec copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_operator_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DocumentSpec::operator ==(DocumentSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_operator_220(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool DocumentSpec::operator ==(DocumentSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "DocumentSpec.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DocumentSpec*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const DocumentSpec this, const DocumentSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_operator_220_comment =
    "C++ Interface:\n"
    "eq(const DocumentSpec this, const DocumentSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_operator_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DocumentSpec::operator !=(DocumentSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_operator_221(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool DocumentSpec::operator !=(DocumentSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "DocumentSpec.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DocumentSpec*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const DocumentSpec this, const DocumentSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_operator_221_comment =
    "C++ Interface:\n"
    "ne(const DocumentSpec this, const DocumentSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_operator_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DocumentSpec::operator <(DocumentSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_operator_222(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool DocumentSpec::operator <(DocumentSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "DocumentSpec.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DocumentSpec*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const DocumentSpec this, const DocumentSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_operator_222_comment =
    "C++ Interface:\n"
    "lessThan(const DocumentSpec this, const DocumentSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::operator <\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_operator_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DocumentSpec::compare_to(DocumentSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_compare_to_223(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int DocumentSpec::compare_to(DocumentSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "DocumentSpec.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const DocumentSpec*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const DocumentSpec this, const DocumentSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_compare_to_223_comment =
    "C++ Interface:\n"
    "compareTo(const DocumentSpec this, const DocumentSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::compare_to\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_compare_to_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::set_url(URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_set_url_224(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DocumentSpec::set_url(URLSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUrl", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setUrl", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "DocumentSpec.setUrl", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_url(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DocumentSpec.setUrl() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUrl(non-const DocumentSpec this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_set_url_224_comment =
    "C++ Interface:\n"
    "setUrl(non-const DocumentSpec this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::set_url\n"
    "//       Access: Published\n"
    "//  Description: Changes the URL of the DocumentSpec without modifying\n"
    "//               its other properties.  Normally this would be a\n"
    "//               strange thing to do, because the tag and date are\n"
    "//               usually strongly associated with the URL.  To get a\n"
    "//               DocumentSpec pointing to a new URL, you would\n"
    "//               normally create a new DocumentSpec object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_set_url_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline URLSpec const &DocumentSpec::get_url(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_get_url_225(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline URLSpec const &DocumentSpec::get_url(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUrl", key_word_list));
        else
            (PyArg_Parse(args, ":getUrl"));
        if(!PyErr_Occurred())
        {
            URLSpec const *return_value = &(((const DocumentSpec*)local_this)->get_url());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUrl(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_get_url_225_comment =
    "C++ Interface:\n"
    "getUrl(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::get_url\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the URL of the DocumentSpec.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_get_url_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::set_tag(HTTPEntityTag const &tag)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_set_tag_226(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DocumentSpec::set_tag(HTTPEntityTag const &tag)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTag", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTag", &param1));
            if(!PyErr_Occurred())
            {
                HTTPEntityTag *param1_this = (HTTPEntityTag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPEntityTag, 1, "DocumentSpec.setTag", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_tag(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DocumentSpec.setTag() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTag(non-const DocumentSpec this, const HTTPEntityTag tag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_set_tag_226_comment =
    "C++ Interface:\n"
    "setTag(non-const DocumentSpec this, const HTTPEntityTag tag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::set_tag\n"
    "//       Access: Published\n"
    "//  Description: Changes the identity tag associated with the\n"
    "//               DocumentSpec.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_set_tag_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DocumentSpec::has_tag(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_has_tag_227(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DocumentSpec::has_tag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTag", key_word_list));
        else
            (PyArg_Parse(args, ":hasTag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DocumentSpec*)local_this)->has_tag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTag(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_has_tag_227_comment =
    "C++ Interface:\n"
    "hasTag(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::has_tag\n"
    "//       Access: Published\n"
    "//  Description: Returns true if an identity tag is associated with\n"
    "//               the DocumentSpec.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_has_tag_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPEntityTag const &DocumentSpec::get_tag(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_get_tag_228(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPEntityTag const &DocumentSpec::get_tag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTag", key_word_list));
        else
            (PyArg_Parse(args, ":getTag"));
        if(!PyErr_Occurred())
        {
            HTTPEntityTag const *return_value = &(((const DocumentSpec*)local_this)->get_tag());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPEntityTag,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTag(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_get_tag_228_comment =
    "C++ Interface:\n"
    "getTag(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::get_tag\n"
    "//       Access: Published\n"
    "//  Description: Returns the identity tag associated with the\n"
    "//               DocumentSpec, if there is one.  It is an error to\n"
    "//               call this if has_tag() returns false.\n"
    "//\n"
    "//               The identity tag is set by the HTTP server to\n"
    "//               uniquely refer to a particular version of a document.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_get_tag_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::clear_tag(void)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_clear_tag_229(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DocumentSpec::clear_tag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTag", key_word_list));
        else
            (PyArg_Parse(args, ":clearTag"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_tag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DocumentSpec.clearTag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTag(non-const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_clear_tag_229_comment =
    "C++ Interface:\n"
    "clearTag(non-const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::clear_tag\n"
    "//       Access: Published\n"
    "//  Description: Removes the identity tag associated with the\n"
    "//               DocumentSpec, if there is one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_clear_tag_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::set_date(HTTPDate const &date)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_set_date_230(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DocumentSpec::set_date(HTTPDate const &date)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"date", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDate", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDate", &param1));
            if(!PyErr_Occurred())
            {
                HTTPDate *param1_this = (HTTPDate *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPDate, 1, "DocumentSpec.setDate", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_date(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DocumentSpec.setDate() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDate(non-const DocumentSpec this, const HTTPDate date)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_set_date_230_comment =
    "C++ Interface:\n"
    "setDate(non-const DocumentSpec this, const HTTPDate date)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::set_date\n"
    "//       Access: Published\n"
    "//  Description: Changes the last-modified date associated with the\n"
    "//               DocumentSpec.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_set_date_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DocumentSpec::has_date(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_has_date_231(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DocumentSpec::has_date(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasDate", key_word_list));
        else
            (PyArg_Parse(args, ":hasDate"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DocumentSpec*)local_this)->has_date();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDate(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_has_date_231_comment =
    "C++ Interface:\n"
    "hasDate(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::has_date\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a last-modified date is associated\n"
    "//               with the DocumentSpec.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_has_date_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPDate const &DocumentSpec::get_date(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_get_date_232(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPDate const &DocumentSpec::get_date(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDate", key_word_list));
        else
            (PyArg_Parse(args, ":getDate"));
        if(!PyErr_Occurred())
        {
            HTTPDate const *return_value = &(((const DocumentSpec*)local_this)->get_date());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPDate,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDate(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_get_date_232_comment =
    "C++ Interface:\n"
    "getDate(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::get_date\n"
    "//       Access: Published\n"
    "//  Description: Returns the last-modified date associated with the\n"
    "//               DocumentSpec, if there is one.  It is an error to\n"
    "//               call this if has_date() returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_get_date_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::clear_date(void)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_clear_date_233(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DocumentSpec::clear_date(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDate", key_word_list));
        else
            (PyArg_Parse(args, ":clearDate"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_date();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DocumentSpec.clearDate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDate(non-const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_clear_date_233_comment =
    "C++ Interface:\n"
    "clearDate(non-const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::clear_date\n"
    "//       Access: Published\n"
    "//  Description: Removes the last-modified date associated with the\n"
    "//               DocumentSpec, if there is one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_clear_date_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_set_request_mode_235(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode)
        int param1;
        static char * key_word_list[] = {(char *)"request_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRequestMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRequestMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_request_mode((DocumentSpec::RequestMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DocumentSpec.setRequestMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRequestMode(non-const DocumentSpec this, int request_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_set_request_mode_235_comment =
    "C++ Interface:\n"
    "setRequestMode(non-const DocumentSpec this, int request_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::set_request_mode\n"
    "//       Access: Published\n"
    "//  Description: Sets the request mode of this DocumentSpec.  This is\n"
    "//               only relevant when using the DocumentSpec to generate\n"
    "//               a request (for instance, in HTTPChannel).  This\n"
    "//               specifies whether the document request will ask the\n"
    "//               server for a newer version than the indicated\n"
    "//               version, or the exact version, neither, or either.\n"
    "//\n"
    "//               The possible values are:\n"
    "//\n"
    "//                 RM_any: ignore date and tag (if specified), and\n"
    "//                 retrieve any document that matches the URL.  For a\n"
    "//                 subrange request, if the document matches the\n"
    "//                 version indicated exactly, retrieve the subrange\n"
    "//                 only; otherwise, retrieve the entire document.\n"
    "//\n"
    "//                 RM_equal: request only the precise version of the\n"
    "//                 document that matches the particular date and/or\n"
    "//                 tag exactly, if specified; fail if this version is\n"
    "//                 not available.\n"
    "//\n"
    "//                 RM_newer: request any document that is newer than\n"
    "//                 the version indicated by the particular date and/or\n"
    "//                 tag; fail if only that version (or older versions)\n"
    "//                 are available.\n"
    "//\n"
    "//                 RM_newer_or_equal: request any document that\n"
    "//                 matches the version indicated by the particular\n"
    "//                 date and/or tag, or is a newer version; fail if\n"
    "//                 only older versions are available.\n"
    "//\n"
    "//               In any of the above, you may specify either or both\n"
    "//               of the last-modified date and the identity tag,\n"
    "//               whichever is known to the client.\n"
    "//\n"
    "//               The default mode is RM_any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_set_request_mode_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_get_request_mode_236(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRequestMode", key_word_list));
        else
            (PyArg_Parse(args, ":getRequestMode"));
        if(!PyErr_Occurred())
        {
            DocumentSpec::RequestMode return_value = ((const DocumentSpec*)local_this)->get_request_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRequestMode(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_get_request_mode_236_comment =
    "C++ Interface:\n"
    "getRequestMode(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::get_request_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the request mode of this DocumentSpec.  See\n"
    "//               set_request_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_get_request_mode_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_set_cache_control_238(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control)
        int param1;
        static char * key_word_list[] = {(char *)"cache_control", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCacheControl", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCacheControl", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cache_control((DocumentSpec::CacheControl)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DocumentSpec.setCacheControl() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCacheControl(non-const DocumentSpec this, int cache_control)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_set_cache_control_238_comment =
    "C++ Interface:\n"
    "setCacheControl(non-const DocumentSpec this, int cache_control)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::set_cache_control\n"
    "//       Access: Published\n"
    "//  Description: Specifies what kind of cached value is acceptable for\n"
    "//               this document.  Warning: some HTTP proxies may not\n"
    "//               respect this setting and may return a cached result\n"
    "//               anyway.\n"
    "//\n"
    "//                 CC_allow_cache: the normal HTTP behavior; the\n"
    "//                 server may return a cached value if it believes it\n"
    "//                 is valid.\n"
    "//\n"
    "//                 CC_revalidate: a proxy is forced to contact the\n"
    "//                 origin server and verify that is cached value is in\n"
    "//                 fact still valid before it returns it.\n"
    "//\n"
    "//                 CC_no_cache: a proxy must not return its cached\n"
    "//                 value at all, but is forced to go all the way back\n"
    "//                 to the origin server for the official document.\n"
    "//\n"
    "//               The default mode is CC_allow_cache.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_set_cache_control_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_get_cache_control_239(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheControl", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheControl"));
        if(!PyErr_Occurred())
        {
            DocumentSpec::CacheControl return_value = ((const DocumentSpec*)local_this)->get_cache_control();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheControl(const DocumentSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_get_cache_control_239_comment =
    "C++ Interface:\n"
    "getCacheControl(const DocumentSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::get_cache_control\n"
    "//       Access: Published\n"
    "//  Description: Returns the request mode of this DocumentSpec.  See\n"
    "//               set_cache_control().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_get_cache_control_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DocumentSpec::input(istream &in)
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_input_240(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool DocumentSpec::input(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:input", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:input", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "DocumentSpec.input", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->input(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DocumentSpec.input() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "input(non-const DocumentSpec this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_input_240_comment =
    "C++ Interface:\n"
    "input(non-const DocumentSpec this, non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::input\n"
    "//       Access: Published\n"
    "//  Description: Can be used to read in the DocumentSpec from a stream\n"
    "//               generated either by output() or write().  Returns\n"
    "//               true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_input_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DocumentSpec::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_output_241(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DocumentSpec::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DocumentSpec.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DocumentSpec*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DocumentSpec this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_output_241_comment =
    "C++ Interface:\n"
    "output(const DocumentSpec this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_output_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DocumentSpec::write(ostream &out, int indent_level) const
 * void DocumentSpec::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DocumentSpec_write_242(PyObject *self, PyObject *args,PyObject *kwds) {
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DocumentSpec::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DocumentSpec.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DocumentSpec*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DocumentSpec::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DocumentSpec.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DocumentSpec*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DocumentSpec this, non-const Ostream out)\n"
          "write(const DocumentSpec this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DocumentSpec_write_242_comment =
    "C++ Interface:\n"
    "write(const DocumentSpec this, non-const Ostream out)\n"
    "write(const DocumentSpec this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DocumentSpec::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DocumentSpec_write_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DocumentSpec::DocumentSpec(void)
 * inline DocumentSpec::DocumentSpec(DocumentSpec const &copy)
 * inline DocumentSpec::DocumentSpec(URLSpec const &url)
 * inline DocumentSpec::DocumentSpec(basic_string< char > const &url)
 *******************************************************************/
int  Dtool_Init_DocumentSpec(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline DocumentSpec::DocumentSpec(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DocumentSpec", key_word_list))
            {
                DocumentSpec *return_value = new DocumentSpec();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DocumentSpec,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline DocumentSpec::DocumentSpec(DocumentSpec const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DocumentSpec", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DocumentSpec", &param0));
                if(!PyErr_Occurred())
                {
                    DocumentSpec *param0_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DocumentSpec, 0, "DocumentSpec.DocumentSpec", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DocumentSpec *return_value = new DocumentSpec(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DocumentSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline DocumentSpec::DocumentSpec(URLSpec const &url)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"url", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DocumentSpec", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DocumentSpec", &param0));
                if(!PyErr_Occurred())
                {
                    URLSpec *param0_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_URLSpec, 0, "DocumentSpec.DocumentSpec", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        DocumentSpec *return_value = new DocumentSpec(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DocumentSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline DocumentSpec::DocumentSpec(basic_string< char > const &url)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"url", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DocumentSpec", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DocumentSpec", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DocumentSpec *return_value = new DocumentSpec(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DocumentSpec,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DocumentSpec() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DocumentSpec()\n"
          "DocumentSpec(const DocumentSpec copy)\n"
          "DocumentSpec(const URLSpec url)\n"
          "DocumentSpec(string url)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DocumentSpec(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DocumentSpec)
    {
        printf("DocumentSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DocumentSpec * local_this = (DocumentSpec *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DocumentSpec)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DocumentSpec(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DocumentSpec)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HTTPChannel 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline HTTPClient *HTTPChannel::get_client(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_client_247(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPClient *HTTPChannel::get_client(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClient", key_word_list));
        else
            (PyArg_Parse(args, ":getClient"));
        if(!PyErr_Occurred())
        {
            HTTPClient *return_value = ((const HTTPChannel*)local_this)->get_client();
            if (return_value != (HTTPClient *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPClient,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClient(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_client_247_comment =
    "C++ Interface:\n"
    "getClient(const HTTPChannel this)\n"
    "\n"
    "// Filename: httpChannel.I\n"
    "// Created by:  drose (24Sep02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_client\n"
    "//       Access: Published\n"
    "//  Description: Returns the HTTPClient object that owns this channel.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_client_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_is_valid_248(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_is_valid_248_comment =
    "C++ Interface:\n"
    "isValid(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the last-requested document was\n"
    "//               successfully retrieved and is ready to be read, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_is_valid_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::is_connection_ready(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_is_connection_ready_249(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::is_connection_ready(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isConnectionReady", key_word_list));
        else
            (PyArg_Parse(args, ":isConnectionReady"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->is_connection_ready();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isConnectionReady(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_is_connection_ready_249_comment =
    "C++ Interface:\n"
    "isConnectionReady(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::is_connection_ready\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a connection has been established to\n"
    "//               the named server in a previous call to connect_to()\n"
    "//               or begin_connect_to(), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_is_connection_ready_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline URLSpec const &HTTPChannel::get_url(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_url_250(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline URLSpec const &HTTPChannel::get_url(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUrl", key_word_list));
        else
            (PyArg_Parse(args, ":getUrl"));
        if(!PyErr_Occurred())
        {
            URLSpec const *return_value = &(((const HTTPChannel*)local_this)->get_url());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUrl(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_url_250_comment =
    "C++ Interface:\n"
    "getUrl(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_url\n"
    "//       Access: Published\n"
    "//  Description: Returns the URL that was used to retrieve the\n"
    "//               most recent document: whatever URL was last passed to\n"
    "//               get_document() or get_header().  If a redirect has\n"
    "//               transparently occurred, this will return the new,\n"
    "//               redirected URL (the actual URL at which the document\n"
    "//               was located).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_url_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DocumentSpec const &HTTPChannel::get_document_spec(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_document_spec_251(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DocumentSpec const &HTTPChannel::get_document_spec(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDocumentSpec", key_word_list));
        else
            (PyArg_Parse(args, ":getDocumentSpec"));
        if(!PyErr_Occurred())
        {
            DocumentSpec const *return_value = &(((const HTTPChannel*)local_this)->get_document_spec());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DocumentSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDocumentSpec(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_document_spec_251_comment =
    "C++ Interface:\n"
    "getDocumentSpec(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_document_spec\n"
    "//       Access: Published\n"
    "//  Description: Returns the DocumentSpec associated with the most\n"
    "//               recent document.  This includes its actual URL\n"
    "//               (following redirects) along with the identity tag and\n"
    "//               last-modified date, if supplied by the server.\n"
    "//\n"
    "//               This structure may be saved and used to retrieve the\n"
    "//               same version of the document later, or to\n"
    "//               conditionally retrieve a newer version if it is\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_document_spec_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HTTPEnum::HTTPVersion HTTPChannel::get_http_version(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_http_version_252(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPEnum::HTTPVersion HTTPChannel::get_http_version(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHttpVersion", key_word_list));
        else
            (PyArg_Parse(args, ":getHttpVersion"));
        if(!PyErr_Occurred())
        {
            HTTPEnum::HTTPVersion return_value = ((const HTTPChannel*)local_this)->get_http_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHttpVersion(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_http_version_252_comment =
    "C++ Interface:\n"
    "getHttpVersion(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_http_version\n"
    "//       Access: Published\n"
    "//  Description: Returns the HTTP version number returned by the\n"
    "//               server, as one of the HTTPClient enumerated types,\n"
    "//               e.g. HTTPClient::HV_11.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_http_version_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPChannel::get_http_version_string(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_http_version_string_253(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPChannel::get_http_version_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHttpVersionString", key_word_list));
        else
            (PyArg_Parse(args, ":getHttpVersionString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPChannel*)local_this)->get_http_version_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHttpVersionString(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_http_version_string_253_comment =
    "C++ Interface:\n"
    "getHttpVersionString(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_http_version_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the HTTP version number returned by the\n"
    "//               server, formatted as a string, e.g. \"HTTP/1.1\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_http_version_string_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HTTPChannel::get_status_code(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_status_code_254(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int HTTPChannel::get_status_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStatusCode", key_word_list));
        else
            (PyArg_Parse(args, ":getStatusCode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const HTTPChannel*)local_this)->get_status_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStatusCode(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_status_code_254_comment =
    "C++ Interface:\n"
    "getStatusCode(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_status_code\n"
    "//       Access: Published\n"
    "//  Description: Returns the HTML return code from the document\n"
    "//               retrieval request.  This will be in the 200 range if\n"
    "//               the document is successfully retrieved, or some other\n"
    "//               value in the case of an error.\n"
    "//\n"
    "//               Some proxy errors during an https-over-proxy request\n"
    "//               would return the same status code as a different\n"
    "//               error that occurred on the host server.  To\n"
    "//               differentiate these cases, status codes that are\n"
    "//               returned by the proxy during the CONNECT phase\n"
    "//               (except code 407) are incremented by 1000.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_status_code_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPChannel::get_status_string(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_status_string_255(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPChannel::get_status_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStatusString", key_word_list));
        else
            (PyArg_Parse(args, ":getStatusString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPChannel*)local_this)->get_status_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStatusString(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_status_string_255_comment =
    "C++ Interface:\n"
    "getStatusString(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_status_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the string as returned by the server\n"
    "//               describing the status code for humans.  This may or\n"
    "//               may not be meaningful.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_status_string_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPChannel::get_www_realm(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_www_realm_256(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPChannel::get_www_realm(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWwwRealm", key_word_list));
        else
            (PyArg_Parse(args, ":getWwwRealm"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPChannel*)local_this)->get_www_realm();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWwwRealm(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_www_realm_256_comment =
    "C++ Interface:\n"
    "getWwwRealm(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_www_realm\n"
    "//       Access: Published\n"
    "//  Description: If the document failed to connect because of a 401\n"
    "//               (Authorization required), this method will return the\n"
    "//               \"realm\" returned by the server in which the requested\n"
    "//               document must be authenticated.  This string may be\n"
    "//               presented to the user to request an associated\n"
    "//               username and password (which then should be stored in\n"
    "//               HTTPClient::set_username()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_www_realm_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &HTTPChannel::get_proxy_realm(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_proxy_realm_257(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &HTTPChannel::get_proxy_realm(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProxyRealm", key_word_list));
        else
            (PyArg_Parse(args, ":getProxyRealm"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const HTTPChannel*)local_this)->get_proxy_realm();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProxyRealm(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_proxy_realm_257_comment =
    "C++ Interface:\n"
    "getProxyRealm(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_proxy_realm\n"
    "//       Access: Published\n"
    "//  Description: If the document failed to connect because of a 407\n"
    "//               (Proxy authorization required), this method will\n"
    "//               return the \"realm\" returned by the proxy.  This\n"
    "//               string may be presented to the user to request an\n"
    "//               associated username and password (which then should\n"
    "//               be stored in HTTPClient::set_username()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_proxy_realm_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline URLSpec const &HTTPChannel::get_redirect(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_redirect_258(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline URLSpec const &HTTPChannel::get_redirect(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRedirect", key_word_list));
        else
            (PyArg_Parse(args, ":getRedirect"));
        if(!PyErr_Occurred())
        {
            URLSpec const *return_value = &(((const HTTPChannel*)local_this)->get_redirect());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRedirect(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_redirect_258_comment =
    "C++ Interface:\n"
    "getRedirect(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_redirect\n"
    "//       Access: Published\n"
    "//  Description: If the document failed with a redirect code (300\n"
    "//               series), this will generally contain the new URL the\n"
    "//               server wants us to try.  In many cases, the client\n"
    "//               will automatically follow redirects; if these are\n"
    "//               succesful the client will return a successful code\n"
    "//               and get_redirect() will return empty, but get_url()\n"
    "//               will return the new, redirected URL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_redirect_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HTTPChannel::get_header_value(basic_string< char > const &key) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_header_value_259(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HTTPChannel::get_header_value(basic_string< char > const &key) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"key", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getHeaderValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getHeaderValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HTTPChannel*)local_this)->get_header_value(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeaderValue(const HTTPChannel this, string key)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_header_value_259_comment =
    "C++ Interface:\n"
    "getHeaderValue(const HTTPChannel this, string key)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_header_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the HTML header value associated with the\n"
    "//               indicated key, or empty string if the key was not\n"
    "//               defined in the message returned by the server.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_header_value_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HTTPChannel::get_num_redirect_steps(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_num_redirect_steps_260(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int HTTPChannel::get_num_redirect_steps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumRedirectSteps", key_word_list));
        else
            (PyArg_Parse(args, ":getNumRedirectSteps"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const HTTPChannel*)local_this)->get_num_redirect_steps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumRedirectSteps(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_num_redirect_steps_260_comment =
    "C++ Interface:\n"
    "getNumRedirectSteps(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_num_redirect_steps\n"
    "//       Access: Published\n"
    "//  Description: If the document automatically followed one or more\n"
    "//               redirects, this will return the number of redirects\n"
    "//               that were automatically followed.  Use\n"
    "//               get_redirect_step() to retrieve each URL in\n"
    "//               sequence.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_num_redirect_steps_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline URLSpec const &HTTPChannel::get_redirect_step(int n) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_redirect_step_261(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline URLSpec const &HTTPChannel::get_redirect_step(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getRedirectStep", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getRedirectStep", &param1));
        if(!PyErr_Occurred())
        {
            URLSpec const *return_value = &(((const HTTPChannel*)local_this)->get_redirect_step((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRedirectStep(const HTTPChannel this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_redirect_step_261_comment =
    "C++ Interface:\n"
    "getRedirectStep(const HTTPChannel this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_redirect_step\n"
    "//       Access: Published\n"
    "//  Description: Use in conjunction with get_num_redirect_steps() to\n"
    "//               extract the chain of URL's that the channel was\n"
    "//               automatically redirected through to arrive at the\n"
    "//               final document.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_redirect_step_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_persistent_connection(bool persistent_connection)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_persistent_connection_262(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_persistent_connection(bool persistent_connection)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"persistent_connection", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPersistentConnection", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPersistentConnection", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_persistent_connection((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setPersistentConnection() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPersistentConnection(non-const HTTPChannel this, bool persistent_connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_persistent_connection_262_comment =
    "C++ Interface:\n"
    "setPersistentConnection(non-const HTTPChannel this, bool persistent_connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_persistent_connection\n"
    "//       Access: Published\n"
    "//  Description: Indicates whether the HTTPChannel should try to keep\n"
    "//               the connection to the server open and reuse that\n"
    "//               connection for multiple documents, or whether it\n"
    "//               should close the connection and open a new one for\n"
    "//               each request.  Set this true to keep the connections\n"
    "//               around when possible, false to recycle them.\n"
    "//\n"
    "//               It makes most sense to set this false when the\n"
    "//               HTTPChannel will be used only once to retrieve a\n"
    "//               single document, true when you will be using the same\n"
    "//               HTTPChannel object to retrieve multiple documents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_persistent_connection_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_persistent_connection(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_persistent_connection_263(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::get_persistent_connection(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPersistentConnection", key_word_list));
        else
            (PyArg_Parse(args, ":getPersistentConnection"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->get_persistent_connection();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPersistentConnection(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_persistent_connection_263_comment =
    "C++ Interface:\n"
    "getPersistentConnection(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_persistent_connection\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the HTTPChannel should try to keep\n"
    "//               the connection to the server open and reuse that\n"
    "//               connection for multiple documents, or whether it\n"
    "//               should close the connection and open a new one for\n"
    "//               each request.  See set_persistent_connection().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_persistent_connection_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPChannel::will_close_connection(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_will_close_connection_264(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool HTTPChannel::will_close_connection(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":willCloseConnection", key_word_list));
        else
            (PyArg_Parse(args, ":willCloseConnection"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->will_close_connection();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "willCloseConnection(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_will_close_connection_264_comment =
    "C++ Interface:\n"
    "willCloseConnection(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::will_close_connection\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the server has indicated it will\n"
    "//               close the connection after this document has been\n"
    "//               read, or false if it will remain open (and future\n"
    "//               documents may be requested on the same connection).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_will_close_connection_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_allow_proxy(bool allow_proxy)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_allow_proxy_265(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_allow_proxy(bool allow_proxy)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"allow_proxy", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAllowProxy", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAllowProxy", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_allow_proxy((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setAllowProxy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAllowProxy(non-const HTTPChannel this, bool allow_proxy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_allow_proxy_265_comment =
    "C++ Interface:\n"
    "setAllowProxy(non-const HTTPChannel this, bool allow_proxy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_allow_proxy\n"
    "//       Access: Published\n"
    "//  Description: If this is true (the normal case), the HTTPClient\n"
    "//               will be consulted for information about the proxy to\n"
    "//               be used for each connection via this HTTPChannel.  If\n"
    "//               this has been set to false by the user, then all\n"
    "//               connections will be made directly, regardless of the\n"
    "//               proxy settings indicated on the HTTPClient.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_allow_proxy_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_allow_proxy(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_allow_proxy_266(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::get_allow_proxy(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAllowProxy", key_word_list));
        else
            (PyArg_Parse(args, ":getAllowProxy"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->get_allow_proxy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAllowProxy(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_allow_proxy_266_comment =
    "C++ Interface:\n"
    "getAllowProxy(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_allow_proxy\n"
    "//       Access: Published\n"
    "//  Description: If this is true (the normal case), the HTTPClient\n"
    "//               will be consulted for information about the proxy to\n"
    "//               be used for each connection via this HTTPChannel.  If\n"
    "//               this has been set to false by the user, then all\n"
    "//               connections will be made directly, regardless of the\n"
    "//               proxy settings indicated on the HTTPClient.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_allow_proxy_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_proxy_tunnel(bool proxy_tunnel)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_proxy_tunnel_267(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_proxy_tunnel(bool proxy_tunnel)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"proxy_tunnel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setProxyTunnel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setProxyTunnel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_proxy_tunnel((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setProxyTunnel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setProxyTunnel(non-const HTTPChannel this, bool proxy_tunnel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_proxy_tunnel_267_comment =
    "C++ Interface:\n"
    "setProxyTunnel(non-const HTTPChannel this, bool proxy_tunnel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_proxy_tunnel\n"
    "//       Access: Published\n"
    "//  Description: Normally, a proxy is itself asked for ordinary URL's,\n"
    "//               and the proxy decides whether to hand the client a\n"
    "//               cached version of the document or to contact the\n"
    "//               server for a fresh version.  The proxy may also\n"
    "//               modify the headers and transfer encoding on the way.\n"
    "//\n"
    "//               If this is set to true, then instead of asking for\n"
    "//               URL's from the proxy, we will ask the proxy to open a\n"
    "//               connection to the server (for instance, on port 80);\n"
    "//               if the proxy honors this request, then we contact the\n"
    "//               server directly through this connection to retrieve\n"
    "//               the document.  If the proxy does not honor the\n"
    "//               connect request, then the retrieve operation fails.\n"
    "//\n"
    "//               SSL connections (e.g. https), and connections through\n"
    "//               a Socks proxy, are always tunneled, regardless of the\n"
    "//               setting of this flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_proxy_tunnel_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_proxy_tunnel(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_proxy_tunnel_268(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::get_proxy_tunnel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProxyTunnel", key_word_list));
        else
            (PyArg_Parse(args, ":getProxyTunnel"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->get_proxy_tunnel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProxyTunnel(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_proxy_tunnel_268_comment =
    "C++ Interface:\n"
    "getProxyTunnel(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_proxy_tunnel\n"
    "//       Access: Published\n"
    "//  Description: Returns true if connections always tunnel through a\n"
    "//               proxy, or false (the normal case) if we allow the\n"
    "//               proxy to serve up documents.  See set_proxy_tunnel().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_proxy_tunnel_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_connect_timeout(double timeout_seconds)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_connect_timeout_269(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_connect_timeout(double timeout_seconds)
        double param1;
        static char * key_word_list[] = {(char *)"timeout_seconds", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setConnectTimeout", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setConnectTimeout", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_connect_timeout((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setConnectTimeout() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setConnectTimeout(non-const HTTPChannel this, float timeout_seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_connect_timeout_269_comment =
    "C++ Interface:\n"
    "setConnectTimeout(non-const HTTPChannel this, float timeout_seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_connect_timeout\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum length of time, in seconds, that the\n"
    "//               channel will wait before giving up on establishing a\n"
    "//               TCP connection.\n"
    "//\n"
    "//               At present, this is used only for the nonblocking\n"
    "//               interfaces (e.g. begin_get_document(),\n"
    "//               begin_connect_to()), but it is used whether\n"
    "//               set_blocking_connect() is true or false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_connect_timeout_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double HTTPChannel::get_connect_timeout(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_connect_timeout_270(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double HTTPChannel::get_connect_timeout(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getConnectTimeout", key_word_list));
        else
            (PyArg_Parse(args, ":getConnectTimeout"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const HTTPChannel*)local_this)->get_connect_timeout();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConnectTimeout(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_connect_timeout_270_comment =
    "C++ Interface:\n"
    "getConnectTimeout(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_connect_timeout\n"
    "//       Access: Published\n"
    "//  Description: Returns the length of time, in seconds, to wait for a\n"
    "//               new nonblocking socket to connect.  See\n"
    "//               set_connect_timeout().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_connect_timeout_270_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_blocking_connect(bool blocking_connect)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_blocking_connect_271(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_blocking_connect(bool blocking_connect)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"blocking_connect", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBlockingConnect", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setBlockingConnect", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_blocking_connect((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setBlockingConnect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlockingConnect(non-const HTTPChannel this, bool blocking_connect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_blocking_connect_271_comment =
    "C++ Interface:\n"
    "setBlockingConnect(non-const HTTPChannel this, bool blocking_connect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_blocking_connect\n"
    "//       Access: Published\n"
    "//  Description: If this flag is true, a socket connect will block\n"
    "//               even for nonblocking I/O calls like\n"
    "//               begin_get_document(), begin_connect_to(), etc.  If\n"
    "//               false, a socket connect will not block for\n"
    "//               nonblocking I/O calls, but will block for blocking\n"
    "//               I/O calls (get_document(), connect_to(), etc.).\n"
    "//\n"
    "//               Setting this true is useful when you want to use\n"
    "//               non-blocking I/O once you have established the\n"
    "//               connection, but you don't want to bother with polling\n"
    "//               for the initial connection.  It's also useful when\n"
    "//               you don't particularly care about non-blocking I/O,\n"
    "//               but you need to respect timeouts like connect_timeout\n"
    "//               and http_timeout.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_blocking_connect_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_blocking_connect(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_blocking_connect_272(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::get_blocking_connect(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlockingConnect", key_word_list));
        else
            (PyArg_Parse(args, ":getBlockingConnect"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->get_blocking_connect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockingConnect(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_blocking_connect_272_comment =
    "C++ Interface:\n"
    "getBlockingConnect(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_blocking_connect\n"
    "//       Access: Published\n"
    "//  Description: If this flag is true, a socket connect will block\n"
    "//               even for nonblocking I/O calls like\n"
    "//               begin_get_document(), begin_connect_to(), etc.  If\n"
    "//               false, a socket connect will not block for\n"
    "//               nonblocking I/O calls, but will block for blocking\n"
    "//               I/O calls (get_document(), connect_to(), etc.).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_blocking_connect_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_http_timeout(double timeout_seconds)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_http_timeout_273(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_http_timeout(double timeout_seconds)
        double param1;
        static char * key_word_list[] = {(char *)"timeout_seconds", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHttpTimeout", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHttpTimeout", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_http_timeout((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setHttpTimeout() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHttpTimeout(non-const HTTPChannel this, float timeout_seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_http_timeout_273_comment =
    "C++ Interface:\n"
    "setHttpTimeout(non-const HTTPChannel this, float timeout_seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_http_timeout\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum length of time, in seconds, that the\n"
    "//               channel will wait for the HTTP server to finish\n"
    "//               sending its response to our request.\n"
    "//\n"
    "//               The timer starts counting after the TCP connection\n"
    "//               has been established (see set_connect_timeout(),\n"
    "//               above) and the request has been sent.\n"
    "//\n"
    "//               At present, this is used only for the nonblocking\n"
    "//               interfaces (e.g. begin_get_document(),\n"
    "//               begin_connect_to()), but it is used whether\n"
    "//               set_blocking_connect() is true or false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_http_timeout_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double HTTPChannel::get_http_timeout(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_http_timeout_274(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double HTTPChannel::get_http_timeout(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHttpTimeout", key_word_list));
        else
            (PyArg_Parse(args, ":getHttpTimeout"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const HTTPChannel*)local_this)->get_http_timeout();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHttpTimeout(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_http_timeout_274_comment =
    "C++ Interface:\n"
    "getHttpTimeout(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_http_timeout\n"
    "//       Access: Published\n"
    "//  Description: Returns the length of time, in seconds, to wait for \n"
    "//               the HTTP server to respond to our request.  See\n"
    "//               set_http_timeout().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_http_timeout_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_skip_body_size(unsigned int skip_body_size)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_skip_body_size_275(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_skip_body_size(unsigned int skip_body_size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"skip_body_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSkipBodySize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSkipBodySize", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_skip_body_size(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setSkipBodySize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSkipBodySize(non-const HTTPChannel this, unsigned int skip_body_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_skip_body_size_275_comment =
    "C++ Interface:\n"
    "setSkipBodySize(non-const HTTPChannel this, unsigned int skip_body_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_skip_body_size\n"
    "//       Access: Published\n"
    "//  Description: Specifies the maximum number of bytes in a received\n"
    "//               (but unwanted) body that will be skipped past, in\n"
    "//               order to reset to a new request.\n"
    "//\n"
    "//               That is, if this HTTPChannel requests a file via\n"
    "//               get_document(), but does not call download_to_ram(),\n"
    "//               download_to_file(), or open_read_body(), and instead\n"
    "//               immediately requests a new file, then the HTTPChannel\n"
    "//               has a choice whether to skip past the unwanted\n"
    "//               document, or to close the connection and open a new\n"
    "//               one.  If the number of bytes to skip is more than\n"
    "//               this threshold, the connection will be closed;\n"
    "//               otherwise, the data will simply be read and\n"
    "//               discarded.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_skip_body_size_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_skip_body_size(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_skip_body_size_276(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_skip_body_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSkipBodySize", key_word_list));
        else
            (PyArg_Parse(args, ":getSkipBodySize"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_skip_body_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSkipBodySize(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_skip_body_size_276_comment =
    "C++ Interface:\n"
    "getSkipBodySize(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_skip_body_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of bytes in a received\n"
    "//               (but unwanted) body that will be skipped past, in\n"
    "//               order to reset to a new request.  See\n"
    "//               set_skip_body_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_skip_body_size_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_idle_timeout(double idle_timeout)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_idle_timeout_277(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_idle_timeout(double idle_timeout)
        double param1;
        static char * key_word_list[] = {(char *)"idle_timeout", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setIdleTimeout", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setIdleTimeout", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_idle_timeout((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setIdleTimeout() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIdleTimeout(non-const HTTPChannel this, float idle_timeout)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_idle_timeout_277_comment =
    "C++ Interface:\n"
    "setIdleTimeout(non-const HTTPChannel this, float idle_timeout)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_idle_timeout\n"
    "//       Access: Published\n"
    "//  Description: Specifies the amount of time, in seconds, in which a\n"
    "//               previously-established connection is allowed to\n"
    "//               remain open and unused.  If a previous connection has\n"
    "//               remained unused for at least this number of seconds,\n"
    "//               it will be closed and a new connection will be\n"
    "//               opened; otherwise, the same connection will be reused\n"
    "//               for the next request (for this particular\n"
    "//               HTTPChannel).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_idle_timeout_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double HTTPChannel::get_idle_timeout(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_idle_timeout_278(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double HTTPChannel::get_idle_timeout(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIdleTimeout", key_word_list));
        else
            (PyArg_Parse(args, ":getIdleTimeout"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const HTTPChannel*)local_this)->get_idle_timeout();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIdleTimeout(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_idle_timeout_278_comment =
    "C++ Interface:\n"
    "getIdleTimeout(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_idle_timeout\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time, in seconds, in which an\n"
    "//               previously-established connection is allowed to\n"
    "//               remain open and unused.  See set_idle_timeout().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_idle_timeout_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_download_throttle(bool download_throttle)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_download_throttle_279(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_download_throttle(bool download_throttle)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"download_throttle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDownloadThrottle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setDownloadThrottle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_download_throttle((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setDownloadThrottle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDownloadThrottle(non-const HTTPChannel this, bool download_throttle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_download_throttle_279_comment =
    "C++ Interface:\n"
    "setDownloadThrottle(non-const HTTPChannel this, bool download_throttle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_download_throttle\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether nonblocking downloads (via\n"
    "//               download_to_file() or download_to_ram()) will be\n"
    "//               limited so as not to use all available bandwidth.\n"
    "//\n"
    "//               If this is true, when a download has been started on\n"
    "//               this channel it will be invoked no more frequently\n"
    "//               than get_max_updates_per_second(), and the total\n"
    "//               bandwidth used by the download will be no more than\n"
    "//               get_max_bytes_per_second().  If this is false,\n"
    "//               downloads will proceed as fast as the server can send\n"
    "//               the data.\n"
    "//\n"
    "//               This only has effect on the nonblocking I/O methods\n"
    "//               like begin_get_document(), etc.  The blocking methods\n"
    "//               like get_document() always use as much CPU and\n"
    "//               bandwidth as they can get.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_download_throttle_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_download_throttle(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_download_throttle_280(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::get_download_throttle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDownloadThrottle", key_word_list));
        else
            (PyArg_Parse(args, ":getDownloadThrottle"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->get_download_throttle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDownloadThrottle(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_download_throttle_280_comment =
    "C++ Interface:\n"
    "getDownloadThrottle(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_download_throttle\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the nonblocking downloads will be\n"
    "//               bandwidth-limited.  See set_download_throttle().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_download_throttle_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_max_bytes_per_second(double max_bytes_per_second)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_max_bytes_per_second_281(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_max_bytes_per_second(double max_bytes_per_second)
        double param1;
        static char * key_word_list[] = {(char *)"max_bytes_per_second", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxBytesPerSecond", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxBytesPerSecond", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_bytes_per_second((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setMaxBytesPerSecond() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxBytesPerSecond(non-const HTTPChannel this, float max_bytes_per_second)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_max_bytes_per_second_281_comment =
    "C++ Interface:\n"
    "setMaxBytesPerSecond(non-const HTTPChannel this, float max_bytes_per_second)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_max_bytes_per_second\n"
    "//       Access: Published\n"
    "//  Description: When bandwidth throttling is in effect (see\n"
    "//               set_download_throttle()), this specifies the maximum\n"
    "//               number of bytes per second that may be consumed by\n"
    "//               this channel.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_max_bytes_per_second_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double HTTPChannel::get_max_bytes_per_second(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_max_bytes_per_second_282(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double HTTPChannel::get_max_bytes_per_second(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxBytesPerSecond", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxBytesPerSecond"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const HTTPChannel*)local_this)->get_max_bytes_per_second();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxBytesPerSecond(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_max_bytes_per_second_282_comment =
    "C++ Interface:\n"
    "getMaxBytesPerSecond(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_max_bytes_per_second\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of bytes per second that\n"
    "//               may be consumed by this channel when\n"
    "//               get_download_throttle() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_max_bytes_per_second_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_max_updates_per_second(double max_updates_per_second)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_max_updates_per_second_283(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_max_updates_per_second(double max_updates_per_second)
        double param1;
        static char * key_word_list[] = {(char *)"max_updates_per_second", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxUpdatesPerSecond", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxUpdatesPerSecond", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_updates_per_second((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setMaxUpdatesPerSecond() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxUpdatesPerSecond(non-const HTTPChannel this, float max_updates_per_second)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_max_updates_per_second_283_comment =
    "C++ Interface:\n"
    "setMaxUpdatesPerSecond(non-const HTTPChannel this, float max_updates_per_second)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_max_updates_per_second\n"
    "//       Access: Published\n"
    "//  Description: When bandwidth throttling is in effect (see\n"
    "//               set_download_throttle()), this specifies the maximum\n"
    "//               number of times per second that run() will attempt to\n"
    "//               do any downloading at all.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_max_updates_per_second_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double HTTPChannel::get_max_updates_per_second(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_max_updates_per_second_284(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double HTTPChannel::get_max_updates_per_second(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxUpdatesPerSecond", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxUpdatesPerSecond"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const HTTPChannel*)local_this)->get_max_updates_per_second();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxUpdatesPerSecond(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_max_updates_per_second_284_comment =
    "C++ Interface:\n"
    "getMaxUpdatesPerSecond(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_max_updates_per_second\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum number of times per second that\n"
    "//               run() will do anything at all, when\n"
    "//               get_download_throttle() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_max_updates_per_second_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::set_expected_file_size(unsigned int file_size)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_set_expected_file_size_285(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::set_expected_file_size(unsigned int file_size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"file_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setExpectedFileSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setExpectedFileSize", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_expected_file_size(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.setExpectedFileSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExpectedFileSize(non-const HTTPChannel this, unsigned int file_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_set_expected_file_size_285_comment =
    "C++ Interface:\n"
    "setExpectedFileSize(non-const HTTPChannel this, unsigned int file_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::set_expected_file_size\n"
    "//       Access: Published\n"
    "//  Description: This may be called immediately after a call to\n"
    "//               get_document() or some related function to specify\n"
    "//               the expected size of the document we are retrieving,\n"
    "//               if we happen to know.  This is used as the return\n"
    "//               value to get_file_size() only in the case that the\n"
    "//               server does not tell us the actual file size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_set_expected_file_size_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int HTTPChannel::get_file_size(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_file_size_286(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int HTTPChannel::get_file_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFileSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const HTTPChannel*)local_this)->get_file_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileSize(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_file_size_286_comment =
    "C++ Interface:\n"
    "getFileSize(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_file_size\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the size of the file, if it is known.\n"
    "//               Returns the value set by set_expected_file_size() if\n"
    "//               the file size is not known, or 0 if this value was\n"
    "//               not set.\n"
    "//\n"
    "//               If the file is dynamically generated, the size may\n"
    "//               not be available until a read has started\n"
    "//               (e.g. open_read_body() has been called); and even\n"
    "//               then it may increase as more of the file is read due\n"
    "//               to the nature of HTTP/1.1 requests which can change\n"
    "//               their minds midstream about how much data they're\n"
    "//               sending you.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_file_size_286_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::is_file_size_known(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_is_file_size_known_287(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::is_file_size_known(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isFileSizeKnown", key_word_list));
        else
            (PyArg_Parse(args, ":isFileSizeKnown"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->is_file_size_known();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFileSizeKnown(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_is_file_size_known_287_comment =
    "C++ Interface:\n"
    "isFileSizeKnown(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::is_file_size_known\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the size of the file we are currently\n"
    "//               retrieving was told us by the server and thus is\n"
    "//               reliably known, or false if the size reported by\n"
    "//               get_file_size() represents an educated guess\n"
    "//               (possibly as set by set_expected_file_size(), or as\n"
    "//               inferred from a chunked transfer encoding in\n"
    "//               progress).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_is_file_size_known_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_first_byte_requested(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_first_byte_requested_288(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_first_byte_requested(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFirstByteRequested", key_word_list));
        else
            (PyArg_Parse(args, ":getFirstByteRequested"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_first_byte_requested();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFirstByteRequested(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_first_byte_requested_288_comment =
    "C++ Interface:\n"
    "getFirstByteRequested(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_first_byte_requested\n"
    "//       Access: Published\n"
    "//  Description: Returns the first byte of the file requested by the\n"
    "//               request.  This will normally be 0 to indicate that\n"
    "//               the file is being requested from the beginning, but\n"
    "//               if the file was requested via a get_subdocument()\n"
    "//               call, this will contain the first_byte parameter from\n"
    "//               that call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_first_byte_requested_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_last_byte_requested(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_last_byte_requested_289(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_last_byte_requested(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLastByteRequested", key_word_list));
        else
            (PyArg_Parse(args, ":getLastByteRequested"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_last_byte_requested();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLastByteRequested(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_last_byte_requested_289_comment =
    "C++ Interface:\n"
    "getLastByteRequested(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_last_byte_requested\n"
    "//       Access: Published\n"
    "//  Description: Returns the last byte of the file requested by the\n"
    "//               request.  This will normally be 0 to indicate that\n"
    "//               the file is being requested to its last byte, but if\n"
    "//               the file was requested via a get_subdocument() call,\n"
    "//               this will contain the last_byte parameter from that\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_last_byte_requested_289_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_first_byte_delivered(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_first_byte_delivered_290(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_first_byte_delivered(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFirstByteDelivered", key_word_list));
        else
            (PyArg_Parse(args, ":getFirstByteDelivered"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_first_byte_delivered();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFirstByteDelivered(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_first_byte_delivered_290_comment =
    "C++ Interface:\n"
    "getFirstByteDelivered(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_first_byte_delivered\n"
    "//       Access: Published\n"
    "//  Description: Returns the first byte of the file (that will be)\n"
    "//               delivered by the server in response to the current\n"
    "//               request.  Normally, this is the same as\n"
    "//               get_first_byte_requested(), but some servers will\n"
    "//               ignore a subdocument request and always return the\n"
    "//               whole file, in which case this value will be 0,\n"
    "//               regardless of what was requested to\n"
    "//               get_subdocument().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_first_byte_delivered_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_last_byte_delivered(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_last_byte_delivered_291(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_last_byte_delivered(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLastByteDelivered", key_word_list));
        else
            (PyArg_Parse(args, ":getLastByteDelivered"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_last_byte_delivered();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLastByteDelivered(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_last_byte_delivered_291_comment =
    "C++ Interface:\n"
    "getLastByteDelivered(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_last_byte_delivered\n"
    "//       Access: Published\n"
    "//  Description: Returns the last byte of the file (that will be)\n"
    "//               delivered by the server in response to the current\n"
    "//               request.  Normally, this is the same as\n"
    "//               get_last_byte_requested(), but some servers will\n"
    "//               ignore a subdocument request and always return the\n"
    "//               whole file, in which case this value will be 0,\n"
    "//               regardless of what was requested to\n"
    "//               get_subdocument().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_last_byte_delivered_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPChannel::write_headers(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_write_headers_292(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HTTPChannel::write_headers(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeHeaders", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeHeaders", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPChannel.writeHeaders", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HTTPChannel*)local_this)->write_headers(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeHeaders(const HTTPChannel this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_write_headers_292_comment =
    "C++ Interface:\n"
    "writeHeaders(const HTTPChannel this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::write_headers\n"
    "//       Access: Published\n"
    "//  Description: Outputs a list of all headers defined by the server\n"
    "//               to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_write_headers_292_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::reset(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_reset_293(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_reset_293_comment =
    "C++ Interface:\n"
    "reset(non-const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::reset\n"
    "//       Access: Published\n"
    "//  Description: Stops whatever file transaction is currently in\n"
    "//               progress, closes the connection, and resets to begin\n"
    "//               anew.  You shouldn't ever need to call this, since\n"
    "//               the channel should be able to reset itself cleanly\n"
    "//               between requests, but it is provided in case you are\n"
    "//               an especially nervous type.\n"
    "//\n"
    "//               Don't call this after every request unless you set\n"
    "//               set_persistent_connection() to false, since calling\n"
    "//               reset() rudely closes the connection regardless of\n"
    "//               whether we have told the server we intend to keep it\n"
    "//               open or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_reset_293_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::preserve_status(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_preserve_status_294(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::preserve_status(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":preserveStatus", key_word_list));
        else
            (PyArg_Parse(args, ":preserveStatus"));
        if(!PyErr_Occurred())
        {
            (local_this)->preserve_status();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.preserveStatus() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "preserveStatus(non-const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_preserve_status_294_comment =
    "C++ Interface:\n"
    "preserveStatus(non-const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::preserve_status\n"
    "//       Access: Published\n"
    "//  Description: Preserves the previous status code (presumably a\n"
    "//               failure) from the previous connection attempt.  If\n"
    "//               the subsequent connection attempt also fails, the\n"
    "//               returned status code will be the better of the\n"
    "//               previous code and the current code.\n"
    "//\n"
    "//               This can be called to daisy-chain subsequent attempts\n"
    "//               to download the same document from different servers.\n"
    "//               After all servers have been attempted, the final\n"
    "//               status code will reflect the attempt that most nearly\n"
    "//               succeeded.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_preserve_status_294_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::clear_extra_headers(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_clear_extra_headers_295(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::clear_extra_headers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearExtraHeaders", key_word_list));
        else
            (PyArg_Parse(args, ":clearExtraHeaders"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_extra_headers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.clearExtraHeaders() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearExtraHeaders(non-const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_clear_extra_headers_295_comment =
    "C++ Interface:\n"
    "clearExtraHeaders(non-const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::clear_extra_headers\n"
    "//       Access: Published\n"
    "//  Description: Resets the extra headers that were previously added\n"
    "//               via calls to send_extra_header().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_clear_extra_headers_295_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::send_extra_header(basic_string< char > const &key, basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_send_extra_header_296(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HTTPChannel::send_extra_header(basic_string< char > const &key, basic_string< char > const &value)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"key", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:sendExtraHeader", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->send_extra_header(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.sendExtraHeader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendExtraHeader(non-const HTTPChannel this, string key, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_send_extra_header_296_comment =
    "C++ Interface:\n"
    "sendExtraHeader(non-const HTTPChannel this, string key, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::send_extra_header\n"
    "//       Access: Published\n"
    "//  Description: Specifies an additional key: value pair that is added\n"
    "//               into the header sent to the server with the next\n"
    "//               request.  This is passed along with no interpretation\n"
    "//               by the HTTPChannel code.  You may call this\n"
    "//               repeatedly to append multiple headers.\n"
    "//\n"
    "//               This is persistent for one request only; it must be\n"
    "//               set again for each new request.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_send_extra_header_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_document(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_document_297(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::get_document(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDocument", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getDocument", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.getDocument", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->get_document(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.getDocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDocument(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_document_297_comment =
    "C++ Interface:\n"
    "getDocument(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_document\n"
    "//       Access: Published\n"
    "//  Description: Opens the named document for reading, if available.\n"
    "//               Returns true if successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_document_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_subdocument(DocumentSpec const &url, unsigned int first_byte, unsigned int last_byte)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_subdocument_298(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::get_subdocument(DocumentSpec const &url, unsigned int first_byte, unsigned int last_byte)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"url", (char *)"first_byte", (char *)"last_byte", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:getSubdocument", key_word_list, &param1, &param2, &param3))
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.getSubdocument", 1, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param1_this == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->get_subdocument(*param1_this, PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                     Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.getSubdocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdocument(non-const HTTPChannel this, const DocumentSpec url, unsigned int first_byte, unsigned int last_byte)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_subdocument_298_comment =
    "C++ Interface:\n"
    "getSubdocument(non-const HTTPChannel this, const DocumentSpec url, unsigned int first_byte, unsigned int last_byte)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_subdocument\n"
    "//       Access: Published\n"
    "//  Description: Retrieves only the specified byte range of the\n"
    "//               indicated document.  If last_byte is 0, it stands for\n"
    "//               the last byte of the document.  When a subdocument is\n"
    "//               requested, get_file_size() and get_bytes_downloaded()\n"
    "//               will report the number of bytes of the subdocument,\n"
    "//               not of the complete document.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_subdocument_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_header(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_header_299(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::get_header(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getHeader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getHeader", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.getHeader", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->get_header(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.getHeader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeader(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_header_299_comment =
    "C++ Interface:\n"
    "getHeader(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_header\n"
    "//       Access: Published\n"
    "//  Description: Like get_document(), except only the header\n"
    "//               associated with the document is retrieved.  This may\n"
    "//               be used to test for existence of the document; it\n"
    "//               might also return the size of the document (if the\n"
    "//               server gives us this information).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_header_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::post_form(DocumentSpec const &url, basic_string< char > const &body)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_post_form_300(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::post_form(DocumentSpec const &url, basic_string< char > const &body)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"url", (char *)"body", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:postForm", key_word_list, &param1, &param2_str, &param2_len))
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.postForm", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->post_form(*param1_this, basic_string<char>(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.postForm() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "postForm(non-const HTTPChannel this, const DocumentSpec url, string body)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_post_form_300_comment =
    "C++ Interface:\n"
    "postForm(non-const HTTPChannel this, const DocumentSpec url, string body)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::post_form\n"
    "//       Access: Published\n"
    "//  Description: Posts form data to a particular URL and retrieves the\n"
    "//               response.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_post_form_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::put_document(DocumentSpec const &url, basic_string< char > const &body)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_put_document_301(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::put_document(DocumentSpec const &url, basic_string< char > const &body)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"url", (char *)"body", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:putDocument", key_word_list, &param1, &param2_str, &param2_len))
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.putDocument", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->put_document(*param1_this, basic_string<char>(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.putDocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "putDocument(non-const HTTPChannel this, const DocumentSpec url, string body)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_put_document_301_comment =
    "C++ Interface:\n"
    "putDocument(non-const HTTPChannel this, const DocumentSpec url, string body)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::put_document\n"
    "//       Access: Published\n"
    "//  Description: Uploads the indicated body to the server to replace\n"
    "//               the indicated URL, if the server allows this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_put_document_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::delete_document(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_delete_document_302(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::delete_document(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:deleteDocument", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:deleteDocument", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.deleteDocument", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->delete_document(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.deleteDocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "deleteDocument(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_delete_document_302_comment =
    "C++ Interface:\n"
    "deleteDocument(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::delete_document\n"
    "//       Access: Published\n"
    "//  Description: Requests the server to remove the indicated URL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_delete_document_302_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_trace(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_trace_303(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::get_trace(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getTrace", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getTrace", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.getTrace", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->get_trace(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.getTrace() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrace(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_trace_303_comment =
    "C++ Interface:\n"
    "getTrace(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_trace\n"
    "//       Access: Published\n"
    "//  Description: Sends a TRACE message to the server, which should\n"
    "//               return back the same message as the server received\n"
    "//               it, allowing inspection of proxy hops, etc.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_trace_303_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::connect_to(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_connect_to_304(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::connect_to(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:connectTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:connectTo", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.connectTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->connect_to(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.connectTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "connectTo(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_connect_to_304_comment =
    "C++ Interface:\n"
    "connectTo(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::connect_to\n"
    "//       Access: Published\n"
    "//  Description: Establish a direct connection to the server and port\n"
    "//               indicated by the URL, but do not issue any HTTP\n"
    "//               requests.  If successful, the connection may then be\n"
    "//               taken to use for whatever purposes you like by\n"
    "//               calling get_connection().\n"
    "//\n"
    "//               This establishes a blocking I/O socket.  Also see\n"
    "//               begin_connect_to().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_connect_to_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::get_options(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_options_305(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HTTPChannel::get_options(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getOptions", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getOptions", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.getOptions", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->get_options(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.getOptions() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOptions(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_options_305_comment =
    "C++ Interface:\n"
    "getOptions(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_options\n"
    "//       Access: Published\n"
    "//  Description: Sends an OPTIONS message to the server, which should\n"
    "//               query the available options, possibly in relation to\n"
    "//               a specified URL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_options_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::begin_get_document(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_begin_get_document_306(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPChannel::begin_get_document(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginGetDocument", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginGetDocument", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.beginGetDocument", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_get_document(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.beginGetDocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginGetDocument(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_begin_get_document_306_comment =
    "C++ Interface:\n"
    "beginGetDocument(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::begin_get_document\n"
    "//       Access: Published\n"
    "//  Description: Begins a non-blocking request to retrieve a given\n"
    "//               document.  This method will return immediately, even\n"
    "//               before a connection to the server has necessarily\n"
    "//               been established; you must then call run() from time\n"
    "//               to time until the return value of run() is false.\n"
    "//               Then you may check is_valid() and get_status_code()\n"
    "//               to determine the status of your request.\n"
    "//\n"
    "//               If a previous request had been pending, that request\n"
    "//               is discarded.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_begin_get_document_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::begin_get_subdocument(DocumentSpec const &url, unsigned int first_byte, unsigned int last_byte)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_begin_get_subdocument_307(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPChannel::begin_get_subdocument(DocumentSpec const &url, unsigned int first_byte, unsigned int last_byte)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"url", (char *)"first_byte", (char *)"last_byte", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:beginGetSubdocument", key_word_list, &param1, &param2, &param3))
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.beginGetSubdocument", 1, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param1_this == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)))
                {
                    (local_this)->begin_get_subdocument(*param1_this, PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint));
                     Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.beginGetSubdocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginGetSubdocument(non-const HTTPChannel this, const DocumentSpec url, unsigned int first_byte, unsigned int last_byte)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_begin_get_subdocument_307_comment =
    "C++ Interface:\n"
    "beginGetSubdocument(non-const HTTPChannel this, const DocumentSpec url, unsigned int first_byte, unsigned int last_byte)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::begin_get_subdocument\n"
    "//       Access: Published\n"
    "//  Description: Begins a non-blocking request to retrieve only the\n"
    "//               specified byte range of the indicated document.  If\n"
    "//               last_byte is 0, it stands for the last byte of the\n"
    "//               document.  When a subdocument is requested,\n"
    "//               get_file_size() and get_bytes_downloaded() will\n"
    "//               report the number of bytes of the subdocument, not of\n"
    "//               the complete document.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_begin_get_subdocument_307_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::begin_get_header(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_begin_get_header_308(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPChannel::begin_get_header(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginGetHeader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginGetHeader", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.beginGetHeader", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_get_header(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.beginGetHeader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginGetHeader(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_begin_get_header_308_comment =
    "C++ Interface:\n"
    "beginGetHeader(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::begin_get_header\n"
    "//       Access: Published\n"
    "//  Description: Begins a non-blocking request to retrieve a given\n"
    "//               header.  See begin_get_document() and get_header().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_begin_get_header_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::begin_post_form(DocumentSpec const &url, basic_string< char > const &body)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_begin_post_form_309(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPChannel::begin_post_form(DocumentSpec const &url, basic_string< char > const &body)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"url", (char *)"body", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:beginPostForm", key_word_list, &param1, &param2_str, &param2_len))
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.beginPostForm", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_post_form(*param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.beginPostForm() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginPostForm(non-const HTTPChannel this, const DocumentSpec url, string body)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_begin_post_form_309_comment =
    "C++ Interface:\n"
    "beginPostForm(non-const HTTPChannel this, const DocumentSpec url, string body)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::begin_post_form\n"
    "//       Access: Published\n"
    "//  Description: Posts form data to a particular URL and retrieves the\n"
    "//               response, all using non-blocking I/O.  See\n"
    "//               begin_get_document() and post_form().\n"
    "//\n"
    "//               It is important to note that you *must* call run()\n"
    "//               repeatedly after calling this method until run()\n"
    "//               returns false, and you may not call any other\n"
    "//               document posting or retrieving methods using the\n"
    "//               HTTPChannel object in the interim, or your form data\n"
    "//               may not get posted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_begin_post_form_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPChannel::run(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_run_310(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HTTPChannel::run(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":run", key_word_list));
        else
            (PyArg_Parse(args, ":run"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->run();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.run() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "run(non-const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_run_310_comment =
    "C++ Interface:\n"
    "run(non-const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::run\n"
    "//       Access: Published\n"
    "//  Description: This must be called from time to time when\n"
    "//               non-blocking I/O is in use.  It checks for data\n"
    "//               coming in on the socket and writes data out to the\n"
    "//               socket when possible, and does whatever processing is\n"
    "//               required towards completing the current task.\n"
    "//\n"
    "//               The return value is true if the task is still pending\n"
    "//               (and run() will need to be called again in the\n"
    "//               future), or false if the current task is complete.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_run_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HTTPChannel::begin_connect_to(DocumentSpec const &url)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_begin_connect_to_311(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HTTPChannel::begin_connect_to(DocumentSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginConnectTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginConnectTo", &param1));
            if(!PyErr_Occurred())
            {
                DocumentSpec *param1_this = (DocumentSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DocumentSpec, 1, "HTTPChannel.beginConnectTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_connect_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HTTPChannel.beginConnectTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginConnectTo(non-const HTTPChannel this, const DocumentSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_begin_connect_to_311_comment =
    "C++ Interface:\n"
    "beginConnectTo(non-const HTTPChannel this, const DocumentSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::begin_connect_to\n"
    "//       Access: Published\n"
    "//  Description: Begins a non-blocking request to establish a direct\n"
    "//               connection to the server and port indicated by the\n"
    "//               URL.  No HTTP requests will be issued beyond what is\n"
    "//               necessary to establish the connection.  When run()\n"
    "//               has finished, you may call is_connection_ready() to\n"
    "//               determine if the connection was successfully\n"
    "//               established.\n"
    "//\n"
    "//               If successful, the connection may then be taken to\n"
    "//               use for whatever purposes you like by calling\n"
    "//               get_connection().\n"
    "//\n"
    "//               This establishes a nonblocking I/O socket.  Also see\n"
    "//               connect_to().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_begin_connect_to_311_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ISocketStream *HTTPChannel::open_read_body(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_open_read_body_312(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ISocketStream *HTTPChannel::open_read_body(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":openReadBody", key_word_list));
        else
            (PyArg_Parse(args, ":openReadBody"));
        if(!PyErr_Occurred())
        {
            ISocketStream *return_value = (local_this)->open_read_body();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ISocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.openReadBody() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openReadBody(non-const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_open_read_body_312_comment =
    "C++ Interface:\n"
    "openReadBody(non-const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::open_read_body\n"
    "//       Access: Published\n"
    "//  Description: Returns a newly-allocated istream suitable for\n"
    "//               reading the body of the document.  This may only be\n"
    "//               called immediately after a call to get_document() or\n"
    "//               post_form(), or after a call to run() has returned\n"
    "//               false.\n"
    "//\n"
    "//               Note that, in nonblocking mode, the returned stream\n"
    "//               may report an early EOF, even before the actual end\n"
    "//               of file.  When this happens, you should call\n"
    "//               stream->is_closed() to determine whether you should\n"
    "//               attempt to read some more later.\n"
    "//\n"
    "//               The user is responsible for passing the returned\n"
    "//               istream to close_read_body() later.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_open_read_body_312_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HTTPChannel::close_read_body(istream *stream) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_close_read_body_313(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HTTPChannel::close_read_body(istream *stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:closeReadBody", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:closeReadBody", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "HTTPChannel.closeReadBody", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HTTPChannel*)local_this)->close_read_body(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "closeReadBody(const HTTPChannel this, non-const Istream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_close_read_body_313_comment =
    "C++ Interface:\n"
    "closeReadBody(const HTTPChannel this, non-const Istream stream)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::close_read_body\n"
    "//       Access: Public\n"
    "//  Description: Closes a file opened by a previous call to\n"
    "//               open_read_body().  This really just deletes the\n"
    "//               istream pointer, but it is recommended to use this\n"
    "//               interface instead of deleting it explicitly, to help\n"
    "//               work around compiler issues.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_close_read_body_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes)
 * bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes = (1))
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_download_to_file_314(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:downloadToFile", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:downloadToFile", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "HTTPChannel.downloadToFile", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->download_to_file(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HTTPChannel.downloadToFile() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"subdocument_resumes", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:downloadToFile", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "HTTPChannel.downloadToFile", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->download_to_file(*param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HTTPChannel.downloadToFile() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "downloadToFile() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "downloadToFile(non-const HTTPChannel this, const Filename filename)\n"
          "downloadToFile(non-const HTTPChannel this, const Filename filename, bool subdocument_resumes)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_download_to_file_314_comment =
    "C++ Interface:\n"
    "downloadToFile(non-const HTTPChannel this, const Filename filename)\n"
    "downloadToFile(non-const HTTPChannel this, const Filename filename, bool subdocument_resumes)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::download_to_file\n"
    "//       Access: Published\n"
    "//  Description: Specifies the name of a file to download the\n"
    "//               resulting document to.  This should be called\n"
    "//               immediately after get_document() or\n"
    "//               begin_get_document() or related functions.\n"
    "//\n"
    "//               In the case of the blocking I/O methods like\n"
    "//               get_document(), this function will download the\n"
    "//               entire document to the file and return true if it was\n"
    "//               successfully downloaded, false otherwise.\n"
    "//\n"
    "//               In the case of non-blocking I/O methods like\n"
    "//               begin_get_document(), this function simply indicates an\n"
    "//               intention to download to the indicated file.  It\n"
    "//               returns true if the file can be opened for writing,\n"
    "//               false otherwise, but the contents will not be\n"
    "//               completely downloaded until run() has returned false.\n"
    "//               At this time, it is possible that a communications\n"
    "//               error will have left a partial file, so\n"
    "//               is_download_complete() may be called to test this.\n"
    "//\n"
    "//               If subdocument_resumes is true and the document in\n"
    "//               question was previously requested as a subdocument\n"
    "//               (i.e. get_subdocument() with a first_byte value\n"
    "//               greater than zero), this will automatically seek to\n"
    "//               the appropriate byte within the file for writing the\n"
    "//               output.  In this case, the file must already exist\n"
    "//               and must have at least first_byte bytes in it.  If\n"
    "//               subdocument_resumes is false, a subdocument will\n"
    "//               always be downloaded beginning at the first byte of\n"
    "//               the file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_download_to_file_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes)
 * bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes = (1))
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_download_to_ram_315(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"ramfile", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:downloadToRam", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:downloadToRam", &param1));
                if(!PyErr_Occurred())
                {
                    Ramfile *param1_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Ramfile, 1, "HTTPChannel.downloadToRam", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->download_to_ram(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HTTPChannel.downloadToRam() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"ramfile", (char *)"subdocument_resumes", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:downloadToRam", key_word_list, &param1, &param2))
                {
                    Ramfile *param1_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Ramfile, 1, "HTTPChannel.downloadToRam", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->download_to_ram(param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HTTPChannel.downloadToRam() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "downloadToRam() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "downloadToRam(non-const HTTPChannel this, non-const Ramfile ramfile)\n"
          "downloadToRam(non-const HTTPChannel this, non-const Ramfile ramfile, bool subdocument_resumes)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_download_to_ram_315_comment =
    "C++ Interface:\n"
    "downloadToRam(non-const HTTPChannel this, non-const Ramfile ramfile)\n"
    "downloadToRam(non-const HTTPChannel this, non-const Ramfile ramfile, bool subdocument_resumes)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::download_to_ram\n"
    "//       Access: Published\n"
    "//  Description: Specifies a Ramfile object to download the\n"
    "//               resulting document to.  This should be called\n"
    "//               immediately after get_document() or\n"
    "//               begin_get_document() or related functions.\n"
    "//\n"
    "//               In the case of the blocking I/O methods like\n"
    "//               get_document(), this function will download the\n"
    "//               entire document to the Ramfile and return true if it\n"
    "//               was successfully downloaded, false otherwise.\n"
    "//\n"
    "//               In the case of non-blocking I/O methods like\n"
    "//               begin_get_document(), this function simply indicates an\n"
    "//               intention to download to the indicated Ramfile.  It\n"
    "//               returns true if the file can be opened for writing,\n"
    "//               false otherwise, but the contents will not be\n"
    "//               completely downloaded until run() has returned false.\n"
    "//               At this time, it is possible that a communications\n"
    "//               error will have left a partial file, so\n"
    "//               is_download_complete() may be called to test this.\n"
    "//\n"
    "//               If subdocument_resumes is true and the document in\n"
    "//               question was previously requested as a subdocument\n"
    "//               (i.e. get_subdocument() with a first_byte value\n"
    "//               greater than zero), this will automatically seek to\n"
    "//               the appropriate byte within the Ramfile for writing\n"
    "//               the output.  In this case, the Ramfile must already\n"
    "//               have at least first_byte bytes in it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_download_to_ram_315_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HTTPChannel::download_to_stream(ostream *strm, bool subdocument_resumes)
 * bool HTTPChannel::download_to_stream(ostream *strm, bool subdocument_resumes = (1))
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_download_to_stream_316(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool HTTPChannel::download_to_stream(ostream *strm, bool subdocument_resumes = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"strm", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:downloadToStream", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:downloadToStream", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPChannel.downloadToStream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->download_to_stream(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HTTPChannel.downloadToStream() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool HTTPChannel::download_to_stream(ostream *strm, bool subdocument_resumes)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"strm", (char *)"subdocument_resumes", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:downloadToStream", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HTTPChannel.downloadToStream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->download_to_stream(param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HTTPChannel.downloadToStream() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "downloadToStream() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "downloadToStream(non-const HTTPChannel this, non-const Ostream strm)\n"
          "downloadToStream(non-const HTTPChannel this, non-const Ostream strm, bool subdocument_resumes)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_download_to_stream_316_comment =
    "C++ Interface:\n"
    "downloadToStream(non-const HTTPChannel this, non-const Ostream strm)\n"
    "downloadToStream(non-const HTTPChannel this, non-const Ostream strm, bool subdocument_resumes)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::download_to_stream\n"
    "//       Access: Published\n"
    "//  Description: Specifies the name of an ostream to download the\n"
    "//               resulting document to.  This should be called\n"
    "//               immediately after get_document() or\n"
    "//               begin_get_document() or related functions.\n"
    "//\n"
    "//               In the case of the blocking I/O methods like\n"
    "//               get_document(), this function will download the\n"
    "//               entire document to the file and return true if it was\n"
    "//               successfully downloaded, false otherwise.\n"
    "//\n"
    "//               In the case of non-blocking I/O methods like\n"
    "//               begin_get_document(), this function simply indicates an\n"
    "//               intention to download to the indicated file.  It\n"
    "//               returns true if the file can be opened for writing,\n"
    "//               false otherwise, but the contents will not be\n"
    "//               completely downloaded until run() has returned false.\n"
    "//               At this time, it is possible that a communications\n"
    "//               error will have left a partial file, so\n"
    "//               is_download_complete() may be called to test this.\n"
    "//\n"
    "//               If subdocument_resumes is true and the document in\n"
    "//               question was previously requested as a subdocument\n"
    "//               (i.e. get_subdocument() with a first_byte value\n"
    "//               greater than zero), this will automatically seek to\n"
    "//               the appropriate byte within the file for writing the\n"
    "//               output.  In this case, the file must already exist\n"
    "//               and must have at least first_byte bytes in it.  If\n"
    "//               subdocument_resumes is false, a subdocument will\n"
    "//               always be downloaded beginning at the first byte of\n"
    "//               the file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_download_to_stream_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SocketStream *HTTPChannel::get_connection(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_connection_317(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SocketStream *HTTPChannel::get_connection(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getConnection", key_word_list));
        else
            (PyArg_Parse(args, ":getConnection"));
        if(!PyErr_Occurred())
        {
            SocketStream *return_value = (local_this)->get_connection();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HTTPChannel.getConnection() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConnection(non-const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_connection_317_comment =
    "C++ Interface:\n"
    "getConnection(non-const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_connection\n"
    "//       Access: Published\n"
    "//  Description: Returns the connection that was established via a\n"
    "//               previous call to connect_to() or begin_connect_to(),\n"
    "//               or NULL if the connection attempt failed or if those\n"
    "//               methods have not recently been called.\n"
    "//\n"
    "//               This stream has been allocated from the free store.\n"
    "//               It is the user's responsibility to delete this\n"
    "//               pointer when finished with it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_connection_317_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_bytes_downloaded(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_bytes_downloaded_318(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_bytes_downloaded(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBytesDownloaded", key_word_list));
        else
            (PyArg_Parse(args, ":getBytesDownloaded"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_bytes_downloaded();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBytesDownloaded(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_bytes_downloaded_318_comment =
    "C++ Interface:\n"
    "getBytesDownloaded(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_bytes_downloaded\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bytes downloaded during the\n"
    "//               last (or current) download_to_file() or\n"
    "//               download_to_ram operation().  This can be used in\n"
    "//               conjunction with get_file_size() to report the\n"
    "//               percent complete (but be careful, since\n"
    "//               get_file_size() may return 0 if the server has not\n"
    "//               told us the size of the file).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_bytes_downloaded_318_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int HTTPChannel::get_bytes_requested(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_bytes_requested_319(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int HTTPChannel::get_bytes_requested(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBytesRequested", key_word_list));
        else
            (PyArg_Parse(args, ":getBytesRequested"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const HTTPChannel*)local_this)->get_bytes_requested();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBytesRequested(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_bytes_requested_319_comment =
    "C++ Interface:\n"
    "getBytesRequested(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::get_bytes_requested\n"
    "//       Access: Published\n"
    "//  Description: When download throttling is in effect\n"
    "//               (set_download_throttle() has been set to true) and\n"
    "//               non-blocking I/O methods (like begin_get_document())\n"
    "//               are used, this returns the number of bytes\n"
    "//               \"requested\" from the server so far: that is, the\n"
    "//               theoretical maximum value for get_bytes_downloaded(),\n"
    "//               if the server has been keeping up with our demand.\n"
    "//\n"
    "//               If this number is less than get_bytes_downloaded(),\n"
    "//               then the server has not been supplying bytes fast\n"
    "//               enough to meet our own download throttle rate.\n"
    "//\n"
    "//               When download throttling is not in effect, or when\n"
    "//               the blocking I/O methods (like get_document(), etc.)\n"
    "//               are used, this returns 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_bytes_requested_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HTTPChannel::is_download_complete(void) const
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_is_download_complete_320(PyObject *self, PyObject *args,PyObject *kwds) {
    HTTPChannel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPChannel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool HTTPChannel::is_download_complete(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDownloadComplete", key_word_list));
        else
            (PyArg_Parse(args, ":isDownloadComplete"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const HTTPChannel*)local_this)->is_download_complete();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDownloadComplete(const HTTPChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_is_download_complete_320_comment =
    "C++ Interface:\n"
    "isDownloadComplete(const HTTPChannel this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HTTPChannel::is_download_complete\n"
    "//       Access: Published\n"
    "//  Description: Returns true when a download_to() or\n"
    "//               download_to_ram() has executed and the file has been\n"
    "//               fully downloaded.  If this still returns false after\n"
    "//               processing has completed, there was an error in\n"
    "//               transmission.\n"
    "//\n"
    "//               Note that simply testing is_download_complete() does\n"
    "//               not prove that the requested document was succesfully\n"
    "//               retrieved--you might have just downloaded the \"404\n"
    "//               not found\" stub (for instance) that a server would\n"
    "//               provide in response to some error condition.  You\n"
    "//               should also check is_valid() to prove that the file\n"
    "//               you expected has been successfully retrieved.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HTTPChannel_is_download_complete_320_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle HTTPChannel::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_HTTPChannel_get_class_type_321(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle HTTPChannel::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = HTTPChannel::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HTTPChannel_get_class_type_321_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_HTTPChannel_get_class_type_321_comment = NULL;
#endif

int  Dtool_Init_HTTPChannel(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (HTTPChannel)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_HTTPChannel_get_redirect_steps(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumRedirectSteps", "getRedirectStep");
}
inline void  * Dtool_UpcastInterface_HTTPChannel(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HTTPChannel)
    {
        printf("HTTPChannel ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HTTPChannel * local_this = (HTTPChannel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HTTPChannel)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HTTPChannel(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HTTPChannel)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (HTTPChannel*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (HTTPChannel*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (HTTPChannel*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Decompressor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int Decompressor::initiate(Filename const &source_file)
 * int Decompressor::initiate(Filename const &source_file, Filename const &dest_file)
 *******************************************************************/
static PyObject *Dtool_Decompressor_initiate_325(PyObject *self, PyObject *args,PyObject *kwds) {
    Decompressor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Decompressor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int Decompressor::initiate(Filename const &source_file)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"source_file", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:initiate", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:initiate", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Decompressor.initiate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->initiate(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Decompressor.initiate() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int Decompressor::initiate(Filename const &source_file, Filename const &dest_file)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"source_file", (char *)"dest_file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:initiate", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Decompressor.initiate", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Decompressor.initiate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        int return_value = (local_this)->initiate(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Decompressor.initiate() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "initiate() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "initiate(non-const Decompressor this, const Filename source_file)\n"
          "initiate(non-const Decompressor this, const Filename source_file, const Filename dest_file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Decompressor_initiate_325_comment =
    "C++ Interface:\n"
    "initiate(non-const Decompressor this, const Filename source_file)\n"
    "initiate(non-const Decompressor this, const Filename source_file, const Filename dest_file)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Decompressor::initiate\n"
    "//       Access: Public\n"
    "//  Description: Begins a background decompression of the named file\n"
    "//               (whose filename must end in \".pz\") to a new file\n"
    "//               without the .pz extension.  The source file is\n"
    "//               removed after successful completion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Decompressor::initiate\n"
    "//       Access: Public\n"
    "//  Description: Begins a background decompression from the named\n"
    "//               source file to the named destination file.  The\n"
    "//               source file is removed after successful completion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Decompressor_initiate_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Decompressor::run(void)
 *******************************************************************/
static PyObject *Dtool_Decompressor_run_326(PyObject *self, PyObject *args,PyObject *kwds) {
    Decompressor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Decompressor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int Decompressor::run(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":run", key_word_list));
        else
            (PyArg_Parse(args, ":run"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->run();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Decompressor.run() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "run(non-const Decompressor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Decompressor_run_326_comment =
    "C++ Interface:\n"
    "run(non-const Decompressor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Decompressor::run\n"
    "//       Access: Public\n"
    "//  Description: Called each frame to do the next bit of work in the\n"
    "//               background task.  Returns EU_ok if a chunk is\n"
    "//               completed but there is more to go, or EU_success when\n"
    "//               we're all done.  Any other return value indicates an\n"
    "//               error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Decompressor_run_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Decompressor::decompress(Filename const &source_file)
 * bool Decompressor::decompress(Ramfile &source_and_dest_file)
 *******************************************************************/
static PyObject *Dtool_Decompressor_decompress_327(PyObject *self, PyObject *args,PyObject *kwds) {
    Decompressor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Decompressor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool Decompressor::decompress(Filename const &source_file)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source_file", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:decompress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:decompress", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Decompressor.decompress", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->decompress(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool Decompressor::decompress(Ramfile &source_and_dest_file)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source_and_dest_file", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:decompress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:decompress", &param1));
            if(!PyErr_Occurred())
            {
                Ramfile *param1_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Ramfile, 1, "Decompressor.decompress", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->decompress(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decompress(non-const Decompressor this, const Filename source_file)\n"
          "decompress(non-const Decompressor this, non-const Ramfile source_and_dest_file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Decompressor_decompress_327_comment =
    "C++ Interface:\n"
    "decompress(non-const Decompressor this, const Filename source_file)\n"
    "decompress(non-const Decompressor this, non-const Ramfile source_and_dest_file)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Decompressor::decompress\n"
    "//       Access: Public\n"
    "//  Description: Performs a foreground decompression of the named\n"
    "//               file; does not return until the decompression is\n"
    "//               complete.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Decompressor::decompress\n"
    "//       Access: Public\n"
    "//  Description: Does an in-memory decompression of the indicated\n"
    "//               Ramfile.  The decompressed contents are written back\n"
    "//               into the same Ramfile on completion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Decompressor_decompress_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Decompressor::get_progress(void) const
 *******************************************************************/
static PyObject *Dtool_Decompressor_get_progress_328(PyObject *self, PyObject *args,PyObject *kwds) {
    Decompressor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Decompressor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Decompressor::get_progress(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProgress", key_word_list));
        else
            (PyArg_Parse(args, ":getProgress"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Decompressor*)local_this)->get_progress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProgress(const Decompressor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Decompressor_get_progress_328_comment =
    "C++ Interface:\n"
    "getProgress(const Decompressor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Decompressor::get_progress\n"
    "//       Access: Public\n"
    "//  Description: Returns the ratio through the decompression step\n"
    "//               in the background.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Decompressor_get_progress_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Decompressor::Decompressor(void)
 *******************************************************************/
int  Dtool_Init_Decompressor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Decompressor::Decompressor(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Decompressor", key_word_list))
        {
            Decompressor *return_value = new Decompressor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Decompressor,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Decompressor()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Decompressor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Decompressor)
    {
        printf("Decompressor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Decompressor * local_this = (Decompressor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Decompressor)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Decompressor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Decompressor)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DownloadDb 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_output_333(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DownloadDb::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DownloadDb.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DownloadDb*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DownloadDb this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_output_333_comment =
    "C++ Interface:\n"
    "output(const DownloadDb this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::output\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_output_333_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_write_334(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DownloadDb::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DownloadDb.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DownloadDb*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const DownloadDb this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_write_334_comment =
    "C++ Interface:\n"
    "write(const DownloadDb this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::write\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_write_334_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::write_version_map(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_write_version_map_335(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DownloadDb::write_version_map(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeVersionMap", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeVersionMap", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DownloadDb.writeVersionMap", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DownloadDb*)local_this)->write_version_map(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeVersionMap(const DownloadDb this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_write_version_map_335_comment =
    "C++ Interface:\n"
    "writeVersionMap(const DownloadDb this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::write_version_map\n"
    "//       Access: Protected\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::write_version_map\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_write_version_map_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::write_client_db(Filename &file)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_write_client_db_336(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool DownloadDb::write_client_db(Filename &file)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"file", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeClientDb", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeClientDb", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.writeClientDb", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->write_client_db(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.writeClientDb() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeClientDb(non-const DownloadDb this, non-const Filename file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_write_client_db_336_comment =
    "C++ Interface:\n"
    "writeClientDb(non-const DownloadDb this, non-const Filename file)\n"
    "\n"
    "// Write a database file\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_write_client_db_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::write_server_db(Filename &file)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_write_server_db_337(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool DownloadDb::write_server_db(Filename &file)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"file", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeServerDb", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeServerDb", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.writeServerDb", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->write_server_db(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.writeServerDb() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeServerDb(non-const DownloadDb this, non-const Filename file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_write_server_db_337_comment =
    "C++ Interface:\n"
    "writeServerDb(non-const DownloadDb this, non-const Filename file)\n"
    "\n"
    "// Write a database file\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_write_server_db_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DownloadDb::get_client_num_multifiles(void) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_client_num_multifiles_338(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DownloadDb::get_client_num_multifiles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClientNumMultifiles", key_word_list));
        else
            (PyArg_Parse(args, ":getClientNumMultifiles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DownloadDb*)local_this)->get_client_num_multifiles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClientNumMultifiles(const DownloadDb this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_client_num_multifiles_338_comment =
    "C++ Interface:\n"
    "getClientNumMultifiles(const DownloadDb this)\n"
    "\n"
    "// Filename: downloadDb.I\n"
    "// Created by:  shochet (08Sep00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_client_num_multifiles_338_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DownloadDb::get_server_num_multifiles(void) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_num_multifiles_339(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DownloadDb::get_server_num_multifiles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getServerNumMultifiles", key_word_list));
        else
            (PyArg_Parse(args, ":getServerNumMultifiles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DownloadDb*)local_this)->get_server_num_multifiles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerNumMultifiles(const DownloadDb this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_num_multifiles_339_comment =
    "C++ Interface:\n"
    "getServerNumMultifiles(const DownloadDb this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_num_multifiles_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DownloadDb::get_client_multifile_name(int index) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_client_multifile_name_340(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DownloadDb::get_client_multifile_name(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getClientMultifileName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getClientMultifileName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DownloadDb*)local_this)->get_client_multifile_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClientMultifileName(const DownloadDb this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_client_multifile_name_340_comment =
    "C++ Interface:\n"
    "getClientMultifileName(const DownloadDb this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_client_multifile_name_340_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DownloadDb::get_server_multifile_name(int index) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_multifile_name_341(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DownloadDb::get_server_multifile_name(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getServerMultifileName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getServerMultifileName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DownloadDb*)local_this)->get_server_multifile_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerMultifileName(const DownloadDb this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_multifile_name_341_comment =
    "C++ Interface:\n"
    "getServerMultifileName(const DownloadDb this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_multifile_name_341_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DownloadDb::get_client_multifile_size(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_client_multifile_size_342(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DownloadDb::get_client_multifile_size(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getClientMultifileSize", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getClientMultifileSize", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DownloadDb*)local_this)->get_client_multifile_size(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClientMultifileSize(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_client_multifile_size_342_comment =
    "C++ Interface:\n"
    "getClientMultifileSize(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_client_multifile_size_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DownloadDb::set_client_multifile_size(basic_string< char > mfname, int size)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_size_343(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DownloadDb::set_client_multifile_size(basic_string< char > mfname, int size)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"mfname", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setClientMultifileSize", key_word_list, &param1_str, &param1_len, &param2))
        {
            (local_this)->set_client_multifile_size(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setClientMultifileSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileSize(non-const DownloadDb this, string mfname, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_size_343_comment =
    "C++ Interface:\n"
    "setClientMultifileSize(non-const DownloadDb this, string mfname, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_size_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DownloadDb::set_client_multifile_delta_size(basic_string< char > mfname, int size)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_delta_size_344(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DownloadDb::set_client_multifile_delta_size(basic_string< char > mfname, int size)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"mfname", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setClientMultifileDeltaSize", key_word_list, &param1_str, &param1_len, &param2))
        {
            int return_value = (local_this)->set_client_multifile_delta_size(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setClientMultifileDeltaSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileDeltaSize(non-const DownloadDb this, string mfname, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_delta_size_344_comment =
    "C++ Interface:\n"
    "setClientMultifileDeltaSize(non-const DownloadDb this, string mfname, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_delta_size_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DownloadDb::get_server_multifile_size(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_multifile_size_345(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DownloadDb::get_server_multifile_size(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getServerMultifileSize", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getServerMultifileSize", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DownloadDb*)local_this)->get_server_multifile_size(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerMultifileSize(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_multifile_size_345_comment =
    "C++ Interface:\n"
    "getServerMultifileSize(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_multifile_size_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DownloadDb::set_server_multifile_size(basic_string< char > mfname, int size)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_server_multifile_size_346(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DownloadDb::set_server_multifile_size(basic_string< char > mfname, int size)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"mfname", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setServerMultifileSize", key_word_list, &param1_str, &param1_len, &param2))
        {
            (local_this)->set_server_multifile_size(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setServerMultifileSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setServerMultifileSize(non-const DownloadDb this, string mfname, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_server_multifile_size_346_comment =
    "C++ Interface:\n"
    "setServerMultifileSize(non-const DownloadDb this, string mfname, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_server_multifile_size_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DownloadDb::get_client_multifile_phase(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_client_multifile_phase_347(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DownloadDb::get_client_multifile_phase(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getClientMultifilePhase", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getClientMultifilePhase", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DownloadDb*)local_this)->get_client_multifile_phase(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClientMultifilePhase(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_client_multifile_phase_347_comment =
    "C++ Interface:\n"
    "getClientMultifilePhase(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_client_multifile_phase_347_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DownloadDb::get_server_multifile_phase(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_multifile_phase_348(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DownloadDb::get_server_multifile_phase(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getServerMultifilePhase", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getServerMultifilePhase", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DownloadDb*)local_this)->get_server_multifile_phase(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerMultifilePhase(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_multifile_phase_348_comment =
    "C++ Interface:\n"
    "getServerMultifilePhase(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_multifile_phase_348_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DownloadDb::set_client_multifile_incomplete(basic_string< char > mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_incomplete_349(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DownloadDb::set_client_multifile_incomplete(basic_string< char > mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setClientMultifileIncomplete", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setClientMultifileIncomplete", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_multifile_incomplete(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setClientMultifileIncomplete() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileIncomplete(non-const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_incomplete_349_comment =
    "C++ Interface:\n"
    "setClientMultifileIncomplete(non-const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_incomplete_349_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DownloadDb::set_client_multifile_complete(basic_string< char > mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_complete_350(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DownloadDb::set_client_multifile_complete(basic_string< char > mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setClientMultifileComplete", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setClientMultifileComplete", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_multifile_complete(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setClientMultifileComplete() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileComplete(non-const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_complete_350_comment =
    "C++ Interface:\n"
    "setClientMultifileComplete(non-const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_complete_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DownloadDb::set_client_multifile_decompressed(basic_string< char > mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_decompressed_351(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DownloadDb::set_client_multifile_decompressed(basic_string< char > mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setClientMultifileDecompressed", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setClientMultifileDecompressed", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_multifile_decompressed(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setClientMultifileDecompressed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileDecompressed(non-const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_decompressed_351_comment =
    "C++ Interface:\n"
    "setClientMultifileDecompressed(non-const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_decompressed_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DownloadDb::set_client_multifile_extracted(basic_string< char > mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_extracted_352(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DownloadDb::set_client_multifile_extracted(basic_string< char > mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setClientMultifileExtracted", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setClientMultifileExtracted", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_multifile_extracted(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.setClientMultifileExtracted() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileExtracted(non-const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_extracted_352_comment =
    "C++ Interface:\n"
    "setClientMultifileExtracted(non-const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_extracted_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DownloadDb::get_server_num_files(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_num_files_353(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DownloadDb::get_server_num_files(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getServerNumFiles", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getServerNumFiles", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DownloadDb*)local_this)->get_server_num_files(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerNumFiles(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_num_files_353_comment =
    "C++ Interface:\n"
    "getServerNumFiles(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_num_files_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DownloadDb::get_server_file_name(basic_string< char > mfname, int index) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_file_name_354(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DownloadDb::get_server_file_name(basic_string< char > mfname, int index) const
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"mfname", (char *)"index", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:getServerFileName", key_word_list, &param1_str, &param1_len, &param2))
        {
            basic_string< char > return_value = ((const DownloadDb*)local_this)->get_server_file_name(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerFileName(const DownloadDb this, string mfname, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_file_name_354_comment =
    "C++ Interface:\n"
    "getServerFileName(const DownloadDb this, string mfname, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_file_name_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::client_multifile_exists(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_client_multifile_exists_355(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DownloadDb::client_multifile_exists(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clientMultifileExists", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clientMultifileExists", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DownloadDb*)local_this)->client_multifile_exists(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientMultifileExists(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_client_multifile_exists_355_comment =
    "C++ Interface:\n"
    "clientMultifileExists(const DownloadDb this, string mfname)\n"
    "\n"
    "// Queries from the Launcher\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_client_multifile_exists_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::client_multifile_complete(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_client_multifile_complete_356(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DownloadDb::client_multifile_complete(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clientMultifileComplete", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clientMultifileComplete", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DownloadDb*)local_this)->client_multifile_complete(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientMultifileComplete(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_client_multifile_complete_356_comment =
    "C++ Interface:\n"
    "clientMultifileComplete(const DownloadDb this, string mfname)\n"
    "\n"
    "// Queries from the Launcher\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description: A multifile is complete when it is completely\n"
    "//               downloaded. Note: it may already be decompressed\n"
    "//               or extracted and it is still complete\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_client_multifile_complete_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::client_multifile_decompressed(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_client_multifile_decompressed_357(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DownloadDb::client_multifile_decompressed(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clientMultifileDecompressed", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clientMultifileDecompressed", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DownloadDb*)local_this)->client_multifile_decompressed(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientMultifileDecompressed(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_client_multifile_decompressed_357_comment =
    "C++ Interface:\n"
    "clientMultifileDecompressed(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_client_multifile_decompressed_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::client_multifile_extracted(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_client_multifile_extracted_358(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DownloadDb::client_multifile_extracted(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clientMultifileExtracted", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clientMultifileExtracted", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DownloadDb*)local_this)->client_multifile_extracted(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientMultifileExtracted(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_client_multifile_extracted_358_comment =
    "C++ Interface:\n"
    "clientMultifileExtracted(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_client_multifile_extracted_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HashVal DownloadDb::get_client_multifile_hash(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_client_multifile_hash_359(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-HashVal DownloadDb::get_client_multifile_hash(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getClientMultifileHash", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getClientMultifileHash", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            HashVal result = ((const DownloadDb*)local_this)->get_client_multifile_hash(basic_string<char>(param1_str, param1_len));
            HashVal *return_value = new HashVal(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HashVal,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClientMultifileHash(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_client_multifile_hash_359_comment =
    "C++ Interface:\n"
    "getClientMultifileHash(const DownloadDb this, string mfname)\n"
    "\n"
    "// Ask what version (told with the hash) this multifile is\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description: Return the hash value of the file we are working on\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_client_multifile_hash_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::set_client_multifile_hash(basic_string< char > mfname, HashVal val)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_client_multifile_hash_360(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DownloadDb::set_client_multifile_hash(basic_string< char > mfname, HashVal val)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mfname", (char *)"val", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setClientMultifileHash", key_word_list, &param1_str, &param1_len, &param2))
            {
                HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_HashVal, 2, "DownloadDb.setClientMultifileHash", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_client_multifile_hash(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.setClientMultifileHash() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientMultifileHash(non-const DownloadDb this, string mfname, const HashVal val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_client_multifile_hash_360_comment =
    "C++ Interface:\n"
    "setClientMultifileHash(non-const DownloadDb this, string mfname, const HashVal val)\n"
    "\n"
    "// Ask what version (told with the hash) this multifile is\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description: Set the hash value of file we are working on\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_client_multifile_hash_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HashVal DownloadDb::get_server_multifile_hash(basic_string< char > mfname) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_server_multifile_hash_361(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-HashVal DownloadDb::get_server_multifile_hash(basic_string< char > mfname) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getServerMultifileHash", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getServerMultifileHash", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            HashVal result = ((const DownloadDb*)local_this)->get_server_multifile_hash(basic_string<char>(param1_str, param1_len));
            HashVal *return_value = new HashVal(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HashVal,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerMultifileHash(const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_server_multifile_hash_361_comment =
    "C++ Interface:\n"
    "getServerMultifileHash(const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description: Return the hash value of the server file\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_server_multifile_hash_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::set_server_multifile_hash(basic_string< char > mfname, HashVal val)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_server_multifile_hash_362(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DownloadDb::set_server_multifile_hash(basic_string< char > mfname, HashVal val)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mfname", (char *)"val", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setServerMultifileHash", key_word_list, &param1_str, &param1_len, &param2))
            {
                HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_HashVal, 2, "DownloadDb.setServerMultifileHash", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_server_multifile_hash(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.setServerMultifileHash() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setServerMultifileHash(non-const DownloadDb this, string mfname, const HashVal val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_server_multifile_hash_362_comment =
    "C++ Interface:\n"
    "setServerMultifileHash(non-const DownloadDb this, string mfname, const HashVal val)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description: Set the hash value of file we are working on\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_server_multifile_hash_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::delete_client_multifile(basic_string< char > mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_delete_client_multifile_363(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DownloadDb::delete_client_multifile(basic_string< char > mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:deleteClientMultifile", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:deleteClientMultifile", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->delete_client_multifile(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.deleteClientMultifile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "deleteClientMultifile(non-const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_delete_client_multifile_363_comment =
    "C++ Interface:\n"
    "deleteClientMultifile(non-const DownloadDb this, string mfname)\n"
    "\n"
    "// Operations on multifiles\n"
    "\n"
    "// Operations on multifiles\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_delete_client_multifile_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::add_client_multifile(basic_string< char > server_mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_add_client_multifile_364(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DownloadDb::add_client_multifile(basic_string< char > server_mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"server_mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addClientMultifile", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addClientMultifile", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_client_multifile(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.addClientMultifile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addClientMultifile(non-const DownloadDb this, string server_mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_add_client_multifile_364_comment =
    "C++ Interface:\n"
    "addClientMultifile(non-const DownloadDb this, string server_mfname)\n"
    "\n"
    "// Operations on multifiles\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_add_client_multifile_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::expand_client_multifile(basic_string< char > mfname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_expand_client_multifile_365(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DownloadDb::expand_client_multifile(basic_string< char > mfname)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"mfname", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:expandClientMultifile", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:expandClientMultifile", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->expand_client_multifile(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.expandClientMultifile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "expandClientMultifile(non-const DownloadDb this, string mfname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_expand_client_multifile_365_comment =
    "C++ Interface:\n"
    "expandClientMultifile(non-const DownloadDb this, string mfname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_expand_client_multifile_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::create_new_server_db(void)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_create_new_server_db_366(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DownloadDb::create_new_server_db(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":createNewServerDb", key_word_list));
        else
            (PyArg_Parse(args, ":createNewServerDb"));
        if(!PyErr_Occurred())
        {
            (local_this)->create_new_server_db();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.createNewServerDb() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "createNewServerDb(non-const DownloadDb this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_create_new_server_db_366_comment =
    "C++ Interface:\n"
    "createNewServerDb(non-const DownloadDb this)\n"
    "\n"
    "// Server side operations to create multifile records\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::create_new_server_db\n"
    "//       Access: Public\n"
    "//  Description: Used on the server side makefiles to create a\n"
    "//               new clean server db\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_create_new_server_db_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::server_add_multifile(basic_string< char > mfname, float phase, int size, int status)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_server_add_multifile_367(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DownloadDb::server_add_multifile(basic_string< char > mfname, float phase, int size, int status)
        char *param1_str; int param1_len;
        double param2;
        int param3;
        int param4;
        static char * key_word_list[] = {(char *)"mfname", (char *)"phase", (char *)"size", (char *)"status", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dii:serverAddMultifile", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4))
        {
            (local_this)->server_add_multifile(basic_string<char>(param1_str, param1_len), (float)param2, (int)param3, (int)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.serverAddMultifile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "serverAddMultifile(non-const DownloadDb this, string mfname, float phase, int size, int status)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_server_add_multifile_367_comment =
    "C++ Interface:\n"
    "serverAddMultifile(non-const DownloadDb this, string mfname, float phase, int size, int status)\n"
    "\n"
    "// Server side operations to create multifile records\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_server_add_multifile_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::server_add_file(basic_string< char > mfname, basic_string< char > fname)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_server_add_file_368(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DownloadDb::server_add_file(basic_string< char > mfname, basic_string< char > fname)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"mfname", (char *)"fname", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:serverAddFile", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->server_add_file(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DownloadDb.serverAddFile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "serverAddFile(non-const DownloadDb this, string mfname, string fname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_server_add_file_368_comment =
    "C++ Interface:\n"
    "serverAddFile(non-const DownloadDb this, string mfname, string fname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_server_add_file_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::add_version(Filename const &name, HashVal const &hash, int version)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_add_version_371(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DownloadDb::add_version(Filename const &name, HashVal const &hash, int version)
            PyObject *param1;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"hash", (char *)"version", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:addVersion", key_word_list, &param1, &param2, &param3))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.addVersion", 1, coerced_ptr, report_errors);
HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_HashVal, 2, "DownloadDb.addVersion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->add_version(*param1_this, *param2_this, (int)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.addVersion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addVersion(non-const DownloadDb this, const Filename name, const HashVal hash, int version)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_add_version_371_comment =
    "C++ Interface:\n"
    "addVersion(non-const DownloadDb this, const Filename name, const HashVal hash, int version)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::add_version\n"
    "//       Access: Published\n"
    "//  Description: Appends a new version of the file onto the end of the\n"
    "//               list, or changes the hash associated with a version\n"
    "//               previously added.\n"
    "//\n"
    "//               Note: version numbers start at 1\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_add_version_371_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::insert_new_version(Filename const &name, HashVal const &hash)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_insert_new_version_372(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DownloadDb::insert_new_version(Filename const &name, HashVal const &hash)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"hash", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:insertNewVersion", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.insertNewVersion", 1, coerced_ptr, report_errors);
HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_HashVal, 2, "DownloadDb.insertNewVersion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->insert_new_version(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.insertNewVersion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "insertNewVersion(non-const DownloadDb this, const Filename name, const HashVal hash)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_insert_new_version_372_comment =
    "C++ Interface:\n"
    "insertNewVersion(non-const DownloadDb this, const Filename name, const HashVal hash)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::insert_new_version\n"
    "//       Access: Published\n"
    "//  Description: Inserts a new version 1 copy of the file, sliding all\n"
    "//               the other versions up by one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_insert_new_version_372_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DownloadDb::has_version(Filename const &name) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_has_version_373(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool DownloadDb::has_version(Filename const &name) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasVersion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasVersion", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.hasVersion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DownloadDb*)local_this)->has_version(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasVersion(const DownloadDb this, const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_has_version_373_comment =
    "C++ Interface:\n"
    "hasVersion(const DownloadDb this, const Filename name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::has_version\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated file has version\n"
    "//               information, false otherwise.  Some files recorded in\n"
    "//               the database may not bother to track versions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_has_version_373_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DownloadDb::get_num_versions(Filename const &name) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_num_versions_374(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int DownloadDb::get_num_versions(Filename const &name) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNumVersions", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getNumVersions", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.getNumVersions", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const DownloadDb*)local_this)->get_num_versions(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVersions(const DownloadDb this, const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_num_versions_374_comment =
    "C++ Interface:\n"
    "getNumVersions(const DownloadDb this, const Filename name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::get_num_versions\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of versions stored for the\n"
    "//               indicated file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_num_versions_374_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DownloadDb::set_num_versions(Filename const &name, int num_versions)
 *******************************************************************/
static PyObject *Dtool_DownloadDb_set_num_versions_375(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DownloadDb::set_num_versions(Filename const &name, int num_versions)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"name", (char *)"num_versions", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setNumVersions", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.setNumVersions", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_num_versions(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DownloadDb.setNumVersions() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumVersions(non-const DownloadDb this, const Filename name, int num_versions)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_set_num_versions_375_comment =
    "C++ Interface:\n"
    "setNumVersions(non-const DownloadDb this, const Filename name, int num_versions)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::set_num_versions\n"
    "//       Access: Published\n"
    "//  Description: Reduces the number of versions of a particular file\n"
    "//               stored in the ddb by throwing away all versions\n"
    "//               higher than the indicated index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_set_num_versions_375_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DownloadDb::get_version(Filename const &name, HashVal const &hash) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_version_376(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int DownloadDb::get_version(Filename const &name, HashVal const &hash) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"hash", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getVersion", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.getVersion", 1, coerced_ptr, report_errors);
HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_HashVal, 2, "DownloadDb.getVersion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    int return_value = ((const DownloadDb*)local_this)->get_version(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVersion(const DownloadDb this, const Filename name, const HashVal hash)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_version_376_comment =
    "C++ Interface:\n"
    "getVersion(const DownloadDb this, const Filename name, const HashVal hash)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::get_version\n"
    "//       Access: Published\n"
    "//  Description: Returns the version number of this particular file,\n"
    "//               determined by looking up the hash generated from the\n"
    "//               file.  Returns -1 if the version number cannot be\n"
    "//               determined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_version_376_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HashVal const &DownloadDb::get_hash(Filename const &name, int version) const
 *******************************************************************/
static PyObject *Dtool_DownloadDb_get_hash_377(PyObject *self, PyObject *args,PyObject *kwds) {
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-HashVal const &DownloadDb::get_hash(Filename const &name, int version) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"name", (char *)"version", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:getHash", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.getHash", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    HashVal const *return_value = &(((const DownloadDb*)local_this)->get_hash(*param1_this, (int)param2));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_HashVal,false, true);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHash(const DownloadDb this, const Filename name, int version)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DownloadDb_get_hash_377_comment =
    "C++ Interface:\n"
    "getHash(const DownloadDb this, const Filename name, int version)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DownloadDb::get_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns the MD5 hash associated with the indicated\n"
    "//               version of the indicated file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DownloadDb_get_hash_377_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DownloadDb::DownloadDb(void)
 * DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
 * DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
 *******************************************************************/
int  Dtool_Init_DownloadDb(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DownloadDb::DownloadDb(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DownloadDb", key_word_list))
            {
                DownloadDb *return_value = new DownloadDb();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DownloadDb,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"server_file", (char *)"client_file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:DownloadDb", key_word_list, &param0, &param1))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DownloadDb.DownloadDb", 0, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.DownloadDb", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DownloadDb,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"server_file", (char *)"client_file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:DownloadDb", key_word_list, &param0, &param1))
                {
                    Ramfile *param0_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Ramfile, 0, "DownloadDb.DownloadDb", 0, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DownloadDb.DownloadDb", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DownloadDb,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DownloadDb() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DownloadDb()\n"
          "DownloadDb(non-const Filename server_file, non-const Filename client_file)\n"
          "DownloadDb(non-const Ramfile server_file, non-const Filename client_file)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DownloadDb(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DownloadDb)
    {
        printf("DownloadDb ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DownloadDb * local_this = (DownloadDb *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DownloadDb)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DownloadDb(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DownloadDb)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileHTTP 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileHTTP::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileHTTP_get_class_type_382(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileHTTP::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileHTTP::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileHTTP_get_class_type_382_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileHTTP_get_class_type_382_comment = NULL;
#endif

int  Dtool_Init_VirtualFileHTTP(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (VirtualFileHTTP)");
       return -1;
}
inline void  * Dtool_UpcastInterface_VirtualFileHTTP(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileHTTP)
    {
        printf("VirtualFileHTTP ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileHTTP * local_this = (VirtualFileHTTP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileHTTP)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_VirtualFile)
        return ( VirtualFile *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileHTTP(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileHTTP)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileHTTP*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileHTTP*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileHTTP*)other_this;
    }
    if(from_type == &Dtool_VirtualFile)
    {
          VirtualFile* other_this = (VirtualFile*)from_this;
          return (VirtualFileHTTP*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileMountHTTP 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline HTTPClient *VirtualFileMountHTTP::get_http_client(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountHTTP_get_http_client_386(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMountHTTP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMountHTTP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HTTPClient *VirtualFileMountHTTP::get_http_client(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHttpClient", key_word_list));
        else
            (PyArg_Parse(args, ":getHttpClient"));
        if(!PyErr_Occurred())
        {
            HTTPClient *return_value = ((const VirtualFileMountHTTP*)local_this)->get_http_client();
            if (return_value != (HTTPClient *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HTTPClient,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHttpClient(const VirtualFileMountHTTP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountHTTP_get_http_client_386_comment =
    "C++ Interface:\n"
    "getHttpClient(const VirtualFileMountHTTP this)\n"
    "\n"
    "// Filename: virtualFileMountHTTP.I\n"
    "// Created by:  drose (30Oct08)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMountHTTP::get_http_client\n"
    "//       Access: Published\n"
    "//  Description: Returns the HTTPClient object that services this\n"
    "//               mount point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMountHTTP_get_http_client_386_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline URLSpec const &VirtualFileMountHTTP::get_root(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountHTTP_get_root_387(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMountHTTP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMountHTTP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline URLSpec const &VirtualFileMountHTTP::get_root(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRoot", key_word_list));
        else
            (PyArg_Parse(args, ":getRoot"));
        if(!PyErr_Occurred())
        {
            URLSpec const *return_value = &(((const VirtualFileMountHTTP*)local_this)->get_root());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_URLSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRoot(const VirtualFileMountHTTP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountHTTP_get_root_387_comment =
    "C++ Interface:\n"
    "getRoot(const VirtualFileMountHTTP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMountHTTP::get_root\n"
    "//       Access: Published\n"
    "//  Description: Returns the URL that represents the root of this\n"
    "//               mount point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMountHTTP_get_root_387_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void VirtualFileMountHTTP::reload_vfs_mount_url(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_388(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void VirtualFileMountHTTP::reload_vfs_mount_url(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":reloadVfsMountUrl", key_word_list))
        {
            VirtualFileMountHTTP::reload_vfs_mount_url();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reloadVfsMountUrl()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_388_comment =
    "C++ Interface:\n"
    "reloadVfsMountUrl()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMountHTTP::reload_vfs_mount_url\n"
    "//       Access: Published, Static\n"
    "//  Description: Reads all of the vfs-mount-url lines in the\n"
    "//               Config.prc file and replaces the mount settings to\n"
    "//               match them.  \n"
    "//\n"
    "//               This will mount any url's mentioned in the config\n"
    "//               file, and unmount and unmount any url's no longer\n"
    "//               mentioned in the config file.  Normally, it is called\n"
    "//               automatically at startup, and need not be called\n"
    "//               again, unless you have fiddled with some config\n"
    "//               settings.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_388_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileMountHTTP::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountHTTP_get_class_type_389(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileMountHTTP::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileMountHTTP::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountHTTP_get_class_type_389_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileMountHTTP_get_class_type_389_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
 * VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http = ((get_global_ptr())))
 *******************************************************************/
int  Dtool_Init_VirtualFileMountHTTP(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http = ((get_global_ptr())))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"root", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:VirtualFileMountHTTP", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:VirtualFileMountHTTP", &param0));
                if(!PyErr_Occurred())
                {
                    URLSpec *param0_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_URLSpec, 0, "VirtualFileMountHTTP.VirtualFileMountHTTP", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_VirtualFileMountHTTP,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"root", (char *)"http", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:VirtualFileMountHTTP", key_word_list, &param0, &param1))
                {
                    URLSpec *param0_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_URLSpec, 0, "VirtualFileMountHTTP.VirtualFileMountHTTP", 1, coerced_ptr, report_errors);
HTTPClient *param1_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPClient, 1, "VirtualFileMountHTTP.VirtualFileMountHTTP", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*param0_this, param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_VirtualFileMountHTTP,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "VirtualFileMountHTTP() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "VirtualFileMountHTTP(const URLSpec root)\n"
          "VirtualFileMountHTTP(const URLSpec root, non-const HTTPClient http)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_VirtualFileMountHTTP(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileMountHTTP)
    {
        printf("VirtualFileMountHTTP ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileMountHTTP * local_this = (VirtualFileMountHTTP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileMountHTTP)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_VirtualFileMount)
        return ( VirtualFileMount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileMountHTTP(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileMountHTTP)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileMountHTTP*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileMountHTTP*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileMountHTTP*)other_this;
    }
    if(from_type == &Dtool_VirtualFileMount)
    {
          VirtualFileMount* other_this = (VirtualFileMount*)from_this;
          return (VirtualFileMountHTTP*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Extractor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool Extractor::set_multifile(Filename const &multifile_name)
 *******************************************************************/
static PyObject *Dtool_Extractor_set_multifile_393(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool Extractor::set_multifile(Filename const &multifile_name)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"multifile_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMultifile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMultifile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Extractor.setMultifile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_multifile(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Extractor.setMultifile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMultifile(non-const Extractor this, const Filename multifile_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_set_multifile_393_comment =
    "C++ Interface:\n"
    "setMultifile(non-const Extractor this, const Filename multifile_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::set_multifile\n"
    "//       Access: Published\n"
    "//  Description: Specifies the filename of the Multifile that the\n"
    "//               Extractor will read.  Returns true on success, false\n"
    "//               if the mulifile name is invalid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_set_multifile_393_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Extractor::set_extract_dir(Filename const &extract_dir)
 *******************************************************************/
static PyObject *Dtool_Extractor_set_extract_dir_394(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Extractor::set_extract_dir(Filename const &extract_dir)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"extract_dir", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setExtractDir", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setExtractDir", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Extractor.setExtractDir", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_extract_dir(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Extractor.setExtractDir() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExtractDir(non-const Extractor this, const Filename extract_dir)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_set_extract_dir_394_comment =
    "C++ Interface:\n"
    "setExtractDir(non-const Extractor this, const Filename extract_dir)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::set_extract_dir\n"
    "//       Access: Published\n"
    "//  Description: Specifies the directory into which all extracted\n"
    "//               subfiles will be written.  Relative paths of subfiles\n"
    "//               within the Multifile will be written as relative\n"
    "//               paths to this directory.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_set_extract_dir_394_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Extractor::reset(void)
 *******************************************************************/
static PyObject *Dtool_Extractor_reset_395(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Extractor::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Extractor.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const Extractor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_reset_395_comment =
    "C++ Interface:\n"
    "reset(non-const Extractor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::reset\n"
    "//       Access: Published\n"
    "//  Description: Interrupts the Extractor in the middle of its\n"
    "//               business and makes it ready to accept a new list of\n"
    "//               subfiles to extract.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_reset_395_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Extractor::request_subfile(Filename const &subfile_name)
 *******************************************************************/
static PyObject *Dtool_Extractor_request_subfile_396(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool Extractor::request_subfile(Filename const &subfile_name)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"subfile_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:requestSubfile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:requestSubfile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Extractor.requestSubfile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->request_subfile(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Extractor.requestSubfile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "requestSubfile(non-const Extractor this, const Filename subfile_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_request_subfile_396_comment =
    "C++ Interface:\n"
    "requestSubfile(non-const Extractor this, const Filename subfile_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::request_subfile\n"
    "//       Access: Published\n"
    "//  Description: Requests a particular subfile to be extracted when\n"
    "//               step() or run() is called.  Returns true if the\n"
    "//               subfile exists, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_request_subfile_396_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Extractor::request_all_subfiles(void)
 *******************************************************************/
static PyObject *Dtool_Extractor_request_all_subfiles_397(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int Extractor::request_all_subfiles(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":requestAllSubfiles", key_word_list));
        else
            (PyArg_Parse(args, ":requestAllSubfiles"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->request_all_subfiles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Extractor.requestAllSubfiles() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "requestAllSubfiles(non-const Extractor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_request_all_subfiles_397_comment =
    "C++ Interface:\n"
    "requestAllSubfiles(non-const Extractor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::request_all_subfiles\n"
    "//       Access: Published\n"
    "//  Description: Requests all subfiles in the Multifile to be\n"
    "//               extracted.  Returns the number requested.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_request_all_subfiles_397_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Extractor::step(void)
 *******************************************************************/
static PyObject *Dtool_Extractor_step_398(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int Extractor::step(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":step", key_word_list));
        else
            (PyArg_Parse(args, ":step"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->step();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Extractor.step() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "step(non-const Extractor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_step_398_comment =
    "C++ Interface:\n"
    "step(non-const Extractor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::step\n"
    "//       Access: Published\n"
    "//  Description: After all of the requests have been made via\n"
    "//               request_file() or request_all_subfiles(), call step()\n"
    "//               repeatedly until it stops returning EU_ok.\n"
    "//\n"
    "//               step() extracts the next small unit of data from the\n"
    "//               Multifile.  Returns EU_ok if progress is continuing,\n"
    "//               EU_error_abort if there is a problem, or EU_success\n"
    "//               when the last piece has been extracted.\n"
    "//\n"
    "//               Also see run().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_step_398_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Extractor::get_progress(void) const
 *******************************************************************/
static PyObject *Dtool_Extractor_get_progress_399(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Extractor::get_progress(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProgress", key_word_list));
        else
            (PyArg_Parse(args, ":getProgress"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Extractor*)local_this)->get_progress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProgress(const Extractor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_get_progress_399_comment =
    "C++ Interface:\n"
    "getProgress(const Extractor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::get_progress\n"
    "//       Access: Public\n"
    "//  Description: Returns the fraction of the Multifile extracted so\n"
    "//               far.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_get_progress_399_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Extractor::run(void)
 *******************************************************************/
static PyObject *Dtool_Extractor_run_400(PyObject *self, PyObject *args,PyObject *kwds) {
    Extractor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Extractor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Extractor::run(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":run", key_word_list));
        else
            (PyArg_Parse(args, ":run"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->run();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Extractor.run() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "run(non-const Extractor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Extractor_run_400_comment =
    "C++ Interface:\n"
    "run(non-const Extractor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Extractor::run\n"
    "//       Access: Published\n"
    "//  Description: A convenience function to extract the Multifile all\n"
    "//               at once, when you don't care about doing it in the\n"
    "//               background.\n"
    "//\n"
    "//               First, call request_file() or request_all_files() to\n"
    "//               specify the files you would like to extract, then\n"
    "//               call run() to do the extraction.  Also see step() for\n"
    "//               when you would like the extraction to happen as a\n"
    "//               background task.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Extractor_run_400_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Extractor::Extractor(void)
 *******************************************************************/
int  Dtool_Init_Extractor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Extractor::Extractor(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Extractor", key_word_list))
        {
            Extractor *return_value = new Extractor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Extractor,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Extractor()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Extractor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Extractor)
    {
        printf("Extractor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Extractor * local_this = (Extractor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Extractor)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Extractor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Extractor)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MultiplexStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void MultiplexStream::add_ostream(ostream *out, bool delete_later)
 * inline void MultiplexStream::add_ostream(ostream *out, bool delete_later = (0))
 *******************************************************************/
static PyObject *Dtool_MultiplexStream_add_ostream_403(PyObject *self, PyObject *args,PyObject *kwds) {
    MultiplexStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultiplexStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void MultiplexStream::add_ostream(ostream *out, bool delete_later = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addOstream", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addOstream", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MultiplexStream.addOstream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_ostream(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MultiplexStream.addOstream() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void MultiplexStream::add_ostream(ostream *out, bool delete_later)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"delete_later", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addOstream", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MultiplexStream.addOstream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_ostream(param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MultiplexStream.addOstream() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addOstream() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addOstream(non-const MultiplexStream this, non-const Ostream out)\n"
          "addOstream(non-const MultiplexStream this, non-const Ostream out, bool delete_later)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultiplexStream_add_ostream_403_comment =
    "C++ Interface:\n"
    "addOstream(non-const MultiplexStream this, non-const Ostream out)\n"
    "addOstream(non-const MultiplexStream this, non-const Ostream out, bool delete_later)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultiplexStream::add_ostream\n"
    "//       Access: Public\n"
    "//  Description: Adds the indicated generic ostream to the multiplex\n"
    "//               output.  The ostream will receive whatever data is\n"
    "//               sent to the pipe.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MultiplexStream_add_ostream_403_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MultiplexStream::add_standard_output(void)
 *******************************************************************/
static PyObject *Dtool_MultiplexStream_add_standard_output_405(PyObject *self, PyObject *args,PyObject *kwds) {
    MultiplexStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultiplexStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MultiplexStream::add_standard_output(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":addStandardOutput", key_word_list));
        else
            (PyArg_Parse(args, ":addStandardOutput"));
        if(!PyErr_Occurred())
        {
            (local_this)->add_standard_output();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MultiplexStream.addStandardOutput() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addStandardOutput(non-const MultiplexStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultiplexStream_add_standard_output_405_comment =
    "C++ Interface:\n"
    "addStandardOutput(non-const MultiplexStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultiplexStream::add_standard_output\n"
    "//       Access: Public\n"
    "//  Description: Adds the standard output channel.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MultiplexStream_add_standard_output_405_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MultiplexStream::add_file(Filename file)
 *******************************************************************/
static PyObject *Dtool_MultiplexStream_add_file_406(PyObject *self, PyObject *args,PyObject *kwds) {
    MultiplexStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultiplexStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool MultiplexStream::add_file(Filename file)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"file", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addFile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "MultiplexStream.addFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_file(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MultiplexStream.addFile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFile(non-const MultiplexStream this, const Filename file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultiplexStream_add_file_406_comment =
    "C++ Interface:\n"
    "addFile(non-const MultiplexStream this, const Filename file)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultiplexStream::add_file\n"
    "//       Access: Public\n"
    "//  Description: Adds the given file to the multiplex output.  The\n"
    "//               file is opened in append mode with line buffering.\n"
    "//               Returns false if the file cannot be opened.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MultiplexStream_add_file_406_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MultiplexStream::add_system_debug(void)
 *******************************************************************/
static PyObject *Dtool_MultiplexStream_add_system_debug_407(PyObject *self, PyObject *args,PyObject *kwds) {
    MultiplexStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultiplexStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MultiplexStream::add_system_debug(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":addSystemDebug", key_word_list));
        else
            (PyArg_Parse(args, ":addSystemDebug"));
        if(!PyErr_Occurred())
        {
            (local_this)->add_system_debug();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MultiplexStream.addSystemDebug() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSystemDebug(non-const MultiplexStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultiplexStream_add_system_debug_407_comment =
    "C++ Interface:\n"
    "addSystemDebug(non-const MultiplexStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultiplexStream::add_system_debug\n"
    "//       Access: Public\n"
    "//  Description: Adds the system debug output the the multiplex\n"
    "//               output.  This may map to a syslog or some such\n"
    "//               os-specific output system.  It may do nothing on a\n"
    "//               particular system.\n"
    "//\n"
    "//               Presently, this maps only to OutputDebugString() on\n"
    "//               Windows.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MultiplexStream_add_system_debug_407_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MultiplexStream::flush(void)
 *******************************************************************/
static PyObject *Dtool_MultiplexStream_flush_408(PyObject *self, PyObject *args,PyObject *kwds) {
    MultiplexStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultiplexStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MultiplexStream::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MultiplexStream.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const MultiplexStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultiplexStream_flush_408_comment =
    "C++ Interface:\n"
    "flush(non-const MultiplexStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultiplexStream::flush\n"
    "//       Access: Public\n"
    "//  Description: Forces out all output that hasn't yet been written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MultiplexStream_flush_408_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MultiplexStream::MultiplexStream(void)
 *******************************************************************/
int  Dtool_Init_MultiplexStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline MultiplexStream::MultiplexStream(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":MultiplexStream", key_word_list))
        {
            MultiplexStream *return_value = new MultiplexStream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MultiplexStream,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MultiplexStream()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MultiplexStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MultiplexStream)
    {
        printf("MultiplexStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MultiplexStream * local_this = (MultiplexStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MultiplexStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MultiplexStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MultiplexStream)
        return from_this;
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (MultiplexStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Patcher 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int Patcher::initiate(Filename &patch, Filename &infile)
 *******************************************************************/
static PyObject *Dtool_Patcher_initiate_413(PyObject *self, PyObject *args,PyObject *kwds) {
    Patcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int Patcher::initiate(Filename &patch, Filename &infile)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"patch", (char *)"infile", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:initiate", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patcher.initiate", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Patcher.initiate", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    int return_value = (local_this)->initiate(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Patcher.initiate() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initiate(non-const Patcher this, non-const Filename patch, non-const Filename infile)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patcher_initiate_413_comment =
    "C++ Interface:\n"
    "initiate(non-const Patcher this, non-const Filename patch, non-const Filename infile)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patcher::initiate\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patcher_initiate_413_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Patcher::run(void)
 *******************************************************************/
static PyObject *Dtool_Patcher_run_414(PyObject *self, PyObject *args,PyObject *kwds) {
    Patcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int Patcher::run(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":run", key_word_list));
        else
            (PyArg_Parse(args, ":run"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->run();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patcher.run() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "run(non-const Patcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patcher_run_414_comment =
    "C++ Interface:\n"
    "run(non-const Patcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patcher::run\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patcher_run_414_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float Patcher::get_progress(void) const
 *******************************************************************/
static PyObject *Dtool_Patcher_get_progress_415(PyObject *self, PyObject *args,PyObject *kwds) {
    Patcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float Patcher::get_progress(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProgress", key_word_list));
        else
            (PyArg_Parse(args, ":getProgress"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Patcher*)local_this)->get_progress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProgress(const Patcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patcher_get_progress_415_comment =
    "C++ Interface:\n"
    "getProgress(const Patcher this)\n"
    "\n"
    "// Filename: patcher.I\n"
    "// Created by:  darren (20Dec00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patcher::get_progress\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patcher_get_progress_415_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Patcher::Patcher(void)
 * Patcher::Patcher(PointerTo< Buffer > buffer)
 *******************************************************************/
int  Dtool_Init_Patcher(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-Patcher::Patcher(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Patcher", key_word_list))
            {
                Patcher *return_value = new Patcher();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Patcher,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-Patcher::Patcher(PointerTo< Buffer > buffer)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"buffer", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Patcher", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Patcher", &param0));
                if(!PyErr_Occurred())
                {
                    Buffer *param0_this = (Buffer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Buffer, 0, "Patcher.Patcher", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        Patcher *return_value = new Patcher(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Patcher,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Patcher() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Patcher()\n"
          "Patcher(const Buffer buffer)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Patcher(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Patcher)
    {
        printf("Patcher ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Patcher * local_this = (Patcher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Patcher)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Patcher(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Patcher)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StringStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void StringStream::clear_data(void)
 *******************************************************************/
static PyObject *Dtool_StringStream_clear_data_418(PyObject *self, PyObject *args,PyObject *kwds) {
    StringStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StringStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StringStream::clear_data(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearData", key_word_list));
        else
            (PyArg_Parse(args, ":clearData"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StringStream.clearData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearData(non-const StringStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StringStream_clear_data_418_comment =
    "C++ Interface:\n"
    "clearData(non-const StringStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StringStream::clear_data\n"
    "//       Access: Published\n"
    "//  Description: Empties the buffer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StringStream_clear_data_418_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int StringStream::get_data_size(void)
 *******************************************************************/
static PyObject *Dtool_StringStream_get_data_size_419(PyObject *self, PyObject *args,PyObject *kwds) {
    StringStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StringStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int StringStream::get_data_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDataSize", key_word_list));
        else
            (PyArg_Parse(args, ":getDataSize"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_data_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StringStream.getDataSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDataSize(non-const StringStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StringStream_get_data_size_419_comment =
    "C++ Interface:\n"
    "getDataSize(non-const StringStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StringStream::get_data_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of characters available to be read\n"
    "//               from the data stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StringStream_get_data_size_419_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > StringStream::get_data(void)
 *******************************************************************/
static PyObject *Dtool_StringStream_get_data_420(PyObject *self, PyObject *args,PyObject *kwds) {
    StringStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StringStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > StringStream::get_data(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StringStream.getData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(non-const StringStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StringStream_get_data_420_comment =
    "C++ Interface:\n"
    "getData(non-const StringStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StringStream::get_data\n"
    "//       Access: Published\n"
    "//  Description: Returns the contents of the data stream as a string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StringStream_get_data_420_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StringStream::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_StringStream_set_data_421(PyObject *self, PyObject *args,PyObject *kwds) {
    StringStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StringStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StringStream::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StringStream.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const StringStream this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StringStream_set_data_421_comment =
    "C++ Interface:\n"
    "setData(non-const StringStream this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StringStream::set_data\n"
    "//       Access: Published\n"
    "//  Description: Replaces the contents of the data stream.  This\n"
    "//               implicitly reseeks to 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StringStream_set_data_421_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StringStream::StringStream(void)
 * inline StringStream::StringStream(basic_string< char > const &source)
 *******************************************************************/
int  Dtool_Init_StringStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline StringStream::StringStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":StringStream", key_word_list))
            {
                StringStream *return_value = new StringStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StringStream,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline StringStream::StringStream(basic_string< char > const &source)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:StringStream", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:StringStream", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                StringStream *return_value = new StringStream(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StringStream,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "StringStream() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "StringStream()\n"
          "StringStream(string source)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StringStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StringStream)
    {
        printf("StringStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StringStream * local_this = (StringStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StringStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_iostream)
        return ( iostream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *)( iostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StringStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StringStream)
        return from_this;
    if(from_type == &Dtool_iostream)
    {
          iostream* other_this = (iostream*)from_this;
          return (StringStream*)other_this;
    }
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (StringStream*)other_this;
    }
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (StringStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. SSReader | SSReader
//********************************************************************
PyMethodDef Dtool_Methods_SSReader[]= {
  { "receiveDatagram",(PyCFunction ) &Dtool_SSReader_receive_datagram_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_receive_datagram_3_comment},
  { "isClosed",(PyCFunction ) &Dtool_SSReader_is_closed_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_is_closed_4_comment},
  { "close",(PyCFunction ) &Dtool_SSReader_close_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_close_5_comment},
  { "setTcpHeaderSize",(PyCFunction ) &Dtool_SSReader_set_tcp_header_size_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_set_tcp_header_size_6_comment},
  { "getTcpHeaderSize",(PyCFunction ) &Dtool_SSReader_get_tcp_header_size_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_get_tcp_header_size_7_comment},
  { "downcastToISocketStream",(PyCFunction ) &Dtool_SSReader_downcast_to_ISocketStream_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_downcast_to_ISocketStream_26_comment},
  { "downcastToSocketStream",(PyCFunction ) &Dtool_SSReader_downcast_to_SocketStream_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSReader_downcast_to_SocketStream_47_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SSReader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SSReader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SSReader\n"
          "// Description : An internal class for reading from a socket stream.\n"
          "//               This serves as a base class for both ISocketStream\n"
          "//               and SocketStream; its purpose is to minimize\n"
          "//               redundant code between them.  Do not use it directly.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SSReader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SSReader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SSReader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SSReader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SSReader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SSReader)");
             printf(" Error In PyType_ReadySSReader");
             return;
        }
        Py_INCREF(&Dtool_SSReader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SSReader.As_PyTypeObject().tp_dict,"SSReader",&Dtool_SSReader.As_PyObject());
        RegisterRuntimeClass(&Dtool_SSReader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SSReader.As_PyTypeObject());
        PyModule_AddObject(module, "SSReader",(PyObject *)&Dtool_SSReader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SSWriter | SSWriter
//********************************************************************
PyMethodDef Dtool_Methods_SSWriter[]= {
  { "sendDatagram",(PyCFunction ) &Dtool_SSWriter_send_datagram_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_send_datagram_10_comment},
  { "isClosed",(PyCFunction ) &Dtool_SSWriter_is_closed_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_is_closed_11_comment},
  { "close",(PyCFunction ) &Dtool_SSWriter_close_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_close_12_comment},
  { "setCollectTcp",(PyCFunction ) &Dtool_SSWriter_set_collect_tcp_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_set_collect_tcp_13_comment},
  { "getCollectTcp",(PyCFunction ) &Dtool_SSWriter_get_collect_tcp_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_get_collect_tcp_14_comment},
  { "setCollectTcpInterval",(PyCFunction ) &Dtool_SSWriter_set_collect_tcp_interval_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_set_collect_tcp_interval_15_comment},
  { "getCollectTcpInterval",(PyCFunction ) &Dtool_SSWriter_get_collect_tcp_interval_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_get_collect_tcp_interval_16_comment},
  { "setTcpHeaderSize",(PyCFunction ) &Dtool_SSWriter_set_tcp_header_size_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_set_tcp_header_size_17_comment},
  { "getTcpHeaderSize",(PyCFunction ) &Dtool_SSWriter_get_tcp_header_size_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_get_tcp_header_size_18_comment},
  { "considerFlush",(PyCFunction ) &Dtool_SSWriter_consider_flush_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_consider_flush_19_comment},
  { "flush",(PyCFunction ) &Dtool_SSWriter_flush_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_flush_20_comment},
  { "downcastToOSocketStream",(PyCFunction ) &Dtool_SSWriter_downcast_to_OSocketStream_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_downcast_to_OSocketStream_37_comment},
  { "downcastToSocketStream",(PyCFunction ) &Dtool_SSWriter_downcast_to_SocketStream_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SSWriter_downcast_to_SocketStream_49_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SSWriter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SSWriter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SSWriter\n"
          "// Description : An internal class for writing to a socket stream.\n"
          "//               This serves as a base class for both OSocketStream\n"
          "//               and SocketStream; its purpose is to minimize\n"
          "//               redundant code between them.  Do not use it directly.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SSWriter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SSWriter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SSWriter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SSWriter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SSWriter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SSWriter)");
             printf(" Error In PyType_ReadySSWriter");
             return;
        }
        Py_INCREF(&Dtool_SSWriter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SSWriter.As_PyTypeObject().tp_dict,"SSWriter",&Dtool_SSWriter.As_PyObject());
        RegisterRuntimeClass(&Dtool_SSWriter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SSWriter.As_PyTypeObject());
        PyModule_AddObject(module, "SSWriter",(PyObject *)&Dtool_SSWriter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ISocketStream | ISocketStream
//********************************************************************
PyMethodDef Dtool_Methods_ISocketStream[]= {
  { "isClosed",(PyCFunction ) &Dtool_ISocketStream_is_closed_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISocketStream_is_closed_29_comment},
  { "close",(PyCFunction ) &Dtool_ISocketStream_close_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISocketStream_close_30_comment},
  { "getReadState",(PyCFunction ) &Dtool_ISocketStream_get_read_state_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISocketStream_get_read_state_31_comment},
  { "upcastToIstream",(PyCFunction ) &Dtool_ISocketStream_upcast_to_istream_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISocketStream_upcast_to_istream_23_comment},
  { "upcastToSSReader",(PyCFunction ) &Dtool_ISocketStream_upcast_to_SSReader_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISocketStream_upcast_to_SSReader_25_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ISocketStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ISocketStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ISocketStream\n"
          "// Description : This is a base class for istreams implemented in\n"
          "//               Panda that read from a (possibly non-blocking)\n"
          "//               socket.  It adds is_closed(), which can be called\n"
          "//               after an eof condition to check whether the socket\n"
          "//               has been closed, or whether more data may be\n"
          "//               available later.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_SSReader._Dtool_ClassInit(NULL);
        Dtool_ISocketStream.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_istream.As_PyTypeObject(),&Dtool_SSReader.As_PyTypeObject());
        Dtool_ISocketStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ISocketStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ISocketStream.As_PyTypeObject().tp_dict);
        // Enum  ISocketStream::ReadState;
        PyDict_SetItemString(Dtool_ISocketStream.As_PyTypeObject().tp_dict,"RSInitial",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_ISocketStream.As_PyTypeObject().tp_dict,"RSReading",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_ISocketStream.As_PyTypeObject().tp_dict,"RSComplete",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_ISocketStream.As_PyTypeObject().tp_dict,"RSError",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_ISocketStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ISocketStream)");
             printf(" Error In PyType_ReadyISocketStream");
             return;
        }
        Py_INCREF(&Dtool_ISocketStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ISocketStream.As_PyTypeObject().tp_dict,"ISocketStream",&Dtool_ISocketStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_ISocketStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ISocketStream.As_PyTypeObject());
        PyModule_AddObject(module, "ISocketStream",(PyObject *)&Dtool_ISocketStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OSocketStream | OSocketStream
//********************************************************************
PyMethodDef Dtool_Methods_OSocketStream[]= {
  { "isClosed",(PyCFunction ) &Dtool_OSocketStream_is_closed_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OSocketStream_is_closed_38_comment},
  { "close",(PyCFunction ) &Dtool_OSocketStream_close_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OSocketStream_close_39_comment},
  { "flush",(PyCFunction ) &Dtool_OSocketStream_flush_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OSocketStream_flush_40_comment},
  { "upcastToOstream",(PyCFunction ) &Dtool_OSocketStream_upcast_to_ostream_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OSocketStream_upcast_to_ostream_34_comment},
  { "upcastToSSWriter",(PyCFunction ) &Dtool_OSocketStream_upcast_to_SSWriter_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OSocketStream_upcast_to_SSWriter_36_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OSocketStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OSocketStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OSocketStream\n"
          "// Description : A base class for ostreams that write to a (possibly\n"
          "//               non-blocking) socket.  It adds is_closed(), which can\n"
          "//               be called after any write operation fails to check\n"
          "//               whether the socket has been closed, or whether more\n"
          "//               data may be sent later.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_SSWriter._Dtool_ClassInit(NULL);
        Dtool_OSocketStream.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_ostream.As_PyTypeObject(),&Dtool_SSWriter.As_PyTypeObject());
        Dtool_OSocketStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OSocketStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OSocketStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OSocketStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OSocketStream)");
             printf(" Error In PyType_ReadyOSocketStream");
             return;
        }
        Py_INCREF(&Dtool_OSocketStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OSocketStream.As_PyTypeObject().tp_dict,"OSocketStream",&Dtool_OSocketStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_OSocketStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OSocketStream.As_PyTypeObject());
        PyModule_AddObject(module, "OSocketStream",(PyObject *)&Dtool_OSocketStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SocketStream | SocketStream
//********************************************************************
PyMethodDef Dtool_Methods_SocketStream[]= {
  { "isClosed",(PyCFunction ) &Dtool_SocketStream_is_closed_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_is_closed_50_comment},
  { "close",(PyCFunction ) &Dtool_SocketStream_close_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_close_51_comment},
  { "setTcpHeaderSize",(PyCFunction ) &Dtool_SocketStream_set_tcp_header_size_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_set_tcp_header_size_52_comment},
  { "getTcpHeaderSize",(PyCFunction ) &Dtool_SocketStream_get_tcp_header_size_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_get_tcp_header_size_53_comment},
  { "flush",(PyCFunction ) &Dtool_SocketStream_flush_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_flush_54_comment},
  { "upcastToIostream",(PyCFunction ) &Dtool_SocketStream_upcast_to_iostream_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_upcast_to_iostream_44_comment},
  { "upcastToSSReader",(PyCFunction ) &Dtool_SocketStream_upcast_to_SSReader_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_upcast_to_SSReader_46_comment},
  { "upcastToSSWriter",(PyCFunction ) &Dtool_SocketStream_upcast_to_SSWriter_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SocketStream_upcast_to_SSWriter_48_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SocketStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SocketStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SocketStream\n"
          "// Description : A base class for iostreams that read and write to a\n"
          "//               (possibly non-blocking) socket.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_iostream._Dtool_ClassInit(NULL);
        Dtool_SSReader._Dtool_ClassInit(NULL);
        Dtool_SSWriter._Dtool_ClassInit(NULL);
        Dtool_SocketStream.As_PyTypeObject().tp_bases = Py_BuildValue("(OOO)",&Dtool_iostream.As_PyTypeObject(),&Dtool_SSReader.As_PyTypeObject(),&Dtool_SSWriter.As_PyTypeObject());
        Dtool_SocketStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SocketStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SocketStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SocketStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SocketStream)");
             printf(" Error In PyType_ReadySocketStream");
             return;
        }
        Py_INCREF(&Dtool_SocketStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SocketStream.As_PyTypeObject().tp_dict,"SocketStream",&Dtool_SocketStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_SocketStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SocketStream.As_PyTypeObject());
        PyModule_AddObject(module, "SocketStream",(PyObject *)&Dtool_SocketStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. URLSpec | URLSpec
//********************************************************************
PyMethodDef Dtool_Methods_URLSpec[]= {
  { "assign",(PyCFunction ) &Dtool_URLSpec_operator_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_operator_58_comment},
  { "eq",(PyCFunction ) &Dtool_URLSpec_operator_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_operator_59_comment},
  { "ne",(PyCFunction ) &Dtool_URLSpec_operator_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_operator_60_comment},
  { "lessThan",(PyCFunction ) &Dtool_URLSpec_operator_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_operator_61_comment},
  { "compareTo",(PyCFunction ) &Dtool_URLSpec_compare_to_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_compare_to_62_comment},
  { "hasScheme",(PyCFunction ) &Dtool_URLSpec_has_scheme_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_scheme_63_comment},
  { "hasAuthority",(PyCFunction ) &Dtool_URLSpec_has_authority_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_authority_64_comment},
  { "hasUsername",(PyCFunction ) &Dtool_URLSpec_has_username_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_username_65_comment},
  { "hasServer",(PyCFunction ) &Dtool_URLSpec_has_server_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_server_66_comment},
  { "hasPort",(PyCFunction ) &Dtool_URLSpec_has_port_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_port_67_comment},
  { "hasPath",(PyCFunction ) &Dtool_URLSpec_has_path_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_path_68_comment},
  { "hasQuery",(PyCFunction ) &Dtool_URLSpec_has_query_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_has_query_69_comment},
  { "getScheme",(PyCFunction ) &Dtool_URLSpec_get_scheme_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_scheme_70_comment},
  { "getAuthority",(PyCFunction ) &Dtool_URLSpec_get_authority_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_authority_71_comment},
  { "getUsername",(PyCFunction ) &Dtool_URLSpec_get_username_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_username_72_comment},
  { "getServer",(PyCFunction ) &Dtool_URLSpec_get_server_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_server_73_comment},
  { "getPortStr",(PyCFunction ) &Dtool_URLSpec_get_port_str_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_port_str_74_comment},
  { "getPort",(PyCFunction ) &Dtool_URLSpec_get_port_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_port_75_comment},
  { "getServerAndPort",(PyCFunction ) &Dtool_URLSpec_get_server_and_port_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_server_and_port_76_comment},
  { "isDefaultPort",(PyCFunction ) &Dtool_URLSpec_is_default_port_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_is_default_port_77_comment},
  { "getDefaultPortForScheme",(PyCFunction ) &Dtool_URLSpec_get_default_port_for_scheme_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_default_port_for_scheme_78_comment},
  { "getPath",(PyCFunction ) &Dtool_URLSpec_get_path_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_path_79_comment},
  { "getQuery",(PyCFunction ) &Dtool_URLSpec_get_query_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_query_80_comment},
  { "getPathAndQuery",(PyCFunction ) &Dtool_URLSpec_get_path_and_query_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_path_and_query_81_comment},
  { "isSsl",(PyCFunction ) &Dtool_URLSpec_is_ssl_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_is_ssl_82_comment},
  { "getUrl",(PyCFunction ) &Dtool_URLSpec_get_url_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_get_url_83_comment},
  { "setScheme",(PyCFunction ) &Dtool_URLSpec_set_scheme_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_scheme_84_comment},
  { "setAuthority",(PyCFunction ) &Dtool_URLSpec_set_authority_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_authority_85_comment},
  { "setUsername",(PyCFunction ) &Dtool_URLSpec_set_username_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_username_86_comment},
  { "setServer",(PyCFunction ) &Dtool_URLSpec_set_server_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_server_87_comment},
  { "setPort",(PyCFunction ) &Dtool_URLSpec_set_port_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_port_88_comment},
  { "setServerAndPort",(PyCFunction ) &Dtool_URLSpec_set_server_and_port_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_server_and_port_89_comment},
  { "setPath",(PyCFunction ) &Dtool_URLSpec_set_path_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_path_90_comment},
  { "setQuery",(PyCFunction ) &Dtool_URLSpec_set_query_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_query_91_comment},
  { "setUrl",(PyCFunction ) &Dtool_URLSpec_set_url_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_set_url_92_comment},
  { "cStr",(PyCFunction ) &Dtool_URLSpec_c_str_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_c_str_94_comment},
  { "empty",(PyCFunction ) &Dtool_URLSpec_empty_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_empty_95_comment},
  { "length",(PyCFunction ) &Dtool_URLSpec_length_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_length_96_comment},
  { "__getitem__",(PyCFunction ) &Dtool_URLSpec_operator_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_operator_97_comment},
  { "input",(PyCFunction ) &Dtool_URLSpec_input_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_input_98_comment},
  { "output",(PyCFunction ) &Dtool_URLSpec_output_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_output_99_comment},
  { "quote",(PyCFunction ) &Dtool_URLSpec_quote_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_quote_100_comment},
  { "quotePlus",(PyCFunction ) &Dtool_URLSpec_quote_plus_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_quote_plus_101_comment},
  { "unquote",(PyCFunction ) &Dtool_URLSpec_unquote_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_unquote_102_comment},
  { "unquotePlus",(PyCFunction ) &Dtool_URLSpec_unquote_plus_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_unquote_plus_103_comment},
  { "operatorTypecast",(PyCFunction ) &Dtool_URLSpec_operator_typecast_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_URLSpec_operator_typecast_93_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     URLSpec ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_URLSpec_operator_97__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_URLSpec_operator_97(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     URLSpec
//////////////////
static PyObject *  Dtool_Repr_URLSpec(PyObject * self)
{
    URLSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_URLSpec,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_URLSpec(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_URLSpec.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : URLSpec\n"
          "// Description : A container for a URL, e.g. \"http://server:port/path\".\n"
          "//\n"
          "//               The URLSpec object is similar to a Filename in that\n"
          "//               it contains logic to identify the various parts of a\n"
          "//               URL and return (or modify) them separately.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_URLSpec.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_URLSpec.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_URLSpec.As_PyTypeObject().tp_dict);
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_URLSpec.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_URLSpec_operator_97__getitem__;
        // __repr__
        Dtool_URLSpec.As_PyTypeObject().tp_repr = & Dtool_Repr_URLSpec;
        // __str__ Repr Proxy
        Dtool_URLSpec.As_PyTypeObject().tp_str = & Dtool_Repr_URLSpec;
        if(PyType_Ready(&Dtool_URLSpec.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(URLSpec)");
             printf(" Error In PyType_ReadyURLSpec");
             return;
        }
        Py_INCREF(&Dtool_URLSpec.As_PyTypeObject());
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"URLSpec",&Dtool_URLSpec.As_PyObject());
        //  Static Method getDefaultPortForScheme
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"getDefaultPortForScheme",PyCFunction_New(&Dtool_Methods_URLSpec[20],&Dtool_URLSpec.As_PyObject()));
        //  Static Method quote
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"quote",PyCFunction_New(&Dtool_Methods_URLSpec[41],&Dtool_URLSpec.As_PyObject()));
        //  Static Method quotePlus
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"quotePlus",PyCFunction_New(&Dtool_Methods_URLSpec[42],&Dtool_URLSpec.As_PyObject()));
        //  Static Method unquote
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"unquote",PyCFunction_New(&Dtool_Methods_URLSpec[43],&Dtool_URLSpec.As_PyObject()));
        //  Static Method unquotePlus
        PyDict_SetItemString(Dtool_URLSpec.As_PyTypeObject().tp_dict,"unquotePlus",PyCFunction_New(&Dtool_Methods_URLSpec[44],&Dtool_URLSpec.As_PyObject()));
        RegisterRuntimeClass(&Dtool_URLSpec,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_URLSpec.As_PyTypeObject());
        PyModule_AddObject(module, "URLSpec",(PyObject *)&Dtool_URLSpec.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HTTPEnum | HTTPEnum
//********************************************************************
PyMethodDef Dtool_Methods_HTTPEnum[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_HTTPEnum(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HTTPEnum.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HTTPEnum\n"
          "// Description : This class is just used as a namespace wrapper for\n"
          "//               some of the enumerated types used by various classes\n"
          "//               within the HTTPClient family.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_HTTPEnum.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_HTTPEnum.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HTTPEnum.As_PyTypeObject().tp_dict);
        // Enum  HTTPEnum::HTTPVersion;
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"HV09",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"HV10",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"HV11",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"HVOther",PyInt_FromLong(3));
        // Enum  HTTPEnum::Method;
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MOptions",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MGet",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MHead",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MPost",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MPut",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MDelete",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MTrace",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"MConnect",PyInt_FromLong(7));
        if(PyType_Ready(&Dtool_HTTPEnum.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HTTPEnum)");
             printf(" Error In PyType_ReadyHTTPEnum");
             return;
        }
        Py_INCREF(&Dtool_HTTPEnum.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HTTPEnum.As_PyTypeObject().tp_dict,"HTTPEnum",&Dtool_HTTPEnum.As_PyObject());
        RegisterRuntimeClass(&Dtool_HTTPEnum,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HTTPEnum.As_PyTypeObject());
        PyModule_AddObject(module, "HTTPEnum",(PyObject *)&Dtool_HTTPEnum.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HTTPDate | HTTPDate
//********************************************************************
PyMethodDef Dtool_Methods_HTTPDate[]= {
  { "assign",(PyCFunction ) &Dtool_HTTPDate_operator_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_111_comment},
  { "now",(PyCFunction ) &Dtool_HTTPDate_now_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_now_112_comment},
  { "isValid",(PyCFunction ) &Dtool_HTTPDate_is_valid_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_is_valid_113_comment},
  { "getString",(PyCFunction ) &Dtool_HTTPDate_get_string_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_get_string_114_comment},
  { "getTime",(PyCFunction ) &Dtool_HTTPDate_get_time_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_get_time_115_comment},
  { "eq",(PyCFunction ) &Dtool_HTTPDate_operator_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_116_comment},
  { "ne",(PyCFunction ) &Dtool_HTTPDate_operator_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_117_comment},
  { "lessThan",(PyCFunction ) &Dtool_HTTPDate_operator_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_118_comment},
  { "greaterThan",(PyCFunction ) &Dtool_HTTPDate_operator_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_119_comment},
  { "compareTo",(PyCFunction ) &Dtool_HTTPDate_compare_to_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_compare_to_120_comment},
  { "__iadd__",(PyCFunction ) &Dtool_HTTPDate_operator_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_121_comment},
  { "__isub__",(PyCFunction ) &Dtool_HTTPDate_operator_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_122_comment},
  { "__add__",(PyCFunction ) &Dtool_HTTPDate_operator_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_123_comment},
  { "__sub__",(PyCFunction ) &Dtool_HTTPDate_operator_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_operator_124_comment},
  { "input",(PyCFunction ) &Dtool_HTTPDate_input_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_input_125_comment},
  { "output",(PyCFunction ) &Dtool_HTTPDate_output_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPDate_output_126_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     HTTPDate ...tp_as_number->nb_subtract = __sub__
//////////////////
static PyObject *Dtool_HTTPDate_operator_124__sub__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_HTTPDate_operator_124(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     HTTPDate ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_HTTPDate_operator_121__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_HTTPDate_operator_121(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     HTTPDate ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_HTTPDate_operator_123__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_HTTPDate_operator_123(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     HTTPDate ...tp_as_number->nb_inplace_subtract = __isub__
//////////////////
static PyObject *Dtool_HTTPDate_operator_122__isub__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_HTTPDate_operator_122(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     HTTPDate
//////////////////
static PyObject *  Dtool_Repr_HTTPDate(PyObject * self)
{
    HTTPDate * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPDate,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_HTTPDate(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HTTPDate.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HTTPDate\n"
          "// Description : A container for an HTTP-legal time/date indication.\n"
          "//               This can accept a string from an HTTP header and will\n"
          "//               decode it into a C time_t value; conversely, it can\n"
          "//               accept a time_t value and encode it for output as a\n"
          "//               string.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_HTTPDate.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_HTTPDate.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HTTPDate.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HTTPDate.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_subtract = __sub__
        Dtool_HTTPDate.As_PyTypeObject().tp_as_number->nb_subtract = &Dtool_HTTPDate_operator_124__sub__;
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_HTTPDate.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_HTTPDate_operator_121__iadd__;
        // tp_as_number->nb_add = __add__
        Dtool_HTTPDate.As_PyTypeObject().tp_as_number->nb_add = &Dtool_HTTPDate_operator_123__add__;
        // tp_as_number->nb_inplace_subtract = __isub__
        Dtool_HTTPDate.As_PyTypeObject().tp_as_number->nb_inplace_subtract = &Dtool_HTTPDate_operator_122__isub__;
        // __repr__
        Dtool_HTTPDate.As_PyTypeObject().tp_repr = & Dtool_Repr_HTTPDate;
        // __str__ Repr Proxy
        Dtool_HTTPDate.As_PyTypeObject().tp_str = & Dtool_Repr_HTTPDate;
        if(PyType_Ready(&Dtool_HTTPDate.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HTTPDate)");
             printf(" Error In PyType_ReadyHTTPDate");
             return;
        }
        Py_INCREF(&Dtool_HTTPDate.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HTTPDate.As_PyTypeObject().tp_dict,"HTTPDate",&Dtool_HTTPDate.As_PyObject());
        //  Static Method now
        PyDict_SetItemString(Dtool_HTTPDate.As_PyTypeObject().tp_dict,"now",PyCFunction_New(&Dtool_Methods_HTTPDate[1],&Dtool_HTTPDate.As_PyObject()));
        RegisterRuntimeClass(&Dtool_HTTPDate,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HTTPDate.As_PyTypeObject());
        PyModule_AddObject(module, "HTTPDate",(PyObject *)&Dtool_HTTPDate.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HTTPCookie | HTTPCookie
//********************************************************************
PyMethodDef Dtool_Methods_HTTPCookie[]= {
  { "setName",(PyCFunction ) &Dtool_HTTPCookie_set_name_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_set_name_131_comment},
  { "getName",(PyCFunction ) &Dtool_HTTPCookie_get_name_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_get_name_132_comment},
  { "setValue",(PyCFunction ) &Dtool_HTTPCookie_set_value_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_set_value_133_comment},
  { "getValue",(PyCFunction ) &Dtool_HTTPCookie_get_value_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_get_value_134_comment},
  { "setDomain",(PyCFunction ) &Dtool_HTTPCookie_set_domain_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_set_domain_135_comment},
  { "getDomain",(PyCFunction ) &Dtool_HTTPCookie_get_domain_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_get_domain_136_comment},
  { "setPath",(PyCFunction ) &Dtool_HTTPCookie_set_path_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_set_path_137_comment},
  { "getPath",(PyCFunction ) &Dtool_HTTPCookie_get_path_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_get_path_138_comment},
  { "setExpires",(PyCFunction ) &Dtool_HTTPCookie_set_expires_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_set_expires_139_comment},
  { "clearExpires",(PyCFunction ) &Dtool_HTTPCookie_clear_expires_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_clear_expires_140_comment},
  { "hasExpires",(PyCFunction ) &Dtool_HTTPCookie_has_expires_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_has_expires_141_comment},
  { "getExpires",(PyCFunction ) &Dtool_HTTPCookie_get_expires_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_get_expires_142_comment},
  { "setSecure",(PyCFunction ) &Dtool_HTTPCookie_set_secure_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_set_secure_143_comment},
  { "getSecure",(PyCFunction ) &Dtool_HTTPCookie_get_secure_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_get_secure_144_comment},
  { "lessThan",(PyCFunction ) &Dtool_HTTPCookie_operator_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_operator_145_comment},
  { "updateFrom",(PyCFunction ) &Dtool_HTTPCookie_update_from_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_update_from_146_comment},
  { "parseSetCookie",(PyCFunction ) &Dtool_HTTPCookie_parse_set_cookie_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_parse_set_cookie_147_comment},
  { "isExpired",(PyCFunction ) &Dtool_HTTPCookie_is_expired_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_is_expired_148_comment},
  { "matchesUrl",(PyCFunction ) &Dtool_HTTPCookie_matches_url_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_matches_url_149_comment},
  { "output",(PyCFunction ) &Dtool_HTTPCookie_output_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPCookie_output_150_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     HTTPCookie
//////////////////
static PyObject *  Dtool_Repr_HTTPCookie(PyObject * self)
{
    HTTPCookie * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPCookie,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_HTTPCookie(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HTTPCookie.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HTTPCookie\n"
          "// Description : A cookie sent from an HTTP server to be stored on the\n"
          "//               client and returned when the path and/or domain\n"
          "//               matches.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_HTTPCookie.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_HTTPCookie.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HTTPCookie.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HTTPCookie.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_HTTPCookie.As_PyTypeObject().tp_repr = & Dtool_Repr_HTTPCookie;
        // __str__ Repr Proxy
        Dtool_HTTPCookie.As_PyTypeObject().tp_str = & Dtool_Repr_HTTPCookie;
        if(PyType_Ready(&Dtool_HTTPCookie.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HTTPCookie)");
             printf(" Error In PyType_ReadyHTTPCookie");
             return;
        }
        Py_INCREF(&Dtool_HTTPCookie.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HTTPCookie.As_PyTypeObject().tp_dict,"HTTPCookie",&Dtool_HTTPCookie.As_PyObject());
        RegisterRuntimeClass(&Dtool_HTTPCookie,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HTTPCookie.As_PyTypeObject());
        PyModule_AddObject(module, "HTTPCookie",(PyObject *)&Dtool_HTTPCookie.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HTTPClient | HTTPClient
//********************************************************************
PyMethodDef Dtool_Methods_HTTPClient[]= {
  { "assign",(PyCFunction ) &Dtool_HTTPClient_operator_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_operator_154_comment},
  { "initRandomSeed",(PyCFunction ) &Dtool_HTTPClient_init_random_seed_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_init_random_seed_155_comment},
  { "setProxySpec",(PyCFunction ) &Dtool_HTTPClient_set_proxy_spec_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_proxy_spec_156_comment},
  { "getProxySpec",(PyCFunction ) &Dtool_HTTPClient_get_proxy_spec_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_proxy_spec_157_comment},
  { "setDirectHostSpec",(PyCFunction ) &Dtool_HTTPClient_set_direct_host_spec_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_direct_host_spec_158_comment},
  { "getDirectHostSpec",(PyCFunction ) &Dtool_HTTPClient_get_direct_host_spec_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_direct_host_spec_159_comment},
  { "setTryAllDirect",(PyCFunction ) &Dtool_HTTPClient_set_try_all_direct_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_try_all_direct_160_comment},
  { "getTryAllDirect",(PyCFunction ) &Dtool_HTTPClient_get_try_all_direct_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_try_all_direct_161_comment},
  { "clearProxy",(PyCFunction ) &Dtool_HTTPClient_clear_proxy_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_clear_proxy_162_comment},
  { "addProxy",(PyCFunction ) &Dtool_HTTPClient_add_proxy_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_add_proxy_163_comment},
  { "clearDirectHost",(PyCFunction ) &Dtool_HTTPClient_clear_direct_host_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_clear_direct_host_164_comment},
  { "addDirectHost",(PyCFunction ) &Dtool_HTTPClient_add_direct_host_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_add_direct_host_165_comment},
  { "getProxiesForUrl",(PyCFunction ) &Dtool_HTTPClient_get_proxies_for_url_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_proxies_for_url_166_comment},
  { "setUsername",(PyCFunction ) &Dtool_HTTPClient_set_username_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_username_167_comment},
  { "getUsername",(PyCFunction ) &Dtool_HTTPClient_get_username_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_username_168_comment},
  { "setCookie",(PyCFunction ) &Dtool_HTTPClient_set_cookie_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_cookie_169_comment},
  { "clearCookie",(PyCFunction ) &Dtool_HTTPClient_clear_cookie_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_clear_cookie_170_comment},
  { "clearAllCookies",(PyCFunction ) &Dtool_HTTPClient_clear_all_cookies_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_clear_all_cookies_171_comment},
  { "hasCookie",(PyCFunction ) &Dtool_HTTPClient_has_cookie_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_has_cookie_172_comment},
  { "getCookie",(PyCFunction ) &Dtool_HTTPClient_get_cookie_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_cookie_173_comment},
  { "copyCookiesFrom",(PyCFunction ) &Dtool_HTTPClient_copy_cookies_from_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_copy_cookies_from_174_comment},
  { "writeCookies",(PyCFunction ) &Dtool_HTTPClient_write_cookies_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_write_cookies_175_comment},
  { "sendCookies",(PyCFunction ) &Dtool_HTTPClient_send_cookies_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_send_cookies_176_comment},
  { "setClientCertificateFilename",(PyCFunction ) &Dtool_HTTPClient_set_client_certificate_filename_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_client_certificate_filename_177_comment},
  { "setClientCertificatePem",(PyCFunction ) &Dtool_HTTPClient_set_client_certificate_pem_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_client_certificate_pem_178_comment},
  { "setClientCertificatePassphrase",(PyCFunction ) &Dtool_HTTPClient_set_client_certificate_passphrase_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_client_certificate_passphrase_179_comment},
  { "loadClientCertificate",(PyCFunction ) &Dtool_HTTPClient_load_client_certificate_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_load_client_certificate_180_comment},
  { "addPreapprovedServerCertificateFilename",(PyCFunction ) &Dtool_HTTPClient_add_preapproved_server_certificate_filename_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_add_preapproved_server_certificate_filename_181_comment},
  { "addPreapprovedServerCertificatePem",(PyCFunction ) &Dtool_HTTPClient_add_preapproved_server_certificate_pem_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_add_preapproved_server_certificate_pem_182_comment},
  { "addPreapprovedServerCertificateName",(PyCFunction ) &Dtool_HTTPClient_add_preapproved_server_certificate_name_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_add_preapproved_server_certificate_name_183_comment},
  { "clearPreapprovedServerCertificates",(PyCFunction ) &Dtool_HTTPClient_clear_preapproved_server_certificates_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_clear_preapproved_server_certificates_184_comment},
  { "clearAllPreapprovedServerCertificates",(PyCFunction ) &Dtool_HTTPClient_clear_all_preapproved_server_certificates_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_clear_all_preapproved_server_certificates_185_comment},
  { "setHttpVersion",(PyCFunction ) &Dtool_HTTPClient_set_http_version_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_http_version_186_comment},
  { "getHttpVersion",(PyCFunction ) &Dtool_HTTPClient_get_http_version_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_http_version_187_comment},
  { "getHttpVersionString",(PyCFunction ) &Dtool_HTTPClient_get_http_version_string_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_http_version_string_188_comment},
  { "parseHttpVersionString",(PyCFunction ) &Dtool_HTTPClient_parse_http_version_string_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_parse_http_version_string_189_comment},
  { "loadCertificates",(PyCFunction ) &Dtool_HTTPClient_load_certificates_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_load_certificates_190_comment},
  { "setVerifySsl",(PyCFunction ) &Dtool_HTTPClient_set_verify_ssl_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_verify_ssl_192_comment},
  { "getVerifySsl",(PyCFunction ) &Dtool_HTTPClient_get_verify_ssl_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_verify_ssl_193_comment},
  { "setCipherList",(PyCFunction ) &Dtool_HTTPClient_set_cipher_list_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_set_cipher_list_194_comment},
  { "getCipherList",(PyCFunction ) &Dtool_HTTPClient_get_cipher_list_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_cipher_list_195_comment},
  { "makeChannel",(PyCFunction ) &Dtool_HTTPClient_make_channel_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_make_channel_196_comment},
  { "postForm",(PyCFunction ) &Dtool_HTTPClient_post_form_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_post_form_197_comment},
  { "getDocument",(PyCFunction ) &Dtool_HTTPClient_get_document_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_document_198_comment},
  { "getHeader",(PyCFunction ) &Dtool_HTTPClient_get_header_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_header_199_comment},
  { "base64Encode",(PyCFunction ) &Dtool_HTTPClient_base64_encode_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_base64_encode_200_comment},
  { "base64Decode",(PyCFunction ) &Dtool_HTTPClient_base64_decode_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_base64_decode_201_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_HTTPClient_get_global_ptr_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPClient_get_global_ptr_202_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_HTTPClient(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HTTPClient.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HTTPClient\n"
          "// Description : Handles contacting an HTTP server and retrieving a\n"
          "//               document.  Each HTTPClient object represents a\n"
          "//               separate context, and stores its own list of cookies,\n"
          "//               passwords, and certificates; however, a given\n"
          "//               HTTPClient is capable of making multiple simultaneous\n"
          "//               requests to the same or different servers.\n"
          "//\n"
          "//               It is up to the programmer whether one HTTPClient\n"
          "//               should be used to retrieve all documents, or a\n"
          "//               separate one should be created each time.  There is a\n"
          "//               default, global HTTPClient available in\n"
          "//               HTTPClient::get_global_ptr().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_HTTPClient.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_HTTPClient.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HTTPClient.As_PyTypeObject().tp_dict);
        // Enum  HTTPClient::VerifySSL;
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"VSNoVerify",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"VSNoDateCheck",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"VSNormal",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_HTTPClient.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HTTPClient)");
             printf(" Error In PyType_ReadyHTTPClient");
             return;
        }
        Py_INCREF(&Dtool_HTTPClient.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"HTTPClient",&Dtool_HTTPClient.As_PyObject());
        //  Static Method initRandomSeed
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"initRandomSeed",PyCFunction_New(&Dtool_Methods_HTTPClient[1],&Dtool_HTTPClient.As_PyObject()));
        //  Static Method parseHttpVersionString
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"parseHttpVersionString",PyCFunction_New(&Dtool_Methods_HTTPClient[35],&Dtool_HTTPClient.As_PyObject()));
        //  Static Method base64Encode
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"base64Encode",PyCFunction_New(&Dtool_Methods_HTTPClient[45],&Dtool_HTTPClient.As_PyObject()));
        //  Static Method base64Decode
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"base64Decode",PyCFunction_New(&Dtool_Methods_HTTPClient[46],&Dtool_HTTPClient.As_PyObject()));
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_HTTPClient.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_HTTPClient[47],&Dtool_HTTPClient.As_PyObject()));
        RegisterRuntimeClass(&Dtool_HTTPClient,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HTTPClient.As_PyTypeObject());
        PyModule_AddObject(module, "HTTPClient",(PyObject *)&Dtool_HTTPClient.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HTTPEntityTag | HTTPEntityTag
//********************************************************************
PyMethodDef Dtool_Methods_HTTPEntityTag[]= {
  { "assign",(PyCFunction ) &Dtool_HTTPEntityTag_operator_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_operator_205_comment},
  { "isWeak",(PyCFunction ) &Dtool_HTTPEntityTag_is_weak_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_is_weak_206_comment},
  { "getTag",(PyCFunction ) &Dtool_HTTPEntityTag_get_tag_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_get_tag_207_comment},
  { "getString",(PyCFunction ) &Dtool_HTTPEntityTag_get_string_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_get_string_208_comment},
  { "strongEquiv",(PyCFunction ) &Dtool_HTTPEntityTag_strong_equiv_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_strong_equiv_209_comment},
  { "weakEquiv",(PyCFunction ) &Dtool_HTTPEntityTag_weak_equiv_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_weak_equiv_210_comment},
  { "eq",(PyCFunction ) &Dtool_HTTPEntityTag_operator_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_operator_211_comment},
  { "ne",(PyCFunction ) &Dtool_HTTPEntityTag_operator_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_operator_212_comment},
  { "lessThan",(PyCFunction ) &Dtool_HTTPEntityTag_operator_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_operator_213_comment},
  { "compareTo",(PyCFunction ) &Dtool_HTTPEntityTag_compare_to_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_compare_to_214_comment},
  { "output",(PyCFunction ) &Dtool_HTTPEntityTag_output_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPEntityTag_output_215_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     HTTPEntityTag
//////////////////
static PyObject *  Dtool_Repr_HTTPEntityTag(PyObject * self)
{
    HTTPEntityTag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HTTPEntityTag,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_HTTPEntityTag(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HTTPEntityTag.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HTTPEntityTag\n"
          "// Description : A container for an \"entity tag\" from an HTTP server.\n"
          "//               This is used to identify a particular version of a\n"
          "//               document or resource, particularly useful for\n"
          "//               verifying caches.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_HTTPEntityTag.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_HTTPEntityTag.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HTTPEntityTag.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HTTPEntityTag.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_HTTPEntityTag.As_PyTypeObject().tp_repr = & Dtool_Repr_HTTPEntityTag;
        // __str__ Repr Proxy
        Dtool_HTTPEntityTag.As_PyTypeObject().tp_str = & Dtool_Repr_HTTPEntityTag;
        if(PyType_Ready(&Dtool_HTTPEntityTag.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HTTPEntityTag)");
             printf(" Error In PyType_ReadyHTTPEntityTag");
             return;
        }
        Py_INCREF(&Dtool_HTTPEntityTag.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HTTPEntityTag.As_PyTypeObject().tp_dict,"HTTPEntityTag",&Dtool_HTTPEntityTag.As_PyObject());
        RegisterRuntimeClass(&Dtool_HTTPEntityTag,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HTTPEntityTag.As_PyTypeObject());
        PyModule_AddObject(module, "HTTPEntityTag",(PyObject *)&Dtool_HTTPEntityTag.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DocumentSpec | DocumentSpec
//********************************************************************
PyMethodDef Dtool_Methods_DocumentSpec[]= {
  { "assign",(PyCFunction ) &Dtool_DocumentSpec_operator_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_operator_219_comment},
  { "eq",(PyCFunction ) &Dtool_DocumentSpec_operator_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_operator_220_comment},
  { "ne",(PyCFunction ) &Dtool_DocumentSpec_operator_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_operator_221_comment},
  { "lessThan",(PyCFunction ) &Dtool_DocumentSpec_operator_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_operator_222_comment},
  { "compareTo",(PyCFunction ) &Dtool_DocumentSpec_compare_to_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_compare_to_223_comment},
  { "setUrl",(PyCFunction ) &Dtool_DocumentSpec_set_url_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_set_url_224_comment},
  { "getUrl",(PyCFunction ) &Dtool_DocumentSpec_get_url_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_get_url_225_comment},
  { "setTag",(PyCFunction ) &Dtool_DocumentSpec_set_tag_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_set_tag_226_comment},
  { "hasTag",(PyCFunction ) &Dtool_DocumentSpec_has_tag_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_has_tag_227_comment},
  { "getTag",(PyCFunction ) &Dtool_DocumentSpec_get_tag_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_get_tag_228_comment},
  { "clearTag",(PyCFunction ) &Dtool_DocumentSpec_clear_tag_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_clear_tag_229_comment},
  { "setDate",(PyCFunction ) &Dtool_DocumentSpec_set_date_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_set_date_230_comment},
  { "hasDate",(PyCFunction ) &Dtool_DocumentSpec_has_date_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_has_date_231_comment},
  { "getDate",(PyCFunction ) &Dtool_DocumentSpec_get_date_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_get_date_232_comment},
  { "clearDate",(PyCFunction ) &Dtool_DocumentSpec_clear_date_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_clear_date_233_comment},
  { "setRequestMode",(PyCFunction ) &Dtool_DocumentSpec_set_request_mode_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_set_request_mode_235_comment},
  { "getRequestMode",(PyCFunction ) &Dtool_DocumentSpec_get_request_mode_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_get_request_mode_236_comment},
  { "setCacheControl",(PyCFunction ) &Dtool_DocumentSpec_set_cache_control_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_set_cache_control_238_comment},
  { "getCacheControl",(PyCFunction ) &Dtool_DocumentSpec_get_cache_control_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_get_cache_control_239_comment},
  { "input",(PyCFunction ) &Dtool_DocumentSpec_input_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_input_240_comment},
  { "output",(PyCFunction ) &Dtool_DocumentSpec_output_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_output_241_comment},
  { "write",(PyCFunction ) &Dtool_DocumentSpec_write_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DocumentSpec_write_242_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DocumentSpec
//////////////////
static PyObject *  Dtool_Repr_DocumentSpec(PyObject * self)
{
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DocumentSpec
//////////////////
static PyObject *  Dtool_Str_DocumentSpec(PyObject * self)
{
    DocumentSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DocumentSpec,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DocumentSpec(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DocumentSpec.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DocumentSpec\n"
          "// Description : A descriptor that refers to a particular version of a\n"
          "//               document.  This includes the URL of the document and\n"
          "//               its identity tag and last-modified dates.\n"
          "//\n"
          "//               The DocumentSpec may also be used to request a newer\n"
          "//               document than a particular one if available, for\n"
          "//               instance to refresh a cached document.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DocumentSpec.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DocumentSpec.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DocumentSpec.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DocumentSpec.As_PyTypeObject().tp_repr = & Dtool_Repr_DocumentSpec;
        // __str__
        Dtool_DocumentSpec.As_PyTypeObject().tp_str = & Dtool_Str_DocumentSpec;
        // Enum  DocumentSpec::RequestMode;
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"RMAny",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"RMEqual",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"RMNewer",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"RMEqualOrNewer",PyInt_FromLong(3));
        // Enum  DocumentSpec::CacheControl;
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"CCAllowCache",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"CCRevalidate",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"CCNoCache",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_DocumentSpec.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DocumentSpec)");
             printf(" Error In PyType_ReadyDocumentSpec");
             return;
        }
        Py_INCREF(&Dtool_DocumentSpec.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DocumentSpec.As_PyTypeObject().tp_dict,"DocumentSpec",&Dtool_DocumentSpec.As_PyObject());
        RegisterRuntimeClass(&Dtool_DocumentSpec,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DocumentSpec.As_PyTypeObject());
        PyModule_AddObject(module, "DocumentSpec",(PyObject *)&Dtool_DocumentSpec.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HTTPChannel | HTTPChannel
//********************************************************************
PyMethodDef Dtool_Methods_HTTPChannel[]= {
  { "getClient",(PyCFunction ) &Dtool_HTTPChannel_get_client_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_client_247_comment},
  { "isValid",(PyCFunction ) &Dtool_HTTPChannel_is_valid_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_is_valid_248_comment},
  { "isConnectionReady",(PyCFunction ) &Dtool_HTTPChannel_is_connection_ready_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_is_connection_ready_249_comment},
  { "getUrl",(PyCFunction ) &Dtool_HTTPChannel_get_url_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_url_250_comment},
  { "getDocumentSpec",(PyCFunction ) &Dtool_HTTPChannel_get_document_spec_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_document_spec_251_comment},
  { "getHttpVersion",(PyCFunction ) &Dtool_HTTPChannel_get_http_version_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_http_version_252_comment},
  { "getHttpVersionString",(PyCFunction ) &Dtool_HTTPChannel_get_http_version_string_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_http_version_string_253_comment},
  { "getStatusCode",(PyCFunction ) &Dtool_HTTPChannel_get_status_code_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_status_code_254_comment},
  { "getStatusString",(PyCFunction ) &Dtool_HTTPChannel_get_status_string_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_status_string_255_comment},
  { "getWwwRealm",(PyCFunction ) &Dtool_HTTPChannel_get_www_realm_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_www_realm_256_comment},
  { "getProxyRealm",(PyCFunction ) &Dtool_HTTPChannel_get_proxy_realm_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_proxy_realm_257_comment},
  { "getRedirect",(PyCFunction ) &Dtool_HTTPChannel_get_redirect_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_redirect_258_comment},
  { "getHeaderValue",(PyCFunction ) &Dtool_HTTPChannel_get_header_value_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_header_value_259_comment},
  { "getNumRedirectSteps",(PyCFunction ) &Dtool_HTTPChannel_get_num_redirect_steps_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_num_redirect_steps_260_comment},
  { "getRedirectStep",(PyCFunction ) &Dtool_HTTPChannel_get_redirect_step_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_redirect_step_261_comment},
  { "setPersistentConnection",(PyCFunction ) &Dtool_HTTPChannel_set_persistent_connection_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_persistent_connection_262_comment},
  { "getPersistentConnection",(PyCFunction ) &Dtool_HTTPChannel_get_persistent_connection_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_persistent_connection_263_comment},
  { "willCloseConnection",(PyCFunction ) &Dtool_HTTPChannel_will_close_connection_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_will_close_connection_264_comment},
  { "setAllowProxy",(PyCFunction ) &Dtool_HTTPChannel_set_allow_proxy_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_allow_proxy_265_comment},
  { "getAllowProxy",(PyCFunction ) &Dtool_HTTPChannel_get_allow_proxy_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_allow_proxy_266_comment},
  { "setProxyTunnel",(PyCFunction ) &Dtool_HTTPChannel_set_proxy_tunnel_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_proxy_tunnel_267_comment},
  { "getProxyTunnel",(PyCFunction ) &Dtool_HTTPChannel_get_proxy_tunnel_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_proxy_tunnel_268_comment},
  { "setConnectTimeout",(PyCFunction ) &Dtool_HTTPChannel_set_connect_timeout_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_connect_timeout_269_comment},
  { "getConnectTimeout",(PyCFunction ) &Dtool_HTTPChannel_get_connect_timeout_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_connect_timeout_270_comment},
  { "setBlockingConnect",(PyCFunction ) &Dtool_HTTPChannel_set_blocking_connect_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_blocking_connect_271_comment},
  { "getBlockingConnect",(PyCFunction ) &Dtool_HTTPChannel_get_blocking_connect_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_blocking_connect_272_comment},
  { "setHttpTimeout",(PyCFunction ) &Dtool_HTTPChannel_set_http_timeout_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_http_timeout_273_comment},
  { "getHttpTimeout",(PyCFunction ) &Dtool_HTTPChannel_get_http_timeout_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_http_timeout_274_comment},
  { "setSkipBodySize",(PyCFunction ) &Dtool_HTTPChannel_set_skip_body_size_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_skip_body_size_275_comment},
  { "getSkipBodySize",(PyCFunction ) &Dtool_HTTPChannel_get_skip_body_size_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_skip_body_size_276_comment},
  { "setIdleTimeout",(PyCFunction ) &Dtool_HTTPChannel_set_idle_timeout_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_idle_timeout_277_comment},
  { "getIdleTimeout",(PyCFunction ) &Dtool_HTTPChannel_get_idle_timeout_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_idle_timeout_278_comment},
  { "setDownloadThrottle",(PyCFunction ) &Dtool_HTTPChannel_set_download_throttle_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_download_throttle_279_comment},
  { "getDownloadThrottle",(PyCFunction ) &Dtool_HTTPChannel_get_download_throttle_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_download_throttle_280_comment},
  { "setMaxBytesPerSecond",(PyCFunction ) &Dtool_HTTPChannel_set_max_bytes_per_second_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_max_bytes_per_second_281_comment},
  { "getMaxBytesPerSecond",(PyCFunction ) &Dtool_HTTPChannel_get_max_bytes_per_second_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_max_bytes_per_second_282_comment},
  { "setMaxUpdatesPerSecond",(PyCFunction ) &Dtool_HTTPChannel_set_max_updates_per_second_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_max_updates_per_second_283_comment},
  { "getMaxUpdatesPerSecond",(PyCFunction ) &Dtool_HTTPChannel_get_max_updates_per_second_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_max_updates_per_second_284_comment},
  { "setExpectedFileSize",(PyCFunction ) &Dtool_HTTPChannel_set_expected_file_size_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_set_expected_file_size_285_comment},
  { "getFileSize",(PyCFunction ) &Dtool_HTTPChannel_get_file_size_286, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_file_size_286_comment},
  { "isFileSizeKnown",(PyCFunction ) &Dtool_HTTPChannel_is_file_size_known_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_is_file_size_known_287_comment},
  { "getFirstByteRequested",(PyCFunction ) &Dtool_HTTPChannel_get_first_byte_requested_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_first_byte_requested_288_comment},
  { "getLastByteRequested",(PyCFunction ) &Dtool_HTTPChannel_get_last_byte_requested_289, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_last_byte_requested_289_comment},
  { "getFirstByteDelivered",(PyCFunction ) &Dtool_HTTPChannel_get_first_byte_delivered_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_first_byte_delivered_290_comment},
  { "getLastByteDelivered",(PyCFunction ) &Dtool_HTTPChannel_get_last_byte_delivered_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_last_byte_delivered_291_comment},
  { "writeHeaders",(PyCFunction ) &Dtool_HTTPChannel_write_headers_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_write_headers_292_comment},
  { "reset",(PyCFunction ) &Dtool_HTTPChannel_reset_293, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_reset_293_comment},
  { "preserveStatus",(PyCFunction ) &Dtool_HTTPChannel_preserve_status_294, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_preserve_status_294_comment},
  { "clearExtraHeaders",(PyCFunction ) &Dtool_HTTPChannel_clear_extra_headers_295, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_clear_extra_headers_295_comment},
  { "sendExtraHeader",(PyCFunction ) &Dtool_HTTPChannel_send_extra_header_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_send_extra_header_296_comment},
  { "getDocument",(PyCFunction ) &Dtool_HTTPChannel_get_document_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_document_297_comment},
  { "getSubdocument",(PyCFunction ) &Dtool_HTTPChannel_get_subdocument_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_subdocument_298_comment},
  { "getHeader",(PyCFunction ) &Dtool_HTTPChannel_get_header_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_header_299_comment},
  { "postForm",(PyCFunction ) &Dtool_HTTPChannel_post_form_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_post_form_300_comment},
  { "putDocument",(PyCFunction ) &Dtool_HTTPChannel_put_document_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_put_document_301_comment},
  { "deleteDocument",(PyCFunction ) &Dtool_HTTPChannel_delete_document_302, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_delete_document_302_comment},
  { "getTrace",(PyCFunction ) &Dtool_HTTPChannel_get_trace_303, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_trace_303_comment},
  { "connectTo",(PyCFunction ) &Dtool_HTTPChannel_connect_to_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_connect_to_304_comment},
  { "getOptions",(PyCFunction ) &Dtool_HTTPChannel_get_options_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_options_305_comment},
  { "beginGetDocument",(PyCFunction ) &Dtool_HTTPChannel_begin_get_document_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_begin_get_document_306_comment},
  { "beginGetSubdocument",(PyCFunction ) &Dtool_HTTPChannel_begin_get_subdocument_307, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_begin_get_subdocument_307_comment},
  { "beginGetHeader",(PyCFunction ) &Dtool_HTTPChannel_begin_get_header_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_begin_get_header_308_comment},
  { "beginPostForm",(PyCFunction ) &Dtool_HTTPChannel_begin_post_form_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_begin_post_form_309_comment},
  { "run",(PyCFunction ) &Dtool_HTTPChannel_run_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_run_310_comment},
  { "beginConnectTo",(PyCFunction ) &Dtool_HTTPChannel_begin_connect_to_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_begin_connect_to_311_comment},
  { "openReadBody",(PyCFunction ) &Dtool_HTTPChannel_open_read_body_312, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_open_read_body_312_comment},
  { "closeReadBody",(PyCFunction ) &Dtool_HTTPChannel_close_read_body_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_close_read_body_313_comment},
  { "downloadToFile",(PyCFunction ) &Dtool_HTTPChannel_download_to_file_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_download_to_file_314_comment},
  { "downloadToRam",(PyCFunction ) &Dtool_HTTPChannel_download_to_ram_315, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_download_to_ram_315_comment},
  { "downloadToStream",(PyCFunction ) &Dtool_HTTPChannel_download_to_stream_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_download_to_stream_316_comment},
  { "getConnection",(PyCFunction ) &Dtool_HTTPChannel_get_connection_317, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_connection_317_comment},
  { "getBytesDownloaded",(PyCFunction ) &Dtool_HTTPChannel_get_bytes_downloaded_318, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_bytes_downloaded_318_comment},
  { "getBytesRequested",(PyCFunction ) &Dtool_HTTPChannel_get_bytes_requested_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_bytes_requested_319_comment},
  { "isDownloadComplete",(PyCFunction ) &Dtool_HTTPChannel_is_download_complete_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_is_download_complete_320_comment},
  { "getClassType",(PyCFunction ) &Dtool_HTTPChannel_get_class_type_321, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HTTPChannel_get_class_type_321_comment},
  { "getRedirectSteps",(PyCFunction) &MakeSeq_HTTPChannel_get_redirect_steps, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_HTTPChannel(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HTTPChannel.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HTTPChannel\n"
          "// Description : A single channel of communication from an HTTPClient.\n"
          "//               This is similar to the concept of a 'connection',\n"
          "//               except that HTTP is technically connectionless; in\n"
          "//               fact, a channel may represent one unbroken connection\n"
          "//               or it may transparently close and reopen a new\n"
          "//               connection with each request.\n"
          "//\n"
          "//               A channel is conceptually a single thread of I/O.\n"
          "//               One document at a time may be requested using a\n"
          "//               channel; a new document may (in general) not be\n"
          "//               requested from the same HTTPChannel until the first\n"
          "//               document has been fully retrieved.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_HTTPChannel.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_HTTPChannel.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HTTPChannel.As_PyTypeObject().tp_dict);
        // Enum  HTTPChannel::StatusCode;
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCIncomplete",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCInternalError",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCNoConnection",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCTimeout",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCLostConnection",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCNonHttpResponse",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCInvalidHttp",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSocksInvalidVersion",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSocksNoAcceptableLoginMethod",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSocksRefused",PyInt_FromLong(9));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSocksNoConnection",PyInt_FromLong(10));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSslInternalFailure",PyInt_FromLong(11));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSslNoHandshake",PyInt_FromLong(12));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCHttpErrorWatermark",PyInt_FromLong(13));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSslInvalidServerCertificate",PyInt_FromLong(14));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSslSelfSignedServerCertificate",PyInt_FromLong(15));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCSslUnexpectedServer",PyInt_FromLong(16));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCDownloadOpenError",PyInt_FromLong(17));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCDownloadWriteError",PyInt_FromLong(18));
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"SCDownloadInvalidRange",PyInt_FromLong(19));
        if(PyType_Ready(&Dtool_HTTPChannel.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HTTPChannel)");
             printf(" Error In PyType_ReadyHTTPChannel");
             return;
        }
        Py_INCREF(&Dtool_HTTPChannel.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"HTTPChannel",&Dtool_HTTPChannel.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_HTTPChannel.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_HTTPChannel[74],&Dtool_HTTPChannel.As_PyObject()));
        RegisterRuntimeClass(&Dtool_HTTPChannel,HTTPChannel::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HTTPChannel.As_PyTypeObject());
        PyModule_AddObject(module, "HTTPChannel",(PyObject *)&Dtool_HTTPChannel.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Decompressor | Decompressor
//********************************************************************
PyMethodDef Dtool_Methods_Decompressor[]= {
  { "initiate",(PyCFunction ) &Dtool_Decompressor_initiate_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Decompressor_initiate_325_comment},
  { "run",(PyCFunction ) &Dtool_Decompressor_run_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Decompressor_run_326_comment},
  { "decompress",(PyCFunction ) &Dtool_Decompressor_decompress_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Decompressor_decompress_327_comment},
  { "getProgress",(PyCFunction ) &Dtool_Decompressor_get_progress_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Decompressor_get_progress_328_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Decompressor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Decompressor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Decompressor\n"
          "// Description : This manages run-time decompression of a\n"
          "//               zlib-compressed stream, as a background or foreground\n"
          "//               task.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Decompressor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Decompressor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Decompressor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Decompressor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Decompressor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Decompressor)");
             printf(" Error In PyType_ReadyDecompressor");
             return;
        }
        Py_INCREF(&Dtool_Decompressor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Decompressor.As_PyTypeObject().tp_dict,"Decompressor",&Dtool_Decompressor.As_PyObject());
        RegisterRuntimeClass(&Dtool_Decompressor,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Decompressor.As_PyTypeObject());
        PyModule_AddObject(module, "Decompressor",(PyObject *)&Dtool_Decompressor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DownloadDb | DownloadDb
//********************************************************************
PyMethodDef Dtool_Methods_DownloadDb[]= {
  { "output",(PyCFunction ) &Dtool_DownloadDb_output_333, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_output_333_comment},
  { "write",(PyCFunction ) &Dtool_DownloadDb_write_334, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_write_334_comment},
  { "writeVersionMap",(PyCFunction ) &Dtool_DownloadDb_write_version_map_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_write_version_map_335_comment},
  { "writeClientDb",(PyCFunction ) &Dtool_DownloadDb_write_client_db_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_write_client_db_336_comment},
  { "writeServerDb",(PyCFunction ) &Dtool_DownloadDb_write_server_db_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_write_server_db_337_comment},
  { "getClientNumMultifiles",(PyCFunction ) &Dtool_DownloadDb_get_client_num_multifiles_338, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_client_num_multifiles_338_comment},
  { "getServerNumMultifiles",(PyCFunction ) &Dtool_DownloadDb_get_server_num_multifiles_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_num_multifiles_339_comment},
  { "getClientMultifileName",(PyCFunction ) &Dtool_DownloadDb_get_client_multifile_name_340, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_client_multifile_name_340_comment},
  { "getServerMultifileName",(PyCFunction ) &Dtool_DownloadDb_get_server_multifile_name_341, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_multifile_name_341_comment},
  { "getClientMultifileSize",(PyCFunction ) &Dtool_DownloadDb_get_client_multifile_size_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_client_multifile_size_342_comment},
  { "setClientMultifileSize",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_size_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_size_343_comment},
  { "setClientMultifileDeltaSize",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_delta_size_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_delta_size_344_comment},
  { "getServerMultifileSize",(PyCFunction ) &Dtool_DownloadDb_get_server_multifile_size_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_multifile_size_345_comment},
  { "setServerMultifileSize",(PyCFunction ) &Dtool_DownloadDb_set_server_multifile_size_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_server_multifile_size_346_comment},
  { "getClientMultifilePhase",(PyCFunction ) &Dtool_DownloadDb_get_client_multifile_phase_347, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_client_multifile_phase_347_comment},
  { "getServerMultifilePhase",(PyCFunction ) &Dtool_DownloadDb_get_server_multifile_phase_348, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_multifile_phase_348_comment},
  { "setClientMultifileIncomplete",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_incomplete_349, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_incomplete_349_comment},
  { "setClientMultifileComplete",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_complete_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_complete_350_comment},
  { "setClientMultifileDecompressed",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_decompressed_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_decompressed_351_comment},
  { "setClientMultifileExtracted",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_extracted_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_extracted_352_comment},
  { "getServerNumFiles",(PyCFunction ) &Dtool_DownloadDb_get_server_num_files_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_num_files_353_comment},
  { "getServerFileName",(PyCFunction ) &Dtool_DownloadDb_get_server_file_name_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_file_name_354_comment},
  { "clientMultifileExists",(PyCFunction ) &Dtool_DownloadDb_client_multifile_exists_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_client_multifile_exists_355_comment},
  { "clientMultifileComplete",(PyCFunction ) &Dtool_DownloadDb_client_multifile_complete_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_client_multifile_complete_356_comment},
  { "clientMultifileDecompressed",(PyCFunction ) &Dtool_DownloadDb_client_multifile_decompressed_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_client_multifile_decompressed_357_comment},
  { "clientMultifileExtracted",(PyCFunction ) &Dtool_DownloadDb_client_multifile_extracted_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_client_multifile_extracted_358_comment},
  { "getClientMultifileHash",(PyCFunction ) &Dtool_DownloadDb_get_client_multifile_hash_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_client_multifile_hash_359_comment},
  { "setClientMultifileHash",(PyCFunction ) &Dtool_DownloadDb_set_client_multifile_hash_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_client_multifile_hash_360_comment},
  { "getServerMultifileHash",(PyCFunction ) &Dtool_DownloadDb_get_server_multifile_hash_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_server_multifile_hash_361_comment},
  { "setServerMultifileHash",(PyCFunction ) &Dtool_DownloadDb_set_server_multifile_hash_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_server_multifile_hash_362_comment},
  { "deleteClientMultifile",(PyCFunction ) &Dtool_DownloadDb_delete_client_multifile_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_delete_client_multifile_363_comment},
  { "addClientMultifile",(PyCFunction ) &Dtool_DownloadDb_add_client_multifile_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_add_client_multifile_364_comment},
  { "expandClientMultifile",(PyCFunction ) &Dtool_DownloadDb_expand_client_multifile_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_expand_client_multifile_365_comment},
  { "createNewServerDb",(PyCFunction ) &Dtool_DownloadDb_create_new_server_db_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_create_new_server_db_366_comment},
  { "serverAddMultifile",(PyCFunction ) &Dtool_DownloadDb_server_add_multifile_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_server_add_multifile_367_comment},
  { "serverAddFile",(PyCFunction ) &Dtool_DownloadDb_server_add_file_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_server_add_file_368_comment},
  { "addVersion",(PyCFunction ) &Dtool_DownloadDb_add_version_371, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_add_version_371_comment},
  { "insertNewVersion",(PyCFunction ) &Dtool_DownloadDb_insert_new_version_372, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_insert_new_version_372_comment},
  { "hasVersion",(PyCFunction ) &Dtool_DownloadDb_has_version_373, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_has_version_373_comment},
  { "getNumVersions",(PyCFunction ) &Dtool_DownloadDb_get_num_versions_374, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_num_versions_374_comment},
  { "setNumVersions",(PyCFunction ) &Dtool_DownloadDb_set_num_versions_375, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_set_num_versions_375_comment},
  { "getVersion",(PyCFunction ) &Dtool_DownloadDb_get_version_376, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_version_376_comment},
  { "getHash",(PyCFunction ) &Dtool_DownloadDb_get_hash_377, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DownloadDb_get_hash_377_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DownloadDb
//////////////////
static PyObject *  Dtool_Repr_DownloadDb(PyObject * self)
{
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DownloadDb
//////////////////
static PyObject *  Dtool_Str_DownloadDb(PyObject * self)
{
    DownloadDb * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DownloadDb,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DownloadDb(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DownloadDb.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DownloadDb\n"
          "// Description : A listing of files within multifiles for management\n"
          "//               of client-side synchronization with a server-provided\n"
          "//               set of files.\n"
          "//\n"
          "//               This class manages one copy of the database for the\n"
          "//               client, representing the files on the client system,\n"
          "//               and another copy for the server, representing the\n"
          "//               files the server has available.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DownloadDb.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DownloadDb.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DownloadDb.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DownloadDb.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DownloadDb.As_PyTypeObject().tp_repr = & Dtool_Repr_DownloadDb;
        // __str__
        Dtool_DownloadDb.As_PyTypeObject().tp_str = & Dtool_Str_DownloadDb;
        // Enum  DownloadDb::Status;
        PyDict_SetItemString(Dtool_DownloadDb.As_PyTypeObject().tp_dict,"StatusIncomplete",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_DownloadDb.As_PyTypeObject().tp_dict,"StatusComplete",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_DownloadDb.As_PyTypeObject().tp_dict,"StatusDecompressed",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_DownloadDb.As_PyTypeObject().tp_dict,"StatusExtracted",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_DownloadDb.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DownloadDb)");
             printf(" Error In PyType_ReadyDownloadDb");
             return;
        }
        Py_INCREF(&Dtool_DownloadDb.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DownloadDb.As_PyTypeObject().tp_dict,"DownloadDb",&Dtool_DownloadDb.As_PyObject());
        RegisterRuntimeClass(&Dtool_DownloadDb,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DownloadDb.As_PyTypeObject());
        PyModule_AddObject(module, "DownloadDb",(PyObject *)&Dtool_DownloadDb.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileHTTP | VirtualFileHTTP
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileHTTP[]= {
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileHTTP_get_class_type_382, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileHTTP_get_class_type_382_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualFileHTTP(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileHTTP.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileHTTP\n"
          "// Description : This maps a document retrieved from an HTTPClient\n"
          "//               into the VirtualFileSystem, allowing models etc. to\n"
          "//               be loaded directly from a web page.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VirtualFile._Dtool_ClassInit(NULL);
        Dtool_VirtualFileHTTP.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VirtualFile.As_PyTypeObject());
        Dtool_VirtualFileHTTP.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileHTTP.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileHTTP.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualFileHTTP.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileHTTP)");
             printf(" Error In PyType_ReadyVirtualFileHTTP");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileHTTP.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileHTTP.As_PyTypeObject().tp_dict,"VirtualFileHTTP",&Dtool_VirtualFileHTTP.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileHTTP.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileHTTP[0],&Dtool_VirtualFileHTTP.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileHTTP,VirtualFileHTTP::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileHTTP.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileHTTP",(PyObject *)&Dtool_VirtualFileHTTP.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileMountHTTP | VirtualFileMountHTTP
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileMountHTTP[]= {
  { "getHttpClient",(PyCFunction ) &Dtool_VirtualFileMountHTTP_get_http_client_386, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountHTTP_get_http_client_386_comment},
  { "getRoot",(PyCFunction ) &Dtool_VirtualFileMountHTTP_get_root_387, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountHTTP_get_root_387_comment},
  { "reloadVfsMountUrl",(PyCFunction ) &Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_388, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_388_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileMountHTTP_get_class_type_389, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountHTTP_get_class_type_389_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualFileMountHTTP(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileMountHTTP\n"
          "// Description : Maps a web page (URL root) into the\n"
          "//               VirtualFileSystem.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VirtualFileMount._Dtool_ClassInit(NULL);
        Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VirtualFileMount.As_PyTypeObject());
        Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualFileMountHTTP.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileMountHTTP)");
             printf(" Error In PyType_ReadyVirtualFileMountHTTP");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileMountHTTP.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_dict,"VirtualFileMountHTTP",&Dtool_VirtualFileMountHTTP.As_PyObject());
        //  Static Method reloadVfsMountUrl
        PyDict_SetItemString(Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_dict,"reloadVfsMountUrl",PyCFunction_New(&Dtool_Methods_VirtualFileMountHTTP[2],&Dtool_VirtualFileMountHTTP.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileMountHTTP.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileMountHTTP[3],&Dtool_VirtualFileMountHTTP.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileMountHTTP,VirtualFileMountHTTP::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileMountHTTP.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileMountHTTP",(PyObject *)&Dtool_VirtualFileMountHTTP.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Extractor | Extractor
//********************************************************************
PyMethodDef Dtool_Methods_Extractor[]= {
  { "setMultifile",(PyCFunction ) &Dtool_Extractor_set_multifile_393, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_set_multifile_393_comment},
  { "setExtractDir",(PyCFunction ) &Dtool_Extractor_set_extract_dir_394, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_set_extract_dir_394_comment},
  { "reset",(PyCFunction ) &Dtool_Extractor_reset_395, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_reset_395_comment},
  { "requestSubfile",(PyCFunction ) &Dtool_Extractor_request_subfile_396, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_request_subfile_396_comment},
  { "requestAllSubfiles",(PyCFunction ) &Dtool_Extractor_request_all_subfiles_397, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_request_all_subfiles_397_comment},
  { "step",(PyCFunction ) &Dtool_Extractor_step_398, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_step_398_comment},
  { "getProgress",(PyCFunction ) &Dtool_Extractor_get_progress_399, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_get_progress_399_comment},
  { "run",(PyCFunction ) &Dtool_Extractor_run_400, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Extractor_run_400_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Extractor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Extractor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Extractor\n"
          "// Description : This class automatically extracts the contents of a\n"
          "//               Multifile to the current directory (or to a specified\n"
          "//               directory) in the background.\n"
          "//\n"
          "//               It is designed to limit its use of system resources\n"
          "//               and run unobtrusively in the background.  After\n"
          "//               specifying the files you wish to extract via repeated\n"
          "//               calls to request_subfile(), begin the process by\n"
          "//               calling run() repeatedly.  Each call to run()\n"
          "//               extracts another small portion of the Multifile.\n"
          "//               Call run() whenever you have spare cycles until run()\n"
          "//               returns EU_success.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Extractor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Extractor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Extractor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Extractor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Extractor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Extractor)");
             printf(" Error In PyType_ReadyExtractor");
             return;
        }
        Py_INCREF(&Dtool_Extractor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Extractor.As_PyTypeObject().tp_dict,"Extractor",&Dtool_Extractor.As_PyObject());
        RegisterRuntimeClass(&Dtool_Extractor,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Extractor.As_PyTypeObject());
        PyModule_AddObject(module, "Extractor",(PyObject *)&Dtool_Extractor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MultiplexStream | MultiplexStream
//********************************************************************
PyMethodDef Dtool_Methods_MultiplexStream[]= {
  { "addOstream",(PyCFunction ) &Dtool_MultiplexStream_add_ostream_403, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultiplexStream_add_ostream_403_comment},
  { "addStandardOutput",(PyCFunction ) &Dtool_MultiplexStream_add_standard_output_405, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultiplexStream_add_standard_output_405_comment},
  { "addFile",(PyCFunction ) &Dtool_MultiplexStream_add_file_406, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultiplexStream_add_file_406_comment},
  { "addSystemDebug",(PyCFunction ) &Dtool_MultiplexStream_add_system_debug_407, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultiplexStream_add_system_debug_407_comment},
  { "flush",(PyCFunction ) &Dtool_MultiplexStream_flush_408, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultiplexStream_flush_408_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MultiplexStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MultiplexStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MultiplexStream\n"
          "// Description : This is a special ostream that forwards the data that\n"
          "//               is written to it to any number of other sources, for\n"
          "//               instance other ostreams, or explicitly to a disk file\n"
          "//               or to system logging utilities.  It's a very handy\n"
          "//               thing to set Notify to refer to when running in batch\n"
          "//               mode.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_MultiplexStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ostream.As_PyTypeObject());
        Dtool_MultiplexStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MultiplexStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MultiplexStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MultiplexStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MultiplexStream)");
             printf(" Error In PyType_ReadyMultiplexStream");
             return;
        }
        Py_INCREF(&Dtool_MultiplexStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MultiplexStream.As_PyTypeObject().tp_dict,"MultiplexStream",&Dtool_MultiplexStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_MultiplexStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MultiplexStream.As_PyTypeObject());
        PyModule_AddObject(module, "MultiplexStream",(PyObject *)&Dtool_MultiplexStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Patcher | Patcher
//********************************************************************
PyMethodDef Dtool_Methods_Patcher[]= {
  { "initiate",(PyCFunction ) &Dtool_Patcher_initiate_413, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patcher_initiate_413_comment},
  { "run",(PyCFunction ) &Dtool_Patcher_run_414, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patcher_run_414_comment},
  { "getProgress",(PyCFunction ) &Dtool_Patcher_get_progress_415, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patcher_get_progress_415_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Patcher(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Patcher.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Patcher\n"
          "// Description : Applies a patch synchronously\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Patcher.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Patcher.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Patcher.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Patcher.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Patcher.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Patcher)");
             printf(" Error In PyType_ReadyPatcher");
             return;
        }
        Py_INCREF(&Dtool_Patcher.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Patcher.As_PyTypeObject().tp_dict,"Patcher",&Dtool_Patcher.As_PyObject());
        RegisterRuntimeClass(&Dtool_Patcher,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Patcher.As_PyTypeObject());
        PyModule_AddObject(module, "Patcher",(PyObject *)&Dtool_Patcher.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StringStream | StringStream
//********************************************************************
PyMethodDef Dtool_Methods_StringStream[]= {
  { "clearData",(PyCFunction ) &Dtool_StringStream_clear_data_418, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StringStream_clear_data_418_comment},
  { "getDataSize",(PyCFunction ) &Dtool_StringStream_get_data_size_419, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StringStream_get_data_size_419_comment},
  { "getData",(PyCFunction ) &Dtool_StringStream_get_data_420, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StringStream_get_data_420_comment},
  { "setData",(PyCFunction ) &Dtool_StringStream_set_data_421, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StringStream_set_data_421_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StringStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StringStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StringStream\n"
          "// Description : A bi-directional stream object that reads and writes\n"
          "//               data to an internal buffer, which can be retrieved\n"
          "//               and/or set as a string.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_iostream._Dtool_ClassInit(NULL);
        Dtool_StringStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_iostream.As_PyTypeObject());
        Dtool_StringStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StringStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StringStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StringStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StringStream)");
             printf(" Error In PyType_ReadyStringStream");
             return;
        }
        Py_INCREF(&Dtool_StringStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StringStream.As_PyTypeObject().tp_dict,"StringStream",&Dtool_StringStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_StringStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StringStream.As_PyTypeObject());
        PyModule_AddObject(module, "StringStream",(PyObject *)&Dtool_StringStream.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..SSReader
//********************************************************************
   Dtool_PyModuleClassInit_SSReader(module);
//********************************************************************
//*** Module Init Updcall ..SSWriter
//********************************************************************
   Dtool_PyModuleClassInit_SSWriter(module);
//********************************************************************
//*** Module Init Updcall ..ISocketStream
//********************************************************************
   Dtool_PyModuleClassInit_ISocketStream(module);
//********************************************************************
//*** Module Init Updcall ..OSocketStream
//********************************************************************
   Dtool_PyModuleClassInit_OSocketStream(module);
//********************************************************************
//*** Module Init Updcall ..SocketStream
//********************************************************************
   Dtool_PyModuleClassInit_SocketStream(module);
//********************************************************************
//*** Module Init Updcall ..URLSpec
//********************************************************************
   Dtool_PyModuleClassInit_URLSpec(module);
//********************************************************************
//*** Module Init Updcall ..HTTPEnum
//********************************************************************
   Dtool_PyModuleClassInit_HTTPEnum(module);
//********************************************************************
//*** Module Init Updcall ..HTTPDate
//********************************************************************
   Dtool_PyModuleClassInit_HTTPDate(module);
//********************************************************************
//*** Module Init Updcall ..HTTPCookie
//********************************************************************
   Dtool_PyModuleClassInit_HTTPCookie(module);
//********************************************************************
//*** Module Init Updcall ..HTTPClient
//********************************************************************
   Dtool_PyModuleClassInit_HTTPClient(module);
//********************************************************************
//*** Module Init Updcall ..HTTPEntityTag
//********************************************************************
   Dtool_PyModuleClassInit_HTTPEntityTag(module);
//********************************************************************
//*** Module Init Updcall ..DocumentSpec
//********************************************************************
   Dtool_PyModuleClassInit_DocumentSpec(module);
//********************************************************************
//*** Module Init Updcall ..HTTPChannel
//********************************************************************
   Dtool_PyModuleClassInit_HTTPChannel(module);
//********************************************************************
//*** Module Init Updcall ..Decompressor
//********************************************************************
   Dtool_PyModuleClassInit_Decompressor(module);
//********************************************************************
//*** Module Init Updcall ..DownloadDb
//********************************************************************
   Dtool_PyModuleClassInit_DownloadDb(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileHTTP
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileHTTP(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileMountHTTP
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileMountHTTP(module);
//********************************************************************
//*** Module Init Updcall ..Extractor
//********************************************************************
   Dtool_PyModuleClassInit_Extractor(module);
//********************************************************************
//*** Module Init Updcall ..MultiplexStream
//********************************************************************
   Dtool_PyModuleClassInit_MultiplexStream(module);
//********************************************************************
//*** Module Init Updcall ..Patcher
//********************************************************************
   Dtool_PyModuleClassInit_Patcher(module);
//********************************************************************
//*** Module Init Updcall ..StringStream
//********************************************************************
   Dtool_PyModuleClassInit_StringStream(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "checkCrc", (PyCFunction) &Dtool_check_crc_378, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_check_crc_378_comment},
  { "checkAdler", (PyCFunction) &Dtool_check_adler_379, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_check_adler_379_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdownloader_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212817,  /* file_identifier */
  "libdownloader",  /* library_name */
  "2KOd",  /* library_hash_name */
  "pandaexpress",  /* module_name */
  "libdownloader.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  919  /* next_index */
};

Configure(_in_configure_libdownloader);
ConfigureFn(_in_configure_libdownloader) {
  interrogate_request_module(&_in_module_def);
}

