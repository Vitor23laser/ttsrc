/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/pnmtext -Ipanda/src/pnmtext -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpnmtext_igate.cxx -od built_Rocket/pandac/input/libpnmtext.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/pnmtext -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/freetype/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libpnmtext config_pnmtext.h freetypeFace.h freetypeFont.h pnmTextGlyph.h pnmTextMaker.h pnmtext_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpnmtext
#include "py_panda.h"  

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "config_pnmtext.h"
#include "filename.h"
#include "freetypeFace.h"
#include "freetypeFont.h"
#include <ft2build.h>
#include "mutexHolder.h"
#include "namable.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pmutex.h"
#include "pnmImage.h"
#include "pnmTextGlyph.h"
#include "pnmTextMaker.h"
#include "pvector.h"
#include "textEncoder.h"
#include "typedReferenceCount.h"
#include "vector_int.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. FreetypeFont
//********************************************************************
typedef  FreetypeFont  FreetypeFont_localtype;
Define_Module_Class(panda,FreetypeFont,FreetypeFont_localtype,FreetypeFont);
//********************************************************************
//*** prototypes for .. PNMTextGlyph
//********************************************************************
typedef  PNMTextGlyph  PNMTextGlyph_localtype;
Define_Module_Class(panda,PNMTextGlyph,PNMTextGlyph_localtype,PNMTextGlyph);
//********************************************************************
//*** prototypes for .. PNMTextMaker
//********************************************************************
typedef  PNMTextMaker  PNMTextMaker_localtype;
Define_Module_Class(panda,PNMTextMaker,PNMTextMaker_localtype,PNMTextMaker);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PNMImage;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. FreetypeFont 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool FreetypeFont::set_point_size(float point_size)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_set_point_size_4(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool FreetypeFont::set_point_size(float point_size)
        double param1;
        static char * key_word_list[] = {(char *)"point_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPointSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPointSize", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_point_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FreetypeFont.setPointSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPointSize(non-const FreetypeFont this, float point_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_set_point_size_4_comment =
    "C++ Interface:\n"
    "setPointSize(non-const FreetypeFont this, float point_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::set_point_size\n"
    "//       Access: Public\n"
    "//  Description: Sets the point size of the font.  This controls the\n"
    "//               apparent size of the font onscreen.  By convention, a\n"
    "//               10 point font is about 1 screen unit high.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_set_point_size_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FreetypeFont::get_point_size(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_point_size_5(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FreetypeFont::get_point_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPointSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FreetypeFont*)local_this)->get_point_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointSize(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_point_size_5_comment =
    "C++ Interface:\n"
    "getPointSize(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_point_size\n"
    "//       Access: Public\n"
    "//  Description: Returns the point size of the font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_point_size_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool FreetypeFont::set_pixels_per_unit(float pixels_per_unit)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_set_pixels_per_unit_6(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool FreetypeFont::set_pixels_per_unit(float pixels_per_unit)
        double param1;
        static char * key_word_list[] = {(char *)"pixels_per_unit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPixelsPerUnit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPixelsPerUnit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_pixels_per_unit((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FreetypeFont.setPixelsPerUnit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPixelsPerUnit(non-const FreetypeFont this, float pixels_per_unit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_set_pixels_per_unit_6_comment =
    "C++ Interface:\n"
    "setPixelsPerUnit(non-const FreetypeFont this, float pixels_per_unit)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::set_pixels_per_unit\n"
    "//       Access: Public\n"
    "//  Description: Set the resolution of the texture map, and hence the\n"
    "//               clarity of the resulting font.  This sets the number\n"
    "//               of pixels in the texture map that are used for each\n"
    "//               onscreen unit.\n"
    "//\n"
    "//               Setting this number larger results in an easier to\n"
    "//               read font, but at the cost of more texture memory.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_set_pixels_per_unit_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FreetypeFont::get_pixels_per_unit(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_pixels_per_unit_7(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FreetypeFont::get_pixels_per_unit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelsPerUnit", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelsPerUnit"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FreetypeFont*)local_this)->get_pixels_per_unit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelsPerUnit(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_pixels_per_unit_7_comment =
    "C++ Interface:\n"
    "getPixelsPerUnit(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_pixels_per_unit\n"
    "//       Access: Public\n"
    "//  Description: Returns the resolution of the texture map.  See\n"
    "//               set_pixels_per_unit().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_pixels_per_unit_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool FreetypeFont::set_pixel_size(float pixel_size)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_set_pixel_size_8(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool FreetypeFont::set_pixel_size(float pixel_size)
        double param1;
        static char * key_word_list[] = {(char *)"pixel_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPixelSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPixelSize", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_pixel_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FreetypeFont.setPixelSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPixelSize(non-const FreetypeFont this, float pixel_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_set_pixel_size_8_comment =
    "C++ Interface:\n"
    "setPixelSize(non-const FreetypeFont this, float pixel_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::set_pixel_size\n"
    "//       Access: Public\n"
    "//  Description: Computes the appropriate pixels_per_unit value to set\n"
    "//               the size of the font in the texture to the indicated\n"
    "//               number of pixels.  This is just another way to\n"
    "//               specify pixels_per_unit().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_set_pixel_size_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FreetypeFont::get_pixel_size(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_pixel_size_9(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FreetypeFont::get_pixel_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FreetypeFont*)local_this)->get_pixel_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelSize(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_pixel_size_9_comment =
    "C++ Interface:\n"
    "getPixelSize(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_pixel_size\n"
    "//       Access: Public\n"
    "//  Description: Returns the size of the font in pixels, as it appears\n"
    "//               in the texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_pixel_size_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool FreetypeFont::set_scale_factor(float scale_factor)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_set_scale_factor_10(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool FreetypeFont::set_scale_factor(float scale_factor)
        double param1;
        static char * key_word_list[] = {(char *)"scale_factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setScaleFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setScaleFactor", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_scale_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FreetypeFont.setScaleFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScaleFactor(non-const FreetypeFont this, float scale_factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_set_scale_factor_10_comment =
    "C++ Interface:\n"
    "setScaleFactor(non-const FreetypeFont this, float scale_factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::set_scale_factor\n"
    "//       Access: Public\n"
    "//  Description: Sets the factor by which the font is rendered larger\n"
    "//               by the FreeType library before being filtered down to\n"
    "//               its actual size in the texture as specified by\n"
    "//               set_pixels_per_unit().  This may be set to a number\n"
    "//               larger than 1.0 to improve the font's antialiasing\n"
    "//               (since FreeType doesn't really do a swell job of\n"
    "//               antialiasing by itself).  There is some performance\n"
    "//               implication for setting this different than 1.0.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_set_scale_factor_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FreetypeFont::get_scale_factor(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_scale_factor_11(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FreetypeFont::get_scale_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScaleFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getScaleFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FreetypeFont*)local_this)->get_scale_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScaleFactor(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_scale_factor_11_comment =
    "C++ Interface:\n"
    "getScaleFactor(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_scale_factor\n"
    "//       Access: Public\n"
    "//  Description: Returns the antialiasing scale factor.  See\n"
    "//               set_scale_factor().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_scale_factor_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FreetypeFont::set_native_antialias(bool native_antialias)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_set_native_antialias_12(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FreetypeFont::set_native_antialias(bool native_antialias)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"native_antialias", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNativeAntialias", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setNativeAntialias", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_native_antialias((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FreetypeFont.setNativeAntialias() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNativeAntialias(non-const FreetypeFont this, bool native_antialias)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_set_native_antialias_12_comment =
    "C++ Interface:\n"
    "setNativeAntialias(non-const FreetypeFont this, bool native_antialias)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::set_native_antialias\n"
    "//       Access: Public\n"
    "//  Description: Sets whether the Freetype library's built-in\n"
    "//               antialias mode is enabled.  There are two unrelated\n"
    "//               ways to achieve antialiasing: with Freetype's native\n"
    "//               antialias mode, and with the use of a scale_factor\n"
    "//               greater than one.  By default, both modes are\n"
    "//               enabled.\n"
    "//\n"
    "//               At low resolutions, some fonts may do better with one\n"
    "//               mode or the other.  In general, Freetype's native\n"
    "//               antialiasing will produce less blurry results, but\n"
    "//               may introduce more artifacts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_set_native_antialias_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool FreetypeFont::get_native_antialias(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_native_antialias_13(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool FreetypeFont::get_native_antialias(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNativeAntialias", key_word_list));
        else
            (PyArg_Parse(args, ":getNativeAntialias"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const FreetypeFont*)local_this)->get_native_antialias();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNativeAntialias(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_native_antialias_13_comment =
    "C++ Interface:\n"
    "getNativeAntialias(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_native_antialias\n"
    "//       Access: Public\n"
    "//  Description: Returns whether Freetype's built-in antialias mode is\n"
    "//               enabled.  See set_native_antialias().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_native_antialias_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FreetypeFont::get_font_pixel_size(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_font_pixel_size_14(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FreetypeFont::get_font_pixel_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFontPixelSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFontPixelSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FreetypeFont*)local_this)->get_font_pixel_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFontPixelSize(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_font_pixel_size_14_comment =
    "C++ Interface:\n"
    "getFontPixelSize(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_font_pixel_size\n"
    "//       Access: Public\n"
    "//  Description: This is used to report whether the requested pixel\n"
    "//               size is being only approximated by a fixed-pixel-size\n"
    "//               font.  This returns 0 in the normal case, in which a\n"
    "//               scalable font is used, or the fixed-pixel-size font\n"
    "//               has exactly the requested pixel size.\n"
    "//\n"
    "//               If this returns non-zero, it is the pixel size of the\n"
    "//               font that we are using to approximate our desired\n"
    "//               size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_font_pixel_size_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FreetypeFont::get_line_height(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_line_height_15(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FreetypeFont::get_line_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLineHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getLineHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FreetypeFont*)local_this)->get_line_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLineHeight(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_line_height_15_comment =
    "C++ Interface:\n"
    "getLineHeight(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_line_height\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of units high each line of text\n"
    "//               is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_line_height_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FreetypeFont::get_space_advance(void) const
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_space_advance_16(PyObject *self, PyObject *args,PyObject *kwds) {
    FreetypeFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FreetypeFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FreetypeFont::get_space_advance(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpaceAdvance", key_word_list));
        else
            (PyArg_Parse(args, ":getSpaceAdvance"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FreetypeFont*)local_this)->get_space_advance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpaceAdvance(const FreetypeFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_space_advance_16_comment =
    "C++ Interface:\n"
    "getSpaceAdvance(const FreetypeFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_space_advance\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of units wide a space is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_space_advance_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float FreetypeFont::get_points_per_unit(void)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_points_per_unit_17(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float FreetypeFont::get_points_per_unit(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointsPerUnit", key_word_list))
        {
            float return_value = FreetypeFont::get_points_per_unit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointsPerUnit()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_points_per_unit_17_comment =
    "C++ Interface:\n"
    "getPointsPerUnit()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_points_per_unit\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the point size of the font that is one Panda\n"
    "//               unit high.  This is an arbitrary Panda convention for\n"
    "//               text, and is set to 10.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_points_per_unit_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float FreetypeFont::get_points_per_inch(void)
 *******************************************************************/
static PyObject *Dtool_FreetypeFont_get_points_per_inch_18(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float FreetypeFont::get_points_per_inch(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointsPerInch", key_word_list))
        {
            float return_value = FreetypeFont::get_points_per_inch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointsPerInch()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FreetypeFont_get_points_per_inch_18_comment =
    "C++ Interface:\n"
    "getPointsPerInch()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FreetypeFont::get_points_per_inch\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the number of points in one inch.  This is a\n"
    "//               universal typographic convention.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FreetypeFont_get_points_per_inch_18_comment = NULL;
#endif

int  Dtool_Init_FreetypeFont(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (FreetypeFont)");
       return -1;
}
inline void  * Dtool_UpcastInterface_FreetypeFont(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FreetypeFont)
    {
        printf("FreetypeFont ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FreetypeFont * local_this = (FreetypeFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FreetypeFont)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FreetypeFont(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FreetypeFont)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FreetypeFont*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMTextGlyph 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_advance(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_advance_22(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_advance(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAdvance", key_word_list));
        else
            (PyArg_Parse(args, ":getAdvance"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_advance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAdvance(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_advance_22_comment =
    "C++ Interface:\n"
    "getAdvance(const PNMTextGlyph this)\n"
    "\n"
    "// Filename: pnmTextGlyph.I\n"
    "// Created by:  drose (07Sep03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_advance\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of pixels by which the pen should\n"
    "//               be advanced after rendering this glyph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_advance_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LVecBase4f const &fg)
 * void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LVecBase4f const &fg, LVecBase4f const &interior)
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_place_23(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LVecBase4f const &fg)
                PyObject *param1;
                int param2;
                int param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"dest_image", (char *)"xp", (char *)"yp", (char *)"fg", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OiiO:place", key_word_list, &param1, &param2, &param3, &param4))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMTextGlyph.place", 0, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "PNMTextGlyph.place", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param4_this == NULL)))
                    {
                        (local_this)->place(*param1_this, (int)param2, (int)param3, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMTextGlyph.place() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LVecBase4f const &fg, LVecBase4f const &interior)
                PyObject *param1;
                int param2;
                int param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"dest_image", (char *)"xp", (char *)"yp", (char *)"fg", (char *)"interior", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OiiOO:place", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMTextGlyph.place", 0, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "PNMTextGlyph.place", 1, coerced_ptr, report_errors);
LVecBase4f *param5_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase4f, 5, "PNMTextGlyph.place", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)))
                    {
                        (local_this)->place(*param1_this, (int)param2, (int)param3, *param4_this, *param5_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMTextGlyph.place() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "place() takes 5 or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "place(non-const PNMTextGlyph this, non-const PNMImage dest_image, int xp, int yp, const VBase4 fg)\n"
          "place(non-const PNMTextGlyph this, non-const PNMImage dest_image, int xp, int yp, const VBase4 fg, const VBase4 interior)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_place_23_comment =
    "C++ Interface:\n"
    "place(non-const PNMTextGlyph this, non-const PNMImage dest_image, int xp, int yp, const VBase4 fg)\n"
    "place(non-const PNMTextGlyph this, non-const PNMImage dest_image, int xp, int yp, const VBase4 fg, const VBase4 interior)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::place\n"
    "//       Access: Public\n"
    "//  Description: Copies the glyph to the indicated destination image\n"
    "//               at the indicated origin.  It colors the glyph pixels\n"
    "//               the indicated foreground color, blends antialiased\n"
    "//               pixels with the appropriate amount of the foreground\n"
    "//               color and the existing background color, and leaves\n"
    "//               other pixels alone.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::place\n"
    "//       Access: Public\n"
    "//  Description: This flavor of place() also fills in the interior\n"
    "//               color.  This requires that determine_interior was\n"
    "//               called earlier.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_place_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_left(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_left_24(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_left(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeft", key_word_list));
        else
            (PyArg_Parse(args, ":getLeft"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_left();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeft(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_left_24_comment =
    "C++ Interface:\n"
    "getLeft(const PNMTextGlyph this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_left\n"
    "//       Access: Public\n"
    "//  Description: Returns the x coordinate of the leftmost pixel in the\n"
    "//               glyph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_left_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_right(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_right_25(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_right(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRight", key_word_list));
        else
            (PyArg_Parse(args, ":getRight"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_right();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRight(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_right_25_comment =
    "C++ Interface:\n"
    "getRight(const PNMTextGlyph this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_right\n"
    "//       Access: Public\n"
    "//  Description: Returns the x coordinate of the rightmost pixel in the\n"
    "//               glyph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_right_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_bottom(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_bottom_26(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_bottom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBottom", key_word_list));
        else
            (PyArg_Parse(args, ":getBottom"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_bottom();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBottom(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_bottom_26_comment =
    "C++ Interface:\n"
    "getBottom(const PNMTextGlyph this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_bottom\n"
    "//       Access: Public\n"
    "//  Description: Returns the y coordinate of the bottommost pixel in\n"
    "//               the glyph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_bottom_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_top(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_top_27(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_top(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTop", key_word_list));
        else
            (PyArg_Parse(args, ":getTop"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_top();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTop(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_top_27_comment =
    "C++ Interface:\n"
    "getTop(const PNMTextGlyph this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_top\n"
    "//       Access: Public\n"
    "//  Description: Returns the y coordinate of the topmost pixel in the\n"
    "//               glyph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_top_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_height_28(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_height_28_comment =
    "C++ Interface:\n"
    "getHeight(const PNMTextGlyph this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_height\n"
    "//       Access: Public\n"
    "//  Description: Returns the height of the glyph in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_height_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextGlyph::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_width_29(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMTextGlyph::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMTextGlyph*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const PNMTextGlyph this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_width_29_comment =
    "C++ Interface:\n"
    "getWidth(const PNMTextGlyph this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_width\n"
    "//       Access: Public\n"
    "//  Description: Returns the width of the glyph in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_width_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMTextGlyph::get_value(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_value_30(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMTextGlyph::get_value(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getValue", key_word_list, &param1, &param2))
        {
            double return_value = ((const PNMTextGlyph*)local_this)->get_value((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const PNMTextGlyph this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_value_30_comment =
    "C++ Interface:\n"
    "getValue(const PNMTextGlyph this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_value\n"
    "//       Access: Public\n"
    "//  Description: Returns the value of the indicated pixel of the\n"
    "//               glyph.  The result is in the range [0, 1], where 0\n"
    "//               indicates the pixel is not part of the glyph, and 1\n"
    "//               indicates it is.  Intermediate values are used to\n"
    "//               represent antialiasing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_value_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMTextGlyph::get_interior_flag(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMTextGlyph_get_interior_flag_31(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextGlyph * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextGlyph,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PNMTextGlyph::get_interior_flag(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getInteriorFlag", key_word_list, &param1, &param2))
        {
            bool return_value = ((const PNMTextGlyph*)local_this)->get_interior_flag((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInteriorFlag(const PNMTextGlyph this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextGlyph_get_interior_flag_31_comment =
    "C++ Interface:\n"
    "getInteriorFlag(const PNMTextGlyph this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextGlyph::get_interior_flag\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the indicated pixel represents a\n"
    "//               pixel in the interior of a hollow font, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextGlyph_get_interior_flag_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMTextGlyph::PNMTextGlyph(double advance)
 *******************************************************************/
int  Dtool_Init_PNMTextGlyph(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PNMTextGlyph::PNMTextGlyph(double advance)
        double param0;
        static char * key_word_list[] = {(char *)"advance", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:PNMTextGlyph", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:PNMTextGlyph", &param0));
        if(!PyErr_Occurred())
        {
            PNMTextGlyph *return_value = new PNMTextGlyph((double)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMTextGlyph,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PNMTextGlyph(float advance)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PNMTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMTextGlyph)
    {
        printf("PNMTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMTextGlyph * local_this = (PNMTextGlyph *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMTextGlyph)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMTextGlyph(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMTextGlyph)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMTextMaker 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool PNMTextMaker::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_is_valid_36(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PNMTextMaker::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PNMTextMaker*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const PNMTextMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_is_valid_36_comment =
    "C++ Interface:\n"
    "isValid(const PNMTextMaker this)\n"
    "\n"
    "// Filename: pnmTextMaker.I\n"
    "// Created by:  drose (07Sep03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the PNMTextMaker is valid and ready to\n"
    "//               generate text, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_is_valid_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMTextMaker::set_align(PNMTextMaker::Alignment align_type)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_set_align_37(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMTextMaker::set_align(PNMTextMaker::Alignment align_type)
        int param1;
        static char * key_word_list[] = {(char *)"align_type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAlign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAlign", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_align((PNMTextMaker::Alignment)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMTextMaker.setAlign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlign(non-const PNMTextMaker this, int align_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_set_align_37_comment =
    "C++ Interface:\n"
    "setAlign(non-const PNMTextMaker this, int align_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::set_align\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_set_align_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMTextMaker::Alignment PNMTextMaker::get_align(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_get_align_38(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PNMTextMaker::Alignment PNMTextMaker::get_align(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlign", key_word_list));
        else
            (PyArg_Parse(args, ":getAlign"));
        if(!PyErr_Occurred())
        {
            PNMTextMaker::Alignment return_value = ((const PNMTextMaker*)local_this)->get_align();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlign(const PNMTextMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_get_align_38_comment =
    "C++ Interface:\n"
    "getAlign(const PNMTextMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::get_align\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_get_align_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMTextMaker::set_interior_flag(bool interior_flag)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_set_interior_flag_39(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMTextMaker::set_interior_flag(bool interior_flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"interior_flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInteriorFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setInteriorFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_interior_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMTextMaker.setInteriorFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInteriorFlag(non-const PNMTextMaker this, bool interior_flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_set_interior_flag_39_comment =
    "C++ Interface:\n"
    "setInteriorFlag(non-const PNMTextMaker this, bool interior_flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::set_interior_flag\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag that indicates whether the interior of\n"
    "//               hollow fonts is identified as a preprocess as each\n"
    "//               glyph is loaded.  If this flag is true, you may\n"
    "//               specify an interior color along with a fg and bg\n"
    "//               color when you place text; if the flag is false, the\n"
    "//               interior color is ignored.\n"
    "//\n"
    "//               It is generally best to set_native_antialias(0) when\n"
    "//               using this feature.  Also, this works best when the\n"
    "//               pixel size is not very small.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_set_interior_flag_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMTextMaker::get_interior_flag(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_get_interior_flag_40(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PNMTextMaker::get_interior_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInteriorFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getInteriorFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PNMTextMaker*)local_this)->get_interior_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInteriorFlag(const PNMTextMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_get_interior_flag_40_comment =
    "C++ Interface:\n"
    "getInteriorFlag(const PNMTextMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::get_interior_flag\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_get_interior_flag_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMTextMaker::set_fg(LVecBase4f const &fg)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_set_fg_41(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMTextMaker::set_fg(LVecBase4f const &fg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"fg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFg", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFg", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PNMTextMaker.setFg", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_fg(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMTextMaker.setFg() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFg(non-const PNMTextMaker this, const VBase4 fg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_set_fg_41_comment =
    "C++ Interface:\n"
    "setFg(non-const PNMTextMaker this, const VBase4 fg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::set_fg\n"
    "//       Access: Published\n"
    "//  Description: Sets the foreground color of text that will be\n"
    "//               generated by future calls to generate_into().  This\n"
    "//               is the color that all of the \"on\" pixels in the font\n"
    "//               will show as.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_set_fg_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PNMTextMaker::get_fg(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_get_fg_42(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PNMTextMaker::get_fg(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFg", key_word_list));
        else
            (PyArg_Parse(args, ":getFg"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PNMTextMaker*)local_this)->get_fg());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFg(const PNMTextMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_get_fg_42_comment =
    "C++ Interface:\n"
    "getFg(const PNMTextMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::get_fg\n"
    "//       Access: Published\n"
    "//  Description: Returns the foreground color of text that will be\n"
    "//               generated by future calls to generate_into().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_get_fg_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMTextMaker::set_interior(LVecBase4f const &interior)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_set_interior_43(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMTextMaker::set_interior(LVecBase4f const &interior)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"interior", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInterior", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setInterior", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PNMTextMaker.setInterior", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_interior(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMTextMaker.setInterior() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInterior(non-const PNMTextMaker this, const VBase4 interior)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_set_interior_43_comment =
    "C++ Interface:\n"
    "setInterior(non-const PNMTextMaker this, const VBase4 interior)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::set_interior\n"
    "//       Access: Published\n"
    "//  Description: Sets the color that will be used to render the\n"
    "//               interior portions of hollow fonts in future calls to\n"
    "//               generate_into().  This is respected only if\n"
    "//               interior_flag is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_set_interior_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PNMTextMaker::get_interior(void) const
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_get_interior_44(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PNMTextMaker::get_interior(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInterior", key_word_list));
        else
            (PyArg_Parse(args, ":getInterior"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PNMTextMaker*)local_this)->get_interior());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInterior(const PNMTextMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_get_interior_44_comment =
    "C++ Interface:\n"
    "getInterior(const PNMTextMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::get_interior\n"
    "//       Access: Published\n"
    "//  Description: Returns the color that will be used to render the\n"
    "//               interior portions of hollow fonts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_get_interior_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextMaker::generate_into(basic_string< char > const &text, PNMImage &dest_image, int x, int y)
 * int PNMTextMaker::generate_into(basic_string< wchar_t > const &text, PNMImage &dest_image, int x, int y)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_generate_into_45(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int PNMTextMaker::generate_into(basic_string< wchar_t > const &text, PNMImage &dest_image, int x, int y)
            PyUnicodeObject *param1
;
            PyObject *param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"text", (char *)"dest_image", (char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "UOii:generateInto", key_word_list, &param1, &param2, &param3, &param4))
            {
                 int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);PNMImage *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMImage, 2, "PNMTextMaker.generateInto", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    int return_value = (local_this)->generate_into(basic_string<wchar_t>((wchar_t *)param1_str, param1_len), *param2_this, (int)param3, (int)param4);
                     delete[] param1_str;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline int PNMTextMaker::generate_into(basic_string< char > const &text, PNMImage &dest_image, int x, int y)
            char *param1_str; int param1_len;
            PyObject *param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"text", (char *)"dest_image", (char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oii:generateInto", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4))
            {
                PNMImage *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMImage, 2, "PNMTextMaker.generateInto", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    int return_value = (local_this)->generate_into(basic_string<char>(param1_str, param1_len), *param2_this, (int)param3, (int)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generateInto(non-const PNMTextMaker this, string text, non-const PNMImage dest_image, int x, int y)\n"
          "generateInto(non-const PNMTextMaker this, string text, non-const PNMImage dest_image, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_generate_into_45_comment =
    "C++ Interface:\n"
    "generateInto(non-const PNMTextMaker this, string text, non-const PNMImage dest_image, int x, int y)\n"
    "generateInto(non-const PNMTextMaker this, string text, non-const PNMImage dest_image, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::generate_into\n"
    "//       Access: Public\n"
    "//  Description: Generates a single line of text into the indicated\n"
    "//               image at the indicated position; the return value is\n"
    "//               the total width in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::generate_into\n"
    "//       Access: Public\n"
    "//  Description: Generates a single line of text into the indicated\n"
    "//               image at the indicated position; the return value is\n"
    "//               the total width in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_generate_into_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMTextMaker::calc_width(basic_string< char > const &text)
 * int PNMTextMaker::calc_width(basic_string< wchar_t > const &text)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_calc_width_46(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline int PNMTextMaker::calc_width(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:calcWidth", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:calcWidth", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->calc_width(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 int PNMTextMaker::calc_width(basic_string< wchar_t > const &text)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:calcWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:calcWidth", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            int return_value = (local_this)->calc_width(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcWidth(non-const PNMTextMaker this, string text)\n"
          "calcWidth(non-const PNMTextMaker this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_calc_width_46_comment =
    "C++ Interface:\n"
    "calcWidth(non-const PNMTextMaker this, string text)\n"
    "calcWidth(non-const PNMTextMaker this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::calc_width\n"
    "//       Access: Public\n"
    "//  Description: Returns the width in pixels of the indicated line of\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::calc_width\n"
    "//       Access: Public\n"
    "//  Description: Returns the width in pixels of the indicated line of\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_calc_width_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMTextGlyph *PNMTextMaker::get_glyph(int character)
 *******************************************************************/
static PyObject *Dtool_PNMTextMaker_get_glyph_47(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMTextMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMTextMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PNMTextGlyph *PNMTextMaker::get_glyph(int character)
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getGlyph", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getGlyph", &param1));
        if(!PyErr_Occurred())
        {
            PNMTextGlyph *return_value = (local_this)->get_glyph((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMTextGlyph,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMTextMaker.getGlyph() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlyph(non-const PNMTextMaker this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMTextMaker_get_glyph_47_comment =
    "C++ Interface:\n"
    "getGlyph(non-const PNMTextMaker this, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMTextMaker::get_glyph\n"
    "//       Access: Public\n"
    "//  Description: Returns the glyph for the indicated index, or NULL if\n"
    "//               it is not defined in the font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMTextMaker_get_glyph_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMTextMaker::PNMTextMaker(Filename const &font_filename, int face_index)
 * PNMTextMaker::PNMTextMaker(PNMTextMaker const &copy)
 * PNMTextMaker::PNMTextMaker(char const *font_data, int data_length, int face_index)
 *******************************************************************/
int  Dtool_Init_PNMTextMaker(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PNMTextMaker::PNMTextMaker(PNMTextMaker const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PNMTextMaker", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PNMTextMaker", &param0));
                if(!PyErr_Occurred())
                {
                    PNMTextMaker *param0_this = (PNMTextMaker *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMTextMaker, 0, "PNMTextMaker.PNMTextMaker", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PNMTextMaker *return_value = new PNMTextMaker(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMTextMaker,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PNMTextMaker::PNMTextMaker(Filename const &font_filename, int face_index)
                PyObject *param0;
                int param1;
                static char * key_word_list[] = {(char *)"font_filename", (char *)"face_index", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:PNMTextMaker", key_word_list, &param0, &param1))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "PNMTextMaker.PNMTextMaker", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PNMTextMaker *return_value = new PNMTextMaker(*param0_this, (int)param1);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMTextMaker,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-PNMTextMaker::PNMTextMaker(char const *font_data, int data_length, int face_index)
            char *param0;
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"font_data", (char *)"data_length", (char *)"face_index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "sii:PNMTextMaker", key_word_list, &param0, &param1, &param2))
            {
                PNMTextMaker *return_value = new PNMTextMaker((char const *)param0, (int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMTextMaker,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PNMTextMaker() takes 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PNMTextMaker(const PNMTextMaker copy)\n"
          "PNMTextMaker(const Filename font_filename, int face_index)\n"
          "PNMTextMaker(string font_data, int data_length, int face_index)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PNMTextMaker(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMTextMaker)
    {
        printf("PNMTextMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMTextMaker * local_this = (PNMTextMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMTextMaker)
        return local_this;
    if(requested_type == &Dtool_FreetypeFont)
        return ( FreetypeFont *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( FreetypeFont *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMTextMaker(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMTextMaker)
        return from_this;
    if(from_type == &Dtool_FreetypeFont)
    {
          FreetypeFont* other_this = (FreetypeFont*)from_this;
          return (PNMTextMaker*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PNMTextMaker*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. FreetypeFont | FreetypeFont
//********************************************************************
PyMethodDef Dtool_Methods_FreetypeFont[]= {
  { "setPointSize",(PyCFunction ) &Dtool_FreetypeFont_set_point_size_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_set_point_size_4_comment},
  { "getPointSize",(PyCFunction ) &Dtool_FreetypeFont_get_point_size_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_point_size_5_comment},
  { "setPixelsPerUnit",(PyCFunction ) &Dtool_FreetypeFont_set_pixels_per_unit_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_set_pixels_per_unit_6_comment},
  { "getPixelsPerUnit",(PyCFunction ) &Dtool_FreetypeFont_get_pixels_per_unit_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_pixels_per_unit_7_comment},
  { "setPixelSize",(PyCFunction ) &Dtool_FreetypeFont_set_pixel_size_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_set_pixel_size_8_comment},
  { "getPixelSize",(PyCFunction ) &Dtool_FreetypeFont_get_pixel_size_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_pixel_size_9_comment},
  { "setScaleFactor",(PyCFunction ) &Dtool_FreetypeFont_set_scale_factor_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_set_scale_factor_10_comment},
  { "getScaleFactor",(PyCFunction ) &Dtool_FreetypeFont_get_scale_factor_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_scale_factor_11_comment},
  { "setNativeAntialias",(PyCFunction ) &Dtool_FreetypeFont_set_native_antialias_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_set_native_antialias_12_comment},
  { "getNativeAntialias",(PyCFunction ) &Dtool_FreetypeFont_get_native_antialias_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_native_antialias_13_comment},
  { "getFontPixelSize",(PyCFunction ) &Dtool_FreetypeFont_get_font_pixel_size_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_font_pixel_size_14_comment},
  { "getLineHeight",(PyCFunction ) &Dtool_FreetypeFont_get_line_height_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_line_height_15_comment},
  { "getSpaceAdvance",(PyCFunction ) &Dtool_FreetypeFont_get_space_advance_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_space_advance_16_comment},
  { "getPointsPerUnit",(PyCFunction ) &Dtool_FreetypeFont_get_points_per_unit_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_points_per_unit_17_comment},
  { "getPointsPerInch",(PyCFunction ) &Dtool_FreetypeFont_get_points_per_inch_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FreetypeFont_get_points_per_inch_18_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FreetypeFont(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FreetypeFont.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FreetypeFont\n"
          "// Description : This is a common base class for both DynamicTextFont\n"
          "//               and PNMTextMaker.  Both of these are utility classes\n"
          "//               that use the FreeType library to generate glyphs from\n"
          "//               fonts; this class abstracts out that common wrapper\n"
          "//               around FreeType.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_FreetypeFont.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Namable.As_PyTypeObject());
        Dtool_FreetypeFont.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FreetypeFont.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FreetypeFont.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FreetypeFont.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FreetypeFont)");
             printf(" Error In PyType_ReadyFreetypeFont");
             return;
        }
        Py_INCREF(&Dtool_FreetypeFont.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FreetypeFont.As_PyTypeObject().tp_dict,"FreetypeFont",&Dtool_FreetypeFont.As_PyObject());
        //  Static Method getPointsPerUnit
        PyDict_SetItemString(Dtool_FreetypeFont.As_PyTypeObject().tp_dict,"getPointsPerUnit",PyCFunction_New(&Dtool_Methods_FreetypeFont[13],&Dtool_FreetypeFont.As_PyObject()));
        //  Static Method getPointsPerInch
        PyDict_SetItemString(Dtool_FreetypeFont.As_PyTypeObject().tp_dict,"getPointsPerInch",PyCFunction_New(&Dtool_Methods_FreetypeFont[14],&Dtool_FreetypeFont.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FreetypeFont,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FreetypeFont.As_PyTypeObject());
        PyModule_AddObject(module, "FreetypeFont",(PyObject *)&Dtool_FreetypeFont.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMTextGlyph | PNMTextGlyph
//********************************************************************
PyMethodDef Dtool_Methods_PNMTextGlyph[]= {
  { "getAdvance",(PyCFunction ) &Dtool_PNMTextGlyph_get_advance_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_advance_22_comment},
  { "place",(PyCFunction ) &Dtool_PNMTextGlyph_place_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_place_23_comment},
  { "getLeft",(PyCFunction ) &Dtool_PNMTextGlyph_get_left_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_left_24_comment},
  { "getRight",(PyCFunction ) &Dtool_PNMTextGlyph_get_right_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_right_25_comment},
  { "getBottom",(PyCFunction ) &Dtool_PNMTextGlyph_get_bottom_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_bottom_26_comment},
  { "getTop",(PyCFunction ) &Dtool_PNMTextGlyph_get_top_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_top_27_comment},
  { "getHeight",(PyCFunction ) &Dtool_PNMTextGlyph_get_height_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_height_28_comment},
  { "getWidth",(PyCFunction ) &Dtool_PNMTextGlyph_get_width_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_width_29_comment},
  { "getValue",(PyCFunction ) &Dtool_PNMTextGlyph_get_value_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_value_30_comment},
  { "getInteriorFlag",(PyCFunction ) &Dtool_PNMTextGlyph_get_interior_flag_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextGlyph_get_interior_flag_31_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PNMTextGlyph(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMTextGlyph.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMTextGlyph\n"
          "// Description : A single glyph in a PNMTextMaker.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMTextGlyph.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMTextGlyph.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMTextGlyph.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMTextGlyph.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PNMTextGlyph.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMTextGlyph)");
             printf(" Error In PyType_ReadyPNMTextGlyph");
             return;
        }
        Py_INCREF(&Dtool_PNMTextGlyph.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMTextGlyph.As_PyTypeObject().tp_dict,"PNMTextGlyph",&Dtool_PNMTextGlyph.As_PyObject());
        RegisterRuntimeClass(&Dtool_PNMTextGlyph,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMTextGlyph.As_PyTypeObject());
        PyModule_AddObject(module, "PNMTextGlyph",(PyObject *)&Dtool_PNMTextGlyph.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMTextMaker | PNMTextMaker
//********************************************************************
PyMethodDef Dtool_Methods_PNMTextMaker[]= {
  { "isValid",(PyCFunction ) &Dtool_PNMTextMaker_is_valid_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_is_valid_36_comment},
  { "setAlign",(PyCFunction ) &Dtool_PNMTextMaker_set_align_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_set_align_37_comment},
  { "getAlign",(PyCFunction ) &Dtool_PNMTextMaker_get_align_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_get_align_38_comment},
  { "setInteriorFlag",(PyCFunction ) &Dtool_PNMTextMaker_set_interior_flag_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_set_interior_flag_39_comment},
  { "getInteriorFlag",(PyCFunction ) &Dtool_PNMTextMaker_get_interior_flag_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_get_interior_flag_40_comment},
  { "setFg",(PyCFunction ) &Dtool_PNMTextMaker_set_fg_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_set_fg_41_comment},
  { "getFg",(PyCFunction ) &Dtool_PNMTextMaker_get_fg_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_get_fg_42_comment},
  { "setInterior",(PyCFunction ) &Dtool_PNMTextMaker_set_interior_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_set_interior_43_comment},
  { "getInterior",(PyCFunction ) &Dtool_PNMTextMaker_get_interior_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_get_interior_44_comment},
  { "generateInto",(PyCFunction ) &Dtool_PNMTextMaker_generate_into_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_generate_into_45_comment},
  { "calcWidth",(PyCFunction ) &Dtool_PNMTextMaker_calc_width_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_calc_width_46_comment},
  { "getGlyph",(PyCFunction ) &Dtool_PNMTextMaker_get_glyph_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMTextMaker_get_glyph_47_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PNMTextMaker(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMTextMaker.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMTextMaker\n"
          "// Description : This object uses the Freetype library to generate\n"
          "//               text directly into an image.  It is different from\n"
          "//               the TextNode/DynamicTextFont interface, which use the\n"
          "//               Freetype library to generate text in the scene graph,\n"
          "//               to be rendered onscreen via the Panda render\n"
          "//               traversal.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_FreetypeFont._Dtool_ClassInit(NULL);
        Dtool_PNMTextMaker.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_FreetypeFont.As_PyTypeObject());
        Dtool_PNMTextMaker.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMTextMaker.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMTextMaker.As_PyTypeObject().tp_dict);
        // Enum  PNMTextMaker::Alignment;
        PyDict_SetItemString(Dtool_PNMTextMaker.As_PyTypeObject().tp_dict,"ALeft",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PNMTextMaker.As_PyTypeObject().tp_dict,"ARight",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PNMTextMaker.As_PyTypeObject().tp_dict,"ACenter",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_PNMTextMaker.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMTextMaker)");
             printf(" Error In PyType_ReadyPNMTextMaker");
             return;
        }
        Py_INCREF(&Dtool_PNMTextMaker.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMTextMaker.As_PyTypeObject().tp_dict,"PNMTextMaker",&Dtool_PNMTextMaker.As_PyObject());
        RegisterRuntimeClass(&Dtool_PNMTextMaker,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMTextMaker.As_PyTypeObject());
        PyModule_AddObject(module, "PNMTextMaker",(PyObject *)&Dtool_PNMTextMaker.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..FreetypeFont
//********************************************************************
   Dtool_PyModuleClassInit_FreetypeFont(module);
//********************************************************************
//*** Module Init Updcall ..PNMTextGlyph
//********************************************************************
   Dtool_PyModuleClassInit_PNMTextGlyph(module);
//********************************************************************
//*** Module Init Updcall ..PNMTextMaker
//********************************************************************
   Dtool_PyModuleClassInit_PNMTextMaker(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpnmtext_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212880,  /* file_identifier */
  "libpnmtext",  /* library_name */
  "BrcS",  /* library_hash_name */
  "panda",  /* module_name */
  "libpnmtext.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  117  /* next_index */
};

Configure(_in_configure_libpnmtext);
ConfigureFn(_in_configure_libpnmtext) {
  interrogate_request_module(&_in_module_def);
}

