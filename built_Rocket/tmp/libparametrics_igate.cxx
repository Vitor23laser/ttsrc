/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/parametrics -Ipanda/src/parametrics -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libparametrics_igate.cxx -od built_Rocket/pandac/input/libparametrics.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/parametrics -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libparametrics config_parametrics.h cubicCurveseg.h curveFitter.h hermiteCurve.h nurbsBasisVector.h nurbsCurve.h nurbsCurveEvaluator.h nurbsCurveInterface.h nurbsCurveResult.h nurbsSurfaceEvaluator.h nurbsSurfaceResult.h nurbsVertex.h parametricCurve.h parametricCurveCollection.h parametrics_composite.cxx piecewiseCurve.h ropeNode.h sheetNode.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libparametrics
#include "py_panda.h"  

#include "config_parametrics.h"
#include "cubicCurveseg.h"
#include "curveFitter.h"
#include "hermiteCurve.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "nurbsBasisVector.h"
#include "nurbsCurve.h"
#include "nurbsCurveEvaluator.h"
#include "nurbsCurveInterface.h"
#include "nurbsCurveResult.h"
#include "nurbsSurfaceEvaluator.h"
#include "nurbsSurfaceResult.h"
#include "nurbsVertex.h"
#include "pandabase.h"
#include "parametricCurve.h"
#include "parametricCurveCollection.h"
#include "piecewiseCurve.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "referenceCount.h"
#include "ropeNode.h"
#include "sheetNode.h"
#include "typedef.h"
#include "vector_float.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ParametricCurve
//********************************************************************
typedef  ParametricCurve  ParametricCurve_localtype;
Define_Module_ClassRef(panda,ParametricCurve,ParametricCurve_localtype,ParametricCurve);
//********************************************************************
//*** prototypes for .. CubicCurveseg
//********************************************************************
typedef  CubicCurveseg  CubicCurveseg_localtype;
Define_Module_ClassRef(panda,CubicCurveseg,CubicCurveseg_localtype,CubicCurveseg);
//********************************************************************
//*** prototypes for .. ParametricCurveCollection
//********************************************************************
typedef  ParametricCurveCollection  ParametricCurveCollection_localtype;
Define_Module_ClassRef(panda,ParametricCurveCollection,ParametricCurveCollection_localtype,ParametricCurveCollection);
//********************************************************************
//*** prototypes for .. CurveFitter
//********************************************************************
typedef  CurveFitter  CurveFitter_localtype;
Define_Module_Class(panda,CurveFitter,CurveFitter_localtype,CurveFitter);
//********************************************************************
//*** prototypes for .. PiecewiseCurve
//********************************************************************
typedef  PiecewiseCurve  PiecewiseCurve_localtype;
Define_Module_ClassRef(panda,PiecewiseCurve,PiecewiseCurve_localtype,PiecewiseCurve);
//********************************************************************
//*** prototypes for .. HermiteCurve
//********************************************************************
typedef  HermiteCurve  HermiteCurve_localtype;
Define_Module_ClassRef(panda,HermiteCurve,HermiteCurve_localtype,HermiteCurve);
//********************************************************************
//*** prototypes for .. NurbsCurveInterface
//********************************************************************
typedef  NurbsCurveInterface  NurbsCurveInterface_localtype;
Define_Module_Class(panda,NurbsCurveInterface,NurbsCurveInterface_localtype,NurbsCurveInterface);
//********************************************************************
//*** prototypes for .. NurbsCurve
//********************************************************************
typedef  NurbsCurve  NurbsCurve_localtype;
Define_Module_ClassRef(panda,NurbsCurve,NurbsCurve_localtype,NurbsCurve);
//********************************************************************
//*** prototypes for .. NurbsCurveResult
//********************************************************************
typedef  NurbsCurveResult  NurbsCurveResult_localtype;
Define_Module_ClassRef(panda,NurbsCurveResult,NurbsCurveResult_localtype,NurbsCurveResult);
//********************************************************************
//*** prototypes for .. NurbsCurveEvaluator
//********************************************************************
typedef  NurbsCurveEvaluator  NurbsCurveEvaluator_localtype;
Define_Module_ClassRef(panda,NurbsCurveEvaluator,NurbsCurveEvaluator_localtype,NurbsCurveEvaluator);
//********************************************************************
//*** prototypes for .. NurbsSurfaceResult
//********************************************************************
typedef  NurbsSurfaceResult  NurbsSurfaceResult_localtype;
Define_Module_ClassRef(panda,NurbsSurfaceResult,NurbsSurfaceResult_localtype,NurbsSurfaceResult);
//********************************************************************
//*** prototypes for .. NurbsSurfaceEvaluator
//********************************************************************
typedef  NurbsSurfaceEvaluator  NurbsSurfaceEvaluator_localtype;
Define_Module_ClassRef(panda,NurbsSurfaceEvaluator,NurbsSurfaceEvaluator_localtype,NurbsSurfaceEvaluator);
//********************************************************************
//*** prototypes for .. RopeNode
//********************************************************************
typedef  RopeNode  RopeNode_localtype;
Define_Module_ClassRef(panda,RopeNode,RopeNode_localtype,RopeNode);
//********************************************************************
//*** prototypes for .. SheetNode
//********************************************************************
typedef  SheetNode  SheetNode_localtype;
Define_Module_ClassRef(panda,SheetNode,SheetNode_localtype,SheetNode);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. ParametricCurve 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_is_valid_3(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool ParametricCurve::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ParametricCurve*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const ParametricCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_is_valid_3_comment =
    "C++ Interface:\n"
    "isValid(const ParametricCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::is_valid\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if the curve is defined.  This base\n"
    "//               class function always returns true; derived classes\n"
    "//               might override this to sometimes return false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_is_valid_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float ParametricCurve::get_max_t(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_max_t_4(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float ParametricCurve::get_max_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxT", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParametricCurve*)local_this)->get_max_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxT(const ParametricCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_max_t_4_comment =
    "C++ Interface:\n"
    "getMaxT(const ParametricCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::get_max_t\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the upper bound of t for the entire curve.\n"
    "//               The curve is defined in the range 0.0f <= t <=\n"
    "//               get_max_t().  This base class function always returns\n"
    "//               1.0f; derived classes might override this to return\n"
    "//               something else.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_max_t_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurve::set_curve_type(int type)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_set_curve_type_5(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurve::set_curve_type(int type)
        int param1;
        static char * key_word_list[] = {(char *)"type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCurveType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCurveType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_curve_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurve.setCurveType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCurveType(non-const ParametricCurve this, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_set_curve_type_5_comment =
    "C++ Interface:\n"
    "setCurveType(non-const ParametricCurve this, int type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::set_curve_type\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag indicating the use to which the curve\n"
    "//               is intended to be put.  This flag is optional and\n"
    "//               only serves to provide a hint to the egg reader and\n"
    "//               writer code; it has no effect on the curve's\n"
    "//               behavior.\n"
    "//\n"
    "//               Setting the curve type also sets the num_dimensions\n"
    "//               to 3 or 1 according to the type.\n"
    "//\n"
    "//               THis flag may have one of the values PCT_XYZ,\n"
    "//               PCT_HPR, or PCT_T.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_set_curve_type_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ParametricCurve::get_curve_type(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_curve_type_6(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ParametricCurve::get_curve_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurveType", key_word_list));
        else
            (PyArg_Parse(args, ":getCurveType"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParametricCurve*)local_this)->get_curve_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurveType(const ParametricCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_curve_type_6_comment =
    "C++ Interface:\n"
    "getCurveType(const ParametricCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::get_curve_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag indicating the use to which the curve\n"
    "//               is intended to be put.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_curve_type_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurve::set_num_dimensions(int num)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_set_num_dimensions_7(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurve::set_num_dimensions(int num)
        int param1;
        static char * key_word_list[] = {(char *)"num", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumDimensions", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumDimensions", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_dimensions((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurve.setNumDimensions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumDimensions(non-const ParametricCurve this, int num)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_set_num_dimensions_7_comment =
    "C++ Interface:\n"
    "setNumDimensions(non-const ParametricCurve this, int num)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::set_num_dimensions\n"
    "//       Access: Published\n"
    "//  Description: Specifies the number of significant dimensions in the\n"
    "//               curve's vertices.  This should be one of 1, 2, or 3.\n"
    "//               Normally, XYZ and HPR curves have three dimensions;\n"
    "//               time curves should always have one dimension.  This\n"
    "//               only serves as a hint to the mopath editor, and also\n"
    "//               controls how the curve is written out.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_set_num_dimensions_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ParametricCurve::get_num_dimensions(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_num_dimensions_8(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ParametricCurve::get_num_dimensions(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDimensions", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDimensions"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParametricCurve*)local_this)->get_num_dimensions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDimensions(const ParametricCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_num_dimensions_8_comment =
    "C++ Interface:\n"
    "getNumDimensions(const ParametricCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::get_num_dimensions\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of significant dimensions in the\n"
    "//               curve's vertices, as set by a previous call to\n"
    "//               set_num_dimensions().  This is only a hint as to how\n"
    "//               the curve is intended to be used; the actual number\n"
    "//               of dimensions of any curve is always three.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_num_dimensions_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float ParametricCurve::calc_length(void) const
 * float ParametricCurve::calc_length(float from, float to) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_calc_length_9(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-float ParametricCurve::calc_length(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":calcLength", key_word_list));
            else
                (PyArg_Parse(args, ":calcLength"));
            if(!PyErr_Occurred())
            {
                float return_value = ((const ParametricCurve*)local_this)->calc_length();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-float ParametricCurve::calc_length(float from, float to) const
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:calcLength", key_word_list, &param1, &param2))
            {
                float return_value = ((const ParametricCurve*)local_this)->calc_length((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "calcLength() takes 1 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "calcLength(const ParametricCurve this)\n"
          "calcLength(const ParametricCurve this, float from, float to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_calc_length_9_comment =
    "C++ Interface:\n"
    "calcLength(const ParametricCurve this)\n"
    "calcLength(const ParametricCurve this, float from, float to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::calc_length\n"
    "//       Access: Published\n"
    "//  Description: Approximates the length of the entire curve to within\n"
    "//               a few decimal places.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::calc_length\n"
    "//       Access: Published\n"
    "//  Description: Approximates the length of the curve segment from\n"
    "//               parametric time 'from' to time 'to'.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_calc_length_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float ParametricCurve::find_length(float start_t, float length_offset) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_find_length_10(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float ParametricCurve::find_length(float start_t, float length_offset) const
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"start_t", (char *)"length_offset", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:findLength", key_word_list, &param1, &param2))
        {
            float return_value = ((const ParametricCurve*)local_this)->find_length((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findLength(const ParametricCurve this, float start_t, float length_offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_find_length_10_comment =
    "C++ Interface:\n"
    "findLength(const ParametricCurve this, float start_t, float length_offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::find_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the parametric value corresponding to the\n"
    "//               indicated distance along the curve from the starting\n"
    "//               parametric value.\n"
    "//\n"
    "//               This is the inverse of calc_length(): rather than\n"
    "//               determining the length along the curve between two\n"
    "//               parametric points, it determines the position in\n"
    "//               parametric time of a point n units along the curve.\n"
    "//\n"
    "//               The search distance must not be negative.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_find_length_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::get_point(float t, LVecBase3f &point) const = 0
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_point_11(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual bool ParametricCurve::get_point(float t, LVecBase3f &point) const = 0
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"point", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:getPoint", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurve.getPoint", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = ((const ParametricCurve*)local_this)->get_point((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const ParametricCurve this, float t, non-const VBase3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_point_11_comment =
    "C++ Interface:\n"
    "getPoint(const ParametricCurve this, float t, non-const VBase3 point)\n"
    "\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_point_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::get_tangent(float t, LVecBase3f &tangent) const = 0
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_tangent_12(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual bool ParametricCurve::get_tangent(float t, LVecBase3f &tangent) const = 0
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"tangent", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:getTangent", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurve.getTangent", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = ((const ParametricCurve*)local_this)->get_tangent((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTangent(const ParametricCurve this, float t, non-const VBase3 tangent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_tangent_12_comment =
    "C++ Interface:\n"
    "getTangent(const ParametricCurve this, float t, non-const VBase3 tangent)\n"
    "\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_tangent_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::get_pt(float t, LVecBase3f &point, LVecBase3f &tangent) const = 0
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_pt_13(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual bool ParametricCurve::get_pt(float t, LVecBase3f &point, LVecBase3f &tangent) const = 0
            double param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"t", (char *)"point", (char *)"tangent", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dOO:getPt", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurve.getPt", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "ParametricCurve.getPt", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const ParametricCurve*)local_this)->get_pt((float)param1, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPt(const ParametricCurve this, float t, non-const VBase3 point, non-const VBase3 tangent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_pt_13_comment =
    "C++ Interface:\n"
    "getPt(const ParametricCurve this, float t, non-const VBase3 point, non-const VBase3 tangent)\n"
    "\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_pt_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::get_2ndtangent(float t, LVecBase3f &tangent2) const = 0
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_2ndtangent_14(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual bool ParametricCurve::get_2ndtangent(float t, LVecBase3f &tangent2) const = 0
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"tangent2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:get2ndtangent", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurve.get2ndtangent", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = ((const ParametricCurve*)local_this)->get_2ndtangent((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get2ndtangent(const ParametricCurve this, float t, non-const VBase3 tangent2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_2ndtangent_14_comment =
    "C++ Interface:\n"
    "get2ndtangent(const ParametricCurve this, float t, non-const VBase3 tangent2)\n"
    "\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_2ndtangent_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::adjust_point(float t, float px, float py, float pz)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_adjust_point_15(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool ParametricCurve::adjust_point(float t, float px, float py, float pz)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"t", (char *)"px", (char *)"py", (char *)"pz", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:adjustPoint", key_word_list, &param1, &param2, &param3, &param4))
        {
            bool return_value = (local_this)->adjust_point((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurve.adjustPoint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "adjustPoint(non-const ParametricCurve this, float t, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_adjust_point_15_comment =
    "C++ Interface:\n"
    "adjustPoint(non-const ParametricCurve this, float t, float px, float py, float pz)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::adjust_point\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Recomputes the curve such that it passes through the\n"
    "//               point (px, py, pz) at time t, but keeps the same\n"
    "//               tangent value at that point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_adjust_point_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::adjust_tangent(float t, float tx, float ty, float tz)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_adjust_tangent_16(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool ParametricCurve::adjust_tangent(float t, float tx, float ty, float tz)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"t", (char *)"tx", (char *)"ty", (char *)"tz", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:adjustTangent", key_word_list, &param1, &param2, &param3, &param4))
        {
            bool return_value = (local_this)->adjust_tangent((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurve.adjustTangent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "adjustTangent(non-const ParametricCurve this, float t, float tx, float ty, float tz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_adjust_tangent_16_comment =
    "C++ Interface:\n"
    "adjustTangent(non-const ParametricCurve this, float t, float tx, float ty, float tz)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::adjust_tangent\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Recomputes the curve such that it has the tangent\n"
    "//               (tx, ty, tz) at time t, but keeps the same position\n"
    "//               at the point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_adjust_tangent_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::adjust_pt(float t, float px, float py, float pz, float tx, float ty, float tz)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_adjust_pt_17(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool ParametricCurve::adjust_pt(float t, float px, float py, float pz, float tx, float ty, float tz)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        static char * key_word_list[] = {(char *)"t", (char *)"px", (char *)"py", (char *)"pz", (char *)"tx", (char *)"ty", (char *)"tz", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddd:adjustPt", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
        {
            bool return_value = (local_this)->adjust_pt((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurve.adjustPt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "adjustPt(non-const ParametricCurve this, float t, float px, float py, float pz, float tx, float ty, float tz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_adjust_pt_17_comment =
    "C++ Interface:\n"
    "adjustPt(non-const ParametricCurve this, float t, float px, float py, float pz, float tx, float ty, float tz)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::adjust_pt\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Recomputes the curve such that it passes through the\n"
    "//               point (px, py, pz) with the tangent (tx, ty, tz).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_adjust_pt_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::recompute(void)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_recompute_18(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool ParametricCurve::recompute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recompute", key_word_list));
        else
            (PyArg_Parse(args, ":recompute"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->recompute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurve.recompute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recompute(non-const ParametricCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_recompute_18_comment =
    "C++ Interface:\n"
    "recompute(non-const ParametricCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::recompute\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Recalculates the curve, if necessary.  Returns\n"
    "//               true if the resulting curve is valid, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_recompute_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_stitch_19(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:stitch", key_word_list, &param1, &param2))
            {
                ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurve, 1, "ParametricCurve.stitch", 1, coerced_ptr, report_errors);
ParametricCurve *param2_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ParametricCurve, 2, "ParametricCurve.stitch", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->stitch(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParametricCurve.stitch() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stitch(non-const ParametricCurve this, const ParametricCurve a, const ParametricCurve b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_stitch_19_comment =
    "C++ Interface:\n"
    "stitch(non-const ParametricCurve this, const ParametricCurve a, const ParametricCurve b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::stitch\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Regenerates this curve as one long curve: the first\n"
    "//               curve connected end-to-end with the second one.\n"
    "//               Either a or b may be the same as 'this'.\n"
    "//\n"
    "//               Returns true if successful, false on failure or if\n"
    "//               the curve type does not support stitching.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_stitch_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs)
 * bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs = (CS_default))
 * bool ParametricCurve::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_write_egg_20(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs = (CS_default))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeEgg", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeEgg", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ParametricCurve.writeEgg", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->write_egg(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurve.writeEgg() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeEgg", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ParametricCurve.writeEgg", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->write_egg(*param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurve.writeEgg() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurve::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"out", (char *)"filename", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:writeEgg", key_word_list, &param1, &param2, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParametricCurve.writeEgg", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "ParametricCurve.writeEgg", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->write_egg(*param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurve.writeEgg() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeEgg() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeEgg(non-const ParametricCurve this, const Filename filename)\n"
          "writeEgg(non-const ParametricCurve this, const Filename filename, int cs)\n"
          "writeEgg(non-const ParametricCurve this, non-const Ostream out, const Filename filename, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_write_egg_20_comment =
    "C++ Interface:\n"
    "writeEgg(non-const ParametricCurve this, const Filename filename)\n"
    "writeEgg(non-const ParametricCurve this, const Filename filename, int cs)\n"
    "writeEgg(non-const ParametricCurve this, non-const Ostream out, const Filename filename, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::write_egg\n"
    "//       Access: Published\n"
    "//  Description: Writes an egg description of the nurbs curve to the\n"
    "//               specified output file.  Returns true if the file is\n"
    "//               successfully written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurve::write_egg\n"
    "//       Access: Published\n"
    "//  Description: Writes an egg description of the nurbs curve to the\n"
    "//               specified output stream.  Returns true if the file is\n"
    "//               successfully written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurve_write_egg_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ParametricCurve::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ParametricCurve_get_class_type_21(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ParametricCurve::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ParametricCurve::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurve_get_class_type_21_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ParametricCurve_get_class_type_21_comment = NULL;
#endif

int  Dtool_Init_ParametricCurve(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ParametricCurve)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ParametricCurve(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ParametricCurve)
    {
        printf("ParametricCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ParametricCurve * local_this = (ParametricCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ParametricCurve)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ParametricCurve(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ParametricCurve)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ParametricCurve*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (ParametricCurve*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ParametricCurve*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ParametricCurve*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CubicCurveseg 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CubicCurveseg::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CubicCurveseg_get_class_type_23(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CubicCurveseg::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CubicCurveseg::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CubicCurveseg_get_class_type_23_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CubicCurveseg_get_class_type_23_comment = NULL;
#endif

int  Dtool_Init_CubicCurveseg(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CubicCurveseg)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CubicCurveseg(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CubicCurveseg)
    {
        printf("CubicCurveseg ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CubicCurveseg * local_this = (CubicCurveseg *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CubicCurveseg)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_ParametricCurve)
        return ( ParametricCurve *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( ParametricCurve *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CubicCurveseg(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CubicCurveseg)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CubicCurveseg*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (CubicCurveseg*)other_this;
    }
    if(from_type == &Dtool_ParametricCurve)
    {
          ParametricCurve* other_this = (ParametricCurve*)from_this;
          return (CubicCurveseg*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CubicCurveseg*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CubicCurveseg*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ParametricCurveCollection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::add_curve(ParametricCurve *curve)
 * void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_add_curve_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ParametricCurveCollection::add_curve(ParametricCurve *curve)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"curve", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addCurve", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addCurve", &param1));
                if(!PyErr_Occurred())
                {
                    ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurve, 1, "ParametricCurveCollection.addCurve", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_curve(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.addCurve() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"curve", (char *)"index", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:addCurve", key_word_list, &param1, &param2))
                {
                    ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurve, 1, "ParametricCurveCollection.addCurve", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_curve(param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.addCurve() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addCurve() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addCurve(non-const ParametricCurveCollection this, non-const ParametricCurve curve)\n"
          "addCurve(non-const ParametricCurveCollection this, non-const ParametricCurve curve, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_add_curve_27_comment =
    "C++ Interface:\n"
    "addCurve(non-const ParametricCurveCollection this, non-const ParametricCurve curve)\n"
    "addCurve(non-const ParametricCurveCollection this, non-const ParametricCurve curve, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::add_curve\n"
    "//       Access: Published\n"
    "//  Description: Adds a new ParametricCurve to the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::add_curve\n"
    "//       Access: Published\n"
    "//  Description: Adds a new ParametricCurve to the collection at the\n"
    "//               indicated index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_add_curve_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ParametricCurveCollection::add_curves(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_add_curves_28(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ParametricCurveCollection::add_curves(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addCurves", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addCurves", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "ParametricCurveCollection.addCurves", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->add_curves(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParametricCurveCollection.addCurves() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCurves(non-const ParametricCurveCollection this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_add_curves_28_comment =
    "C++ Interface:\n"
    "addCurves(non-const ParametricCurveCollection this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::add_curves\n"
    "//       Access: Published\n"
    "//  Description: Adds all the curves found in the scene graph rooted\n"
    "//               at the given node.  Returns the number of curves\n"
    "//               found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_add_curves_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
 * void ParametricCurveCollection::remove_curve(int index)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_remove_curve_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"curve", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeCurve", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeCurve", &param1));
            if(!PyErr_Occurred())
            {
                ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurve, 1, "ParametricCurveCollection.removeCurve", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_curve(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void ParametricCurveCollection::remove_curve(int index)
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeCurve", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:removeCurve", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->remove_curve((int)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCurve(non-const ParametricCurveCollection this, non-const ParametricCurve curve)\n"
          "removeCurve(non-const ParametricCurveCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_remove_curve_29_comment =
    "C++ Interface:\n"
    "removeCurve(non-const ParametricCurveCollection this, non-const ParametricCurve curve)\n"
    "removeCurve(non-const ParametricCurveCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::remove_curve\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated ParametricCurve from the\n"
    "//               collection.  Returns true if the curve was removed,\n"
    "//               false if it was not a member of the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::remove_curve\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated ParametricCurve from the\n"
    "//               collection, by its index number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_remove_curve_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_has_curve_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"curve", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasCurve", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasCurve", &param1));
            if(!PyErr_Occurred())
            {
                ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurve, 1, "ParametricCurveCollection.hasCurve", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ParametricCurveCollection*)local_this)->has_curve(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCurve(const ParametricCurveCollection this, non-const ParametricCurve curve)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_has_curve_30_comment =
    "C++ Interface:\n"
    "hasCurve(const ParametricCurveCollection this, non-const ParametricCurve curve)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::has_curve\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated ParametricCurve appears in\n"
    "//               this collection, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_has_curve_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::clear(void)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_clear_31(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurveCollection::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurveCollection.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_clear_31_comment =
    "C++ Interface:\n"
    "clear(non-const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all ParametricCurves from the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_clear_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::clear_timewarps(void)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_clear_timewarps_32(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurveCollection::clear_timewarps(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTimewarps", key_word_list));
        else
            (PyArg_Parse(args, ":clearTimewarps"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_timewarps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurveCollection.clearTimewarps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTimewarps(non-const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_clear_timewarps_32_comment =
    "C++ Interface:\n"
    "clearTimewarps(non-const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::clear_timewarps\n"
    "//       Access: Published\n"
    "//  Description: Removes all the timewarp curves from the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_clear_timewarps_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ParametricCurveCollection::get_num_curves(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_num_curves_33(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ParametricCurveCollection::get_num_curves(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCurves", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCurves"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParametricCurveCollection*)local_this)->get_num_curves();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCurves(const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_num_curves_33_comment =
    "C++ Interface:\n"
    "getNumCurves(const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_num_curves\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of ParametricCurves in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_num_curves_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_curve_34(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCurve", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCurve", &param1));
        if(!PyErr_Occurred())
        {
            ParametricCurve *return_value = ((const ParametricCurveCollection*)local_this)->get_curve((int)param1);
            if (return_value != (ParametricCurve *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_ParametricCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurve(const ParametricCurveCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_curve_34_comment =
    "C++ Interface:\n"
    "getCurve(const ParametricCurveCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_curve\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth ParametricCurve in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_curve_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_xyz_curve_35(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXyzCurve", key_word_list));
        else
            (PyArg_Parse(args, ":getXyzCurve"));
        if(!PyErr_Occurred())
        {
            ParametricCurve *return_value = ((const ParametricCurveCollection*)local_this)->get_xyz_curve();
            if (return_value != (ParametricCurve *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_ParametricCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXyzCurve(const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_xyz_curve_35_comment =
    "C++ Interface:\n"
    "getXyzCurve(const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_xyz_curve\n"
    "//       Access: Published\n"
    "//  Description: Returns the first XYZ curve in the collection, if\n"
    "//               any, or NULL if there are none.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_xyz_curve_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_hpr_curve_36(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHprCurve", key_word_list));
        else
            (PyArg_Parse(args, ":getHprCurve"));
        if(!PyErr_Occurred())
        {
            ParametricCurve *return_value = ((const ParametricCurveCollection*)local_this)->get_hpr_curve();
            if (return_value != (ParametricCurve *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_ParametricCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHprCurve(const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_hpr_curve_36_comment =
    "C++ Interface:\n"
    "getHprCurve(const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_hpr_curve\n"
    "//       Access: Published\n"
    "//  Description: Returns the first HPR curve in the collection, if\n"
    "//               any, or NULL if there are none.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_hpr_curve_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_default_curve_37(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultCurve", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultCurve"));
        if(!PyErr_Occurred())
        {
            ParametricCurve *return_value = ((const ParametricCurveCollection*)local_this)->get_default_curve();
            if (return_value != (ParametricCurve *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_ParametricCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultCurve(const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_default_curve_37_comment =
    "C++ Interface:\n"
    "getDefaultCurve(const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_default_curve\n"
    "//       Access: Published\n"
    "//  Description: If there is an XYZ curve in the collection, returns\n"
    "//               it; otherwise, returns the first curve whose type is\n"
    "//               unspecified.  Returns NULL if no curve meets the\n"
    "//               criteria.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_default_curve_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ParametricCurveCollection::get_num_timewarps(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_num_timewarps_38(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ParametricCurveCollection::get_num_timewarps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTimewarps", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTimewarps"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParametricCurveCollection*)local_this)->get_num_timewarps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTimewarps(const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_num_timewarps_38_comment =
    "C++ Interface:\n"
    "getNumTimewarps(const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_num_timewarps\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of timewarp curves in the\n"
    "//               collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_num_timewarps_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_timewarp_curve_39(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTimewarpCurve", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTimewarpCurve", &param1));
        if(!PyErr_Occurred())
        {
            ParametricCurve *return_value = ((const ParametricCurveCollection*)local_this)->get_timewarp_curve((int)param1);
            if (return_value != (ParametricCurve *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_ParametricCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimewarpCurve(const ParametricCurveCollection this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_timewarp_curve_39_comment =
    "C++ Interface:\n"
    "getTimewarpCurve(const ParametricCurveCollection this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_timewarp_curve\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth timewarp curve in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_timewarp_curve_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ParametricCurveCollection::get_max_t(void) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_get_max_t_40(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ParametricCurveCollection::get_max_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxT", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParametricCurveCollection*)local_this)->get_max_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxT(const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_get_max_t_40_comment =
    "C++ Interface:\n"
    "getMaxT(const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::get_max_t\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum T value associated with the\n"
    "//               *last* curve in the collection.  Normally, this will\n"
    "//               be either the XYZ or HPR curve, or a timewarp curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_get_max_t_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::make_even(float max_t, float segments_per_unit)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_make_even_41(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurveCollection::make_even(float max_t, float segments_per_unit)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"max_t", (char *)"segments_per_unit", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:makeEven", key_word_list, &param1, &param2))
        {
            (local_this)->make_even((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurveCollection.makeEven() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeEven(non-const ParametricCurveCollection this, float max_t, float segments_per_unit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_make_even_41_comment =
    "C++ Interface:\n"
    "makeEven(non-const ParametricCurveCollection this, float max_t, float segments_per_unit)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::make_even\n"
    "//       Access: Published\n"
    "//  Description: Discards all existing timewarp curves and recomputes\n"
    "//               a new timewarp curve that maps distance along the\n"
    "//               curve to parametric time, so that the distance\n"
    "//               between any two points in parametric time is\n"
    "//               proportional to the approximate distance of those\n"
    "//               same two points along the XYZ curve.\n"
    "//\n"
    "//               segments_per_unit represents the number of segments to\n"
    "//               take per each unit of parametric time of the original\n"
    "//               XYZ curve.\n"
    "//\n"
    "//               The new timewarp curve (and thus, the apparent range\n"
    "//               of the collection) will range from 0 to max_t.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_make_even_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::face_forward(float segments_per_unit)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_face_forward_42(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurveCollection::face_forward(float segments_per_unit)
        double param1;
        static char * key_word_list[] = {(char *)"segments_per_unit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:faceForward", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:faceForward", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->face_forward((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurveCollection.faceForward() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "faceForward(non-const ParametricCurveCollection this, float segments_per_unit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_face_forward_42_comment =
    "C++ Interface:\n"
    "faceForward(non-const ParametricCurveCollection this, float segments_per_unit)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::face_forward\n"
    "//       Access: Published\n"
    "//  Description: Discards the existing HPR curve and generates a new\n"
    "//               one that looks in the direction of travel along the\n"
    "//               XYZ curve, based on the XYZ curve's tangent at each\n"
    "//               point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_face_forward_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::reset_max_t(float max_t)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_reset_max_t_43(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParametricCurveCollection::reset_max_t(float max_t)
        double param1;
        static char * key_word_list[] = {(char *)"max_t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:resetMaxT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:resetMaxT", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_max_t((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurveCollection.resetMaxT() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetMaxT(non-const ParametricCurveCollection this, float max_t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_reset_max_t_43_comment =
    "C++ Interface:\n"
    "resetMaxT(non-const ParametricCurveCollection this, float max_t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::reset_max_t\n"
    "//       Access: Published\n"
    "//  Description: Adjusts the apparent length of the curve by applying\n"
    "//               a new timewarp that maps the range [0..max_t] to the\n"
    "//               range [0..get_max_t()].  After this call, the curve\n"
    "//               collection will contain one more timewarp curve, and\n"
    "//               get_max_t() will return the given max_t value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_reset_max_t_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::evaluate(float t, LMatrix4f &result, CoordinateSystem cs) const
 * bool ParametricCurveCollection::evaluate(float t, LMatrix4f &result, CoordinateSystem cs = (CS_default)) const
 * bool ParametricCurveCollection::evaluate(float t, LVecBase3f &xyz, LVecBase3f &hpr) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_evaluate_44(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool ParametricCurveCollection::evaluate(float t, LMatrix4f &result, CoordinateSystem cs = (CS_default)) const
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"t", (char *)"result", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:evaluate", key_word_list, &param1, &param2))
                {
                    LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "ParametricCurveCollection.evaluate", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = ((const ParametricCurveCollection*)local_this)->evaluate((float)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool ParametricCurveCollection::evaluate(float t, LVecBase3f &xyz, LVecBase3f &hpr) const
                double param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"t", (char *)"xyz", (char *)"hpr", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dOO:evaluate", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurveCollection.evaluate", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "ParametricCurveCollection.evaluate", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)))
                    {
                        bool return_value = ((const ParametricCurveCollection*)local_this)->evaluate((float)param1, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool ParametricCurveCollection::evaluate(float t, LMatrix4f &result, CoordinateSystem cs) const
                double param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"t", (char *)"result", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dOi:evaluate", key_word_list, &param1, &param2, &param3))
                {
                    LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "ParametricCurveCollection.evaluate", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = ((const ParametricCurveCollection*)local_this)->evaluate((float)param1, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "evaluate() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "evaluate(const ParametricCurveCollection this, float t, non-const Mat4 result)\n"
          "evaluate(const ParametricCurveCollection this, float t, non-const VBase3 xyz, non-const VBase3 hpr)\n"
          "evaluate(const ParametricCurveCollection this, float t, non-const Mat4 result, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_evaluate_44_comment =
    "C++ Interface:\n"
    "evaluate(const ParametricCurveCollection this, float t, non-const Mat4 result)\n"
    "evaluate(const ParametricCurveCollection this, float t, non-const VBase3 xyz, non-const VBase3 hpr)\n"
    "evaluate(const ParametricCurveCollection this, float t, non-const Mat4 result, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::evaluate\n"
    "//       Access: Published\n"
    "//  Description: Computes the position and rotation represented by the\n"
    "//               first XYZ and HPR curves in the collection at the\n"
    "//               given point t, after t has been modified by all the\n"
    "//               timewarp curves in the collection applied in\n"
    "//               sequence, from back to front.\n"
    "//\n"
    "//               Returns true if the point is valid (i.e. t is within\n"
    "//               the bounds indicated by all the timewarp curves and\n"
    "//               within the bounds of the curves themselves), or false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::evaluate\n"
    "//       Access: Published\n"
    "//  Description: Computes the transform matrix representing\n"
    "//               translation to the position indicated by the first\n"
    "//               XYZ curve in the collection and the rotation\n"
    "//               indicated by the first HPR curve in the collection,\n"
    "//               after t has been modified by all the timewarp curves\n"
    "//               in the collection applied in sequence, from back to\n"
    "//               front.\n"
    "//\n"
    "//               Returns true if the point is valid (i.e. t is within\n"
    "//               the bounds indicated by all the timewarp curves and\n"
    "//               within the bounds of the curves themselves), or false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_evaluate_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float ParametricCurveCollection::evaluate_t(float t) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_evaluate_t_45(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float ParametricCurveCollection::evaluate_t(float t) const
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:evaluateT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:evaluateT", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParametricCurveCollection*)local_this)->evaluate_t((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evaluateT(const ParametricCurveCollection this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_evaluate_t_45_comment =
    "C++ Interface:\n"
    "evaluateT(const ParametricCurveCollection this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::evaluate_t\n"
    "//       Access: Published\n"
    "//  Description: Determines the value of t that should be passed to\n"
    "//               the XYZ and HPR curves, after applying the given\n"
    "//               value of t to all the timewarps.  Return -1.0f if the\n"
    "//               value of t exceeds one of the timewarps' ranges.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_evaluate_t_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParametricCurveCollection::evaluate_xyz(float t, LVecBase3f &xyz) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_evaluate_xyz_46(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ParametricCurveCollection::evaluate_xyz(float t, LVecBase3f &xyz) const
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"xyz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:evaluateXyz", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurveCollection.evaluateXyz", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = ((const ParametricCurveCollection*)local_this)->evaluate_xyz((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evaluateXyz(const ParametricCurveCollection this, float t, non-const VBase3 xyz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_evaluate_xyz_46_comment =
    "C++ Interface:\n"
    "evaluateXyz(const ParametricCurveCollection this, float t, non-const VBase3 xyz)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::evaluate_xyz\n"
    "//       Access: Published\n"
    "//  Description: Computes only the XYZ part of the curves.  See\n"
    "//               evaluate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_evaluate_xyz_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParametricCurveCollection::evaluate_hpr(float t, LVecBase3f &hpr) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_evaluate_hpr_47(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ParametricCurveCollection::evaluate_hpr(float t, LVecBase3f &hpr) const
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"hpr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:evaluateHpr", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurveCollection.evaluateHpr", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = ((const ParametricCurveCollection*)local_this)->evaluate_hpr((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evaluateHpr(const ParametricCurveCollection this, float t, non-const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_evaluate_hpr_47_comment =
    "C++ Interface:\n"
    "evaluateHpr(const ParametricCurveCollection this, float t, non-const VBase3 hpr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::evaluate_hpr\n"
    "//       Access: Published\n"
    "//  Description: Computes only the HPR part of the curves.  See\n"
    "//               evaluate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_evaluate_hpr_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::adjust_xyz(float t, LVecBase3f const &xyz)
 * inline bool ParametricCurveCollection::adjust_xyz(float t, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_adjust_xyz_48(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurveCollection::adjust_xyz(float t, LVecBase3f const &xyz)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"t", (char *)"xyz", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:adjustXyz", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurveCollection.adjustXyz", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->adjust_xyz((float)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.adjustXyz() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool ParametricCurveCollection::adjust_xyz(float t, float x, float y, float z)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"t", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:adjustXyz", key_word_list, &param1, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->adjust_xyz((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParametricCurveCollection.adjustXyz() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "adjustXyz() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "adjustXyz(non-const ParametricCurveCollection this, float t, const VBase3 xyz)\n"
          "adjustXyz(non-const ParametricCurveCollection this, float t, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_adjust_xyz_48_comment =
    "C++ Interface:\n"
    "adjustXyz(non-const ParametricCurveCollection this, float t, const VBase3 xyz)\n"
    "adjustXyz(non-const ParametricCurveCollection this, float t, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::adjust_xyz\n"
    "//       Access: Published\n"
    "//  Description: Adjust the XYZ curve at the indicated time to the new\n"
    "//               value.  The curve shape will change correspondingly.\n"
    "//               Returns true if successful, false if unable to make\n"
    "//               the adjustment for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::adjust_xyz\n"
    "//       Access: Published\n"
    "//  Description: Adjust the XYZ curve at the indicated time to the new\n"
    "//               value.  The curve shape will change correspondingly.\n"
    "//               Returns true if successful, false if unable to make\n"
    "//               the adjustment for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_adjust_xyz_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::adjust_hpr(float t, LVecBase3f const &xyz)
 * inline bool ParametricCurveCollection::adjust_hpr(float t, float h, float p, float r)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_adjust_hpr_49(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurveCollection::adjust_hpr(float t, LVecBase3f const &xyz)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"t", (char *)"xyz", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:adjustHpr", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "ParametricCurveCollection.adjustHpr", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->adjust_hpr((float)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.adjustHpr() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool ParametricCurveCollection::adjust_hpr(float t, float h, float p, float r)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"t", (char *)"h", (char *)"p", (char *)"r", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:adjustHpr", key_word_list, &param1, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->adjust_hpr((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParametricCurveCollection.adjustHpr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "adjustHpr() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "adjustHpr(non-const ParametricCurveCollection this, float t, const VBase3 xyz)\n"
          "adjustHpr(non-const ParametricCurveCollection this, float t, float h, float p, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_adjust_hpr_49_comment =
    "C++ Interface:\n"
    "adjustHpr(non-const ParametricCurveCollection this, float t, const VBase3 xyz)\n"
    "adjustHpr(non-const ParametricCurveCollection this, float t, float h, float p, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::adjust_hpr\n"
    "//       Access: Published\n"
    "//  Description: Adjust the HPR curve at the indicated time to the new\n"
    "//               value.  The curve shape will change correspondingly.\n"
    "//               Returns true if successful, false if unable to make\n"
    "//               the adjustment for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::adjust_hpr\n"
    "//       Access: Published\n"
    "//  Description: Adjust the HPR curve at the indicated time to the new\n"
    "//               value.  The curve shape will change correspondingly.\n"
    "//               Returns true if successful, false if unable to make\n"
    "//               the adjustment for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_adjust_hpr_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::recompute(void)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_recompute_50(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool ParametricCurveCollection::recompute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recompute", key_word_list));
        else
            (PyArg_Parse(args, ":recompute"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->recompute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParametricCurveCollection.recompute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recompute(non-const ParametricCurveCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_recompute_50_comment =
    "C++ Interface:\n"
    "recompute(non-const ParametricCurveCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::recompute\n"
    "//       Access: Published\n"
    "//  Description: Ensures all the curves are freshly computed and\n"
    "//               up-to-date.  Returns true if everything is valid,\n"
    "//               false if at least one curve is incorrect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_recompute_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_stitch_51(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:stitch", key_word_list, &param1, &param2))
            {
                ParametricCurveCollection *param1_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurveCollection, 1, "ParametricCurveCollection.stitch", 1, coerced_ptr, report_errors);
ParametricCurveCollection *param2_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ParametricCurveCollection, 2, "ParametricCurveCollection.stitch", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->stitch(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParametricCurveCollection.stitch() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stitch(non-const ParametricCurveCollection this, const ParametricCurveCollection a, const ParametricCurveCollection b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_stitch_51_comment =
    "C++ Interface:\n"
    "stitch(non-const ParametricCurveCollection this, const ParametricCurveCollection a, const ParametricCurveCollection b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::stitch\n"
    "//       Access: Published\n"
    "//  Description: Regenerates this curve as one long curve: the first\n"
    "//               curve connected end-to-end with the second one.\n"
    "//               Either a or b may be the same as 'this'.  This will\n"
    "//               lose any timewarps on the input curves.\n"
    "//\n"
    "//               Returns true if successful, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_stitch_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_output_52(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ParametricCurveCollection::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParametricCurveCollection.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ParametricCurveCollection*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ParametricCurveCollection this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_output_52_comment =
    "C++ Interface:\n"
    "output(const ParametricCurveCollection this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::output\n"
    "//       Access: Published\n"
    "//  Description: Writes a brief one-line description of the\n"
    "//               ParametricCurveCollection to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_output_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParametricCurveCollection::write(ostream &out, int indent_level) const
 * void ParametricCurveCollection::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_write_53(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ParametricCurveCollection::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParametricCurveCollection.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParametricCurveCollection*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ParametricCurveCollection::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParametricCurveCollection.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParametricCurveCollection*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const ParametricCurveCollection this, non-const Ostream out)\n"
          "write(const ParametricCurveCollection this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_write_53_comment =
    "C++ Interface:\n"
    "write(const ParametricCurveCollection this, non-const Ostream out)\n"
    "write(const ParametricCurveCollection this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::write\n"
    "//       Access: Published\n"
    "//  Description: Writes a complete multi-line description of the\n"
    "//               ParametricCurveCollection to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_write_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs)
 * bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs = (CS_default))
 * bool ParametricCurveCollection::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_ParametricCurveCollection_write_egg_54(PyObject *self, PyObject *args,PyObject *kwds) {
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs = (CS_default))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeEgg", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeEgg", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ParametricCurveCollection.writeEgg", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->write_egg(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.writeEgg() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeEgg", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ParametricCurveCollection.writeEgg", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->write_egg(*param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.writeEgg() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ParametricCurveCollection::write_egg(ostream &out, Filename const &filename, CoordinateSystem cs)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"out", (char *)"filename", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:writeEgg", key_word_list, &param1, &param2, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParametricCurveCollection.writeEgg", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "ParametricCurveCollection.writeEgg", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->write_egg(*param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParametricCurveCollection.writeEgg() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeEgg() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeEgg(non-const ParametricCurveCollection this, const Filename filename)\n"
          "writeEgg(non-const ParametricCurveCollection this, const Filename filename, int cs)\n"
          "writeEgg(non-const ParametricCurveCollection this, non-const Ostream out, const Filename filename, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParametricCurveCollection_write_egg_54_comment =
    "C++ Interface:\n"
    "writeEgg(non-const ParametricCurveCollection this, const Filename filename)\n"
    "writeEgg(non-const ParametricCurveCollection this, const Filename filename, int cs)\n"
    "writeEgg(non-const ParametricCurveCollection this, non-const Ostream out, const Filename filename, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::write_egg\n"
    "//       Access: Published\n"
    "//  Description: Writes an egg description of all the nurbs curves in\n"
    "//               the collection to the specified output file.  Returns\n"
    "//               true if the file is successfully written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ParametricCurveCollection::write_egg\n"
    "//       Access: Published\n"
    "//  Description: Writes an egg description of all the nurbs curves in\n"
    "//               the collection to the specified output stream.  Returns\n"
    "//               true if the file is successfully written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParametricCurveCollection_write_egg_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParametricCurveCollection::ParametricCurveCollection(void)
 *******************************************************************/
int  Dtool_Init_ParametricCurveCollection(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ParametricCurveCollection::ParametricCurveCollection(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ParametricCurveCollection", key_word_list))
        {
            ParametricCurveCollection *return_value = new ParametricCurveCollection();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ParametricCurveCollection,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ParametricCurveCollection()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_ParametricCurveCollection_get_curves(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumCurves", "getCurve");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_ParametricCurveCollection_get_timewarp_curves(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumTimewarps", "getTimewarpCurve");
}
inline void  * Dtool_UpcastInterface_ParametricCurveCollection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ParametricCurveCollection)
    {
        printf("ParametricCurveCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ParametricCurveCollection * local_this = (ParametricCurveCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ParametricCurveCollection)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ParametricCurveCollection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ParametricCurveCollection)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ParametricCurveCollection*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CurveFitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::reset(void)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_reset_58(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CurveFitter::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CurveFitter.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const CurveFitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_reset_58_comment =
    "C++ Interface:\n"
    "reset(non-const CurveFitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::reset\n"
    "//       Access: Public\n"
    "//  Description: Removes all the data points previously added to the\n"
    "//               CurveFitter, and initializes it for a new curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_reset_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::add_xyz(float t, LVecBase3f const &xyz)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_add_xyz_59(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CurveFitter::add_xyz(float t, LVecBase3f const &xyz)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"xyz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:addXyz", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "CurveFitter.addXyz", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->add_xyz((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CurveFitter.addXyz() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addXyz(non-const CurveFitter this, float t, const VBase3 xyz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_add_xyz_59_comment =
    "C++ Interface:\n"
    "addXyz(non-const CurveFitter this, float t, const VBase3 xyz)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::add_xyz\n"
    "//       Access: Public\n"
    "//  Description: Adds a single sample xyz.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_add_xyz_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::add_hpr(float t, LVecBase3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_add_hpr_60(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CurveFitter::add_hpr(float t, LVecBase3f const &hpr)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"hpr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:addHpr", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "CurveFitter.addHpr", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->add_hpr((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CurveFitter.addHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addHpr(non-const CurveFitter this, float t, const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_add_hpr_60_comment =
    "C++ Interface:\n"
    "addHpr(non-const CurveFitter this, float t, const VBase3 hpr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::add_hpr\n"
    "//       Access: Public\n"
    "//  Description: Adds a single sample hpr.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_add_hpr_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::add_xyz_hpr(float t, LVecBase3f const &xyz, LVecBase3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_add_xyz_hpr_61(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CurveFitter::add_xyz_hpr(float t, LVecBase3f const &xyz, LVecBase3f const &hpr)
            double param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"t", (char *)"xyz", (char *)"hpr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dOO:addXyzHpr", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "CurveFitter.addXyzHpr", 1, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "CurveFitter.addXyzHpr", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param3_this == NULL)))
                {
                    (local_this)->add_xyz_hpr((float)param1, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CurveFitter.addXyzHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addXyzHpr(non-const CurveFitter this, float t, const VBase3 xyz, const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_add_xyz_hpr_61_comment =
    "C++ Interface:\n"
    "addXyzHpr(non-const CurveFitter this, float t, const VBase3 xyz, const VBase3 hpr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::add_xyz_hpr\n"
    "//       Access: Public\n"
    "//  Description: Adds a single sample xyz & hpr simultaneously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_add_xyz_hpr_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CurveFitter::get_num_samples(void) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_get_num_samples_62(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int CurveFitter::get_num_samples(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSamples", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSamples"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CurveFitter*)local_this)->get_num_samples();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSamples(const CurveFitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_get_num_samples_62_comment =
    "C++ Interface:\n"
    "getNumSamples(const CurveFitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::get_num_samples\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of sample points that have been\n"
    "//               added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_get_num_samples_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float CurveFitter::get_sample_t(int n) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_get_sample_t_63(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float CurveFitter::get_sample_t(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSampleT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSampleT", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CurveFitter*)local_this)->get_sample_t((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSampleT(const CurveFitter this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_get_sample_t_63_comment =
    "C++ Interface:\n"
    "getSampleT(const CurveFitter this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::get_sample_t\n"
    "//       Access: Public\n"
    "//  Description: Returns the parametric value of the nth sample added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_get_sample_t_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f CurveFitter::get_sample_xyz(int n) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_get_sample_xyz_64(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase3f CurveFitter::get_sample_xyz(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSampleXyz", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSampleXyz", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const CurveFitter*)local_this)->get_sample_xyz((int)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSampleXyz(const CurveFitter this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_get_sample_xyz_64_comment =
    "C++ Interface:\n"
    "getSampleXyz(const CurveFitter this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::get_sample_xyz\n"
    "//       Access: Public\n"
    "//  Description: Returns the point in space of the nth sample added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_get_sample_xyz_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f CurveFitter::get_sample_hpr(int n) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_get_sample_hpr_65(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase3f CurveFitter::get_sample_hpr(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSampleHpr", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSampleHpr", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const CurveFitter*)local_this)->get_sample_hpr((int)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSampleHpr(const CurveFitter this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_get_sample_hpr_65_comment =
    "C++ Interface:\n"
    "getSampleHpr(const CurveFitter this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::get_sample_hpr\n"
    "//       Access: Public\n"
    "//  Description: Returns the orientation of the nth sample added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_get_sample_hpr_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f CurveFitter::get_sample_tangent(int n) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_get_sample_tangent_66(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase3f CurveFitter::get_sample_tangent(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSampleTangent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSampleTangent", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const CurveFitter*)local_this)->get_sample_tangent((int)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSampleTangent(const CurveFitter this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_get_sample_tangent_66_comment =
    "C++ Interface:\n"
    "getSampleTangent(const CurveFitter this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::get_sample_tangent\n"
    "//       Access: Public\n"
    "//  Description: Returns the tangent associated with the nth sample\n"
    "//               added.  This is only meaningful if compute_tangents()\n"
    "//               has already been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_get_sample_tangent_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::remove_samples(int begin, int end)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_remove_samples_67(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CurveFitter::remove_samples(int begin, int end)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"begin", (char *)"end", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:removeSamples", key_word_list, &param1, &param2))
        {
            (local_this)->remove_samples((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CurveFitter.removeSamples() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeSamples(non-const CurveFitter this, int begin, int end)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_remove_samples_67_comment =
    "C++ Interface:\n"
    "removeSamples(non-const CurveFitter this, int begin, int end)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::remove_samples\n"
    "//       Access: Public\n"
    "//  Description: Eliminates all samples from index begin, up to but not\n"
    "//               including index end, from the database.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_remove_samples_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::sample(ParametricCurveCollection *curves, int count)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_sample_68(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CurveFitter::sample(ParametricCurveCollection *curves, int count)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"curves", (char *)"count", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:sample", key_word_list, &param1, &param2))
            {
                ParametricCurveCollection *param1_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParametricCurveCollection, 1, "CurveFitter.sample", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->sample(param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CurveFitter.sample() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sample(non-const CurveFitter this, non-const ParametricCurveCollection curves, int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_sample_68_comment =
    "C++ Interface:\n"
    "sample(non-const CurveFitter this, non-const ParametricCurveCollection curves, int count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::sample\n"
    "//       Access: Public\n"
    "//  Description: Generates a series of data points by sampling the\n"
    "//               given curve (or xyz/hpr curves) the indicated number\n"
    "//               of times.  The sampling is made evenly in parametric\n"
    "//               time, and then the timewarps, if any, are applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_sample_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::wrap_hpr(void)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_wrap_hpr_69(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CurveFitter::wrap_hpr(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":wrapHpr", key_word_list));
        else
            (PyArg_Parse(args, ":wrapHpr"));
        if(!PyErr_Occurred())
        {
            (local_this)->wrap_hpr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CurveFitter.wrapHpr() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wrapHpr(non-const CurveFitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_wrap_hpr_69_comment =
    "C++ Interface:\n"
    "wrapHpr(non-const CurveFitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::wrap_hpr\n"
    "//       Access: Public\n"
    "//  Description: Resets each HPR data point so that the maximum delta\n"
    "//               between any two consecutive points is 180 degrees,\n"
    "//               which should prevent incorrect HPR wrapping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_wrap_hpr_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::sort_points(void)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_sort_points_70(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CurveFitter::sort_points(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":sortPoints", key_word_list));
        else
            (PyArg_Parse(args, ":sortPoints"));
        if(!PyErr_Occurred())
        {
            (local_this)->sort_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CurveFitter.sortPoints() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sortPoints(non-const CurveFitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_sort_points_70_comment =
    "C++ Interface:\n"
    "sortPoints(non-const CurveFitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::sort_points\n"
    "//       Access: Public\n"
    "//  Description: Sorts all the data points in order by parametric\n"
    "//               time, in case they were added in an incorrect order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_sort_points_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::desample(float factor)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_desample_71(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CurveFitter::desample(float factor)
        double param1;
        static char * key_word_list[] = {(char *)"factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:desample", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:desample", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->desample((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CurveFitter.desample() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "desample(non-const CurveFitter this, float factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_desample_71_comment =
    "C++ Interface:\n"
    "desample(non-const CurveFitter this, float factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::desample\n"
    "//       Access: Public\n"
    "//  Description: Removes sample points in order to reduce the\n"
    "//               complexity of a sampled curve.  Keeps one out of\n"
    "//               every factor samples.  Also keeps the first and the\n"
    "//               last samples.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_desample_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::compute_tangents(float scale)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_compute_tangents_72(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CurveFitter::compute_tangents(float scale)
        double param1;
        static char * key_word_list[] = {(char *)"scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:computeTangents", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:computeTangents", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->compute_tangents((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CurveFitter.computeTangents() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "computeTangents(non-const CurveFitter this, float scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_compute_tangents_72_comment =
    "C++ Interface:\n"
    "computeTangents(non-const CurveFitter this, float scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::compute_tangents\n"
    "//       Access: Public\n"
    "//  Description: Once a set of points has been built, and prior to\n"
    "//               calling MakeHermite() or MakeNurbs(),\n"
    "//               ComputeTangents() must be called to set up the\n"
    "//               tangents correctly (unless the tangents were defined\n"
    "//               as the points were added).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_compute_tangents_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_make_hermite_73(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeHermite", key_word_list));
        else
            (PyArg_Parse(args, ":makeHermite"));
        if(!PyErr_Occurred())
        {
            PointerTo< ParametricCurveCollection > return_value = ((const CurveFitter*)local_this)->make_hermite();
            if (return_value != (ParametricCurveCollection *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value.p(),Dtool_ParametricCurveCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeHermite(const CurveFitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_make_hermite_73_comment =
    "C++ Interface:\n"
    "makeHermite(const CurveFitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::make_hermite\n"
    "//       Access: Public\n"
    "//  Description: Converts the current set of data points into a\n"
    "//               Hermite curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_make_hermite_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_make_nurbs_74(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeNurbs", key_word_list));
        else
            (PyArg_Parse(args, ":makeNurbs"));
        if(!PyErr_Occurred())
        {
            PointerTo< ParametricCurveCollection > return_value = ((const CurveFitter*)local_this)->make_nurbs();
            if (return_value != (ParametricCurveCollection *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value.p(),Dtool_ParametricCurveCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeNurbs(const CurveFitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_make_nurbs_74_comment =
    "C++ Interface:\n"
    "makeNurbs(const CurveFitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::make_nurbs\n"
    "//       Access: Public\n"
    "//  Description: Converts the current set of data points into a\n"
    "//               NURBS curve.  This gives a smoother curve than\n"
    "//               produced by MakeHermite().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_make_nurbs_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_output_75(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CurveFitter::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CurveFitter.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CurveFitter*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CurveFitter this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_output_75_comment =
    "C++ Interface:\n"
    "output(const CurveFitter this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::output\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_output_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CurveFitter::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CurveFitter_write_76(PyObject *self, PyObject *args,PyObject *kwds) {
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CurveFitter::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CurveFitter.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CurveFitter*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const CurveFitter this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_write_76_comment =
    "C++ Interface:\n"
    "write(const CurveFitter this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CurveFitter::write\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CurveFitter_write_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CurveFitter::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CurveFitter_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CurveFitter::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CurveFitter::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CurveFitter_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CurveFitter_get_class_type_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CurveFitter::CurveFitter(void)
 *******************************************************************/
int  Dtool_Init_CurveFitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CurveFitter::CurveFitter(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CurveFitter", key_word_list))
        {
            CurveFitter *return_value = new CurveFitter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CurveFitter,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CurveFitter()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CurveFitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CurveFitter)
    {
        printf("CurveFitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CurveFitter * local_this = (CurveFitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CurveFitter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CurveFitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CurveFitter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PiecewiseCurve 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PiecewiseCurve::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PiecewiseCurve_get_class_type_80(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PiecewiseCurve::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PiecewiseCurve::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PiecewiseCurve_get_class_type_80_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PiecewiseCurve_get_class_type_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NurbsCurve *PiecewiseCurve::downcast_to_NurbsCurve(void)
 *******************************************************************/
static PyObject *Dtool_PiecewiseCurve_downcast_to_NurbsCurve_124(PyObject *self, PyObject *args,PyObject *kwds) {
    PiecewiseCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PiecewiseCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NurbsCurve *PiecewiseCurve::downcast_to_NurbsCurve(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNurbsCurve", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNurbsCurve"));
        if(!PyErr_Occurred())
        {
            NurbsCurve *return_value = (NurbsCurve *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_NurbsCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PiecewiseCurve.downcastToNurbsCurve() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNurbsCurve(non-const PiecewiseCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PiecewiseCurve_downcast_to_NurbsCurve_124_comment =
    "C++ Interface:\n"
    "downcastToNurbsCurve(non-const PiecewiseCurve this)\n"
    "\n"
    "downcast from PiecewiseCurve to NurbsCurve\n"
    "";
#else
static const char * Dtool_PiecewiseCurve_downcast_to_NurbsCurve_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PiecewiseCurve::PiecewiseCurve(void)
 *******************************************************************/
int  Dtool_Init_PiecewiseCurve(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PiecewiseCurve::PiecewiseCurve(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":PiecewiseCurve", key_word_list))
        {
            PiecewiseCurve *return_value = new PiecewiseCurve();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PiecewiseCurve,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PiecewiseCurve()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PiecewiseCurve(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PiecewiseCurve)
    {
        printf("PiecewiseCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PiecewiseCurve * local_this = (PiecewiseCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PiecewiseCurve)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_ParametricCurve)
        return ( ParametricCurve *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( ParametricCurve *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( ParametricCurve *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PiecewiseCurve(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PiecewiseCurve)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PiecewiseCurve*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PiecewiseCurve*)other_this;
    }
    if(from_type == &Dtool_ParametricCurve)
    {
          ParametricCurve* other_this = (ParametricCurve*)from_this;
          return (PiecewiseCurve*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PiecewiseCurve*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PiecewiseCurve*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HermiteCurve 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int HermiteCurve::get_num_cvs(void) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_num_cvs_83(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int HermiteCurve::get_num_cvs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCvs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCvs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const HermiteCurve*)local_this)->get_num_cvs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCvs(const HermiteCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_num_cvs_83_comment =
    "C++ Interface:\n"
    "getNumCvs(const HermiteCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_num_cvs\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of CV's in the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_num_cvs_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int HermiteCurve::insert_cv(float t)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_insert_cv_84(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int HermiteCurve::insert_cv(float t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:insertCv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:insertCv", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->insert_cv((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HermiteCurve.insertCv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "insertCv(non-const HermiteCurve this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_insert_cv_84_comment =
    "C++ Interface:\n"
    "insertCv(non-const HermiteCurve this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::insert_cv\n"
    "//       Access: Published\n"
    "//  Description: Inserts a new CV at the given parametric point along\n"
    "//               the curve.  If this parametric point is already on\n"
    "//               the curve, the CV is assigned an index between its\n"
    "//               two neighbors and the indices of all following CV's\n"
    "//               are incremented by 1; its in and out tangents are\n"
    "//               chosen to keep the curve consistent.  If the new\n"
    "//               parametric point is beyond the end of the existing\n"
    "//               curve, the curve is extended to meet it and the new\n"
    "//               CV's position, in tangent, and out tangent are set to\n"
    "//               zero.\n"
    "//\n"
    "//               The index number of the new CV is returned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_insert_cv_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HermiteCurve::append_cv(int type, LVecBase3f const &v)
 * int HermiteCurve::append_cv(int type, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_append_cv_85(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline int HermiteCurve::append_cv(int type, LVecBase3f const &v)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"type", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:appendCv", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.appendCv", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        int return_value = (local_this)->append_cv((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HermiteCurve.appendCv() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int HermiteCurve::append_cv(int type, float x, float y, float z)
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"type", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:appendCv", key_word_list, &param1, &param2, &param3, &param4))
            {
                int return_value = (local_this)->append_cv((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HermiteCurve.appendCv() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "appendCv() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "appendCv(non-const HermiteCurve this, int type, const VBase3 v)\n"
          "appendCv(non-const HermiteCurve this, int type, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_append_cv_85_comment =
    "C++ Interface:\n"
    "appendCv(non-const HermiteCurve this, int type, const VBase3 v)\n"
    "appendCv(non-const HermiteCurve this, int type, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::append_cv\n"
    "//       Access: Published\n"
    "//  Description: Adds a new CV to the end of the curve.  The new CV is\n"
    "//               given initial in/out tangents of 0.  The return value\n"
    "//               is the index of the new CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_append_cv_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HermiteCurve::remove_cv(int n)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_remove_cv_86(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HermiteCurve::remove_cv(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeCv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeCv", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->remove_cv((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HermiteCurve.removeCv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCv(non-const HermiteCurve this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_remove_cv_86_comment =
    "C++ Interface:\n"
    "removeCv(non-const HermiteCurve this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::remove_cv\n"
    "//       Access: Published\n"
    "//  Description: Removes the given CV from the curve.  Returns true if\n"
    "//               the CV existed, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_remove_cv_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HermiteCurve::remove_all_cvs(void)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_remove_all_cvs_87(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HermiteCurve::remove_all_cvs(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAllCvs", key_word_list));
        else
            (PyArg_Parse(args, ":removeAllCvs"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_all_cvs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HermiteCurve.removeAllCvs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAllCvs(non-const HermiteCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_remove_all_cvs_87_comment =
    "C++ Interface:\n"
    "removeAllCvs(non-const HermiteCurve this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::remove_all_cvs\n"
    "//       Access: Published\n"
    "//  Description: Removes all CV's from the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_remove_all_cvs_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HermiteCurve::set_cv_type(int n, int type)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_set_cv_type_88(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HermiteCurve::set_cv_type(int n, int type)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"n", (char *)"type", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setCvType", key_word_list, &param1, &param2))
        {
            bool return_value = (local_this)->set_cv_type((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HermiteCurve.setCvType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCvType(non-const HermiteCurve this, int n, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_set_cv_type_88_comment =
    "C++ Interface:\n"
    "setCvType(non-const HermiteCurve this, int n, int type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::set_cv_type\n"
    "//       Access: Published\n"
    "//  Description: Changes the given CV's continuity type.  Legal values\n"
    "//               are HC_CUT, HC_FREE, HC_G1, or HC_SMOOTH.\n"
    "//\n"
    "//               Other than HC_CUT, these have no effect on the actual\n"
    "//               curve; it remains up to user software to impose the\n"
    "//               constraints these imply.\n"
    "//\n"
    "//               HC_CUT implies a disconnection of the curve; HC_FREE\n"
    "//               imposes no constraints on the tangents; HC_G1\n"
    "//               forces the tangents to be collinear, and HC_SMOOTH\n"
    "//               forces the tangents to be identical.  Setting type\n"
    "//               type to HC_G1 or HC_SMOOTH may adjust the out\n"
    "//               tangent to match the in tangent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_set_cv_type_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HermiteCurve::set_cv_point(int n, LVecBase3f const &v)
 * bool HermiteCurve::set_cv_point(int n, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_set_cv_point_89(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool HermiteCurve::set_cv_point(int n, LVecBase3f const &v)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCvPoint", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.setCvPoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_cv_point((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HermiteCurve.setCvPoint() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HermiteCurve::set_cv_point(int n, float x, float y, float z)
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"n", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:setCvPoint", key_word_list, &param1, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->set_cv_point((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HermiteCurve.setCvPoint() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCvPoint() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCvPoint(non-const HermiteCurve this, int n, const VBase3 v)\n"
          "setCvPoint(non-const HermiteCurve this, int n, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_set_cv_point_89_comment =
    "C++ Interface:\n"
    "setCvPoint(non-const HermiteCurve this, int n, const VBase3 v)\n"
    "setCvPoint(non-const HermiteCurve this, int n, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::set_cv_point\n"
    "//       Access: Published\n"
    "//  Description: Changes the given CV's position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_set_cv_point_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HermiteCurve::set_cv_in(int n, LVecBase3f const &v)
 * bool HermiteCurve::set_cv_in(int n, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_set_cv_in_90(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool HermiteCurve::set_cv_in(int n, LVecBase3f const &v)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCvIn", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.setCvIn", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_cv_in((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HermiteCurve.setCvIn() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HermiteCurve::set_cv_in(int n, float x, float y, float z)
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"n", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:setCvIn", key_word_list, &param1, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->set_cv_in((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HermiteCurve.setCvIn() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCvIn() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCvIn(non-const HermiteCurve this, int n, const VBase3 v)\n"
          "setCvIn(non-const HermiteCurve this, int n, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_set_cv_in_90_comment =
    "C++ Interface:\n"
    "setCvIn(non-const HermiteCurve this, int n, const VBase3 v)\n"
    "setCvIn(non-const HermiteCurve this, int n, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::set_cv_in\n"
    "//       Access: Published\n"
    "//  Description: Changes the given CV's in tangent.  Depending on the\n"
    "//               continuity type, this may also adjust the out\n"
    "//               tangent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_set_cv_in_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HermiteCurve::set_cv_out(int n, LVecBase3f const &v)
 * bool HermiteCurve::set_cv_out(int n, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_set_cv_out_91(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool HermiteCurve::set_cv_out(int n, LVecBase3f const &v)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCvOut", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.setCvOut", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_cv_out((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call HermiteCurve.setCvOut() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HermiteCurve::set_cv_out(int n, float x, float y, float z)
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"n", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:setCvOut", key_word_list, &param1, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->set_cv_out((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HermiteCurve.setCvOut() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCvOut() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCvOut(non-const HermiteCurve this, int n, const VBase3 v)\n"
          "setCvOut(non-const HermiteCurve this, int n, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_set_cv_out_91_comment =
    "C++ Interface:\n"
    "setCvOut(non-const HermiteCurve this, int n, const VBase3 v)\n"
    "setCvOut(non-const HermiteCurve this, int n, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::set_cv_out\n"
    "//       Access: Published\n"
    "//  Description: Changes the given CV's out tangent.  Depending on the\n"
    "//               continuity type, this may also adjust the in\n"
    "//               tangent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_set_cv_out_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HermiteCurve::set_cv_tstart(int n, float tstart)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_set_cv_tstart_92(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HermiteCurve::set_cv_tstart(int n, float tstart)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"tstart", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setCvTstart", key_word_list, &param1, &param2))
        {
            bool return_value = (local_this)->set_cv_tstart((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HermiteCurve.setCvTstart() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCvTstart(non-const HermiteCurve this, int n, float tstart)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_set_cv_tstart_92_comment =
    "C++ Interface:\n"
    "setCvTstart(non-const HermiteCurve this, int n, float tstart)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::set_cv_tstart\n"
    "//       Access: Published\n"
    "//  Description: Changes the given CV's parametric starting time.\n"
    "//               This may affect the shape of the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_set_cv_tstart_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HermiteCurve::set_cv_name(int n, char const *name)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_set_cv_name_93(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HermiteCurve::set_cv_name(int n, char const *name)
        int param1;
        char *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "is:setCvName", key_word_list, &param1, &param2))
        {
            bool return_value = (local_this)->set_cv_name((int)param1, (char const *)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HermiteCurve.setCvName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCvName(non-const HermiteCurve this, int n, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_set_cv_name_93_comment =
    "C++ Interface:\n"
    "setCvName(non-const HermiteCurve this, int n, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::set_cv_name\n"
    "//       Access: Published\n"
    "//  Description: Changes the name associated with a particular CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_set_cv_name_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int HermiteCurve::get_cv_type(int n) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_cv_type_94(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int HermiteCurve::get_cv_type(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCvType", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const HermiteCurve*)local_this)->get_cv_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCvType(const HermiteCurve this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_cv_type_94_comment =
    "C++ Interface:\n"
    "getCvType(const HermiteCurve this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_cv_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the given CV's continuity type, HC_CUT,\n"
    "//               HC_FREE, HC_G1, or HC_SMOOTH, or 0 if there is\n"
    "//               no such CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_cv_type_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f const &HermiteCurve::get_cv_point(int n) const
 * void HermiteCurve::get_cv_point(int n, LVecBase3f &v) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_cv_point_95(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-LVecBase3f const &HermiteCurve::get_cv_point(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getCvPoint", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f const *return_value = &(((const HermiteCurve*)local_this)->get_cv_point((int)param1));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void HermiteCurve::get_cv_point(int n, LVecBase3f &v) const
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getCvPoint", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.getCvPoint", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        ((const HermiteCurve*)local_this)->get_cv_point((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCvPoint() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCvPoint(const HermiteCurve this, int n)\n"
          "getCvPoint(const HermiteCurve this, int n, non-const VBase3 v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_cv_point_95_comment =
    "C++ Interface:\n"
    "getCvPoint(const HermiteCurve this, int n)\n"
    "getCvPoint(const HermiteCurve this, int n, non-const VBase3 v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_cv_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the position of the given CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_cv_point_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f const &HermiteCurve::get_cv_in(int n) const
 * void HermiteCurve::get_cv_in(int n, LVecBase3f &v) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_cv_in_96(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-LVecBase3f const &HermiteCurve::get_cv_in(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvIn", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getCvIn", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f const *return_value = &(((const HermiteCurve*)local_this)->get_cv_in((int)param1));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void HermiteCurve::get_cv_in(int n, LVecBase3f &v) const
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getCvIn", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.getCvIn", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        ((const HermiteCurve*)local_this)->get_cv_in((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCvIn() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCvIn(const HermiteCurve this, int n)\n"
          "getCvIn(const HermiteCurve this, int n, non-const VBase3 v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_cv_in_96_comment =
    "C++ Interface:\n"
    "getCvIn(const HermiteCurve this, int n)\n"
    "getCvIn(const HermiteCurve this, int n, non-const VBase3 v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_cv_in\n"
    "//       Access: Published\n"
    "//  Description: Returns the in tangent of the given CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_cv_in_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f const &HermiteCurve::get_cv_out(int n) const
 * void HermiteCurve::get_cv_out(int n, LVecBase3f &v) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_cv_out_97(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-LVecBase3f const &HermiteCurve::get_cv_out(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvOut", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getCvOut", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f const *return_value = &(((const HermiteCurve*)local_this)->get_cv_out((int)param1));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void HermiteCurve::get_cv_out(int n, LVecBase3f &v) const
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getCvOut", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "HermiteCurve.getCvOut", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        ((const HermiteCurve*)local_this)->get_cv_out((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCvOut() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCvOut(const HermiteCurve this, int n)\n"
          "getCvOut(const HermiteCurve this, int n, non-const VBase3 v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_cv_out_97_comment =
    "C++ Interface:\n"
    "getCvOut(const HermiteCurve this, int n)\n"
    "getCvOut(const HermiteCurve this, int n, non-const VBase3 v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_cv_out\n"
    "//       Access: Published\n"
    "//  Description: Returns the out tangent of the given CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_cv_out_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float HermiteCurve::get_cv_tstart(int n) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_cv_tstart_98(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float HermiteCurve::get_cv_tstart(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvTstart", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCvTstart", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const HermiteCurve*)local_this)->get_cv_tstart((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCvTstart(const HermiteCurve this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_cv_tstart_98_comment =
    "C++ Interface:\n"
    "getCvTstart(const HermiteCurve this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_cv_tstart\n"
    "//       Access: Published\n"
    "//  Description: Returns the starting point in parametric space of the\n"
    "//               given CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_cv_tstart_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HermiteCurve::get_cv_name(int n) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_cv_name_99(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HermiteCurve::get_cv_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCvName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HermiteCurve*)local_this)->get_cv_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCvName(const HermiteCurve this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_cv_name_99_comment =
    "C++ Interface:\n"
    "getCvName(const HermiteCurve this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::get_cv_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the given CV, or NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_cv_name_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HermiteCurve::write_cv(ostream &out, int n) const
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_write_cv_100(PyObject *self, PyObject *args,PyObject *kwds) {
    HermiteCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HermiteCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HermiteCurve::write_cv(ostream &out, int n) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"n", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeCv", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HermiteCurve.writeCv", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HermiteCurve*)local_this)->write_cv(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeCv(const HermiteCurve this, non-const Ostream out, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_write_cv_100_comment =
    "C++ Interface:\n"
    "writeCv(const HermiteCurve this, non-const Ostream out, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HermiteCurve::write_cv\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HermiteCurve_write_cv_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle HermiteCurve::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_HermiteCurve_get_class_type_101(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle HermiteCurve::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = HermiteCurve::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HermiteCurve_get_class_type_101_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_HermiteCurve_get_class_type_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HermiteCurve::HermiteCurve(void)
 * HermiteCurve::HermiteCurve(ParametricCurve const &pc)
 *******************************************************************/
int  Dtool_Init_HermiteCurve(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-HermiteCurve::HermiteCurve(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":HermiteCurve", key_word_list))
            {
                HermiteCurve *return_value = new HermiteCurve();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HermiteCurve,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"pc", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HermiteCurve", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HermiteCurve", &param0));
                if(!PyErr_Occurred())
                {
                    ParametricCurve *param0_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ParametricCurve, 0, "HermiteCurve.HermiteCurve", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        HermiteCurve *return_value = new HermiteCurve(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HermiteCurve,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HermiteCurve() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HermiteCurve()\n"
          "HermiteCurve(const ParametricCurve pc)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HermiteCurve(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HermiteCurve)
    {
        printf("HermiteCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HermiteCurve * local_this = (HermiteCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HermiteCurve)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_ParametricCurve)
        return ( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_PiecewiseCurve)
        return ( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HermiteCurve(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HermiteCurve)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (HermiteCurve*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (HermiteCurve*)other_this;
    }
    if(from_type == &Dtool_ParametricCurve)
    {
          ParametricCurve* other_this = (ParametricCurve*)from_this;
          return (HermiteCurve*)other_this;
    }
    if(from_type == &Dtool_PiecewiseCurve)
    {
          PiecewiseCurve* other_this = (PiecewiseCurve*)from_this;
          return (HermiteCurve*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (HermiteCurve*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (HermiteCurve*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NurbsCurveInterface 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void NurbsCurveInterface::set_order(int order) = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_set_order_104(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void NurbsCurveInterface::set_order(int order) = 0
        int param1;
        static char * key_word_list[] = {(char *)"order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.setOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOrder(non-const NurbsCurveInterface this, int order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_set_order_104_comment =
    "C++ Interface:\n"
    "setOrder(non-const NurbsCurveInterface this, int order)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_set_order_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int NurbsCurveInterface::get_order(void) const = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_order_105(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int NurbsCurveInterface::get_order(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getOrder"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveInterface*)local_this)->get_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOrder(const NurbsCurveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_order_105_comment =
    "C++ Interface:\n"
    "getOrder(const NurbsCurveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_order_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int NurbsCurveInterface::get_num_cvs(void) const = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_num_cvs_106(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int NurbsCurveInterface::get_num_cvs(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCvs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCvs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveInterface*)local_this)->get_num_cvs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCvs(const NurbsCurveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_num_cvs_106_comment =
    "C++ Interface:\n"
    "getNumCvs(const NurbsCurveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_num_cvs_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int NurbsCurveInterface::get_num_knots(void) const = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_num_knots_107(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int NurbsCurveInterface::get_num_knots(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumKnots", key_word_list));
        else
            (PyArg_Parse(args, ":getNumKnots"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveInterface*)local_this)->get_num_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumKnots(const NurbsCurveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_num_knots_107_comment =
    "C++ Interface:\n"
    "getNumKnots(const NurbsCurveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_num_knots_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool NurbsCurveInterface::insert_cv(float t) = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_insert_cv_108(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool NurbsCurveInterface::insert_cv(float t) = 0
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:insertCv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:insertCv", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->insert_cv((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.insertCv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "insertCv(non-const NurbsCurveInterface this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_insert_cv_108_comment =
    "C++ Interface:\n"
    "insertCv(non-const NurbsCurveInterface this, float t)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_insert_cv_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveInterface::append_cv(LVecBase3f const &v)
 * inline int NurbsCurveInterface::append_cv(LVecBase4f const &v)
 * inline int NurbsCurveInterface::append_cv(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_append_cv_109(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline int NurbsCurveInterface::append_cv(LVecBase3f const &v)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"v", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:appendCv", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:appendCv", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "NurbsCurveInterface.appendCv", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->append_cv(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline int NurbsCurveInterface::append_cv(LVecBase4f const &v)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"v", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:appendCv", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:appendCv", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "NurbsCurveInterface.appendCv", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->append_cv(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int NurbsCurveInterface::append_cv(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:appendCv", key_word_list, &param1, &param2, &param3))
            {
                int return_value = (local_this)->append_cv((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsCurveInterface.appendCv() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "appendCv() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "appendCv(non-const NurbsCurveInterface this, const VBase3 v)\n"
          "appendCv(non-const NurbsCurveInterface this, const VBase4 v)\n"
          "appendCv(non-const NurbsCurveInterface this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_append_cv_109_comment =
    "C++ Interface:\n"
    "appendCv(non-const NurbsCurveInterface this, const VBase3 v)\n"
    "appendCv(non-const NurbsCurveInterface this, const VBase4 v)\n"
    "appendCv(non-const NurbsCurveInterface this, float x, float y, float z)\n"
    "\n"
    "// Filename: nurbsCurveInterface.I\n"
    "// Created by:  drose (02Mar01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::append_cv\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::append_cv\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::append_cv\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_append_cv_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool NurbsCurveInterface::remove_cv(int n) = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_remove_cv_110(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool NurbsCurveInterface::remove_cv(int n) = 0
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeCv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeCv", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->remove_cv((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.removeCv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCv(non-const NurbsCurveInterface this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_remove_cv_110_comment =
    "C++ Interface:\n"
    "removeCv(non-const NurbsCurveInterface this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_remove_cv_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void NurbsCurveInterface::remove_all_cvs(void) = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_remove_all_cvs_111(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void NurbsCurveInterface::remove_all_cvs(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAllCvs", key_word_list));
        else
            (PyArg_Parse(args, ":removeAllCvs"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_all_cvs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.removeAllCvs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAllCvs(non-const NurbsCurveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_remove_all_cvs_111_comment =
    "C++ Interface:\n"
    "removeAllCvs(non-const NurbsCurveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_remove_all_cvs_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3f const &v)
 * inline bool NurbsCurveInterface::set_cv_point(int n, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_set_cv_point_112(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3f const &v)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCvPoint", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "NurbsCurveInterface.setCvPoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_cv_point((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call NurbsCurveInterface.setCvPoint() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool NurbsCurveInterface::set_cv_point(int n, float x, float y, float z)
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"n", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:setCvPoint", key_word_list, &param1, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->set_cv_point((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsCurveInterface.setCvPoint() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCvPoint() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCvPoint(non-const NurbsCurveInterface this, int n, const VBase3 v)\n"
          "setCvPoint(non-const NurbsCurveInterface this, int n, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_set_cv_point_112_comment =
    "C++ Interface:\n"
    "setCvPoint(non-const NurbsCurveInterface this, int n, const VBase3 v)\n"
    "setCvPoint(non-const NurbsCurveInterface this, int n, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::set_cv_point\n"
    "//       Access: Public, Scheme\n"
    "//  Description: Repositions the indicated CV.  Returns true if\n"
    "//               successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::set_cv_point\n"
    "//       Access: Public, Scheme\n"
    "//  Description: Repositions the indicated CV.  Returns true if\n"
    "//               successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_set_cv_point_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f NurbsCurveInterface::get_cv_point(int n) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_cv_point_113(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f NurbsCurveInterface::get_cv_point(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCvPoint", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const NurbsCurveInterface*)local_this)->get_cv_point((int)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCvPoint(const NurbsCurveInterface this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_cv_point_113_comment =
    "C++ Interface:\n"
    "getCvPoint(const NurbsCurveInterface this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::get_cv_point\n"
    "//       Access: Public, Scheme\n"
    "//  Description: Returns the position of the indicated CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_cv_point_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool NurbsCurveInterface::set_cv_weight(int n, float w)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_set_cv_weight_114(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool NurbsCurveInterface::set_cv_weight(int n, float w)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"w", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setCvWeight", key_word_list, &param1, &param2))
        {
            bool return_value = (local_this)->set_cv_weight((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.setCvWeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCvWeight(non-const NurbsCurveInterface this, int n, float w)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_set_cv_weight_114_comment =
    "C++ Interface:\n"
    "setCvWeight(non-const NurbsCurveInterface this, int n, float w)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::set_cv_weight\n"
    "//       Access: Published\n"
    "//  Description: Sets the weight of the indicated CV without affecting\n"
    "//               its position in 3-d space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_set_cv_weight_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveInterface::get_cv_weight(int n) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_cv_weight_115(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsCurveInterface::get_cv_weight(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCvWeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCvWeight", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsCurveInterface*)local_this)->get_cv_weight((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCvWeight(const NurbsCurveInterface this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_cv_weight_115_comment =
    "C++ Interface:\n"
    "getCvWeight(const NurbsCurveInterface this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::get_cv_weight\n"
    "//       Access: Published\n"
    "//  Description: Returns the weight of the indicated CV.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_cv_weight_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4f const &v) = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_set_cv_116(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4f const &v) = 0
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"v", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCv", key_word_list, &param1, &param2))
            {
                LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "NurbsCurveInterface.setCv", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->set_cv((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsCurveInterface.setCv() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCv(non-const NurbsCurveInterface this, int n, const VBase4 v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_set_cv_116_comment =
    "C++ Interface:\n"
    "setCv(non-const NurbsCurveInterface this, int n, const VBase4 v)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_set_cv_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LVecBase4f NurbsCurveInterface::get_cv(int n) const = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_cv_117(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LVecBase4f NurbsCurveInterface::get_cv(int n) const = 0
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCv", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const NurbsCurveInterface*)local_this)->get_cv((int)param1);
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCv(const NurbsCurveInterface this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_cv_117_comment =
    "C++ Interface:\n"
    "getCv(const NurbsCurveInterface this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_cv_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool NurbsCurveInterface::set_knot(int n, float t) = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_set_knot_118(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool NurbsCurveInterface::set_knot(int n, float t) = 0
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"t", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setKnot", key_word_list, &param1, &param2))
        {
            bool return_value = (local_this)->set_knot((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.setKnot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKnot(non-const NurbsCurveInterface this, int n, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_set_knot_118_comment =
    "C++ Interface:\n"
    "setKnot(non-const NurbsCurveInterface this, int n, float t)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_set_knot_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float NurbsCurveInterface::get_knot(int n) const = 0
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_knot_119(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float NurbsCurveInterface::get_knot(int n) const = 0
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getKnot", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getKnot", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsCurveInterface*)local_this)->get_knot((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKnot(const NurbsCurveInterface this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_knot_119_comment =
    "C++ Interface:\n"
    "getKnot(const NurbsCurveInterface this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_knot_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveInterface::write_cv(ostream &out, int n) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_write_cv_120(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsCurveInterface::write_cv(ostream &out, int n) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"n", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeCv", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "NurbsCurveInterface.writeCv", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const NurbsCurveInterface*)local_this)->write_cv(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeCv(const NurbsCurveInterface this, non-const Ostream out, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_write_cv_120_comment =
    "C++ Interface:\n"
    "writeCv(const NurbsCurveInterface this, non-const Ostream out, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveInterface::write_cv\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_write_cv_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NurbsCurveInterface::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_get_class_type_121(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NurbsCurveInterface::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NurbsCurveInterface::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_get_class_type_121_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_get_class_type_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NurbsCurve *NurbsCurveInterface::downcast_to_NurbsCurve(void)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_126(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NurbsCurve *NurbsCurveInterface::downcast_to_NurbsCurve(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNurbsCurve", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNurbsCurve"));
        if(!PyErr_Occurred())
        {
            NurbsCurve *return_value = (NurbsCurve *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_NurbsCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveInterface.downcastToNurbsCurve() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNurbsCurve(non-const NurbsCurveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_126_comment =
    "C++ Interface:\n"
    "downcastToNurbsCurve(non-const NurbsCurveInterface this)\n"
    "\n"
    "downcast from NurbsCurveInterface to NurbsCurve\n"
    "";
#else
static const char * Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_126_comment = NULL;
#endif

int  Dtool_Init_NurbsCurveInterface(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NurbsCurveInterface)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NurbsCurveInterface(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NurbsCurveInterface)
    {
        printf("NurbsCurveInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NurbsCurveInterface * local_this = (NurbsCurveInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NurbsCurveInterface)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NurbsCurveInterface(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NurbsCurveInterface)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NurbsCurve 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NurbsCurve::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NurbsCurve_get_class_type_129(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NurbsCurve::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NurbsCurve::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurve_get_class_type_129_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NurbsCurve_get_class_type_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void)
 *******************************************************************/
static PyObject *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_123(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToPiecewiseCurve", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToPiecewiseCurve"));
        if(!PyErr_Occurred())
        {
            PiecewiseCurve *return_value = (PiecewiseCurve *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PiecewiseCurve,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurve.upcastToPiecewiseCurve() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToPiecewiseCurve(non-const NurbsCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurve_upcast_to_PiecewiseCurve_123_comment =
    "C++ Interface:\n"
    "upcastToPiecewiseCurve(non-const NurbsCurve this)\n"
    "\n"
    "upcast from NurbsCurve to PiecewiseCurve\n"
    "";
#else
static const char * Dtool_NurbsCurve_upcast_to_PiecewiseCurve_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void)
 *******************************************************************/
static PyObject *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_125(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurve * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurve,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNurbsCurveInterface", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNurbsCurveInterface"));
        if(!PyErr_Occurred())
        {
            NurbsCurveInterface *return_value = (NurbsCurveInterface *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NurbsCurveInterface,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurve.upcastToNurbsCurveInterface() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNurbsCurveInterface(non-const NurbsCurve this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_125_comment =
    "C++ Interface:\n"
    "upcastToNurbsCurveInterface(non-const NurbsCurve this)\n"
    "\n"
    "upcast from NurbsCurve to NurbsCurveInterface\n"
    "";
#else
static const char * Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NurbsCurve::NurbsCurve(void)
 * NurbsCurve::NurbsCurve(ParametricCurve const &pc)
 *******************************************************************/
int  Dtool_Init_NurbsCurve(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-NurbsCurve::NurbsCurve(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":NurbsCurve", key_word_list))
            {
                NurbsCurve *return_value = new NurbsCurve();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_NurbsCurve,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"pc", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:NurbsCurve", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:NurbsCurve", &param0));
                if(!PyErr_Occurred())
                {
                    ParametricCurve *param0_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ParametricCurve, 0, "NurbsCurve.NurbsCurve", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        NurbsCurve *return_value = new NurbsCurve(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_NurbsCurve,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "NurbsCurve() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "NurbsCurve()\n"
          "NurbsCurve(const ParametricCurve pc)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NurbsCurve(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NurbsCurve)
    {
        printf("NurbsCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NurbsCurve * local_this = (NurbsCurve *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NurbsCurve)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_NurbsCurveInterface)
        return ( NurbsCurveInterface *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_ParametricCurve)
        return ( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_PiecewiseCurve)
        return ( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( ParametricCurve *)( PiecewiseCurve *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NurbsCurve(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NurbsCurve)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (NurbsCurve*)other_this;
    }
    if(from_type == &Dtool_NurbsCurveInterface)
    {
          NurbsCurveInterface* other_this = (NurbsCurveInterface*)from_this;
          return (NurbsCurve*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (NurbsCurve*)other_this;
    }
    if(from_type == &Dtool_ParametricCurve)
    {
          ParametricCurve* other_this = (ParametricCurve*)from_this;
          return (NurbsCurve*)other_this;
    }
    if(from_type == &Dtool_PiecewiseCurve)
    {
          PiecewiseCurve* other_this = (PiecewiseCurve*)from_this;
          return (NurbsCurve*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NurbsCurve*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (NurbsCurve*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NurbsCurveResult 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveResult::get_start_t(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_start_t_131(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsCurveResult::get_start_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartT", key_word_list));
        else
            (PyArg_Parse(args, ":getStartT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsCurveResult*)local_this)->get_start_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartT(const NurbsCurveResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_start_t_131_comment =
    "C++ Interface:\n"
    "getStartT(const NurbsCurveResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_start_t\n"
    "//       Access: Published\n"
    "//  Description: Returns the first legal value of t on the curve.\n"
    "//               Usually this is 0.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_start_t_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveResult::get_end_t(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_end_t_132(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsCurveResult::get_end_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndT", key_word_list));
        else
            (PyArg_Parse(args, ":getEndT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsCurveResult*)local_this)->get_end_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndT(const NurbsCurveResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_end_t_132_comment =
    "C++ Interface:\n"
    "getEndT(const NurbsCurveResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_end_t\n"
    "//       Access: Published\n"
    "//  Description: Returns the last legal value of t on the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_end_t_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NurbsCurveResult::eval_point(float t, LVecBase3f &point)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_eval_point_133(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool NurbsCurveResult::eval_point(float t, LVecBase3f &point)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"point", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:evalPoint", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "NurbsCurveResult.evalPoint", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->eval_point((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsCurveResult.evalPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalPoint(non-const NurbsCurveResult this, float t, non-const VBase3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_eval_point_133_comment =
    "C++ Interface:\n"
    "evalPoint(non-const NurbsCurveResult this, float t, non-const VBase3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::eval_point\n"
    "//       Access: Published\n"
    "//  Description: Computes the point on the curve corresponding to the\n"
    "//               indicated value in parametric time.  Returns true if\n"
    "//               the t value is valid, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_eval_point_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NurbsCurveResult::eval_tangent(float t, LVecBase3f &tangent)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_eval_tangent_134(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool NurbsCurveResult::eval_tangent(float t, LVecBase3f &tangent)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"t", (char *)"tangent", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:evalTangent", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "NurbsCurveResult.evalTangent", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->eval_tangent((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsCurveResult.evalTangent() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalTangent(non-const NurbsCurveResult this, float t, non-const VBase3 tangent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_eval_tangent_134_comment =
    "C++ Interface:\n"
    "evalTangent(non-const NurbsCurveResult this, float t, non-const VBase3 tangent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::eval_tangent\n"
    "//       Access: Published\n"
    "//  Description: Computes the tangent to the curve at the indicated\n"
    "//               point in parametric time.  This tangent vector will\n"
    "//               not necessarily be normalized, and could be zero.\n"
    "//               See also eval_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_eval_tangent_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveResult::eval_extended_point(float t, int d)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_eval_extended_point_135(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float NurbsCurveResult::eval_extended_point(float t, int d)
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"t", (char *)"d", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "di:evalExtendedPoint", key_word_list, &param1, &param2))
        {
            float return_value = (local_this)->eval_extended_point((float)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveResult.evalExtendedPoint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalExtendedPoint(non-const NurbsCurveResult this, float t, int d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_eval_extended_point_135_comment =
    "C++ Interface:\n"
    "evalExtendedPoint(non-const NurbsCurveResult this, float t, int d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::eval_extended_point\n"
    "//       Access: Published\n"
    "//  Description: Evaluates the curve in n-dimensional space according\n"
    "//               to the extended vertices associated with the curve in\n"
    "//               the indicated dimension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_eval_extended_point_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveResult::get_num_segments(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_num_segments_137(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsCurveResult::get_num_segments(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSegments", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSegments"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveResult*)local_this)->get_num_segments();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSegments(const NurbsCurveResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_num_segments_137_comment =
    "C++ Interface:\n"
    "getNumSegments(const NurbsCurveResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_num_segments\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of piecewise continuous segments\n"
    "//               within the curve.  This number is usually not\n"
    "//               important unless you plan to call\n"
    "//               eval_segment_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_num_segments_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveResult::eval_segment_point(int segment, float t, LVecBase3f &point) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_eval_segment_point_138(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsCurveResult::eval_segment_point(int segment, float t, LVecBase3f &point) const
            int param1;
            double param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"segment", (char *)"t", (char *)"point", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "idO:evalSegmentPoint", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "NurbsCurveResult.evalSegmentPoint", 0, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    ((const NurbsCurveResult*)local_this)->eval_segment_point((int)param1, (float)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalSegmentPoint(const NurbsCurveResult this, int segment, float t, non-const VBase3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_eval_segment_point_138_comment =
    "C++ Interface:\n"
    "evalSegmentPoint(const NurbsCurveResult this, int segment, float t, non-const VBase3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::eval_segment_point\n"
    "//       Access: Published\n"
    "//  Description: Evaluates the point on the curve corresponding to the\n"
    "//               indicated value in parametric time within the\n"
    "//               indicated curve segment.  t should be in the range\n"
    "//               [0, 1].\n"
    "//\n"
    "//               The curve is internally represented as a number of\n"
    "//               connected (or possibly unconnected) piecewise\n"
    "//               continuous segments.  The exact number of segments\n"
    "//               for a particular curve depends on the knot vector,\n"
    "//               and is returned by get_num_segments().  Normally,\n"
    "//               eval_point() is used to evaluate a point along the\n"
    "//               continuous curve, but when you care more about local\n"
    "//               continuity, you can use eval_segment_point() to\n"
    "//               evaluate the points along each segment.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_eval_segment_point_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveResult::eval_segment_tangent(int segment, float t, LVecBase3f &tangent) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_eval_segment_tangent_139(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsCurveResult::eval_segment_tangent(int segment, float t, LVecBase3f &tangent) const
            int param1;
            double param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"segment", (char *)"t", (char *)"tangent", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "idO:evalSegmentTangent", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "NurbsCurveResult.evalSegmentTangent", 0, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    ((const NurbsCurveResult*)local_this)->eval_segment_tangent((int)param1, (float)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalSegmentTangent(const NurbsCurveResult this, int segment, float t, non-const VBase3 tangent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_eval_segment_tangent_139_comment =
    "C++ Interface:\n"
    "evalSegmentTangent(const NurbsCurveResult this, int segment, float t, non-const VBase3 tangent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::eval_segment_tangent\n"
    "//       Access: Published\n"
    "//  Description: As eval_segment_point, but computes the tangent to\n"
    "//               the curve at the indicated point.  The tangent vector\n"
    "//               will not necessarily be normalized, and could be\n"
    "//               zero, particularly at the endpoints.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_eval_segment_tangent_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float NurbsCurveResult::eval_segment_extended_point(int segment, float t, int d) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_eval_segment_extended_point_140(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float NurbsCurveResult::eval_segment_extended_point(int segment, float t, int d) const
        int param1;
        double param2;
        int param3;
        static char * key_word_list[] = {(char *)"segment", (char *)"t", (char *)"d", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "idi:evalSegmentExtendedPoint", key_word_list, &param1, &param2, &param3))
        {
            float return_value = ((const NurbsCurveResult*)local_this)->eval_segment_extended_point((int)param1, (float)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalSegmentExtendedPoint(const NurbsCurveResult this, int segment, float t, int d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_eval_segment_extended_point_140_comment =
    "C++ Interface:\n"
    "evalSegmentExtendedPoint(const NurbsCurveResult this, int segment, float t, int d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::eval_segment_extended_point\n"
    "//       Access: Published\n"
    "//  Description: Evaluates the curve in n-dimensional space according\n"
    "//               to the extended vertices associated with the curve in\n"
    "//               the indicated dimension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_eval_segment_extended_point_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveResult::get_segment_t(int segment, float t) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_segment_t_142(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsCurveResult::get_segment_t(int segment, float t) const
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"segment", (char *)"t", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:getSegmentT", key_word_list, &param1, &param2))
        {
            float return_value = ((const NurbsCurveResult*)local_this)->get_segment_t((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSegmentT(const NurbsCurveResult this, int segment, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_segment_t_142_comment =
    "C++ Interface:\n"
    "getSegmentT(const NurbsCurveResult this, int segment, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_segment_t\n"
    "//       Access: Published\n"
    "//  Description: Accepts a t value in the range [0, 1], and assumed to\n"
    "//               be relative to the indicated segment (as in\n"
    "//               eval_segment_point()), and returns the corresponding\n"
    "//               t value in the entire curve (as in eval_point()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_segment_t_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveResult::adaptive_sample(float tolerance)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_adaptive_sample_143(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsCurveResult::adaptive_sample(float tolerance)
        double param1;
        static char * key_word_list[] = {(char *)"tolerance", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:adaptiveSample", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:adaptiveSample", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->adaptive_sample((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveResult.adaptiveSample() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "adaptiveSample(non-const NurbsCurveResult this, float tolerance)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_adaptive_sample_143_comment =
    "C++ Interface:\n"
    "adaptiveSample(non-const NurbsCurveResult this, float tolerance)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::adaptive_sample\n"
    "//       Access: Published\n"
    "//  Description: Determines the set of subdivisions necessary to\n"
    "//               approximate the curve with a set of linear segments,\n"
    "//               no point of which is farther than tolerance units\n"
    "//               from the actual curve.\n"
    "//\n"
    "//               After this call, you may walk through the resulting\n"
    "//               set of samples with get_num_samples(),\n"
    "//               get_sample_t(), and get_sample_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_adaptive_sample_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveResult::get_num_samples(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_num_samples_144(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsCurveResult::get_num_samples(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSamples", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSamples"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveResult*)local_this)->get_num_samples();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSamples(const NurbsCurveResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_num_samples_144_comment =
    "C++ Interface:\n"
    "getNumSamples(const NurbsCurveResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_num_samples\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of sample points generated by the\n"
    "//               previous call to adaptive_sample().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_num_samples_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveResult::get_sample_t(int n) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_sample_t_145(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsCurveResult::get_sample_t(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSampleT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSampleT", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsCurveResult*)local_this)->get_sample_t((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSampleT(const NurbsCurveResult this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_sample_t_145_comment =
    "C++ Interface:\n"
    "getSampleT(const NurbsCurveResult this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_sample_t\n"
    "//       Access: Published\n"
    "//  Description: Returns the t value of the nth sample point generated\n"
    "//               by the previous call to adaptive_sample().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_sample_t_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &NurbsCurveResult::get_sample_point(int n) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveResult_get_sample_point_146(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &NurbsCurveResult::get_sample_point(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSamplePoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSamplePoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const NurbsCurveResult*)local_this)->get_sample_point((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSamplePoint(const NurbsCurveResult this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveResult_get_sample_point_146_comment =
    "C++ Interface:\n"
    "getSamplePoint(const NurbsCurveResult this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveResult::get_sample_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the point on the curve of the nth sample\n"
    "//               point generated by the previous call to\n"
    "//               adaptive_sample().\n"
    "//\n"
    "//               For tangents, or extended points, you should use\n"
    "//               get_sample_t() and pass it into eval_tangent() or\n"
    "//               eval_extended_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveResult_get_sample_point_146_comment = NULL;
#endif

int  Dtool_Init_NurbsCurveResult(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NurbsCurveResult)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NurbsCurveResult_get_sample_ts(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumSamples", "getSampleT");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NurbsCurveResult_get_sample_points(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumSamples", "getSamplePoints");
}
inline void  * Dtool_UpcastInterface_NurbsCurveResult(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NurbsCurveResult)
    {
        printf("NurbsCurveResult ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NurbsCurveResult * local_this = (NurbsCurveResult *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NurbsCurveResult)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NurbsCurveResult(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NurbsCurveResult)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NurbsCurveResult*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NurbsCurveEvaluator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void NurbsCurveEvaluator::set_order(int order)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_set_order_149(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NurbsCurveEvaluator::set_order(int order)
        int param1;
        static char * key_word_list[] = {(char *)"order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveEvaluator.setOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOrder(non-const NurbsCurveEvaluator this, int order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_set_order_149_comment =
    "C++ Interface:\n"
    "setOrder(non-const NurbsCurveEvaluator this, int order)\n"
    "\n"
    "// Filename: nurbsCurveEvaluator.I\n"
    "// Created by:  drose (05Dec02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_order\n"
    "//       Access: Published\n"
    "//  Description: Sets the order of the curve.  This resets the knot\n"
    "//               vector to the default knot vector for the number of\n"
    "//               vertices.\n"
    "//\n"
    "//               The order must be 1, 2, 3, or 4, and the value is one\n"
    "//               more than the degree of the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_set_order_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveEvaluator::get_order(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_order_150(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsCurveEvaluator::get_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getOrder"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveEvaluator*)local_this)->get_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOrder(const NurbsCurveEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_order_150_comment =
    "C++ Interface:\n"
    "getOrder(const NurbsCurveEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the order of the curve as set by a previous\n"
    "//               call to set_order().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_order_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveEvaluator::reset(int num_vertices)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_reset_151(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsCurveEvaluator::reset(int num_vertices)
        int param1;
        static char * key_word_list[] = {(char *)"num_vertices", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:reset", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:reset", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->reset((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveEvaluator.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const NurbsCurveEvaluator this, int num_vertices)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_reset_151_comment =
    "C++ Interface:\n"
    "reset(non-const NurbsCurveEvaluator this, int num_vertices)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::reset\n"
    "//       Access: Published\n"
    "//  Description: Resets all the vertices and knots to their default\n"
    "//               values, and sets the curve up with the indicated\n"
    "//               number of vertices.  You must then call set_vertex()\n"
    "//               repeatedly to fill in all of the vertex values\n"
    "//               appropriately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_reset_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveEvaluator::get_num_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_num_vertices_152(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsCurveEvaluator::get_num_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVertices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveEvaluator*)local_this)->get_num_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVertices(const NurbsCurveEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_num_vertices_152_comment =
    "C++ Interface:\n"
    "getNumVertices(const NurbsCurveEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_num_vertices\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of control vertices in the curve.\n"
    "//               This is the number passed to the last call to\n"
    "//               reset().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_num_vertices_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3f const &vertex, float weight)
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3f const &vertex, float weight = (1))
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4f const &vertex)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_set_vertex_153(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3f const &vertex, float weight = (1))
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"i", (char *)"vertex", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setVertex", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "NurbsCurveEvaluator.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4f const &vertex)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"i", (char *)"vertex", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setVertex", key_word_list, &param1, &param2))
                {
                    LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "NurbsCurveEvaluator.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3f const &vertex, float weight)
                int param1;
                PyObject *param2;
                double param3;
                static char * key_word_list[] = {(char *)"i", (char *)"vertex", (char *)"weight", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iOd:setVertex", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "NurbsCurveEvaluator.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, *param2_this, (float)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call NurbsCurveEvaluator.setVertex() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVertex() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVertex(non-const NurbsCurveEvaluator this, int i, const VBase3 vertex)\n"
          "setVertex(non-const NurbsCurveEvaluator this, int i, const VBase4 vertex)\n"
          "setVertex(non-const NurbsCurveEvaluator this, int i, const VBase3 vertex, float weight)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_set_vertex_153_comment =
    "C++ Interface:\n"
    "setVertex(non-const NurbsCurveEvaluator this, int i, const VBase3 vertex)\n"
    "setVertex(non-const NurbsCurveEvaluator this, int i, const VBase4 vertex)\n"
    "setVertex(non-const NurbsCurveEvaluator this, int i, const VBase3 vertex, float weight)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_vertex\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth control vertex of the curve, as a vertex\n"
    "//               in 4-d homogeneous space.  In this form, the first\n"
    "//               three components of the vertex should already have\n"
    "//               been scaled by the fourth component, which is the\n"
    "//               homogeneous weight.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_vertex\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth control vertex of the curve.  This\n"
    "//               flavor sets the vertex as a 3-d coordinate and a\n"
    "//               weight; the 3-d coordinate values are implicitly\n"
    "//               scaled up by the weight factor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_set_vertex_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &NurbsCurveEvaluator::get_vertex(int i) const
 * inline LVecBase4f NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_vertex_154(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline LVecBase4f const &NurbsCurveEvaluator::get_vertex(int i) const
            int param1;
            static char * key_word_list[] = {(char *)"i", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVertex", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getVertex", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f const *return_value = &(((const NurbsCurveEvaluator*)local_this)->get_vertex((int)param1));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LVecBase4f NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"i", (char *)"rel_to", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getVertex", key_word_list, &param1, &param2))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "NurbsCurveEvaluator.getVertex", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        LVecBase4f result = ((const NurbsCurveEvaluator*)local_this)->get_vertex((int)param1, *param2_this);
                        LVecBase4f *return_value = new LVecBase4f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getVertex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getVertex(const NurbsCurveEvaluator this, int i)\n"
          "getVertex(const NurbsCurveEvaluator this, int i, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_vertex_154_comment =
    "C++ Interface:\n"
    "getVertex(const NurbsCurveEvaluator this, int i)\n"
    "getVertex(const NurbsCurveEvaluator this, int i, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_vertex\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth control vertex of the curve, relative\n"
    "//               to its indicated coordinate space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_vertex\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth control vertex of the curve, relative\n"
    "//               to the given coordinate space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_vertex_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
 * inline void NurbsCurveEvaluator::set_vertex_space(int i, basic_string< char > const &space)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_set_vertex_space_155(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void NurbsCurveEvaluator::set_vertex_space(int i, basic_string< char > const &space)
            int param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"i", (char *)"space", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "is#:setVertexSpace", key_word_list, &param1, &param2_str, &param2_len))
            {
                (local_this)->set_vertex_space((int)param1, basic_string<char>(param2_str, param2_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"i", (char *)"space", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setVertexSpace", key_word_list, &param1, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "NurbsCurveEvaluator.setVertexSpace", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_vertex_space((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVertexSpace(non-const NurbsCurveEvaluator this, int i, string space)\n"
          "setVertexSpace(non-const NurbsCurveEvaluator this, int i, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_set_vertex_space_155_comment =
    "C++ Interface:\n"
    "setVertexSpace(non-const NurbsCurveEvaluator this, int i, string space)\n"
    "setVertexSpace(non-const NurbsCurveEvaluator this, int i, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_vertex_space\n"
    "//       Access: Published\n"
    "//  Description: Sets the coordinate space of the nth control vertex.\n"
    "//               If this is not specified, or is set to an empty\n"
    "//               NodePath, the nth control vertex is deemed to be in\n"
    "//               the coordinate space passed to evaluate().\n"
    "//\n"
    "//               This specifies the space as a fixed NodePath, which\n"
    "//               is always the same NodePath.  Also see setting the\n"
    "//               space as a path string, which can specify a different\n"
    "//               NodePath for different instances of the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_vertex_space\n"
    "//       Access: Published\n"
    "//  Description: Sets the coordinate space of the nth control vertex.\n"
    "//               If this is not specified, or is set to an empty\n"
    "//               string, the nth control vertex is deemed to be in\n"
    "//               the coordinate space passed to evaluate().\n"
    "//\n"
    "//               This specifies the space as a string, which describes\n"
    "//               the path to find the node relative to the rel_to\n"
    "//               NodePath when the curve is evaluated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_set_vertex_space_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_vertex_space_156(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"i", (char *)"rel_to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getVertexSpace", key_word_list, &param1, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "NurbsCurveEvaluator.getVertexSpace", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    NodePath result = ((const NurbsCurveEvaluator*)local_this)->get_vertex_space((int)param1, *param2_this);
                    NodePath *return_value = new NodePath(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertexSpace(const NurbsCurveEvaluator this, int i, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_vertex_space_156_comment =
    "C++ Interface:\n"
    "getVertexSpace(const NurbsCurveEvaluator this, int i, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_vertex_space\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate space of the nth control\n"
    "//               vertex of the curve, expressed as a NodePath.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_vertex_space_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, float value)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_set_extended_vertex_157(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, float value)
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"i", (char *)"d", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setExtendedVertex", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_extended_vertex((int)param1, (int)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveEvaluator.setExtendedVertex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExtendedVertex(non-const NurbsCurveEvaluator this, int i, int d, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_set_extended_vertex_157_comment =
    "C++ Interface:\n"
    "setExtendedVertex(non-const NurbsCurveEvaluator this, int i, int d, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_extended_vertex\n"
    "//       Access: Public\n"
    "//  Description: Sets an n-dimensional vertex value.  This allows\n"
    "//               definition of a NURBS surface or curve in a sparse\n"
    "//               n-dimensional space, typically used for associating\n"
    "//               additional properties (like color or joint\n"
    "//               membership) with each vertex of a surface.\n"
    "//\n"
    "//               The value d is an arbitrary integer value and\n"
    "//               specifies the dimension of question for this\n"
    "//               particular vertex.  Any number of dimensions may be\n"
    "//               specified, and they need not be consecutive.  If a\n"
    "//               value for a given dimension is not specified, is it\n"
    "//               implicitly 0.0.\n"
    "//\n"
    "//               The value is implicitly scaled by the homogenous\n"
    "//               weight value--that is, the fourth component of the\n"
    "//               value passed to set_vertex().  This means the\n"
    "//               ordinary vertex must be set first, before the\n"
    "//               extended vertices can be set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_set_extended_vertex_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsCurveEvaluator::get_extended_vertex(int i, int d) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_extended_vertex_158(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsCurveEvaluator::get_extended_vertex(int i, int d) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"i", (char *)"d", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getExtendedVertex", key_word_list, &param1, &param2))
        {
            float return_value = ((const NurbsCurveEvaluator*)local_this)->get_extended_vertex((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtendedVertex(const NurbsCurveEvaluator this, int i, int d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_extended_vertex_158_comment =
    "C++ Interface:\n"
    "getExtendedVertex(const NurbsCurveEvaluator this, int i, int d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::float_extended_vertex\n"
    "//       Access: Public\n"
    "//  Description: Returns an n-dimensional vertex value.  See\n"
    "//               set_extended_vertex().  This returns the value set\n"
    "//               for the indicated dimension, or 0.0 if nothing has\n"
    "//               been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_extended_vertex_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveEvaluator::get_num_knots(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_num_knots_160(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsCurveEvaluator::get_num_knots(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumKnots", key_word_list));
        else
            (PyArg_Parse(args, ":getNumKnots"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveEvaluator*)local_this)->get_num_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumKnots(const NurbsCurveEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_num_knots_160_comment =
    "C++ Interface:\n"
    "getNumKnots(const NurbsCurveEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_num_knots\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of knot values in the curve.  This\n"
    "//               is based on the number of vertices and the order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_num_knots_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveEvaluator::set_knot(int i, float knot)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_set_knot_161(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsCurveEvaluator::set_knot(int i, float knot)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"i", (char *)"knot", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setKnot", key_word_list, &param1, &param2))
        {
            (local_this)->set_knot((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveEvaluator.setKnot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKnot(non-const NurbsCurveEvaluator this, int i, float knot)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_set_knot_161_comment =
    "C++ Interface:\n"
    "setKnot(non-const NurbsCurveEvaluator this, int i, float knot)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::set_knot\n"
    "//       Access: Published\n"
    "//  Description: Sets the value of the nth knot.  Each knot value\n"
    "//               should be greater than or equal to the preceding\n"
    "//               value.  If no knot values are set, a default knot\n"
    "//               vector is supplied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_set_knot_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float NurbsCurveEvaluator::get_knot(int i) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_knot_162(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float NurbsCurveEvaluator::get_knot(int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getKnot", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getKnot", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsCurveEvaluator*)local_this)->get_knot((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKnot(const NurbsCurveEvaluator this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_knot_162_comment =
    "C++ Interface:\n"
    "getKnot(const NurbsCurveEvaluator this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_knot\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the nth knot.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_knot_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveEvaluator::normalize_knots(void)
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_normalize_knots_163(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsCurveEvaluator::normalize_knots(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":normalizeKnots", key_word_list));
        else
            (PyArg_Parse(args, ":normalizeKnots"));
        if(!PyErr_Occurred())
        {
            (local_this)->normalize_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsCurveEvaluator.normalizeKnots() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "normalizeKnots(non-const NurbsCurveEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_normalize_knots_163_comment =
    "C++ Interface:\n"
    "normalizeKnots(non-const NurbsCurveEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::normalize_knots\n"
    "//       Access: Published\n"
    "//  Description: Normalizes the knot sequence so that the parametric\n"
    "//               range of the curve is 0 .. 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_normalize_knots_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsCurveEvaluator::get_num_segments(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_get_num_segments_164(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsCurveEvaluator::get_num_segments(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSegments", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSegments"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsCurveEvaluator*)local_this)->get_num_segments();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSegments(const NurbsCurveEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_get_num_segments_164_comment =
    "C++ Interface:\n"
    "getNumSegments(const NurbsCurveEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::get_num_segments\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of piecewise continuous segments\n"
    "//               in the curve.  This is based on the knot vector.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_get_num_segments_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to) const
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to = ((()))) const
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4f const &mat) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_evaluate_165(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to = ((()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":evaluate", key_word_list));
            else
                (PyArg_Parse(args, ":evaluate"));
            if(!PyErr_Occurred())
            {
                PointerTo< NurbsCurveResult > return_value = ((const NurbsCurveEvaluator*)local_this)->evaluate();
                if (return_value != (NurbsCurveResult *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value.p(),Dtool_NurbsCurveResult,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"rel_to", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:evaluate", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:evaluate", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NurbsCurveEvaluator.evaluate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< NurbsCurveResult > return_value = ((const NurbsCurveEvaluator*)local_this)->evaluate(*param1_this);
                        if (return_value != (NurbsCurveResult *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_NurbsCurveResult,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4f const &mat) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"rel_to", (char *)"mat", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:evaluate", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NurbsCurveEvaluator.evaluate", 1, coerced_ptr, report_errors);
LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "NurbsCurveEvaluator.evaluate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        PointerTo< NurbsCurveResult > return_value = ((const NurbsCurveEvaluator*)local_this)->evaluate(*param1_this, *param2_this);
                        if (return_value != (NurbsCurveResult *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_NurbsCurveResult,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "evaluate() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "evaluate(const NurbsCurveEvaluator this)\n"
          "evaluate(const NurbsCurveEvaluator this, const NodePath rel_to)\n"
          "evaluate(const NurbsCurveEvaluator this, const NodePath rel_to, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_evaluate_165_comment =
    "C++ Interface:\n"
    "evaluate(const NurbsCurveEvaluator this)\n"
    "evaluate(const NurbsCurveEvaluator this, const NodePath rel_to)\n"
    "evaluate(const NurbsCurveEvaluator this, const NodePath rel_to, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::evaluate\n"
    "//       Access: Published\n"
    "//  Description: Returns a NurbsCurveResult object that represents the\n"
    "//               result of applying the knots to all of the current\n"
    "//               values of the vertices, transformed into the\n"
    "//               indicated coordinate space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::evaluate\n"
    "//       Access: Published\n"
    "//  Description: Returns a NurbsCurveResult object that represents the\n"
    "//               result of applying the knots to all of the current\n"
    "//               values of the vertices, transformed into the\n"
    "//               indicated coordinate space, and then further\n"
    "//               transformed by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_evaluate_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsCurveEvaluator::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_NurbsCurveEvaluator_output_166(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsCurveEvaluator::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "NurbsCurveEvaluator.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const NurbsCurveEvaluator*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const NurbsCurveEvaluator this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsCurveEvaluator_output_166_comment =
    "C++ Interface:\n"
    "output(const NurbsCurveEvaluator this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsCurveEvaluator::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsCurveEvaluator_output_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NurbsCurveEvaluator::NurbsCurveEvaluator(void)
 *******************************************************************/
int  Dtool_Init_NurbsCurveEvaluator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NurbsCurveEvaluator::NurbsCurveEvaluator(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NurbsCurveEvaluator", key_word_list))
        {
            NurbsCurveEvaluator *return_value = new NurbsCurveEvaluator();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NurbsCurveEvaluator,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NurbsCurveEvaluator()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NurbsCurveEvaluator_get_vertices(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumVertices", "getVertex");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NurbsCurveEvaluator_get_knots(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumKnots", "getKnot");
}
inline void  * Dtool_UpcastInterface_NurbsCurveEvaluator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NurbsCurveEvaluator)
    {
        printf("NurbsCurveEvaluator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NurbsCurveEvaluator * local_this = (NurbsCurveEvaluator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NurbsCurveEvaluator)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NurbsCurveEvaluator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NurbsCurveEvaluator)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NurbsCurveEvaluator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NurbsSurfaceResult 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::get_start_u(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_start_u_168(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceResult::get_start_u(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartU", key_word_list));
        else
            (PyArg_Parse(args, ":getStartU"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->get_start_u();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartU(const NurbsSurfaceResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_start_u_168_comment =
    "C++ Interface:\n"
    "getStartU(const NurbsSurfaceResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_start_u\n"
    "//       Access: Public\n"
    "//  Description: Returns the first legal value of u on the surface.\n"
    "//               Usually this is 0.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_start_u_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::get_end_u(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_end_u_169(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceResult::get_end_u(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndU", key_word_list));
        else
            (PyArg_Parse(args, ":getEndU"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->get_end_u();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndU(const NurbsSurfaceResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_end_u_169_comment =
    "C++ Interface:\n"
    "getEndU(const NurbsSurfaceResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_end_u\n"
    "//       Access: Public\n"
    "//  Description: Returns the last legal value of u on the surface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_end_u_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::get_start_v(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_start_v_170(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceResult::get_start_v(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartV", key_word_list));
        else
            (PyArg_Parse(args, ":getStartV"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->get_start_v();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartV(const NurbsSurfaceResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_start_v_170_comment =
    "C++ Interface:\n"
    "getStartV(const NurbsSurfaceResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_start_v\n"
    "//       Access: Public\n"
    "//  Description: Returns the first legal value of v on the surface.\n"
    "//               Usually this is 0.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_start_v_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::get_end_v(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_end_v_171(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceResult::get_end_v(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndV", key_word_list));
        else
            (PyArg_Parse(args, ":getEndV"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->get_end_v();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndV(const NurbsSurfaceResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_end_v_171_comment =
    "C++ Interface:\n"
    "getEndV(const NurbsSurfaceResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_end_v\n"
    "//       Access: Public\n"
    "//  Description: Returns the last legal value of v on the surface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_end_v_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NurbsSurfaceResult::eval_point(float u, float v, LVecBase3f &point)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_eval_point_172(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool NurbsSurfaceResult::eval_point(float u, float v, LVecBase3f &point)
            double param1;
            double param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"u", (char *)"v", (char *)"point", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:evalPoint", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "NurbsSurfaceResult.evalPoint", 0, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    bool return_value = (local_this)->eval_point((float)param1, (float)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsSurfaceResult.evalPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalPoint(non-const NurbsSurfaceResult this, float u, float v, non-const VBase3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_eval_point_172_comment =
    "C++ Interface:\n"
    "evalPoint(non-const NurbsSurfaceResult this, float u, float v, non-const VBase3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::eval_point\n"
    "//       Access: Published\n"
    "//  Description: Computes the point on the surface corresponding to the\n"
    "//               indicated value in parametric time.  Returns true if\n"
    "//               the u, v values are valid, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_eval_point_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NurbsSurfaceResult::eval_normal(float u, float v, LVecBase3f &normal)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_eval_normal_173(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool NurbsSurfaceResult::eval_normal(float u, float v, LVecBase3f &normal)
            double param1;
            double param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"u", (char *)"v", (char *)"normal", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:evalNormal", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "NurbsSurfaceResult.evalNormal", 0, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    bool return_value = (local_this)->eval_normal((float)param1, (float)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NurbsSurfaceResult.evalNormal() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalNormal(non-const NurbsSurfaceResult this, float u, float v, non-const VBase3 normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_eval_normal_173_comment =
    "C++ Interface:\n"
    "evalNormal(non-const NurbsSurfaceResult this, float u, float v, non-const VBase3 normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::eval_normal\n"
    "//       Access: Published\n"
    "//  Description: Computes the normal to the surface at the indicated\n"
    "//               point in parametric time.  This normal vector will\n"
    "//               not necessarily be normalized, and could be zero.\n"
    "//               See also eval_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_eval_normal_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::eval_extended_point(float u, float v, int d)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_eval_extended_point_174(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float NurbsSurfaceResult::eval_extended_point(float u, float v, int d)
        double param1;
        double param2;
        int param3;
        static char * key_word_list[] = {(char *)"u", (char *)"v", (char *)"d", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddi:evalExtendedPoint", key_word_list, &param1, &param2, &param3))
        {
            float return_value = (local_this)->eval_extended_point((float)param1, (float)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceResult.evalExtendedPoint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalExtendedPoint(non-const NurbsSurfaceResult this, float u, float v, int d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_eval_extended_point_174_comment =
    "C++ Interface:\n"
    "evalExtendedPoint(non-const NurbsSurfaceResult this, float u, float v, int d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::eval_extended_point\n"
    "//       Access: Published\n"
    "//  Description: Evaluates the surface in n-dimensional space according\n"
    "//               to the extended vertices associated with the surface in\n"
    "//               the indicated dimension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_eval_extended_point_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceResult::get_num_u_segments(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_num_u_segments_176(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceResult::get_num_u_segments(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUSegments", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUSegments"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceResult*)local_this)->get_num_u_segments();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUSegments(const NurbsSurfaceResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_num_u_segments_176_comment =
    "C++ Interface:\n"
    "getNumUSegments(const NurbsSurfaceResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_num_u_segments\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of piecewise continuous segments\n"
    "//               within the surface in the U direction.  This number\n"
    "//               is usually not important unless you plan to call\n"
    "//               eval_segment_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_num_u_segments_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceResult::get_num_v_segments(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_num_v_segments_177(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceResult::get_num_v_segments(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVSegments", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVSegments"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceResult*)local_this)->get_num_v_segments();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVSegments(const NurbsSurfaceResult this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_num_v_segments_177_comment =
    "C++ Interface:\n"
    "getNumVSegments(const NurbsSurfaceResult this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_num_v_segments\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of piecewise continuous segments\n"
    "//               within the surface in the V direction.  This number\n"
    "//               is usually not important unless you plan to call\n"
    "//               eval_segment_point().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_num_v_segments_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceResult::eval_segment_point(int ui, int vi, float u, float v, LVecBase3f &point) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_point_178(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsSurfaceResult::eval_segment_point(int ui, int vi, float u, float v, LVecBase3f &point) const
            int param1;
            int param2;
            double param3;
            double param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"u", (char *)"v", (char *)"point", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddO:evalSegmentPoint", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "NurbsSurfaceResult.evalSegmentPoint", 0, coerced_ptr, report_errors);

                if (!((param5_this == NULL)))
                {
                    ((const NurbsSurfaceResult*)local_this)->eval_segment_point((int)param1, (int)param2, (float)param3, (float)param4, *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalSegmentPoint(const NurbsSurfaceResult this, int ui, int vi, float u, float v, non-const VBase3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_eval_segment_point_178_comment =
    "C++ Interface:\n"
    "evalSegmentPoint(const NurbsSurfaceResult this, int ui, int vi, float u, float v, non-const VBase3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::eval_segment_point\n"
    "//       Access: Published\n"
    "//  Description: Evaluates the point on the surface corresponding to the\n"
    "//               indicated value in parametric time within the\n"
    "//               indicated surface segment.  u and v should be in the\n"
    "//               range [0, 1].\n"
    "//\n"
    "//               The surface is internally represented as a number of\n"
    "//               connected (or possibly unconnected) piecewise\n"
    "//               continuous segments.  The exact number of segments\n"
    "//               for a particular surface depends on the knot vector,\n"
    "//               and is returned by get_num_segments().  Normally,\n"
    "//               eval_point() is used to evaluate a point along the\n"
    "//               continuous surface, but when you care more about local\n"
    "//               continuity, you can use eval_segment_point() to\n"
    "//               evaluate the points along each segment.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_eval_segment_point_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, float u, float v, LVecBase3f &normal) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_normal_179(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, float u, float v, LVecBase3f &normal) const
            int param1;
            int param2;
            double param3;
            double param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"u", (char *)"v", (char *)"normal", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddO:evalSegmentNormal", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "NurbsSurfaceResult.evalSegmentNormal", 0, coerced_ptr, report_errors);

                if (!((param5_this == NULL)))
                {
                    ((const NurbsSurfaceResult*)local_this)->eval_segment_normal((int)param1, (int)param2, (float)param3, (float)param4, *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalSegmentNormal(const NurbsSurfaceResult this, int ui, int vi, float u, float v, non-const VBase3 normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_eval_segment_normal_179_comment =
    "C++ Interface:\n"
    "evalSegmentNormal(const NurbsSurfaceResult this, int ui, int vi, float u, float v, non-const VBase3 normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::eval_segment_normal\n"
    "//       Access: Published\n"
    "//  Description: As eval_segment_point, but computes the normal to\n"
    "//               the surface at the indicated point.  The normal vector\n"
    "//               will not necessarily be normalized, and could be\n"
    "//               zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_eval_segment_normal_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, float u, float v, int d) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_extended_point_180(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, float u, float v, int d) const
        int param1;
        int param2;
        double param3;
        double param4;
        int param5;
        static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"u", (char *)"v", (char *)"d", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddi:evalSegmentExtendedPoint", key_word_list, &param1, &param2, &param3, &param4, &param5))
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->eval_segment_extended_point((int)param1, (int)param2, (float)param3, (float)param4, (int)param5);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "evalSegmentExtendedPoint(const NurbsSurfaceResult this, int ui, int vi, float u, float v, int d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_eval_segment_extended_point_180_comment =
    "C++ Interface:\n"
    "evalSegmentExtendedPoint(const NurbsSurfaceResult this, int ui, int vi, float u, float v, int d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::eval_segment_extended_point\n"
    "//       Access: Published\n"
    "//  Description: Evaluates the surface in n-dimensional space according\n"
    "//               to the extended vertices associated with the surface in\n"
    "//               the indicated dimension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_eval_segment_extended_point_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::get_segment_u(int ui, float u) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_segment_u_182(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceResult::get_segment_u(int ui, float u) const
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"ui", (char *)"u", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:getSegmentU", key_word_list, &param1, &param2))
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->get_segment_u((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSegmentU(const NurbsSurfaceResult this, int ui, float u)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_segment_u_182_comment =
    "C++ Interface:\n"
    "getSegmentU(const NurbsSurfaceResult this, int ui, float u)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_segment_u\n"
    "//       Access: Public\n"
    "//  Description: Accepts a u value in the range [0, 1], and assumed to\n"
    "//               be relative to the indicated segment (as in\n"
    "//               eval_segment_point()), and returns the corresponding\n"
    "//               u value in the entire surface (as in eval_point()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_segment_u_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceResult::get_segment_v(int vi, float v) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceResult_get_segment_v_183(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceResult * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceResult,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceResult::get_segment_v(int vi, float v) const
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"vi", (char *)"v", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:getSegmentV", key_word_list, &param1, &param2))
        {
            float return_value = ((const NurbsSurfaceResult*)local_this)->get_segment_v((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSegmentV(const NurbsSurfaceResult this, int vi, float v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceResult_get_segment_v_183_comment =
    "C++ Interface:\n"
    "getSegmentV(const NurbsSurfaceResult this, int vi, float v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceResult::get_segment_v\n"
    "//       Access: Public\n"
    "//  Description: Accepts a v value in the range [0, 1], and assumed to\n"
    "//               be relative to the indicated segment (as in\n"
    "//               eval_segment_point()), and returns the corresponding\n"
    "//               v value in the entire surface (as in eval_point()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceResult_get_segment_v_183_comment = NULL;
#endif

int  Dtool_Init_NurbsSurfaceResult(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NurbsSurfaceResult)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NurbsSurfaceResult(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NurbsSurfaceResult)
    {
        printf("NurbsSurfaceResult ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NurbsSurfaceResult * local_this = (NurbsSurfaceResult *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NurbsSurfaceResult)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NurbsSurfaceResult(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NurbsSurfaceResult)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NurbsSurfaceResult*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NurbsSurfaceEvaluator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_u_order_186(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
        int param1;
        static char * key_word_list[] = {(char *)"u_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setUOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setUOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_u_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.setUOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUOrder(non-const NurbsSurfaceEvaluator this, int u_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_u_order_186_comment =
    "C++ Interface:\n"
    "setUOrder(non-const NurbsSurfaceEvaluator this, int u_order)\n"
    "\n"
    "// Filename: nurbsSurfaceEvaluator.I\n"
    "// Created by:  drose (10Oct03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_u_order\n"
    "//       Access: Published\n"
    "//  Description: Sets the order of the surface in the U direction.\n"
    "//               This resets the knot vector to the default knot\n"
    "//               vector for the number of vertices.\n"
    "//\n"
    "//               The order must be 1, 2, 3, or 4, and the value is one\n"
    "//               more than the degree of the surface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_u_order_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_u_order(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_u_order_187(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_u_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getUOrder"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_u_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUOrder(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_u_order_187_comment =
    "C++ Interface:\n"
    "getUOrder(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_u_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the order of the surface in the U direction\n"
    "//               as set by a previous call to set_u_order().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_u_order_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_v_order_188(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
        int param1;
        static char * key_word_list[] = {(char *)"v_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setVOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setVOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_v_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.setVOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVOrder(non-const NurbsSurfaceEvaluator this, int v_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_v_order_188_comment =
    "C++ Interface:\n"
    "setVOrder(non-const NurbsSurfaceEvaluator this, int v_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_v_order\n"
    "//       Access: Published\n"
    "//  Description: Sets the order of the surface in the V direction.\n"
    "//               This resets the knot vector to the default knot\n"
    "//               vector for the number of vertices.\n"
    "//\n"
    "//               The order must be 1, 2, 3, or 4, and the value is one\n"
    "//               more than the degree of the surface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_v_order_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_v_order(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_v_order_189(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_v_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getVOrder"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_v_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVOrder(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_v_order_189_comment =
    "C++ Interface:\n"
    "getVOrder(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_v_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the order of the surface in the V direction\n"
    "//               as set by a previous call to set_v_order().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_v_order_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_reset_190(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"num_u_vertices", (char *)"num_v_vertices", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:reset", key_word_list, &param1, &param2))
        {
            (local_this)->reset((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const NurbsSurfaceEvaluator this, int num_u_vertices, int num_v_vertices)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_reset_190_comment =
    "C++ Interface:\n"
    "reset(non-const NurbsSurfaceEvaluator this, int num_u_vertices, int num_v_vertices)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::reset\n"
    "//       Access: Published\n"
    "//  Description: Resets all the vertices and knots to their default\n"
    "//               values, and sets the surface up with the indicated\n"
    "//               number of vertices.  You must then call set_vertex()\n"
    "//               repeatedly to fill in all of the vertex values\n"
    "//               appropriately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_reset_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_191(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUVertices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_num_u_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUVertices(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_191_comment =
    "C++ Interface:\n"
    "getNumUVertices(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_num_u_vertices\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of control vertices in the U\n"
    "//               direction on the surface.  This is the number passed\n"
    "//               to the last call to reset().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_192(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVVertices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_num_v_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVVertices(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_192_comment =
    "C++ Interface:\n"
    "getNumVVertices(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_num_v_vertices\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of control vertices in the V\n"
    "//               direction on the surface.  This is the number passed\n"
    "//               to the last call to reset().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3f const &vertex, float weight)
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3f const &vertex, float weight = (1))
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4f const &vertex)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_vertex_193(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3f const &vertex, float weight = (1))
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"vertex", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setVertex", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "NurbsSurfaceEvaluator.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4f const &vertex)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"vertex", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setVertex", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "NurbsSurfaceEvaluator.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3f const &vertex, float weight)
                int param1;
                int param2;
                PyObject *param3;
                double param4;
                static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"vertex", (char *)"weight", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiOd:setVertex", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "NurbsSurfaceEvaluator.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, (int)param2, *param3_this, (float)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call NurbsSurfaceEvaluator.setVertex() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVertex() takes 4 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, const VBase3 vertex)\n"
          "setVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, const VBase4 vertex)\n"
          "setVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, const VBase3 vertex, float weight)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_vertex_193_comment =
    "C++ Interface:\n"
    "setVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, const VBase3 vertex)\n"
    "setVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, const VBase4 vertex)\n"
    "setVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, const VBase3 vertex, float weight)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_vertex\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth control vertex of the surface, as a vertex\n"
    "//               in 4-d homogeneous space.  In this form, the first\n"
    "//               three components of the vertex should already have\n"
    "//               been scaled by the fourth component, which is the\n"
    "//               homogeneous weight.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_vertex\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth control vertex of the surface.  This\n"
    "//               flavor sets the vertex as a 3-d coordinate and a\n"
    "//               weight; the 3-d coordinate values are implicitly\n"
    "//               scaled up by the weight factor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_vertex_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const
 * inline LVecBase4f NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_vertex_194(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-inline LVecBase4f const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"ui", (char *)"vi", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getVertex", key_word_list, &param1, &param2))
            {
                LVecBase4f const *return_value = &(((const NurbsSurfaceEvaluator*)local_this)->get_vertex((int)param1, (int)param2));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LVecBase4f NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"rel_to", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:getVertex", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "NurbsSurfaceEvaluator.getVertex", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        LVecBase4f result = ((const NurbsSurfaceEvaluator*)local_this)->get_vertex((int)param1, (int)param2, *param3_this);
                        LVecBase4f *return_value = new LVecBase4f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getVertex() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getVertex(const NurbsSurfaceEvaluator this, int ui, int vi)\n"
          "getVertex(const NurbsSurfaceEvaluator this, int ui, int vi, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_vertex_194_comment =
    "C++ Interface:\n"
    "getVertex(const NurbsSurfaceEvaluator this, int ui, int vi)\n"
    "getVertex(const NurbsSurfaceEvaluator this, int ui, int vi, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_vertex\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth control vertex of the surface, relative\n"
    "//               to its indicated coordinate space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_vertex\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth control vertex of the surface, relative\n"
    "//               to the given coordinate space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_vertex_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
 * inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, basic_string< char > const &space)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_vertex_space_195(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, basic_string< char > const &space)
            int param1;
            int param2;
            char *param3_str; int param3_len;
            static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"space", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iis#:setVertexSpace", key_word_list, &param1, &param2, &param3_str, &param3_len))
            {
                (local_this)->set_vertex_space((int)param1, (int)param2, basic_string<char>(param3_str, param3_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
            int param1;
            int param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"space", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setVertexSpace", key_word_list, &param1, &param2, &param3))
            {
                NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "NurbsSurfaceEvaluator.setVertexSpace", 1, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    (local_this)->set_vertex_space((int)param1, (int)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVertexSpace(non-const NurbsSurfaceEvaluator this, int ui, int vi, string space)\n"
          "setVertexSpace(non-const NurbsSurfaceEvaluator this, int ui, int vi, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_vertex_space_195_comment =
    "C++ Interface:\n"
    "setVertexSpace(non-const NurbsSurfaceEvaluator this, int ui, int vi, string space)\n"
    "setVertexSpace(non-const NurbsSurfaceEvaluator this, int ui, int vi, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_vertex_space\n"
    "//       Access: Published\n"
    "//  Description: Sets the coordinate space of the nth control vertex.\n"
    "//               If this is not specified, or is set to an empty\n"
    "//               NodePath, the nth control vertex is deemed to be in\n"
    "//               the coordinate space passed to evaluate().\n"
    "//\n"
    "//               This specifies the space as a fixed NodePath, which\n"
    "//               is always the same NodePath.  Also see setting the\n"
    "//               space as a path string, which can specify a different\n"
    "//               NodePath for different instances of the surface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_vertex_space\n"
    "//       Access: Published\n"
    "//  Description: Sets the coordinate space of the nth control vertex.\n"
    "//               If this is not specified, or is set to an empty\n"
    "//               string, the nth control vertex is deemed to be in\n"
    "//               the coordinate space passed to evaluate().\n"
    "//\n"
    "//               This specifies the space as a string, which describes\n"
    "//               the path to find the node relative to the rel_to\n"
    "//               NodePath when the surface is evaluated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_vertex_space_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_vertex_space_196(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const
            int param1;
            int param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"rel_to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:getVertexSpace", key_word_list, &param1, &param2, &param3))
            {
                NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "NurbsSurfaceEvaluator.getVertexSpace", 1, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    NodePath result = ((const NurbsSurfaceEvaluator*)local_this)->get_vertex_space((int)param1, (int)param2, *param3_this);
                    NodePath *return_value = new NodePath(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertexSpace(const NurbsSurfaceEvaluator this, int ui, int vi, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_vertex_space_196_comment =
    "C++ Interface:\n"
    "getVertexSpace(const NurbsSurfaceEvaluator this, int ui, int vi, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_vertex_space\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate space of the nth control\n"
    "//               vertex of the surface, expressed as a NodePath.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_vertex_space_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, float value)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_197(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, float value)
        int param1;
        int param2;
        int param3;
        double param4;
        static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"d", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiid:setExtendedVertex", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_extended_vertex((int)param1, (int)param2, (int)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.setExtendedVertex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExtendedVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, int d, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_extended_vertex_197_comment =
    "C++ Interface:\n"
    "setExtendedVertex(non-const NurbsSurfaceEvaluator this, int ui, int vi, int d, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_extended_vertex\n"
    "//       Access: Public\n"
    "//  Description: Sets an n-dimensional vertex value.  This allows\n"
    "//               definition of a NURBS surface or surface in a sparse\n"
    "//               n-dimensional space, typically used for associating\n"
    "//               additional properties (like color or joint\n"
    "//               membership) with each vertex of a surface.\n"
    "//\n"
    "//               The value d is an arbitrary integer value and\n"
    "//               specifies the dimension of question for this\n"
    "//               particular vertex.  Any number of dimensions may be\n"
    "//               specified, and they need not be consecutive.  If a\n"
    "//               value for a given dimension is not specified, is it\n"
    "//               implicitly 0.0.\n"
    "//\n"
    "//               The value is implicitly scaled by the homogenous\n"
    "//               weight value--that is, the fourth component of the\n"
    "//               value passed to set_vertex().  This means the\n"
    "//               ordinary vertex must be set first, before the\n"
    "//               extended vertices can be set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_extended_vertex_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_198(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const
        int param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"ui", (char *)"vi", (char *)"d", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:getExtendedVertex", key_word_list, &param1, &param2, &param3))
        {
            float return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_extended_vertex((int)param1, (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtendedVertex(const NurbsSurfaceEvaluator this, int ui, int vi, int d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_extended_vertex_198_comment =
    "C++ Interface:\n"
    "getExtendedVertex(const NurbsSurfaceEvaluator this, int ui, int vi, int d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::float_extended_vertex\n"
    "//       Access: Public\n"
    "//  Description: Returns an n-dimensional vertex value.  See\n"
    "//               set_extended_vertex().  This returns the value set\n"
    "//               for the indicated dimension, or 0.0 if nothing has\n"
    "//               been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_extended_vertex_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_200(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUKnots", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUKnots"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_num_u_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUKnots(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_num_u_knots_200_comment =
    "C++ Interface:\n"
    "getNumUKnots(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_num_u_knots\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of knot values in the surface in\n"
    "//               the U direction.  This is based on the number of\n"
    "//               vertices and the order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_num_u_knots_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceEvaluator::set_u_knot(int i, float knot)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_u_knot_201(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsSurfaceEvaluator::set_u_knot(int i, float knot)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"i", (char *)"knot", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setUKnot", key_word_list, &param1, &param2))
        {
            (local_this)->set_u_knot((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.setUKnot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUKnot(non-const NurbsSurfaceEvaluator this, int i, float knot)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_u_knot_201_comment =
    "C++ Interface:\n"
    "setUKnot(non-const NurbsSurfaceEvaluator this, int i, float knot)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_u_knot\n"
    "//       Access: Published\n"
    "//  Description: Sets the value of the nth knot.  Each knot value\n"
    "//               should be greater than or equal to the preceding\n"
    "//               value.  If no knot values are set, a default knot\n"
    "//               vector is supplied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_u_knot_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float NurbsSurfaceEvaluator::get_u_knot(int i) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_u_knot_202(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float NurbsSurfaceEvaluator::get_u_knot(int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getUKnot", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getUKnot", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_u_knot((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUKnot(const NurbsSurfaceEvaluator this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_u_knot_202_comment =
    "C++ Interface:\n"
    "getUKnot(const NurbsSurfaceEvaluator this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_u_knot\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the nth knot.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_u_knot_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceEvaluator::normalize_u_knots(void)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_203(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsSurfaceEvaluator::normalize_u_knots(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":normalizeUKnots", key_word_list));
        else
            (PyArg_Parse(args, ":normalizeUKnots"));
        if(!PyErr_Occurred())
        {
            (local_this)->normalize_u_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.normalizeUKnots() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "normalizeUKnots(non-const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_normalize_u_knots_203_comment =
    "C++ Interface:\n"
    "normalizeUKnots(non-const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::normalize_u_knots\n"
    "//       Access: Published\n"
    "//  Description: Normalizes the knot sequence so that the parametric\n"
    "//               range of the surface in the U direction is 0 .. 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_normalize_u_knots_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_204(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVKnots", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVKnots"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_num_v_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVKnots(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_num_v_knots_204_comment =
    "C++ Interface:\n"
    "getNumVKnots(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_num_v_knots\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of knot values in the surface in\n"
    "//               the V direction.  This is based on the number of\n"
    "//               vertices and the order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_num_v_knots_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceEvaluator::set_v_knot(int i, float knot)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_set_v_knot_205(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsSurfaceEvaluator::set_v_knot(int i, float knot)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"i", (char *)"knot", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setVKnot", key_word_list, &param1, &param2))
        {
            (local_this)->set_v_knot((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.setVKnot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVKnot(non-const NurbsSurfaceEvaluator this, int i, float knot)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_set_v_knot_205_comment =
    "C++ Interface:\n"
    "setVKnot(non-const NurbsSurfaceEvaluator this, int i, float knot)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::set_v_knot\n"
    "//       Access: Published\n"
    "//  Description: Sets the value of the nth knot.  Each knot value\n"
    "//               should be greater than or equal to the preceding\n"
    "//               value.  If no knot values are set, a default knot\n"
    "//               vector is supplied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_set_v_knot_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float NurbsSurfaceEvaluator::get_v_knot(int i) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_v_knot_206(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float NurbsSurfaceEvaluator::get_v_knot(int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVKnot", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getVKnot", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_v_knot((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVKnot(const NurbsSurfaceEvaluator this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_v_knot_206_comment =
    "C++ Interface:\n"
    "getVKnot(const NurbsSurfaceEvaluator this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_v_knot\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the nth knot.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_v_knot_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceEvaluator::normalize_v_knots(void)
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_207(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NurbsSurfaceEvaluator::normalize_v_knots(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":normalizeVKnots", key_word_list));
        else
            (PyArg_Parse(args, ":normalizeVKnots"));
        if(!PyErr_Occurred())
        {
            (local_this)->normalize_v_knots();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NurbsSurfaceEvaluator.normalizeVKnots() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "normalizeVKnots(non-const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_normalize_v_knots_207_comment =
    "C++ Interface:\n"
    "normalizeVKnots(non-const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::normalize_v_knots\n"
    "//       Access: Published\n"
    "//  Description: Normalizes the knot sequence so that the parametric\n"
    "//               range of the surface in the U direction is 0 .. 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_normalize_v_knots_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_208(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUSegments", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUSegments"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_num_u_segments();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUSegments(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_num_u_segments_208_comment =
    "C++ Interface:\n"
    "getNumUSegments(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_num_u_segments\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of piecewise continuous segments\n"
    "//               in the surface in the U direction.  This is based on\n"
    "//               the knot vector.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_num_u_segments_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_209(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVSegments", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVSegments"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NurbsSurfaceEvaluator*)local_this)->get_num_v_segments();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVSegments(const NurbsSurfaceEvaluator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_get_num_v_segments_209_comment =
    "C++ Interface:\n"
    "getNumVSegments(const NurbsSurfaceEvaluator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::get_num_v_segments\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of piecewise continuous segments\n"
    "//               in the surface in the V direction.  This is based on\n"
    "//               the knot vector.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_get_num_v_segments_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to) const
 * PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to = ((()))) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_evaluate_210(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to = ((()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":evaluate", key_word_list));
            else
                (PyArg_Parse(args, ":evaluate"));
            if(!PyErr_Occurred())
            {
                PointerTo< NurbsSurfaceResult > return_value = ((const NurbsSurfaceEvaluator*)local_this)->evaluate();
                if (return_value != (NurbsSurfaceResult *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value.p(),Dtool_NurbsSurfaceResult,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"rel_to", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:evaluate", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:evaluate", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NurbsSurfaceEvaluator.evaluate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< NurbsSurfaceResult > return_value = ((const NurbsSurfaceEvaluator*)local_this)->evaluate(*param1_this);
                        if (return_value != (NurbsSurfaceResult *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_NurbsSurfaceResult,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "evaluate() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "evaluate(const NurbsSurfaceEvaluator this)\n"
          "evaluate(const NurbsSurfaceEvaluator this, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_evaluate_210_comment =
    "C++ Interface:\n"
    "evaluate(const NurbsSurfaceEvaluator this)\n"
    "evaluate(const NurbsSurfaceEvaluator this, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::evaluate\n"
    "//       Access: Published\n"
    "//  Description: Returns a NurbsSurfaceResult object that represents the\n"
    "//               result of applying the knots to all of the current\n"
    "//               values of the vertices, transformed into the\n"
    "//               indicated coordinate space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_evaluate_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NurbsSurfaceEvaluator::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_NurbsSurfaceEvaluator_output_211(PyObject *self, PyObject *args,PyObject *kwds) {
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NurbsSurfaceEvaluator::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "NurbsSurfaceEvaluator.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const NurbsSurfaceEvaluator*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const NurbsSurfaceEvaluator this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NurbsSurfaceEvaluator_output_211_comment =
    "C++ Interface:\n"
    "output(const NurbsSurfaceEvaluator this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NurbsSurfaceEvaluator::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NurbsSurfaceEvaluator_output_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void)
 *******************************************************************/
int  Dtool_Init_NurbsSurfaceEvaluator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NurbsSurfaceEvaluator", key_word_list))
        {
            NurbsSurfaceEvaluator *return_value = new NurbsSurfaceEvaluator();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NurbsSurfaceEvaluator,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NurbsSurfaceEvaluator()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NurbsSurfaceEvaluator_get_u_knots(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumUKnots", "getUKnot");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NurbsSurfaceEvaluator_get_v_knots(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumVKnots", "getVKnot");
}
inline void  * Dtool_UpcastInterface_NurbsSurfaceEvaluator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NurbsSurfaceEvaluator)
    {
        printf("NurbsSurfaceEvaluator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NurbsSurfaceEvaluator * local_this = (NurbsSurfaceEvaluator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NurbsSurfaceEvaluator)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NurbsSurfaceEvaluator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NurbsSurfaceEvaluator)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NurbsSurfaceEvaluator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. RopeNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_curve_217(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"curve", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCurve", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCurve", &param1));
            if(!PyErr_Occurred())
            {
                NurbsCurveEvaluator *param1_this = (NurbsCurveEvaluator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NurbsCurveEvaluator, 1, "RopeNode.setCurve", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_curve(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RopeNode.setCurve() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCurve(non-const RopeNode this, non-const NurbsCurveEvaluator curve)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_curve_217_comment =
    "C++ Interface:\n"
    "setCurve(non-const RopeNode this, non-const NurbsCurveEvaluator curve)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_curve\n"
    "//       Access: Published\n"
    "//  Description: Sets the particular curve represented by the\n"
    "//               RopeNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_curve_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_curve_218(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurve", key_word_list));
        else
            (PyArg_Parse(args, ":getCurve"));
        if(!PyErr_Occurred())
        {
            NurbsCurveEvaluator *return_value = ((const RopeNode*)local_this)->get_curve();
            if (return_value != (NurbsCurveEvaluator *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NurbsCurveEvaluator,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurve(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_curve_218_comment =
    "C++ Interface:\n"
    "getCurve(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_curve\n"
    "//       Access: Published\n"
    "//  Description: Returns the curve represented by the RopeNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_curve_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_render_mode_219(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
        int param1;
        static char * key_word_list[] = {(char *)"render_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRenderMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRenderMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_render_mode((RopeNode::RenderMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setRenderMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRenderMode(non-const RopeNode this, int render_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_render_mode_219_comment =
    "C++ Interface:\n"
    "setRenderMode(non-const RopeNode this, int render_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_render_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies the method used to render the rope.  The\n"
    "//               simplest is RM_thread, which just draws a one-pixel\n"
    "//               line segment.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_render_mode_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_render_mode_220(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRenderMode", key_word_list));
        else
            (PyArg_Parse(args, ":getRenderMode"));
        if(!PyErr_Occurred())
        {
            RopeNode::RenderMode return_value = ((const RopeNode*)local_this)->get_render_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderMode(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_render_mode_220_comment =
    "C++ Interface:\n"
    "getRenderMode(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_render_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the method used to render the rope.  See\n"
    "//               set_render_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_render_mode_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_uv_mode_221(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
        int param1;
        static char * key_word_list[] = {(char *)"uv_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setUvMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setUvMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_uv_mode((RopeNode::UVMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setUvMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUvMode(non-const RopeNode this, int uv_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_uv_mode_221_comment =
    "C++ Interface:\n"
    "setUvMode(non-const RopeNode this, int uv_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_uv_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies the algorithm to use to generate UV's for\n"
    "//               the rope.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_uv_mode_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_uv_mode_222(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUvMode", key_word_list));
        else
            (PyArg_Parse(args, ":getUvMode"));
        if(!PyErr_Occurred())
        {
            RopeNode::UVMode return_value = ((const RopeNode*)local_this)->get_uv_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUvMode(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_uv_mode_222_comment =
    "C++ Interface:\n"
    "getUvMode(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_uv_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the algorithm to use to generate UV's for the\n"
    "//               rope.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_uv_mode_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_uv_direction(bool u_dominant)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_uv_direction_223(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_uv_direction(bool u_dominant)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"u_dominant", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUvDirection", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUvDirection", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_uv_direction((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setUvDirection() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUvDirection(non-const RopeNode this, bool u_dominant)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_uv_direction_223_comment =
    "C++ Interface:\n"
    "setUvDirection(non-const RopeNode this, bool u_dominant)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_uv_direction\n"
    "//       Access: Published\n"
    "//  Description: Specify true to vary the U coordinate down the length\n"
    "//               of the rope, or false to vary the V coordinate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_uv_direction_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RopeNode::get_uv_direction(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_uv_direction_224(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RopeNode::get_uv_direction(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUvDirection", key_word_list));
        else
            (PyArg_Parse(args, ":getUvDirection"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RopeNode*)local_this)->get_uv_direction();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUvDirection(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_uv_direction_224_comment =
    "C++ Interface:\n"
    "getUvDirection(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_uv_direction\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the rope runs down the U coordinate\n"
    "//               of the texture, or false if it runs down the V\n"
    "//               coordinate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_uv_direction_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_uv_scale(float scale)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_uv_scale_225(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_uv_scale(float scale)
        double param1;
        static char * key_word_list[] = {(char *)"scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setUvScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setUvScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_uv_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setUvScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUvScale(non-const RopeNode this, float scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_uv_scale_225_comment =
    "C++ Interface:\n"
    "setUvScale(non-const RopeNode this, float scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_uv_scale\n"
    "//       Access: Published\n"
    "//  Description: Specifies an additional scaling factor to apply to\n"
    "//               generated UV's along the rope.  This scale factor is\n"
    "//               applied in whichever direction is along the rope, as\n"
    "//               specified by set_uv_direction().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_uv_scale_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RopeNode::get_uv_scale(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_uv_scale_226(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float RopeNode::get_uv_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUvScale", key_word_list));
        else
            (PyArg_Parse(args, ":getUvScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const RopeNode*)local_this)->get_uv_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUvScale(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_uv_scale_226_comment =
    "C++ Interface:\n"
    "getUvScale(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_uv_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the scaling factor to apply to generated UV's\n"
    "//               for the rope.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_uv_scale_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_normal_mode_227(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
        int param1;
        static char * key_word_list[] = {(char *)"normal_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNormalMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNormalMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_normal_mode((RopeNode::NormalMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setNormalMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNormalMode(non-const RopeNode this, int normal_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_normal_mode_227_comment =
    "C++ Interface:\n"
    "setNormalMode(non-const RopeNode this, int normal_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_normal_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies the kind of normals to generate for the\n"
    "//               rope.  This is only applicable when the RenderMode is\n"
    "//               set to RM_tube; in the other render modes, normals\n"
    "//               are never generated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_normal_mode_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_normal_mode_228(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormalMode", key_word_list));
        else
            (PyArg_Parse(args, ":getNormalMode"));
        if(!PyErr_Occurred())
        {
            RopeNode::NormalMode return_value = ((const RopeNode*)local_this)->get_normal_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormalMode(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_normal_mode_228_comment =
    "C++ Interface:\n"
    "getNormalMode(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_normal_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the kind of normals to generate for the rope.\n"
    "//               This is only applicable when the RenderMode is set to\n"
    "//               RM_tube.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_normal_mode_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_tube_up(LVector3f const &tube_up)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_tube_up_229(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void RopeNode::set_tube_up(LVector3f const &tube_up)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tube_up", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTubeUp", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTubeUp", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "RopeNode.setTubeUp", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_tube_up(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RopeNode.setTubeUp() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTubeUp(non-const RopeNode this, const Vec3 tube_up)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_tube_up_229_comment =
    "C++ Interface:\n"
    "setTubeUp(non-const RopeNode this, const Vec3 tube_up)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_tube_up\n"
    "//       Access: Published\n"
    "//  Description: Specifies a normal vector, generally perpendicular to\n"
    "//               the main axis of the starting point of the curve,\n"
    "//               that controls the \"top\" of the curve, when RenderMode\n"
    "//               is RM_tube.  This is used to orient the vertices that\n"
    "//               make up the tube.  If this vector is too nearly\n"
    "//               parallel with the starting direction of the curve,\n"
    "//               there may be a tendency for the whole tube to\n"
    "//               gimble-lock around its primary axis.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_tube_up_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &RopeNode::get_tube_up(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_tube_up_230(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &RopeNode::get_tube_up(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTubeUp", key_word_list));
        else
            (PyArg_Parse(args, ":getTubeUp"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const RopeNode*)local_this)->get_tube_up());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTubeUp(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_tube_up_230_comment =
    "C++ Interface:\n"
    "getTubeUp(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_tube_up\n"
    "//       Access: Published\n"
    "//  Description: Returns the normal vector used to control the \"top\"\n"
    "//               of the curve, when RenderMode is RM_tube.  See\n"
    "//               set_tube_up().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_tube_up_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_use_vertex_color(bool flag)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_use_vertex_color_231(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_use_vertex_color(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUseVertexColor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUseVertexColor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_use_vertex_color((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setUseVertexColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUseVertexColor(non-const RopeNode this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_use_vertex_color_231_comment =
    "C++ Interface:\n"
    "setUseVertexColor(non-const RopeNode this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_use_vertex_color\n"
    "//       Access: Published\n"
    "//  Description: Sets the \"use vertex color\" flag.  When this is true,\n"
    "//               the R, G, B, A vertex color is assumed to be stored\n"
    "//               as the dimensions n + 0, n + 1, n + 2, n + 3,\n"
    "//               respectively, of the extended vertex values, where n\n"
    "//               is the value returned by\n"
    "//               get_vertex_color_dimension().  Use\n"
    "//               NurbsCurveEvaluator::set_extended_vertex() to set\n"
    "//               these values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_use_vertex_color_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RopeNode::get_use_vertex_color(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_use_vertex_color_232(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RopeNode::get_use_vertex_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUseVertexColor", key_word_list));
        else
            (PyArg_Parse(args, ":getUseVertexColor"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RopeNode*)local_this)->get_use_vertex_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUseVertexColor(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_use_vertex_color_232_comment =
    "C++ Interface:\n"
    "getUseVertexColor(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_use_vertex_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"use vertex color\" flag.  See\n"
    "//               set_use_vertex_color().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_use_vertex_color_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int RopeNode::get_vertex_color_dimension(void)
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_vertex_color_dimension_233(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int RopeNode::get_vertex_color_dimension(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getVertexColorDimension", key_word_list))
        {
            int return_value = RopeNode::get_vertex_color_dimension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertexColorDimension()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_vertex_color_dimension_233_comment =
    "C++ Interface:\n"
    "getVertexColorDimension()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_vertex_color_dimension\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the numeric extended dimension in which the\n"
    "//               color components should be found.  See\n"
    "//               NurbsCurveEvaluator::set_extended_vertex().\n"
    "//\n"
    "//               The color components will be expected at (n, n + 1, n\n"
    "//               + 2, n + 3).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_vertex_color_dimension_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_num_subdiv(int num_subdiv)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_num_subdiv_234(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_num_subdiv(int num_subdiv)
        int param1;
        static char * key_word_list[] = {(char *)"num_subdiv", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumSubdiv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumSubdiv", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_subdiv((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setNumSubdiv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumSubdiv(non-const RopeNode this, int num_subdiv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_num_subdiv_234_comment =
    "C++ Interface:\n"
    "setNumSubdiv(non-const RopeNode this, int num_subdiv)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_num_subdiv\n"
    "//       Access: Published\n"
    "//  Description: Specifies the number of subdivisions per cubic\n"
    "//               segment (that is, per unique knot value) to draw in a\n"
    "//               fixed uniform tesselation of the curve.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_num_subdiv_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int RopeNode::get_num_subdiv(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_num_subdiv_235(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int RopeNode::get_num_subdiv(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSubdiv", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSubdiv"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const RopeNode*)local_this)->get_num_subdiv();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSubdiv(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_num_subdiv_235_comment =
    "C++ Interface:\n"
    "getNumSubdiv(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_subdiv\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of subdivisions per cubic segment\n"
    "//               to draw.  See set_num_subdiv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_num_subdiv_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_num_slices(int num_slices)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_num_slices_236(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_num_slices(int num_slices)
        int param1;
        static char * key_word_list[] = {(char *)"num_slices", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumSlices", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumSlices", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_slices((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setNumSlices() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumSlices(non-const RopeNode this, int num_slices)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_num_slices_236_comment =
    "C++ Interface:\n"
    "setNumSlices(non-const RopeNode this, int num_slices)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_num_slices\n"
    "//       Access: Published\n"
    "//  Description: Specifies the number of radial subdivisions to make\n"
    "//               if RenderMode is RM_tube.  It is ignored in the other\n"
    "//               render modes.\n"
    "//\n"
    "//               Increasing this number increases the roundness of a\n"
    "//               cross-section of the tube.  The minimum value for a\n"
    "//               dimensional tube is 3; setting it to 2 will get you a\n"
    "//               thin piece of tape (which is similar to RM_billboard,\n"
    "//               except it won't rotate to face the camera).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_num_slices_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int RopeNode::get_num_slices(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_num_slices_237(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int RopeNode::get_num_slices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSlices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSlices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const RopeNode*)local_this)->get_num_slices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSlices(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_num_slices_237_comment =
    "C++ Interface:\n"
    "getNumSlices(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_slices\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of radial subdivisions to make if\n"
    "//               RenderMode is RM_tube.  It is ignored in the other\n"
    "//               render modes.  See set_num_slices().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_num_slices_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_use_vertex_thickness(bool flag)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_use_vertex_thickness_238(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_use_vertex_thickness(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUseVertexThickness", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUseVertexThickness", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_use_vertex_thickness((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setUseVertexThickness() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUseVertexThickness(non-const RopeNode this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_use_vertex_thickness_238_comment =
    "C++ Interface:\n"
    "setUseVertexThickness(non-const RopeNode this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_use_vertex_thickness\n"
    "//       Access: Published\n"
    "//  Description: Sets the \"use vertex thickness\" flag.  When this is true,\n"
    "//               the vertex thickness is assumed to be stored as the\n"
    "//               dimension get_vertex_thickness_dimension(), of the\n"
    "//               extended vertex values.  Use\n"
    "//               NurbsCurveEvaluator::set_extended_vertex() to set\n"
    "//               these values.\n"
    "//\n"
    "//               In this mode, the overall thickness is also applied\n"
    "//               as a scale to the vertex thickness.  Not all render\n"
    "//               modes support vertex thickness.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_use_vertex_thickness_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RopeNode::get_use_vertex_thickness(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_use_vertex_thickness_239(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RopeNode::get_use_vertex_thickness(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUseVertexThickness", key_word_list));
        else
            (PyArg_Parse(args, ":getUseVertexThickness"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RopeNode*)local_this)->get_use_vertex_thickness();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUseVertexThickness(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_use_vertex_thickness_239_comment =
    "C++ Interface:\n"
    "getUseVertexThickness(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_use_vertex_thickness\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"use vertex thickness\" flag.  See\n"
    "//               set_use_vertex_thickness().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_use_vertex_thickness_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int RopeNode::get_vertex_thickness_dimension(void)
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_vertex_thickness_dimension_240(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int RopeNode::get_vertex_thickness_dimension(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getVertexThicknessDimension", key_word_list))
        {
            int return_value = RopeNode::get_vertex_thickness_dimension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertexThicknessDimension()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_vertex_thickness_dimension_240_comment =
    "C++ Interface:\n"
    "getVertexThicknessDimension()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_vertex_thickness_dimension\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the numeric extended dimension in which the\n"
    "//               thickness component should be found.  See\n"
    "//               NurbsCurveEvaluator::set_extended_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_vertex_thickness_dimension_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_thickness(float thickness)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_thickness_241(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::set_thickness(float thickness)
        double param1;
        static char * key_word_list[] = {(char *)"thickness", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setThickness", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setThickness", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_thickness((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.setThickness() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThickness(non-const RopeNode this, float thickness)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_thickness_241_comment =
    "C++ Interface:\n"
    "setThickness(non-const RopeNode this, float thickness)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_thickness\n"
    "//       Access: Published\n"
    "//  Description: Specifies the thickness of the rope, in pixels or in\n"
    "//               spatial units, depending on the render mode.  See\n"
    "//               set_render_mode().\n"
    "//\n"
    "//               The thickness may also be specified on a per-vertex\n"
    "//               basis.  See set_use_vertex_thickness().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_thickness_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RopeNode::get_thickness(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_thickness_242(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float RopeNode::get_thickness(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThickness", key_word_list));
        else
            (PyArg_Parse(args, ":getThickness"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const RopeNode*)local_this)->get_thickness();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThickness(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_thickness_242_comment =
    "C++ Interface:\n"
    "getThickness(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_thickness\n"
    "//       Access: Published\n"
    "//  Description: Returns the thickness of the rope.  See\n"
    "//               set_thickness().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_thickness_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::set_matrix(LMatrix4f const &matrix)
 *******************************************************************/
static PyObject *Dtool_RopeNode_set_matrix_243(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void RopeNode::set_matrix(LMatrix4f const &matrix)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"matrix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMatrix", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMatrix", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "RopeNode.setMatrix", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_matrix(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RopeNode.setMatrix() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMatrix(non-const RopeNode this, const Mat4 matrix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_set_matrix_243_comment =
    "C++ Interface:\n"
    "setMatrix(non-const RopeNode this, const Mat4 matrix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_matrix\n"
    "//       Access: Published\n"
    "//  Description: Specifies an optional matrix which is used to\n"
    "//               transform each control vertex after it has been\n"
    "//               transformed into the RopeNode's coordinate space, but\n"
    "//               before the polygon vertices are generated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_set_matrix_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RopeNode::clear_matrix(void)
 *******************************************************************/
static PyObject *Dtool_RopeNode_clear_matrix_244(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RopeNode::clear_matrix(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearMatrix", key_word_list));
        else
            (PyArg_Parse(args, ":clearMatrix"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_matrix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RopeNode.clearMatrix() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearMatrix(non-const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_clear_matrix_244_comment =
    "C++ Interface:\n"
    "clearMatrix(non-const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: clear_matrix\n"
    "//       Access: Published\n"
    "//  Description: Resets the node's matrix to identity.  See\n"
    "//               set_matrix().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_clear_matrix_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RopeNode::has_matrix(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_has_matrix_245(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool RopeNode::has_matrix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMatrix", key_word_list));
        else
            (PyArg_Parse(args, ":hasMatrix"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const RopeNode*)local_this)->has_matrix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMatrix(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_has_matrix_245_comment =
    "C++ Interface:\n"
    "hasMatrix(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: has_matrix\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the node has a matrix set, false\n"
    "//               otherwise.  See set_matrix().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_has_matrix_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &RopeNode::get_matrix(void) const
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_matrix_246(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &RopeNode::get_matrix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMatrix", key_word_list));
        else
            (PyArg_Parse(args, ":getMatrix"));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &(((const RopeNode*)local_this)->get_matrix());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMatrix(const RopeNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_matrix_246_comment =
    "C++ Interface:\n"
    "getMatrix(const RopeNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_matrix\n"
    "//       Access: Published\n"
    "//  Description: Returns the optional matrix which is used to\n"
    "//               transform each control vertex after it has been\n"
    "//               transformed into the RopeNode's coordinate space, but\n"
    "//               before the polygon vertices are generated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_get_matrix_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void RopeNode::reset_bound(NodePath const &rel_to)
 *******************************************************************/
static PyObject *Dtool_RopeNode_reset_bound_247(PyObject *self, PyObject *args,PyObject *kwds) {
    RopeNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RopeNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void RopeNode::reset_bound(NodePath const &rel_to)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rel_to", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:resetBound", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:resetBound", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "RopeNode.resetBound", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->reset_bound(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RopeNode.resetBound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBound(non-const RopeNode this, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_reset_bound_247_comment =
    "C++ Interface:\n"
    "resetBound(non-const RopeNode this, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RopeNode::reset_bound\n"
    "//       Access: Published\n"
    "//  Description: Recomputes the bounding volume.  This is normally\n"
    "//               called automatically, but it must occasionally be\n"
    "//               called explicitly when the curve has changed\n"
    "//               properties outside of this node's knowledge.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RopeNode_reset_bound_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle RopeNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_RopeNode_get_class_type_248(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle RopeNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = RopeNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RopeNode_get_class_type_248_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_RopeNode_get_class_type_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RopeNode::RopeNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_RopeNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-RopeNode::RopeNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:RopeNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:RopeNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            RopeNode *return_value = new RopeNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_RopeNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RopeNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_RopeNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RopeNode)
    {
        printf("RopeNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RopeNode * local_this = (RopeNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RopeNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RopeNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RopeNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (RopeNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (RopeNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (RopeNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (RopeNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SheetNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface)
 *******************************************************************/
static PyObject *Dtool_SheetNode_set_surface_252(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"surface", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSurface", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSurface", &param1));
            if(!PyErr_Occurred())
            {
                NurbsSurfaceEvaluator *param1_this = (NurbsSurfaceEvaluator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NurbsSurfaceEvaluator, 1, "SheetNode.setSurface", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_surface(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SheetNode.setSurface() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSurface(non-const SheetNode this, non-const NurbsSurfaceEvaluator surface)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_set_surface_252_comment =
    "C++ Interface:\n"
    "setSurface(non-const SheetNode this, non-const NurbsSurfaceEvaluator surface)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_surface\n"
    "//       Access: Public\n"
    "//  Description: Sets the particular surface represented by the\n"
    "//               SheetNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_set_surface_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const
 *******************************************************************/
static PyObject *Dtool_SheetNode_get_surface_253(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSurface", key_word_list));
        else
            (PyArg_Parse(args, ":getSurface"));
        if(!PyErr_Occurred())
        {
            NurbsSurfaceEvaluator *return_value = ((const SheetNode*)local_this)->get_surface();
            if (return_value != (NurbsSurfaceEvaluator *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NurbsSurfaceEvaluator,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSurface(const SheetNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_get_surface_253_comment =
    "C++ Interface:\n"
    "getSurface(const SheetNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_surface\n"
    "//       Access: Public\n"
    "//  Description: Returns the surface represented by the SheetNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_get_surface_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SheetNode::set_use_vertex_color(bool flag)
 *******************************************************************/
static PyObject *Dtool_SheetNode_set_use_vertex_color_254(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SheetNode::set_use_vertex_color(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUseVertexColor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUseVertexColor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_use_vertex_color((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SheetNode.setUseVertexColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUseVertexColor(non-const SheetNode this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_set_use_vertex_color_254_comment =
    "C++ Interface:\n"
    "setUseVertexColor(non-const SheetNode this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_use_vertex_color\n"
    "//       Access: Public\n"
    "//  Description: Sets the \"use vertex color\" flag.  When this is true,\n"
    "//               the R, G, B, A vertex color is assumed to be stored\n"
    "//               as the dimensions 0, 1, 2, 3, respectively, of the\n"
    "//               extended vertex values.  Use\n"
    "//               NurbsCurveEvaluator::set_extended_vertex() to set\n"
    "//               these values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_set_use_vertex_color_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SheetNode::get_use_vertex_color(void) const
 *******************************************************************/
static PyObject *Dtool_SheetNode_get_use_vertex_color_255(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SheetNode::get_use_vertex_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUseVertexColor", key_word_list));
        else
            (PyArg_Parse(args, ":getUseVertexColor"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SheetNode*)local_this)->get_use_vertex_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUseVertexColor(const SheetNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_get_use_vertex_color_255_comment =
    "C++ Interface:\n"
    "getUseVertexColor(const SheetNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_use_vertex_color\n"
    "//       Access: Public\n"
    "//  Description: Returns the \"use vertex color\" flag.  See\n"
    "//               set_use_vertex_color().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_get_use_vertex_color_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SheetNode::set_num_u_subdiv(int num_u_subdiv)
 *******************************************************************/
static PyObject *Dtool_SheetNode_set_num_u_subdiv_256(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SheetNode::set_num_u_subdiv(int num_u_subdiv)
        int param1;
        static char * key_word_list[] = {(char *)"num_u_subdiv", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumUSubdiv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumUSubdiv", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_u_subdiv((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SheetNode.setNumUSubdiv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumUSubdiv(non-const SheetNode this, int num_u_subdiv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_set_num_u_subdiv_256_comment =
    "C++ Interface:\n"
    "setNumUSubdiv(non-const SheetNode this, int num_u_subdiv)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_num_u_subdiv\n"
    "//       Access: Public\n"
    "//  Description: Specifies the number of subdivisions per cubic\n"
    "//               segment (that is, per unique knot value) to draw in a\n"
    "//               fixed uniform tesselation of the surface in the U\n"
    "//               direction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_set_num_u_subdiv_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SheetNode::get_num_u_subdiv(void) const
 *******************************************************************/
static PyObject *Dtool_SheetNode_get_num_u_subdiv_257(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SheetNode::get_num_u_subdiv(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUSubdiv", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUSubdiv"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SheetNode*)local_this)->get_num_u_subdiv();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUSubdiv(const SheetNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_get_num_u_subdiv_257_comment =
    "C++ Interface:\n"
    "getNumUSubdiv(const SheetNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_u_subdiv\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of subdivisions per cubic segment\n"
    "//               to draw in the U direction.  See set_num_u_subdiv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_get_num_u_subdiv_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SheetNode::set_num_v_subdiv(int num_v_subdiv)
 *******************************************************************/
static PyObject *Dtool_SheetNode_set_num_v_subdiv_258(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SheetNode::set_num_v_subdiv(int num_v_subdiv)
        int param1;
        static char * key_word_list[] = {(char *)"num_v_subdiv", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumVSubdiv", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumVSubdiv", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_v_subdiv((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SheetNode.setNumVSubdiv() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumVSubdiv(non-const SheetNode this, int num_v_subdiv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_set_num_v_subdiv_258_comment =
    "C++ Interface:\n"
    "setNumVSubdiv(non-const SheetNode this, int num_v_subdiv)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: set_num_v_subdiv\n"
    "//       Access: Public\n"
    "//  Description: Specifies the number of subdivisions per cubic\n"
    "//               segment (that is, per unique knot value) to draw in a\n"
    "//               fixed uniform tesselation of the surface in the V\n"
    "//               direction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_set_num_v_subdiv_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SheetNode::get_num_v_subdiv(void) const
 *******************************************************************/
static PyObject *Dtool_SheetNode_get_num_v_subdiv_259(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SheetNode::get_num_v_subdiv(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVSubdiv", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVSubdiv"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SheetNode*)local_this)->get_num_v_subdiv();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVSubdiv(const SheetNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_get_num_v_subdiv_259_comment =
    "C++ Interface:\n"
    "getNumVSubdiv(const SheetNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_v_subdiv\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of subdivisions per cubic segment\n"
    "//               to draw in the V direction.  See set_num_v_subdiv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_get_num_v_subdiv_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SheetNode::reset_bound(NodePath const &rel_to)
 *******************************************************************/
static PyObject *Dtool_SheetNode_reset_bound_260(PyObject *self, PyObject *args,PyObject *kwds) {
    SheetNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SheetNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SheetNode::reset_bound(NodePath const &rel_to)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rel_to", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:resetBound", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:resetBound", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SheetNode.resetBound", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->reset_bound(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SheetNode.resetBound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBound(non-const SheetNode this, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_reset_bound_260_comment =
    "C++ Interface:\n"
    "resetBound(non-const SheetNode this, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SheetNode::reset_bound\n"
    "//       Access: Published\n"
    "//  Description: Recomputes the bounding volume.  This is normally\n"
    "//               called automatically, but it must occasionally be\n"
    "//               called explicitly when the surface has changed\n"
    "//               properties outside of this node's knowledge.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SheetNode_reset_bound_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SheetNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SheetNode_get_class_type_261(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SheetNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SheetNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SheetNode_get_class_type_261_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SheetNode_get_class_type_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SheetNode::SheetNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_SheetNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-SheetNode::SheetNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SheetNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:SheetNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            SheetNode *return_value = new SheetNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_SheetNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SheetNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SheetNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SheetNode)
    {
        printf("SheetNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SheetNode * local_this = (SheetNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SheetNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SheetNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SheetNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (SheetNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (SheetNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SheetNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (SheetNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ParametricCurve | ParametricCurve
//********************************************************************
PyMethodDef Dtool_Methods_ParametricCurve[]= {
  { "isValid",(PyCFunction ) &Dtool_ParametricCurve_is_valid_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_is_valid_3_comment},
  { "getMaxT",(PyCFunction ) &Dtool_ParametricCurve_get_max_t_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_max_t_4_comment},
  { "setCurveType",(PyCFunction ) &Dtool_ParametricCurve_set_curve_type_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_set_curve_type_5_comment},
  { "getCurveType",(PyCFunction ) &Dtool_ParametricCurve_get_curve_type_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_curve_type_6_comment},
  { "setNumDimensions",(PyCFunction ) &Dtool_ParametricCurve_set_num_dimensions_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_set_num_dimensions_7_comment},
  { "getNumDimensions",(PyCFunction ) &Dtool_ParametricCurve_get_num_dimensions_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_num_dimensions_8_comment},
  { "calcLength",(PyCFunction ) &Dtool_ParametricCurve_calc_length_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_calc_length_9_comment},
  { "findLength",(PyCFunction ) &Dtool_ParametricCurve_find_length_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_find_length_10_comment},
  { "getPoint",(PyCFunction ) &Dtool_ParametricCurve_get_point_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_point_11_comment},
  { "getTangent",(PyCFunction ) &Dtool_ParametricCurve_get_tangent_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_tangent_12_comment},
  { "getPt",(PyCFunction ) &Dtool_ParametricCurve_get_pt_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_pt_13_comment},
  { "get2ndtangent",(PyCFunction ) &Dtool_ParametricCurve_get_2ndtangent_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_2ndtangent_14_comment},
  { "adjustPoint",(PyCFunction ) &Dtool_ParametricCurve_adjust_point_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_adjust_point_15_comment},
  { "adjustTangent",(PyCFunction ) &Dtool_ParametricCurve_adjust_tangent_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_adjust_tangent_16_comment},
  { "adjustPt",(PyCFunction ) &Dtool_ParametricCurve_adjust_pt_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_adjust_pt_17_comment},
  { "recompute",(PyCFunction ) &Dtool_ParametricCurve_recompute_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_recompute_18_comment},
  { "stitch",(PyCFunction ) &Dtool_ParametricCurve_stitch_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_stitch_19_comment},
  { "writeEgg",(PyCFunction ) &Dtool_ParametricCurve_write_egg_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_write_egg_20_comment},
  { "getClassType",(PyCFunction ) &Dtool_ParametricCurve_get_class_type_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurve_get_class_type_21_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ParametricCurve(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ParametricCurve.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ParametricCurve\n"
          "// Description : A virtual base class for parametric curves.\n"
          "//               This encapsulates all curves in 3-d space defined\n"
          "//               for a single parameter t in the range [0,get_max_t()].\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_ParametricCurve.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_ParametricCurve.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ParametricCurve.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ParametricCurve.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ParametricCurve.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ParametricCurve)");
             printf(" Error In PyType_ReadyParametricCurve");
             return;
        }
        Py_INCREF(&Dtool_ParametricCurve.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ParametricCurve.As_PyTypeObject().tp_dict,"ParametricCurve",&Dtool_ParametricCurve.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ParametricCurve.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ParametricCurve[18],&Dtool_ParametricCurve.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ParametricCurve,ParametricCurve::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ParametricCurve.As_PyTypeObject());
        PyModule_AddObject(module, "ParametricCurve",(PyObject *)&Dtool_ParametricCurve.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CubicCurveseg | CubicCurveseg
//********************************************************************
PyMethodDef Dtool_Methods_CubicCurveseg[]= {
  { "getClassType",(PyCFunction ) &Dtool_CubicCurveseg_get_class_type_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CubicCurveseg_get_class_type_23_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CubicCurveseg(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CubicCurveseg.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CubicCurveseg\n"
          "// Description : A CubicCurveseg is any curve that can be completely\n"
          "//               described by four 4-valued basis vectors, one for\n"
          "//               each dimension in three-space, and one for the\n"
          "//               homogeneous coordinate.  This includes Beziers,\n"
          "//               Hermites, and NURBS.\n"
          "//\n"
          "//               This class encapsulates a single curve segment of the\n"
          "//               cubic curve.  Normally, when we think of Bezier and\n"
          "//               Hermite curves, we think of a piecewise collection of\n"
          "//               such segments.\n"
          "//\n"
          "//               Although this class includes methods such as\n"
          "//               hermite_basis() and nurbs_basis(), to generate a\n"
          "//               Hermite and NURBS curve segment, respectively, only\n"
          "//               the final basis vectors are stored: the product of\n"
          "//               the basis matrix of the corresponding curve type, and\n"
          "//               its geometry vectors.  This is the minimum\n"
          "//               information needed to evaluate the curve.  However,\n"
          "//               the individual CV's that were used to compute these\n"
          "//               basis vectors are not retained; this might be handled\n"
          "//               in a subclass (for instance, HermiteCurve).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ParametricCurve._Dtool_ClassInit(NULL);
        Dtool_CubicCurveseg.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ParametricCurve.As_PyTypeObject());
        Dtool_CubicCurveseg.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CubicCurveseg.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CubicCurveseg.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CubicCurveseg.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CubicCurveseg)");
             printf(" Error In PyType_ReadyCubicCurveseg");
             return;
        }
        Py_INCREF(&Dtool_CubicCurveseg.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CubicCurveseg.As_PyTypeObject().tp_dict,"CubicCurveseg",&Dtool_CubicCurveseg.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CubicCurveseg.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CubicCurveseg[0],&Dtool_CubicCurveseg.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CubicCurveseg,CubicCurveseg::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CubicCurveseg.As_PyTypeObject());
        PyModule_AddObject(module, "CubicCurveseg",(PyObject *)&Dtool_CubicCurveseg.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ParametricCurveCollection | ParametricCurveCollection
//********************************************************************
PyMethodDef Dtool_Methods_ParametricCurveCollection[]= {
  { "addCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_add_curve_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_add_curve_27_comment},
  { "addCurves",(PyCFunction ) &Dtool_ParametricCurveCollection_add_curves_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_add_curves_28_comment},
  { "removeCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_remove_curve_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_remove_curve_29_comment},
  { "hasCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_has_curve_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_has_curve_30_comment},
  { "clear",(PyCFunction ) &Dtool_ParametricCurveCollection_clear_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_clear_31_comment},
  { "clearTimewarps",(PyCFunction ) &Dtool_ParametricCurveCollection_clear_timewarps_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_clear_timewarps_32_comment},
  { "getNumCurves",(PyCFunction ) &Dtool_ParametricCurveCollection_get_num_curves_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_num_curves_33_comment},
  { "getCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_get_curve_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_curve_34_comment},
  { "getXyzCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_get_xyz_curve_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_xyz_curve_35_comment},
  { "getHprCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_get_hpr_curve_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_hpr_curve_36_comment},
  { "getDefaultCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_get_default_curve_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_default_curve_37_comment},
  { "getNumTimewarps",(PyCFunction ) &Dtool_ParametricCurveCollection_get_num_timewarps_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_num_timewarps_38_comment},
  { "getTimewarpCurve",(PyCFunction ) &Dtool_ParametricCurveCollection_get_timewarp_curve_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_timewarp_curve_39_comment},
  { "getMaxT",(PyCFunction ) &Dtool_ParametricCurveCollection_get_max_t_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_get_max_t_40_comment},
  { "makeEven",(PyCFunction ) &Dtool_ParametricCurveCollection_make_even_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_make_even_41_comment},
  { "faceForward",(PyCFunction ) &Dtool_ParametricCurveCollection_face_forward_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_face_forward_42_comment},
  { "resetMaxT",(PyCFunction ) &Dtool_ParametricCurveCollection_reset_max_t_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_reset_max_t_43_comment},
  { "evaluate",(PyCFunction ) &Dtool_ParametricCurveCollection_evaluate_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_evaluate_44_comment},
  { "evaluateT",(PyCFunction ) &Dtool_ParametricCurveCollection_evaluate_t_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_evaluate_t_45_comment},
  { "evaluateXyz",(PyCFunction ) &Dtool_ParametricCurveCollection_evaluate_xyz_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_evaluate_xyz_46_comment},
  { "evaluateHpr",(PyCFunction ) &Dtool_ParametricCurveCollection_evaluate_hpr_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_evaluate_hpr_47_comment},
  { "adjustXyz",(PyCFunction ) &Dtool_ParametricCurveCollection_adjust_xyz_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_adjust_xyz_48_comment},
  { "adjustHpr",(PyCFunction ) &Dtool_ParametricCurveCollection_adjust_hpr_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_adjust_hpr_49_comment},
  { "recompute",(PyCFunction ) &Dtool_ParametricCurveCollection_recompute_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_recompute_50_comment},
  { "stitch",(PyCFunction ) &Dtool_ParametricCurveCollection_stitch_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_stitch_51_comment},
  { "output",(PyCFunction ) &Dtool_ParametricCurveCollection_output_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_output_52_comment},
  { "write",(PyCFunction ) &Dtool_ParametricCurveCollection_write_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_write_53_comment},
  { "writeEgg",(PyCFunction ) &Dtool_ParametricCurveCollection_write_egg_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParametricCurveCollection_write_egg_54_comment},
  { "getCurves",(PyCFunction) &MakeSeq_ParametricCurveCollection_get_curves, METH_NOARGS, NULL},
  { "getTimewarpCurves",(PyCFunction) &MakeSeq_ParametricCurveCollection_get_timewarp_curves, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ParametricCurveCollection
//////////////////
static PyObject *  Dtool_Repr_ParametricCurveCollection(PyObject * self)
{
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ParametricCurveCollection
//////////////////
static PyObject *  Dtool_Str_ParametricCurveCollection(PyObject * self)
{
    ParametricCurveCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParametricCurveCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ParametricCurveCollection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ParametricCurveCollection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ParametricCurveCollection\n"
          "// Description : This is a set of zero or more ParametricCurves, which\n"
          "//               may or may not be related.  If they are related, the\n"
          "//               set should contain no more than one XYZ curve, no\n"
          "//               more than one HPR curve, and zero or more Timewarp\n"
          "//               curves, which can then be evaluated as a unit to\n"
          "//               return a single transformation matrix for a given\n"
          "//               unit of time.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ParametricCurveCollection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_ParametricCurveCollection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ParametricCurveCollection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ParametricCurveCollection.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ParametricCurveCollection.As_PyTypeObject().tp_repr = & Dtool_Repr_ParametricCurveCollection;
        // __str__
        Dtool_ParametricCurveCollection.As_PyTypeObject().tp_str = & Dtool_Str_ParametricCurveCollection;
        if(PyType_Ready(&Dtool_ParametricCurveCollection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ParametricCurveCollection)");
             printf(" Error In PyType_ReadyParametricCurveCollection");
             return;
        }
        Py_INCREF(&Dtool_ParametricCurveCollection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ParametricCurveCollection.As_PyTypeObject().tp_dict,"ParametricCurveCollection",&Dtool_ParametricCurveCollection.As_PyObject());
        RegisterRuntimeClass(&Dtool_ParametricCurveCollection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ParametricCurveCollection.As_PyTypeObject());
        PyModule_AddObject(module, "ParametricCurveCollection",(PyObject *)&Dtool_ParametricCurveCollection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CurveFitter | CurveFitter
//********************************************************************
PyMethodDef Dtool_Methods_CurveFitter[]= {
  { "reset",(PyCFunction ) &Dtool_CurveFitter_reset_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_reset_58_comment},
  { "addXyz",(PyCFunction ) &Dtool_CurveFitter_add_xyz_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_add_xyz_59_comment},
  { "addHpr",(PyCFunction ) &Dtool_CurveFitter_add_hpr_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_add_hpr_60_comment},
  { "addXyzHpr",(PyCFunction ) &Dtool_CurveFitter_add_xyz_hpr_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_add_xyz_hpr_61_comment},
  { "getNumSamples",(PyCFunction ) &Dtool_CurveFitter_get_num_samples_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_get_num_samples_62_comment},
  { "getSampleT",(PyCFunction ) &Dtool_CurveFitter_get_sample_t_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_get_sample_t_63_comment},
  { "getSampleXyz",(PyCFunction ) &Dtool_CurveFitter_get_sample_xyz_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_get_sample_xyz_64_comment},
  { "getSampleHpr",(PyCFunction ) &Dtool_CurveFitter_get_sample_hpr_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_get_sample_hpr_65_comment},
  { "getSampleTangent",(PyCFunction ) &Dtool_CurveFitter_get_sample_tangent_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_get_sample_tangent_66_comment},
  { "removeSamples",(PyCFunction ) &Dtool_CurveFitter_remove_samples_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_remove_samples_67_comment},
  { "sample",(PyCFunction ) &Dtool_CurveFitter_sample_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_sample_68_comment},
  { "wrapHpr",(PyCFunction ) &Dtool_CurveFitter_wrap_hpr_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_wrap_hpr_69_comment},
  { "sortPoints",(PyCFunction ) &Dtool_CurveFitter_sort_points_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_sort_points_70_comment},
  { "desample",(PyCFunction ) &Dtool_CurveFitter_desample_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_desample_71_comment},
  { "computeTangents",(PyCFunction ) &Dtool_CurveFitter_compute_tangents_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_compute_tangents_72_comment},
  { "makeHermite",(PyCFunction ) &Dtool_CurveFitter_make_hermite_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_make_hermite_73_comment},
  { "makeNurbs",(PyCFunction ) &Dtool_CurveFitter_make_nurbs_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_make_nurbs_74_comment},
  { "output",(PyCFunction ) &Dtool_CurveFitter_output_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_output_75_comment},
  { "write",(PyCFunction ) &Dtool_CurveFitter_write_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_write_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_CurveFitter_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CurveFitter_get_class_type_77_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CurveFitter
//////////////////
static PyObject *  Dtool_Repr_CurveFitter(PyObject * self)
{
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CurveFitter
//////////////////
static PyObject *  Dtool_Str_CurveFitter(PyObject * self)
{
    CurveFitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CurveFitter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CurveFitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CurveFitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CurveFitter\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_CurveFitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_CurveFitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CurveFitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CurveFitter.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CurveFitter.As_PyTypeObject().tp_repr = & Dtool_Repr_CurveFitter;
        // __str__
        Dtool_CurveFitter.As_PyTypeObject().tp_str = & Dtool_Str_CurveFitter;
        if(PyType_Ready(&Dtool_CurveFitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CurveFitter)");
             printf(" Error In PyType_ReadyCurveFitter");
             return;
        }
        Py_INCREF(&Dtool_CurveFitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CurveFitter.As_PyTypeObject().tp_dict,"CurveFitter",&Dtool_CurveFitter.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CurveFitter.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CurveFitter[19],&Dtool_CurveFitter.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CurveFitter,CurveFitter::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CurveFitter.As_PyTypeObject());
        PyModule_AddObject(module, "CurveFitter",(PyObject *)&Dtool_CurveFitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PiecewiseCurve | PiecewiseCurve
//********************************************************************
PyMethodDef Dtool_Methods_PiecewiseCurve[]= {
  { "getClassType",(PyCFunction ) &Dtool_PiecewiseCurve_get_class_type_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PiecewiseCurve_get_class_type_80_comment},
  { "downcastToNurbsCurve",(PyCFunction ) &Dtool_PiecewiseCurve_downcast_to_NurbsCurve_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PiecewiseCurve_downcast_to_NurbsCurve_124_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PiecewiseCurve(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PiecewiseCurve.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PiecewiseCurve\n"
          "// Description : A PiecewiseCurve is a curve made up of several curve\n"
          "//               segments, connected in a head-to-tail fashion.  The\n"
          "//               length of each curve segment in parametric space is\n"
          "//               definable.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ParametricCurve._Dtool_ClassInit(NULL);
        Dtool_PiecewiseCurve.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ParametricCurve.As_PyTypeObject());
        Dtool_PiecewiseCurve.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PiecewiseCurve.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PiecewiseCurve.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PiecewiseCurve.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PiecewiseCurve)");
             printf(" Error In PyType_ReadyPiecewiseCurve");
             return;
        }
        Py_INCREF(&Dtool_PiecewiseCurve.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PiecewiseCurve.As_PyTypeObject().tp_dict,"PiecewiseCurve",&Dtool_PiecewiseCurve.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PiecewiseCurve.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PiecewiseCurve[0],&Dtool_PiecewiseCurve.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PiecewiseCurve,PiecewiseCurve::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PiecewiseCurve.As_PyTypeObject());
        PyModule_AddObject(module, "PiecewiseCurve",(PyObject *)&Dtool_PiecewiseCurve.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HermiteCurve | HermiteCurve
//********************************************************************
PyMethodDef Dtool_Methods_HermiteCurve[]= {
  { "getNumCvs",(PyCFunction ) &Dtool_HermiteCurve_get_num_cvs_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_num_cvs_83_comment},
  { "insertCv",(PyCFunction ) &Dtool_HermiteCurve_insert_cv_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_insert_cv_84_comment},
  { "appendCv",(PyCFunction ) &Dtool_HermiteCurve_append_cv_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_append_cv_85_comment},
  { "removeCv",(PyCFunction ) &Dtool_HermiteCurve_remove_cv_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_remove_cv_86_comment},
  { "removeAllCvs",(PyCFunction ) &Dtool_HermiteCurve_remove_all_cvs_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_remove_all_cvs_87_comment},
  { "setCvType",(PyCFunction ) &Dtool_HermiteCurve_set_cv_type_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_set_cv_type_88_comment},
  { "setCvPoint",(PyCFunction ) &Dtool_HermiteCurve_set_cv_point_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_set_cv_point_89_comment},
  { "setCvIn",(PyCFunction ) &Dtool_HermiteCurve_set_cv_in_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_set_cv_in_90_comment},
  { "setCvOut",(PyCFunction ) &Dtool_HermiteCurve_set_cv_out_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_set_cv_out_91_comment},
  { "setCvTstart",(PyCFunction ) &Dtool_HermiteCurve_set_cv_tstart_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_set_cv_tstart_92_comment},
  { "setCvName",(PyCFunction ) &Dtool_HermiteCurve_set_cv_name_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_set_cv_name_93_comment},
  { "getCvType",(PyCFunction ) &Dtool_HermiteCurve_get_cv_type_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_cv_type_94_comment},
  { "getCvPoint",(PyCFunction ) &Dtool_HermiteCurve_get_cv_point_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_cv_point_95_comment},
  { "getCvIn",(PyCFunction ) &Dtool_HermiteCurve_get_cv_in_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_cv_in_96_comment},
  { "getCvOut",(PyCFunction ) &Dtool_HermiteCurve_get_cv_out_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_cv_out_97_comment},
  { "getCvTstart",(PyCFunction ) &Dtool_HermiteCurve_get_cv_tstart_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_cv_tstart_98_comment},
  { "getCvName",(PyCFunction ) &Dtool_HermiteCurve_get_cv_name_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_cv_name_99_comment},
  { "writeCv",(PyCFunction ) &Dtool_HermiteCurve_write_cv_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_write_cv_100_comment},
  { "getClassType",(PyCFunction ) &Dtool_HermiteCurve_get_class_type_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HermiteCurve_get_class_type_101_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_HermiteCurve(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HermiteCurve.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HermiteCurve\n"
          "// Description : A parametric curve defined by a sequence of control\n"
          "//               vertices, each with an in and out tangent.\n"
          "//\n"
          "//               This class is actually implemented as a\n"
          "//               PiecewiseCurve made up of several CubicCurvesegs,\n"
          "//               each of which is created using the hermite_basis()\n"
          "//               method.  The HermiteCurve class itself keeps its own\n"
          "//               list of the CV's that are used to define the curve\n"
          "//               (since the CubicCurveseg class doesn't retain these).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PiecewiseCurve._Dtool_ClassInit(NULL);
        Dtool_HermiteCurve.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PiecewiseCurve.As_PyTypeObject());
        Dtool_HermiteCurve.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HermiteCurve.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HermiteCurve.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_HermiteCurve.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HermiteCurve)");
             printf(" Error In PyType_ReadyHermiteCurve");
             return;
        }
        Py_INCREF(&Dtool_HermiteCurve.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HermiteCurve.As_PyTypeObject().tp_dict,"HermiteCurve",&Dtool_HermiteCurve.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_HermiteCurve.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_HermiteCurve[18],&Dtool_HermiteCurve.As_PyObject()));
        RegisterRuntimeClass(&Dtool_HermiteCurve,HermiteCurve::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HermiteCurve.As_PyTypeObject());
        PyModule_AddObject(module, "HermiteCurve",(PyObject *)&Dtool_HermiteCurve.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NurbsCurveInterface | NurbsCurveInterface
//********************************************************************
PyMethodDef Dtool_Methods_NurbsCurveInterface[]= {
  { "setOrder",(PyCFunction ) &Dtool_NurbsCurveInterface_set_order_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_set_order_104_comment},
  { "getOrder",(PyCFunction ) &Dtool_NurbsCurveInterface_get_order_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_order_105_comment},
  { "getNumCvs",(PyCFunction ) &Dtool_NurbsCurveInterface_get_num_cvs_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_num_cvs_106_comment},
  { "getNumKnots",(PyCFunction ) &Dtool_NurbsCurveInterface_get_num_knots_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_num_knots_107_comment},
  { "insertCv",(PyCFunction ) &Dtool_NurbsCurveInterface_insert_cv_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_insert_cv_108_comment},
  { "appendCv",(PyCFunction ) &Dtool_NurbsCurveInterface_append_cv_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_append_cv_109_comment},
  { "removeCv",(PyCFunction ) &Dtool_NurbsCurveInterface_remove_cv_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_remove_cv_110_comment},
  { "removeAllCvs",(PyCFunction ) &Dtool_NurbsCurveInterface_remove_all_cvs_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_remove_all_cvs_111_comment},
  { "setCvPoint",(PyCFunction ) &Dtool_NurbsCurveInterface_set_cv_point_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_set_cv_point_112_comment},
  { "getCvPoint",(PyCFunction ) &Dtool_NurbsCurveInterface_get_cv_point_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_cv_point_113_comment},
  { "setCvWeight",(PyCFunction ) &Dtool_NurbsCurveInterface_set_cv_weight_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_set_cv_weight_114_comment},
  { "getCvWeight",(PyCFunction ) &Dtool_NurbsCurveInterface_get_cv_weight_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_cv_weight_115_comment},
  { "setCv",(PyCFunction ) &Dtool_NurbsCurveInterface_set_cv_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_set_cv_116_comment},
  { "getCv",(PyCFunction ) &Dtool_NurbsCurveInterface_get_cv_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_cv_117_comment},
  { "setKnot",(PyCFunction ) &Dtool_NurbsCurveInterface_set_knot_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_set_knot_118_comment},
  { "getKnot",(PyCFunction ) &Dtool_NurbsCurveInterface_get_knot_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_knot_119_comment},
  { "writeCv",(PyCFunction ) &Dtool_NurbsCurveInterface_write_cv_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_write_cv_120_comment},
  { "getClassType",(PyCFunction ) &Dtool_NurbsCurveInterface_get_class_type_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_get_class_type_121_comment},
  { "downcastToNurbsCurve",(PyCFunction ) &Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveInterface_downcast_to_NurbsCurve_126_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NurbsCurveInterface(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NurbsCurveInterface.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NurbsCurveInterface\n"
          "// Description : This abstract class defines the interface only for a\n"
          "//               Nurbs-style curve, with knots and coordinates in\n"
          "//               homogeneous space.\n"
          "//\n"
          "//               The NurbsCurve class inherits both from this and from\n"
          "//               ParametricCurve.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_NurbsCurveInterface.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_NurbsCurveInterface.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NurbsCurveInterface.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NurbsCurveInterface.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NurbsCurveInterface.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NurbsCurveInterface)");
             printf(" Error In PyType_ReadyNurbsCurveInterface");
             return;
        }
        Py_INCREF(&Dtool_NurbsCurveInterface.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NurbsCurveInterface.As_PyTypeObject().tp_dict,"NurbsCurveInterface",&Dtool_NurbsCurveInterface.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NurbsCurveInterface.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NurbsCurveInterface[17],&Dtool_NurbsCurveInterface.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NurbsCurveInterface,NurbsCurveInterface::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NurbsCurveInterface.As_PyTypeObject());
        PyModule_AddObject(module, "NurbsCurveInterface",(PyObject *)&Dtool_NurbsCurveInterface.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NurbsCurve | NurbsCurve
//********************************************************************
PyMethodDef Dtool_Methods_NurbsCurve[]= {
  { "getClassType",(PyCFunction ) &Dtool_NurbsCurve_get_class_type_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurve_get_class_type_129_comment},
  { "upcastToPiecewiseCurve",(PyCFunction ) &Dtool_NurbsCurve_upcast_to_PiecewiseCurve_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurve_upcast_to_PiecewiseCurve_123_comment},
  { "upcastToNurbsCurveInterface",(PyCFunction ) &Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_125_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NurbsCurve(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NurbsCurve.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NurbsCurve\n"
          "// Description : A Nonuniform Rational B-Spline.\n"
          "//\n"
          "//               This class is actually implemented as a\n"
          "//               PiecewiseCurve made up of several CubicCurvesegs,\n"
          "//               each of which is created using the nurbs_basis()\n"
          "//               method.  The list of CV's and knots is kept here,\n"
          "//               within the NurbsCurve class.\n"
          "//\n"
          "//               This class is the original Panda-native\n"
          "//               implementation of a NURBS curve.  It is typedeffed as\n"
          "//               \"NurbsCurve\" and performs all NURBS curve functions\n"
          "//               if we do not have the NURBS++ library available.\n"
          "//\n"
          "//               However, if we *do* have the NURBS++ library, another\n"
          "//               class exists, the NurbsPPCurve, which is a wrapper\n"
          "//               around that library and provides some additional\n"
          "//               functionality.  In that case, the other class is\n"
          "//               typedeffed to \"NurbsCurve\" instead of this one, and\n"
          "//               performs most of the NURBS curve functions.  This\n"
          "//               class then becomes vestigial.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PiecewiseCurve._Dtool_ClassInit(NULL);
        Dtool_NurbsCurveInterface._Dtool_ClassInit(NULL);
        Dtool_NurbsCurve.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_PiecewiseCurve.As_PyTypeObject(),&Dtool_NurbsCurveInterface.As_PyTypeObject());
        Dtool_NurbsCurve.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NurbsCurve.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NurbsCurve.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NurbsCurve.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NurbsCurve)");
             printf(" Error In PyType_ReadyNurbsCurve");
             return;
        }
        Py_INCREF(&Dtool_NurbsCurve.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NurbsCurve.As_PyTypeObject().tp_dict,"NurbsCurve",&Dtool_NurbsCurve.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NurbsCurve.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NurbsCurve[0],&Dtool_NurbsCurve.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NurbsCurve,NurbsCurve::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NurbsCurve.As_PyTypeObject());
        PyModule_AddObject(module, "NurbsCurve",(PyObject *)&Dtool_NurbsCurve.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NurbsCurveResult | NurbsCurveResult
//********************************************************************
PyMethodDef Dtool_Methods_NurbsCurveResult[]= {
  { "getStartT",(PyCFunction ) &Dtool_NurbsCurveResult_get_start_t_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_start_t_131_comment},
  { "getEndT",(PyCFunction ) &Dtool_NurbsCurveResult_get_end_t_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_end_t_132_comment},
  { "evalPoint",(PyCFunction ) &Dtool_NurbsCurveResult_eval_point_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_eval_point_133_comment},
  { "evalTangent",(PyCFunction ) &Dtool_NurbsCurveResult_eval_tangent_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_eval_tangent_134_comment},
  { "evalExtendedPoint",(PyCFunction ) &Dtool_NurbsCurveResult_eval_extended_point_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_eval_extended_point_135_comment},
  { "getNumSegments",(PyCFunction ) &Dtool_NurbsCurveResult_get_num_segments_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_num_segments_137_comment},
  { "evalSegmentPoint",(PyCFunction ) &Dtool_NurbsCurveResult_eval_segment_point_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_eval_segment_point_138_comment},
  { "evalSegmentTangent",(PyCFunction ) &Dtool_NurbsCurveResult_eval_segment_tangent_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_eval_segment_tangent_139_comment},
  { "evalSegmentExtendedPoint",(PyCFunction ) &Dtool_NurbsCurveResult_eval_segment_extended_point_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_eval_segment_extended_point_140_comment},
  { "getSegmentT",(PyCFunction ) &Dtool_NurbsCurveResult_get_segment_t_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_segment_t_142_comment},
  { "adaptiveSample",(PyCFunction ) &Dtool_NurbsCurveResult_adaptive_sample_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_adaptive_sample_143_comment},
  { "getNumSamples",(PyCFunction ) &Dtool_NurbsCurveResult_get_num_samples_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_num_samples_144_comment},
  { "getSampleT",(PyCFunction ) &Dtool_NurbsCurveResult_get_sample_t_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_sample_t_145_comment},
  { "getSamplePoint",(PyCFunction ) &Dtool_NurbsCurveResult_get_sample_point_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveResult_get_sample_point_146_comment},
  { "getSampleTs",(PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_ts, METH_NOARGS, NULL},
  { "getSamplePoints",(PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_points, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NurbsCurveResult(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NurbsCurveResult.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NurbsCurveResult\n"
          "// Description : The result of a NurbsCurveEvaluator.  This object\n"
          "//               represents a curve in a particular coordinate space.\n"
          "//               It can return the point and/or tangent to the curve\n"
          "//               at any point.\n"
          "//\n"
          "//               This is not related to NurbsCurve, CubicCurveseg or\n"
          "//               any of the ParametricCurve-derived objects in this\n"
          "//               module.  It is a completely parallel implementation\n"
          "//               of NURBS curves, and will probably eventually replace\n"
          "//               the whole ParametricCurve class hierarchy.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_NurbsCurveResult.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_NurbsCurveResult.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NurbsCurveResult.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NurbsCurveResult.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NurbsCurveResult.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NurbsCurveResult)");
             printf(" Error In PyType_ReadyNurbsCurveResult");
             return;
        }
        Py_INCREF(&Dtool_NurbsCurveResult.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NurbsCurveResult.As_PyTypeObject().tp_dict,"NurbsCurveResult",&Dtool_NurbsCurveResult.As_PyObject());
        RegisterRuntimeClass(&Dtool_NurbsCurveResult,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NurbsCurveResult.As_PyTypeObject());
        PyModule_AddObject(module, "NurbsCurveResult",(PyObject *)&Dtool_NurbsCurveResult.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NurbsCurveEvaluator | NurbsCurveEvaluator
//********************************************************************
PyMethodDef Dtool_Methods_NurbsCurveEvaluator[]= {
  { "setOrder",(PyCFunction ) &Dtool_NurbsCurveEvaluator_set_order_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_set_order_149_comment},
  { "getOrder",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_order_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_order_150_comment},
  { "reset",(PyCFunction ) &Dtool_NurbsCurveEvaluator_reset_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_reset_151_comment},
  { "getNumVertices",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_num_vertices_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_num_vertices_152_comment},
  { "setVertex",(PyCFunction ) &Dtool_NurbsCurveEvaluator_set_vertex_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_set_vertex_153_comment},
  { "getVertex",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_vertex_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_vertex_154_comment},
  { "setVertexSpace",(PyCFunction ) &Dtool_NurbsCurveEvaluator_set_vertex_space_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_set_vertex_space_155_comment},
  { "getVertexSpace",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_vertex_space_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_vertex_space_156_comment},
  { "setExtendedVertex",(PyCFunction ) &Dtool_NurbsCurveEvaluator_set_extended_vertex_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_set_extended_vertex_157_comment},
  { "getExtendedVertex",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_extended_vertex_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_extended_vertex_158_comment},
  { "getNumKnots",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_num_knots_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_num_knots_160_comment},
  { "setKnot",(PyCFunction ) &Dtool_NurbsCurveEvaluator_set_knot_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_set_knot_161_comment},
  { "getKnot",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_knot_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_knot_162_comment},
  { "normalizeKnots",(PyCFunction ) &Dtool_NurbsCurveEvaluator_normalize_knots_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_normalize_knots_163_comment},
  { "getNumSegments",(PyCFunction ) &Dtool_NurbsCurveEvaluator_get_num_segments_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_get_num_segments_164_comment},
  { "evaluate",(PyCFunction ) &Dtool_NurbsCurveEvaluator_evaluate_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_evaluate_165_comment},
  { "output",(PyCFunction ) &Dtool_NurbsCurveEvaluator_output_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsCurveEvaluator_output_166_comment},
  { "getVertices",(PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_vertices, METH_NOARGS, NULL},
  { "getKnots",(PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_knots, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     NurbsCurveEvaluator
//////////////////
static PyObject *  Dtool_Repr_NurbsCurveEvaluator(PyObject * self)
{
    NurbsCurveEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsCurveEvaluator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_NurbsCurveEvaluator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NurbsCurveEvaluator\n"
          "// Description : This class is an abstraction for evaluating NURBS\n"
          "//               curves.  It accepts an array of vertices, each of\n"
          "//               which may be in a different coordinate space (as\n"
          "//               defined by a NodePath), as well as an optional knot\n"
          "//               vector.\n"
          "//\n"
          "//               This is not related to NurbsCurve, CubicCurveseg or\n"
          "//               any of the ParametricCurve-derived objects in this\n"
          "//               module.  It is a completely parallel implementation\n"
          "//               of NURBS curves, and will probably eventually replace\n"
          "//               the whole ParametricCurve class hierarchy.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_repr = & Dtool_Repr_NurbsCurveEvaluator;
        // __str__ Repr Proxy
        Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_str = & Dtool_Repr_NurbsCurveEvaluator;
        if(PyType_Ready(&Dtool_NurbsCurveEvaluator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NurbsCurveEvaluator)");
             printf(" Error In PyType_ReadyNurbsCurveEvaluator");
             return;
        }
        Py_INCREF(&Dtool_NurbsCurveEvaluator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NurbsCurveEvaluator.As_PyTypeObject().tp_dict,"NurbsCurveEvaluator",&Dtool_NurbsCurveEvaluator.As_PyObject());
        RegisterRuntimeClass(&Dtool_NurbsCurveEvaluator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NurbsCurveEvaluator.As_PyTypeObject());
        PyModule_AddObject(module, "NurbsCurveEvaluator",(PyObject *)&Dtool_NurbsCurveEvaluator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NurbsSurfaceResult | NurbsSurfaceResult
//********************************************************************
PyMethodDef Dtool_Methods_NurbsSurfaceResult[]= {
  { "getStartU",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_start_u_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_start_u_168_comment},
  { "getEndU",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_end_u_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_end_u_169_comment},
  { "getStartV",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_start_v_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_start_v_170_comment},
  { "getEndV",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_end_v_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_end_v_171_comment},
  { "evalPoint",(PyCFunction ) &Dtool_NurbsSurfaceResult_eval_point_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_eval_point_172_comment},
  { "evalNormal",(PyCFunction ) &Dtool_NurbsSurfaceResult_eval_normal_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_eval_normal_173_comment},
  { "evalExtendedPoint",(PyCFunction ) &Dtool_NurbsSurfaceResult_eval_extended_point_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_eval_extended_point_174_comment},
  { "getNumUSegments",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_num_u_segments_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_num_u_segments_176_comment},
  { "getNumVSegments",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_num_v_segments_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_num_v_segments_177_comment},
  { "evalSegmentPoint",(PyCFunction ) &Dtool_NurbsSurfaceResult_eval_segment_point_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_eval_segment_point_178_comment},
  { "evalSegmentNormal",(PyCFunction ) &Dtool_NurbsSurfaceResult_eval_segment_normal_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_eval_segment_normal_179_comment},
  { "evalSegmentExtendedPoint",(PyCFunction ) &Dtool_NurbsSurfaceResult_eval_segment_extended_point_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_eval_segment_extended_point_180_comment},
  { "getSegmentU",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_segment_u_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_segment_u_182_comment},
  { "getSegmentV",(PyCFunction ) &Dtool_NurbsSurfaceResult_get_segment_v_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceResult_get_segment_v_183_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NurbsSurfaceResult(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NurbsSurfaceResult.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NurbsSurfaceResult\n"
          "// Description : The result of a NurbsSurfaceEvaluator.  This object\n"
          "//               represents a surface in a particular coordinate space.\n"
          "//               It can return the point and/or normal to the surface\n"
          "//               at any point.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_NurbsSurfaceResult.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_NurbsSurfaceResult.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NurbsSurfaceResult.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NurbsSurfaceResult.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NurbsSurfaceResult.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NurbsSurfaceResult)");
             printf(" Error In PyType_ReadyNurbsSurfaceResult");
             return;
        }
        Py_INCREF(&Dtool_NurbsSurfaceResult.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NurbsSurfaceResult.As_PyTypeObject().tp_dict,"NurbsSurfaceResult",&Dtool_NurbsSurfaceResult.As_PyObject());
        RegisterRuntimeClass(&Dtool_NurbsSurfaceResult,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NurbsSurfaceResult.As_PyTypeObject());
        PyModule_AddObject(module, "NurbsSurfaceResult",(PyObject *)&Dtool_NurbsSurfaceResult.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NurbsSurfaceEvaluator | NurbsSurfaceEvaluator
//********************************************************************
PyMethodDef Dtool_Methods_NurbsSurfaceEvaluator[]= {
  { "setUOrder",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_u_order_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_u_order_186_comment},
  { "getUOrder",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_u_order_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_u_order_187_comment},
  { "setVOrder",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_v_order_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_v_order_188_comment},
  { "getVOrder",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_v_order_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_v_order_189_comment},
  { "reset",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_reset_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_reset_190_comment},
  { "getNumUVertices",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_191_comment},
  { "getNumVVertices",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_192_comment},
  { "setVertex",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_vertex_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_vertex_193_comment},
  { "getVertex",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_vertex_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_vertex_194_comment},
  { "setVertexSpace",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_vertex_space_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_vertex_space_195_comment},
  { "getVertexSpace",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_vertex_space_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_vertex_space_196_comment},
  { "setExtendedVertex",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_extended_vertex_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertex_197_comment},
  { "getExtendedVertex",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_extended_vertex_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_extended_vertex_198_comment},
  { "getNumUKnots",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_num_u_knots_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_num_u_knots_200_comment},
  { "setUKnot",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_u_knot_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_u_knot_201_comment},
  { "getUKnot",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_u_knot_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_u_knot_202_comment},
  { "normalizeUKnots",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_normalize_u_knots_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_normalize_u_knots_203_comment},
  { "getNumVKnots",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_num_v_knots_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_num_v_knots_204_comment},
  { "setVKnot",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_set_v_knot_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_set_v_knot_205_comment},
  { "getVKnot",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_v_knot_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_v_knot_206_comment},
  { "normalizeVKnots",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_normalize_v_knots_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_normalize_v_knots_207_comment},
  { "getNumUSegments",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_num_u_segments_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_num_u_segments_208_comment},
  { "getNumVSegments",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_get_num_v_segments_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_get_num_v_segments_209_comment},
  { "evaluate",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_evaluate_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_evaluate_210_comment},
  { "output",(PyCFunction ) &Dtool_NurbsSurfaceEvaluator_output_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NurbsSurfaceEvaluator_output_211_comment},
  { "getUKnots",(PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_u_knots, METH_NOARGS, NULL},
  { "getVKnots",(PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_v_knots, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     NurbsSurfaceEvaluator
//////////////////
static PyObject *  Dtool_Repr_NurbsSurfaceEvaluator(PyObject * self)
{
    NurbsSurfaceEvaluator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NurbsSurfaceEvaluator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NurbsSurfaceEvaluator\n"
          "// Description : This class is an abstraction for evaluating NURBS\n"
          "//               surfaces.  It accepts an array of vertices, each of\n"
          "//               which may be in a different coordinate space (as\n"
          "//               defined by a NodePath), as well as an optional knot\n"
          "//               vector.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_repr = & Dtool_Repr_NurbsSurfaceEvaluator;
        // __str__ Repr Proxy
        Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_str = & Dtool_Repr_NurbsSurfaceEvaluator;
        if(PyType_Ready(&Dtool_NurbsSurfaceEvaluator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NurbsSurfaceEvaluator)");
             printf(" Error In PyType_ReadyNurbsSurfaceEvaluator");
             return;
        }
        Py_INCREF(&Dtool_NurbsSurfaceEvaluator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NurbsSurfaceEvaluator.As_PyTypeObject().tp_dict,"NurbsSurfaceEvaluator",&Dtool_NurbsSurfaceEvaluator.As_PyObject());
        RegisterRuntimeClass(&Dtool_NurbsSurfaceEvaluator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NurbsSurfaceEvaluator.As_PyTypeObject());
        PyModule_AddObject(module, "NurbsSurfaceEvaluator",(PyObject *)&Dtool_NurbsSurfaceEvaluator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. RopeNode | RopeNode
//********************************************************************
PyMethodDef Dtool_Methods_RopeNode[]= {
  { "setCurve",(PyCFunction ) &Dtool_RopeNode_set_curve_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_curve_217_comment},
  { "getCurve",(PyCFunction ) &Dtool_RopeNode_get_curve_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_curve_218_comment},
  { "setRenderMode",(PyCFunction ) &Dtool_RopeNode_set_render_mode_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_render_mode_219_comment},
  { "getRenderMode",(PyCFunction ) &Dtool_RopeNode_get_render_mode_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_render_mode_220_comment},
  { "setUvMode",(PyCFunction ) &Dtool_RopeNode_set_uv_mode_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_uv_mode_221_comment},
  { "getUvMode",(PyCFunction ) &Dtool_RopeNode_get_uv_mode_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_uv_mode_222_comment},
  { "setUvDirection",(PyCFunction ) &Dtool_RopeNode_set_uv_direction_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_uv_direction_223_comment},
  { "getUvDirection",(PyCFunction ) &Dtool_RopeNode_get_uv_direction_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_uv_direction_224_comment},
  { "setUvScale",(PyCFunction ) &Dtool_RopeNode_set_uv_scale_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_uv_scale_225_comment},
  { "getUvScale",(PyCFunction ) &Dtool_RopeNode_get_uv_scale_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_uv_scale_226_comment},
  { "setNormalMode",(PyCFunction ) &Dtool_RopeNode_set_normal_mode_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_normal_mode_227_comment},
  { "getNormalMode",(PyCFunction ) &Dtool_RopeNode_get_normal_mode_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_normal_mode_228_comment},
  { "setTubeUp",(PyCFunction ) &Dtool_RopeNode_set_tube_up_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_tube_up_229_comment},
  { "getTubeUp",(PyCFunction ) &Dtool_RopeNode_get_tube_up_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_tube_up_230_comment},
  { "setUseVertexColor",(PyCFunction ) &Dtool_RopeNode_set_use_vertex_color_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_use_vertex_color_231_comment},
  { "getUseVertexColor",(PyCFunction ) &Dtool_RopeNode_get_use_vertex_color_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_use_vertex_color_232_comment},
  { "getVertexColorDimension",(PyCFunction ) &Dtool_RopeNode_get_vertex_color_dimension_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_vertex_color_dimension_233_comment},
  { "setNumSubdiv",(PyCFunction ) &Dtool_RopeNode_set_num_subdiv_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_num_subdiv_234_comment},
  { "getNumSubdiv",(PyCFunction ) &Dtool_RopeNode_get_num_subdiv_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_num_subdiv_235_comment},
  { "setNumSlices",(PyCFunction ) &Dtool_RopeNode_set_num_slices_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_num_slices_236_comment},
  { "getNumSlices",(PyCFunction ) &Dtool_RopeNode_get_num_slices_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_num_slices_237_comment},
  { "setUseVertexThickness",(PyCFunction ) &Dtool_RopeNode_set_use_vertex_thickness_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_use_vertex_thickness_238_comment},
  { "getUseVertexThickness",(PyCFunction ) &Dtool_RopeNode_get_use_vertex_thickness_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_use_vertex_thickness_239_comment},
  { "getVertexThicknessDimension",(PyCFunction ) &Dtool_RopeNode_get_vertex_thickness_dimension_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_vertex_thickness_dimension_240_comment},
  { "setThickness",(PyCFunction ) &Dtool_RopeNode_set_thickness_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_thickness_241_comment},
  { "getThickness",(PyCFunction ) &Dtool_RopeNode_get_thickness_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_thickness_242_comment},
  { "setMatrix",(PyCFunction ) &Dtool_RopeNode_set_matrix_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_set_matrix_243_comment},
  { "clearMatrix",(PyCFunction ) &Dtool_RopeNode_clear_matrix_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_clear_matrix_244_comment},
  { "hasMatrix",(PyCFunction ) &Dtool_RopeNode_has_matrix_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_has_matrix_245_comment},
  { "getMatrix",(PyCFunction ) &Dtool_RopeNode_get_matrix_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_matrix_246_comment},
  { "resetBound",(PyCFunction ) &Dtool_RopeNode_reset_bound_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_reset_bound_247_comment},
  { "getClassType",(PyCFunction ) &Dtool_RopeNode_get_class_type_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RopeNode_get_class_type_248_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RopeNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_RopeNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : RopeNode\n"
          "// Description : This class draws a visible representation of the\n"
          "//               NURBS curve stored in its NurbsCurveEvaluator.  It\n"
          "//               automatically recomputes the curve every frame.\n"
          "//\n"
          "//               This is not related to NurbsCurve, CubicCurveseg or\n"
          "//               any of the ParametricCurve-derived objects in this\n"
          "//               module.  It is a completely parallel implementation\n"
          "//               of NURBS curves, and will probably eventually replace\n"
          "//               the whole ParametricCurve class hierarchy.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_RopeNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_RopeNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RopeNode.As_PyTypeObject().tp_dict);
        // Enum  RopeNode::RenderMode;
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"RMThread",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"RMTape",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"RMBillboard",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"RMTube",PyInt_FromLong(3));
        // Enum  RopeNode::UVMode;
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"UVNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"UVParametric",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"UVDistance",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"UVDistance2",PyInt_FromLong(3));
        // Enum  RopeNode::NormalMode;
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"NMNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"NMVertex",PyInt_FromLong(1));
        if(PyType_Ready(&Dtool_RopeNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RopeNode)");
             printf(" Error In PyType_ReadyRopeNode");
             return;
        }
        Py_INCREF(&Dtool_RopeNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"RopeNode",&Dtool_RopeNode.As_PyObject());
        //  Static Method getVertexColorDimension
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"getVertexColorDimension",PyCFunction_New(&Dtool_Methods_RopeNode[16],&Dtool_RopeNode.As_PyObject()));
        //  Static Method getVertexThicknessDimension
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"getVertexThicknessDimension",PyCFunction_New(&Dtool_Methods_RopeNode[23],&Dtool_RopeNode.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_RopeNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_RopeNode[31],&Dtool_RopeNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_RopeNode,RopeNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RopeNode.As_PyTypeObject());
        PyModule_AddObject(module, "RopeNode",(PyObject *)&Dtool_RopeNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SheetNode | SheetNode
//********************************************************************
PyMethodDef Dtool_Methods_SheetNode[]= {
  { "setSurface",(PyCFunction ) &Dtool_SheetNode_set_surface_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_set_surface_252_comment},
  { "getSurface",(PyCFunction ) &Dtool_SheetNode_get_surface_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_get_surface_253_comment},
  { "setUseVertexColor",(PyCFunction ) &Dtool_SheetNode_set_use_vertex_color_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_set_use_vertex_color_254_comment},
  { "getUseVertexColor",(PyCFunction ) &Dtool_SheetNode_get_use_vertex_color_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_get_use_vertex_color_255_comment},
  { "setNumUSubdiv",(PyCFunction ) &Dtool_SheetNode_set_num_u_subdiv_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_set_num_u_subdiv_256_comment},
  { "getNumUSubdiv",(PyCFunction ) &Dtool_SheetNode_get_num_u_subdiv_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_get_num_u_subdiv_257_comment},
  { "setNumVSubdiv",(PyCFunction ) &Dtool_SheetNode_set_num_v_subdiv_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_set_num_v_subdiv_258_comment},
  { "getNumVSubdiv",(PyCFunction ) &Dtool_SheetNode_get_num_v_subdiv_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_get_num_v_subdiv_259_comment},
  { "resetBound",(PyCFunction ) &Dtool_SheetNode_reset_bound_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_reset_bound_260_comment},
  { "getClassType",(PyCFunction ) &Dtool_SheetNode_get_class_type_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SheetNode_get_class_type_261_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SheetNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SheetNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SheetNode\n"
          "// Description : This class draws a visible representation of the\n"
          "//               NURBS surface stored in its NurbsSurfaceEvaluator.  It\n"
          "//               automatically recomputes the surface every frame.\n"
          "//\n"
          "//               This is not related to NurbsSurface, CubicSurfaceseg\n"
          "//               or any of the ParametricSurface-derived objects in\n"
          "//               this module.  It is a completely parallel\n"
          "//               implementation of NURBS surfaces, and will probably\n"
          "//               eventually replace the whole ParametricSurface class\n"
          "//               hierarchy.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_SheetNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_SheetNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SheetNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SheetNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SheetNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SheetNode)");
             printf(" Error In PyType_ReadySheetNode");
             return;
        }
        Py_INCREF(&Dtool_SheetNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SheetNode.As_PyTypeObject().tp_dict,"SheetNode",&Dtool_SheetNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SheetNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SheetNode[9],&Dtool_SheetNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SheetNode,SheetNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SheetNode.As_PyTypeObject());
        PyModule_AddObject(module, "SheetNode",(PyObject *)&Dtool_SheetNode.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
   PyModule_AddIntConstant(module,"HCCUT",1);
   PyModule_AddIntConstant(module,"HCFREE",2);
   PyModule_AddIntConstant(module,"HCG1",3);
   PyModule_AddIntConstant(module,"HCSMOOTH",4);
   PyModule_AddIntConstant(module,"PCTHPR",2);
   PyModule_AddIntConstant(module,"PCTNONE",0);
   PyModule_AddIntConstant(module,"PCTT",3);
   PyModule_AddIntConstant(module,"PCTXYZ",1);
//********************************************************************
//*** Module Init Updcall ..ParametricCurve
//********************************************************************
   Dtool_PyModuleClassInit_ParametricCurve(module);
//********************************************************************
//*** Module Init Updcall ..CubicCurveseg
//********************************************************************
   Dtool_PyModuleClassInit_CubicCurveseg(module);
//********************************************************************
//*** Module Init Updcall ..ParametricCurveCollection
//********************************************************************
   Dtool_PyModuleClassInit_ParametricCurveCollection(module);
//********************************************************************
//*** Module Init Updcall ..CurveFitter
//********************************************************************
   Dtool_PyModuleClassInit_CurveFitter(module);
//********************************************************************
//*** Module Init Updcall ..PiecewiseCurve
//********************************************************************
   Dtool_PyModuleClassInit_PiecewiseCurve(module);
//********************************************************************
//*** Module Init Updcall ..HermiteCurve
//********************************************************************
   Dtool_PyModuleClassInit_HermiteCurve(module);
//********************************************************************
//*** Module Init Updcall ..NurbsCurveInterface
//********************************************************************
   Dtool_PyModuleClassInit_NurbsCurveInterface(module);
//********************************************************************
//*** Module Init Updcall ..NurbsCurve
//********************************************************************
   Dtool_PyModuleClassInit_NurbsCurve(module);
//********************************************************************
//*** Module Init Updcall ..NurbsCurveResult
//********************************************************************
   Dtool_PyModuleClassInit_NurbsCurveResult(module);
//********************************************************************
//*** Module Init Updcall ..NurbsCurveEvaluator
//********************************************************************
   Dtool_PyModuleClassInit_NurbsCurveEvaluator(module);
//********************************************************************
//*** Module Init Updcall ..NurbsSurfaceResult
//********************************************************************
   Dtool_PyModuleClassInit_NurbsSurfaceResult(module);
//********************************************************************
//*** Module Init Updcall ..NurbsSurfaceEvaluator
//********************************************************************
   Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(module);
//********************************************************************
//*** Module Init Updcall ..RopeNode
//********************************************************************
   Dtool_PyModuleClassInit_RopeNode(module);
//********************************************************************
//*** Module Init Updcall ..SheetNode
//********************************************************************
   Dtool_PyModuleClassInit_SheetNode(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libparametrics_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212913,  /* file_identifier */
  "libparametrics",  /* library_name */
  "Hc9W",  /* library_hash_name */
  "panda",  /* module_name */
  "libparametrics.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  624  /* next_index */
};

Configure(_in_configure_libparametrics);
ConfigureFn(_in_configure_libparametrics) {
  interrogate_request_module(&_in_module_def);
}

