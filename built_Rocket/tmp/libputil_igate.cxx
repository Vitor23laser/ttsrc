/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/putil -Ipanda/src/putil -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libputil_igate.cxx -od built_Rocket/pandac/input/libputil.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/putil -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/zlib/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libputil animInterface.h bam.h bamCache.h bamCacheIndex.h bamCacheRecord.h bamEnums.h bamReader.h bamReaderParam.h bamWriter.h bitArray.h bitMask.h buttonHandle.h buttonRegistry.h cPointerCallbackObject.h cachedTypedWritableReferenceCount.h callbackData.h callbackObject.h clockObject.h collideMask.h compareTo.h config_util.h configurable.h copyOnWriteObject.h copyOnWritePointer.h datagramInputFile.h datagramOutputFile.h doubleBitMask.h drawMask.h factory.h factoryBase.h factoryParam.h factoryParams.h firstOfPairCompare.h firstOfPairLess.h globalPointerRegistry.h indirectCompareNames.h indirectCompareSort.h indirectCompareTo.h ioPtaDatagramFloat.h ioPtaDatagramInt.h ioPtaDatagramShort.h iterator_types.h keyboardButton.h lineStream.h lineStreamBuf.h linkedListNode.h load_prc_file.h loaderOptions.h modifierButtons.h mouseButton.h mouseData.h nameUniquifier.h nodeCachedReferenceCount.h pbitops.h portalMask.h pta_double.h pta_ushort.h putil_composite.cxx pythonCallbackObject.h simpleHashMap.h sparseArray.h string_utils.h timedCycle.h typedWritable.h typedWritableReferenceCount.h uniqueIdAllocator.h updateSeq.h vector_double.h vector_typedWritable.h vector_ulong.h vector_ushort.h vector_writable.h writableConfigurable.h writableParam.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libputil
#include "py_panda.h"  

#include <algorithm>
#include "animInterface.h"
#include "bam.h"
#include "bamCache.h"
#include "bamCacheIndex.h"
#include "bamCacheRecord.h"
#include "bamEnums.h"
#include "bamReader.h"
#include "bamReaderParam.h"
#include "bamWriter.h"
#include "bitArray.h"
#include "bitMask.h"
#include "buttonHandle.h"
#include "buttonRegistry.h"
#include "cPointerCallbackObject.h"
#include "cachedTypedWritableReferenceCount.h"
#include "callbackData.h"
#include "callbackObject.h"
#include "checksumHashGenerator.h"
#include "clockObject.h"
#include "collideMask.h"
#include "compareTo.h"
#include "conditionVar.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableSearchPath.h"
#include "config_util.h"
#include "configurable.h"
#include "copyOnWriteObject.h"
#include "copyOnWritePointer.h"
#include "cycleData.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataWriter.h"
#include "datagramGenerator.h"
#include "datagramInputFile.h"
#include "datagramIterator.h"
#include "datagramOutputFile.h"
#include "datagramSink.h"
#include "dcast.h"
#include "dconfig.h"
#include "doubleBitMask.h"
#include "drawMask.h"
#include "factory.h"
#include "factoryBase.h"
#include "factoryParam.h"
#include "factoryParams.h"
#include "filename.h"
#include "firstOfPairCompare.h"
#include "firstOfPairLess.h"
#include "globalPointerRegistry.h"
#include "indent.h"
#include "indirectCompareNames.h"
#include "indirectCompareSort.h"
#include "indirectCompareTo.h"
#include "ioPtaDatagramFloat.h"
#include "ioPtaDatagramInt.h"
#include "ioPtaDatagramShort.h"
#include "iterator_types.h"
#include "keyboardButton.h"
#include "lineStream.h"
#include "lineStreamBuf.h"
#include "linkedListNode.h"
#include "load_prc_file.h"
#include "loaderOptions.h"
#include "modifierButtons.h"
#include "mouseButton.h"
#include "mouseData.h"
#include "mutexHolder.h"
#include "nameUniquifier.h"
#include "nodeCachedReferenceCount.h"
#include "nodeReferenceCount.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pandabase.h"
#include "pbitops.h"
#include "pdeque.h"
#include "pipelineCycler.h"
#include "pipelineCyclerBase.h"
#include "pmap.h"
#include "pmutex.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "portalMask.h"
#include "pset.h"
#include "pta_double.h"
#include "pta_float.h"
#include "pta_int.h"
#include "pta_ushort.h"
#include "pvector.h"
#include "pythonCallbackObject.h"
#include "reMutex.h"
#include "reMutexHolder.h"
#include "referenceCount.h"
#include "register_type.h"
#include "simpleHashMap.h"
#include "sparseArray.h"
#include <string>
#include "string_utils.h"
#include "thread.h"
#include <time.h>
#include "timedCycle.h"
#include "trueClock.h"
#include "typeHandle.h"
#include "typedObject.h"
#include "typedWritable.h"
#include "typedWritableReferenceCount.h"
#include "uniqueIdAllocator.h"
#include "updateSeq.h"
#include "vector_double.h"
#include "vector_int.h"
#include "vector_typedWritable.h"
#include "vector_ulong.h"
#include "vector_ushort.h"
#include "vector_writable.h"
#include "virtualFile.h"
#include "writableConfigurable.h"
#include "writableParam.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ConstPointerToArray_double
//********************************************************************
typedef  ConstPointerToArray< double >  ConstPointerToArray_double_localtype;
Define_Module_Class(panda,ConstPointerToArray_double,ConstPointerToArray_double_localtype,ConstPointerToArrayDouble);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_double
//********************************************************************
typedef  PointerToArrayBase< double >  PointerToArrayBase_double_localtype;
Define_Module_Class(panda,PointerToArrayBase_double,PointerToArrayBase_double_localtype,PointerToArrayBaseDouble);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_double
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< double > >  PointerToBase_ReferenceCountedVector_double_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_double,PointerToBase_ReferenceCountedVector_double_localtype,PointerToBaseReferenceCountedVectorDouble);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_unsigned_short_int
//********************************************************************
typedef  ConstPointerToArray< unsigned short int >  ConstPointerToArray_unsigned_short_int_localtype;
Define_Module_Class(panda,ConstPointerToArray_unsigned_short_int,ConstPointerToArray_unsigned_short_int_localtype,ConstPointerToArrayUnsignedShortInt);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_unsigned_short_int
//********************************************************************
typedef  PointerToArrayBase< unsigned short int >  PointerToArrayBase_unsigned_short_int_localtype;
Define_Module_Class(panda,PointerToArrayBase_unsigned_short_int,PointerToArrayBase_unsigned_short_int_localtype,PointerToArrayBaseUnsignedShortInt);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_unsigned_short_int
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< unsigned short int > >  PointerToBase_ReferenceCountedVector_unsigned_short_int_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_unsigned_short_int,PointerToBase_ReferenceCountedVector_unsigned_short_int_localtype,PointerToBaseReferenceCountedVectorUnsignedShortInt);
//********************************************************************
//*** prototypes for .. DoubleBitMask_BitMask_unsigned_int_32
//********************************************************************
typedef  DoubleBitMask< BitMask< unsigned int, 32 > >  DoubleBitMask_BitMask_unsigned_int_32_localtype;
Define_Module_Class(panda,DoubleBitMask_BitMask_unsigned_int_32,DoubleBitMask_BitMask_unsigned_int_32_localtype,DoubleBitMaskBitMaskUnsignedInt32);
//********************************************************************
//*** prototypes for .. DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32
//********************************************************************
typedef  DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >  DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_localtype;
Define_Module_Class(panda,DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_localtype,DoubleBitMaskDoubleBitMaskBitMaskUnsignedInt32);
//********************************************************************
//*** prototypes for .. PointerToArray_double
//********************************************************************
typedef  PointerToArray< double >  PointerToArray_double_localtype;
Define_Module_Class(panda,PointerToArray_double,PointerToArray_double_localtype,PointerToArrayDouble);
//********************************************************************
//*** prototypes for .. PointerToArray_unsigned_short_int
//********************************************************************
typedef  PointerToArray< unsigned short int >  PointerToArray_unsigned_short_int_localtype;
Define_Module_Class(panda,PointerToArray_unsigned_short_int,PointerToArray_unsigned_short_int_localtype,PointerToArrayUnsignedShortInt);
//********************************************************************
//*** prototypes for .. basic_string_char
//********************************************************************
typedef  basic_string< char >  basic_string_char_localtype;
Define_Module_Class_Private(panda,basic_string_char,basic_string_char_localtype,BasicStringChar);
//********************************************************************
//*** prototypes for .. AnimInterface
//********************************************************************
typedef  AnimInterface  AnimInterface_localtype;
Define_Module_Class(panda,AnimInterface,AnimInterface_localtype,AnimInterface);
//********************************************************************
//*** prototypes for .. UpdateSeq
//********************************************************************
typedef  UpdateSeq  UpdateSeq_localtype;
Define_Module_Class(panda,UpdateSeq,UpdateSeq_localtype,UpdateSeq);
//********************************************************************
//*** prototypes for .. TypedWritable
//********************************************************************
typedef  TypedWritable  TypedWritable_localtype;
Define_Module_Class(panda,TypedWritable,TypedWritable_localtype,TypedWritable);
//********************************************************************
//*** prototypes for .. TypedWritableReferenceCount
//********************************************************************
typedef  TypedWritableReferenceCount  TypedWritableReferenceCount_localtype;
Define_Module_ClassRef(panda,TypedWritableReferenceCount,TypedWritableReferenceCount_localtype,TypedWritableReferenceCount);
//********************************************************************
//*** prototypes for .. BamCacheRecord
//********************************************************************
typedef  BamCacheRecord  BamCacheRecord_localtype;
Define_Module_ClassRef(panda,BamCacheRecord,BamCacheRecord_localtype,BamCacheRecord);
//********************************************************************
//*** prototypes for .. BamCache
//********************************************************************
typedef  BamCache  BamCache_localtype;
Define_Module_Class(panda,BamCache,BamCache_localtype,BamCache);
//********************************************************************
//*** prototypes for .. BamEnums
//********************************************************************
typedef  BamEnums  BamEnums_localtype;
Define_Module_Class(panda,BamEnums,BamEnums_localtype,BamEnums);
//********************************************************************
//*** prototypes for .. LoaderOptions
//********************************************************************
typedef  LoaderOptions  LoaderOptions_localtype;
Define_Module_Class(panda,LoaderOptions,LoaderOptions_localtype,LoaderOptions);
//********************************************************************
//*** prototypes for .. BamReader
//********************************************************************
typedef  BamReader  BamReader_localtype;
Define_Module_Class(panda,BamReader,BamReader_localtype,BamReader);
//********************************************************************
//*** prototypes for .. BamWriter
//********************************************************************
typedef  BamWriter  BamWriter_localtype;
Define_Module_Class(panda,BamWriter,BamWriter_localtype,BamWriter);
//********************************************************************
//*** prototypes for .. BitMask_unsigned_int_32
//********************************************************************
typedef  BitMask< unsigned int, 32 >  BitMask_unsigned_int_32_localtype;
Define_Module_Class(panda,BitMask_unsigned_int_32,BitMask_unsigned_int_32_localtype,BitMaskUnsignedInt32);
//********************************************************************
//*** prototypes for .. BitMask_unsigned_int64_64
//********************************************************************
typedef  BitMask< unsigned __int64, 64 >  BitMask_unsigned_int64_64_localtype;
Define_Module_Class(panda,BitMask_unsigned_int64_64,BitMask_unsigned_int64_64_localtype,BitMaskUnsignedInt6464);
//********************************************************************
//*** prototypes for .. BitArray
//********************************************************************
typedef  BitArray  BitArray_localtype;
Define_Module_Class(panda,BitArray,BitArray_localtype,BitArray);
//********************************************************************
//*** prototypes for .. ButtonHandle
//********************************************************************
typedef  ButtonHandle  ButtonHandle_localtype;
Define_Module_Class(panda,ButtonHandle,ButtonHandle_localtype,ButtonHandle);
//********************************************************************
//*** prototypes for .. ButtonRegistry
//********************************************************************
typedef  ButtonRegistry  ButtonRegistry_localtype;
Define_Module_Class(panda,ButtonRegistry,ButtonRegistry_localtype,ButtonRegistry);
//********************************************************************
//*** prototypes for .. CallbackObject
//********************************************************************
typedef  CallbackObject  CallbackObject_localtype;
Define_Module_ClassRef(panda,CallbackObject,CallbackObject_localtype,CallbackObject);
//********************************************************************
//*** prototypes for .. CachedTypedWritableReferenceCount
//********************************************************************
typedef  CachedTypedWritableReferenceCount  CachedTypedWritableReferenceCount_localtype;
Define_Module_ClassRef_Private(panda,CachedTypedWritableReferenceCount,CachedTypedWritableReferenceCount_localtype,CachedTypedWritableReferenceCount);
//********************************************************************
//*** prototypes for .. CallbackData
//********************************************************************
typedef  CallbackData  CallbackData_localtype;
Define_Module_Class(panda,CallbackData,CallbackData_localtype,CallbackData);
//********************************************************************
//*** prototypes for .. TimeVal
//********************************************************************
typedef  TimeVal  TimeVal_localtype;
Define_Module_Class(panda,TimeVal,TimeVal_localtype,TimeVal);
//********************************************************************
//*** prototypes for .. ClockObject
//********************************************************************
typedef  ClockObject  ClockObject_localtype;
Define_Module_ClassRef(panda,ClockObject,ClockObject_localtype,ClockObject);
//********************************************************************
//*** prototypes for .. CopyOnWriteObject
//********************************************************************
typedef  CopyOnWriteObject  CopyOnWriteObject_localtype;
Define_Module_ClassRef(panda,CopyOnWriteObject,CopyOnWriteObject_localtype,CopyOnWriteObject);
//********************************************************************
//*** prototypes for .. KeyboardButton
//********************************************************************
typedef  KeyboardButton  KeyboardButton_localtype;
Define_Module_Class(panda,KeyboardButton,KeyboardButton_localtype,KeyboardButton);
//********************************************************************
//*** prototypes for .. LineStream
//********************************************************************
typedef  LineStream  LineStream_localtype;
Define_Module_Class(panda,LineStream,LineStream_localtype,LineStream);
//********************************************************************
//*** prototypes for .. ModifierButtons
//********************************************************************
typedef  ModifierButtons  ModifierButtons_localtype;
Define_Module_Class(panda,ModifierButtons,ModifierButtons_localtype,ModifierButtons);
//********************************************************************
//*** prototypes for .. MouseButton
//********************************************************************
typedef  MouseButton  MouseButton_localtype;
Define_Module_Class(panda,MouseButton,MouseButton_localtype,MouseButton);
//********************************************************************
//*** prototypes for .. MouseData
//********************************************************************
typedef  MouseData  MouseData_localtype;
Define_Module_Class(panda,MouseData,MouseData_localtype,MouseData);
//********************************************************************
//*** prototypes for .. NodeCachedReferenceCount
//********************************************************************
typedef  NodeCachedReferenceCount  NodeCachedReferenceCount_localtype;
Define_Module_ClassRef_Private(panda,NodeCachedReferenceCount,NodeCachedReferenceCount_localtype,NodeCachedReferenceCount);
//********************************************************************
//*** prototypes for .. SparseArray
//********************************************************************
typedef  SparseArray  SparseArray_localtype;
Define_Module_Class(panda,SparseArray,SparseArray_localtype,SparseArray);
//********************************************************************
//*** prototypes for .. PythonCallbackObject
//********************************************************************
typedef  PythonCallbackObject  PythonCallbackObject_localtype;
Define_Module_ClassRef(panda,PythonCallbackObject,PythonCallbackObject_localtype,PythonCallbackObject);
//********************************************************************
//*** prototypes for .. WritableConfigurable
//********************************************************************
typedef  WritableConfigurable  WritableConfigurable_localtype;
Define_Module_Class(panda,WritableConfigurable,WritableConfigurable_localtype,WritableConfigurable);
//********************************************************************
//*** prototypes for .. UniqueIdAllocator
//********************************************************************
typedef  UniqueIdAllocator  UniqueIdAllocator_localtype;
Define_Module_Class(panda,UniqueIdAllocator,UniqueIdAllocator_localtype,UniqueIdAllocator);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ConfigPage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ConfigVariableSearchPath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramGenerator;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramSink;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_HashVal;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PointerToVoid;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Thread;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ios;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ios_base;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_py_decode_TypedWritable_from_bam_stream_226(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, basic_string< char > const &data)
        PyObject *param0;
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"this_class", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:pyDecodeTypedWritableFromBamStream", key_word_list, &param0, &param1_str, &param1_len))
        {
            PyObject *return_value = py_decode_TypedWritable_from_bam_stream(param0, basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pyDecodeTypedWritableFromBamStream(any this_class, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_py_decode_TypedWritable_from_bam_stream_226_comment =
    "C++ Interface:\n"
    "pyDecodeTypedWritableFromBamStream(any this_class, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: py_decode_TypedWritable_from_bam_stream\n"
    "//       Access: Published\n"
    "//  Description: This wrapper is defined as a global function to suit\n"
    "//               pickle's needs.\n"
    "//\n"
    "//               This hooks into the native pickle and cPickle\n"
    "//               modules, but it cannot properly handle\n"
    "//               self-referential BAM objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_py_decode_TypedWritable_from_bam_stream_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_py_decode_TypedWritable_from_bam_stream_persist_227(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, basic_string< char > const &data)
        PyObject *param0;
        PyObject *param1;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"unpickler", (char *)"this_class", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:pyDecodeTypedWritableFromBamStreamPersist", key_word_list, &param0, &param1, &param2_str, &param2_len))
        {
            PyObject *return_value = py_decode_TypedWritable_from_bam_stream_persist(param0, param1, basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pyDecodeTypedWritableFromBamStreamPersist(any unpickler, any this_class, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_py_decode_TypedWritable_from_bam_stream_persist_227_comment =
    "C++ Interface:\n"
    "pyDecodeTypedWritableFromBamStreamPersist(any unpickler, any this_class, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: py_decode_TypedWritable_from_bam_stream_persist\n"
    "//       Access: Published\n"
    "//  Description: This wrapper is defined as a global function to suit\n"
    "//               pickle's needs.\n"
    "//\n"
    "//               This is similar to\n"
    "//               py_decode_TypedWritable_from_bam_stream, but it\n"
    "//               provides additional support for the missing\n"
    "//               persistent-state object needed to properly support\n"
    "//               self-referential BAM objects written to the pickle\n"
    "//               stream.  This hooks into the pickle and cPickle\n"
    "//               modules implemented in direct/src/stdpy.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_py_decode_TypedWritable_from_bam_stream_persist_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConfigVariableSearchPath &get_model_path(void)
 *******************************************************************/
static PyObject *Dtool_get_model_path_592(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-ConfigVariableSearchPath &get_model_path(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getModelPath", key_word_list))
        {
            ConfigVariableSearchPath *return_value = &(get_model_path());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableSearchPath,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModelPath()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_model_path_592_comment =
    "C++ Interface:\n"
    "getModelPath()\n"
    "\n"
    "// Set this true to enable tracking of ReferenceCount pointer\n"
    "// allocation/deallcation via the MemoryUsage object.  This is\n"
    "// primarily useful for detecting memory leaks.  It has no effect when\n"
    "// compiling in NDEBUG mode.\n"
    "//\n"
    "// This variable is no longer defined here; instead, it's a member of\n"
    "// MemoryUsage.\n"
    "//\n"
    "// ConfigVariableBool track_memory_usage(\"track-memory-usage\", false);\n"
    "";
#else
static const char * Dtool_get_model_path_592_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConfigVariableSearchPath &get_plugin_path(void)
 *******************************************************************/
static PyObject *Dtool_get_plugin_path_593(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-ConfigVariableSearchPath &get_plugin_path(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPluginPath", key_word_list))
        {
            ConfigVariableSearchPath *return_value = &(get_plugin_path());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableSearchPath,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPluginPath()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_plugin_path_593_comment =
    "C++ Interface:\n"
    "getPluginPath()\n"
    "\n"
    "";
#else
static const char * Dtool_get_plugin_path_593_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConfigPage *load_prc_file(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_load_prc_file_656(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-ConfigPage *load_prc_file(Filename const &filename)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:loadPrcFile", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:loadPrcFile", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "loadPrcFile", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConfigPage *return_value = load_prc_file(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadPrcFile(const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_load_prc_file_656_comment =
    "C++ Interface:\n"
    "loadPrcFile(const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_prc_file\n"
    "//  Description: A convenience function for loading explicit prc files\n"
    "//               from a disk file or from within a multifile (via the\n"
    "//               virtual file system).  Save the return value and pass\n"
    "//               it to unload_prc_file() if you ever want to unload\n"
    "//               this file later.\n"
    "//\n"
    "//               The filename is first searched along the default prc\n"
    "//               search path, and then also along the model path, for\n"
    "//               convenience.\n"
    "//\n"
    "//               This function is defined in putil instead of in dtool\n"
    "//               with the read of the prc stuff, so that it can take\n"
    "//               advantage of the virtual file system (which is\n"
    "//               defined in express), and the model path (which is in\n"
    "//               putil).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_prc_file\n"
    "//  Description: A convenience function for loading explicit prc files\n"
    "//               from a disk file or from within a multifile (via the\n"
    "//               virtual file system).  Save the return value and pass\n"
    "//               it to unload_prc_file() if you ever want to unload\n"
    "//               this file later.\n"
    "//\n"
    "//               The filename is first searched along the default prc\n"
    "//               search path, and then also along the model path, for\n"
    "//               convenience.\n"
    "//\n"
    "//               This function is defined in putil instead of in dtool\n"
    "//               with the read of the prc stuff, so that it can take\n"
    "//               advantage of the virtual file system (which is\n"
    "//               defined in express), and the model path (which is in\n"
    "//               putil).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_load_prc_file_656_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConfigPage *load_prc_file_data(basic_string< char > const &name, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_load_prc_file_data_657(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-ConfigPage *load_prc_file_data(basic_string< char > const &name, basic_string< char > const &data)
        char *param0_str; int param0_len;
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:loadPrcFileData", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
        {
            ConfigPage *return_value = load_prc_file_data(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadPrcFileData(string name, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_load_prc_file_data_657_comment =
    "C++ Interface:\n"
    "loadPrcFileData(string name, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_prc_file_data\n"
    "//  Description: Another convenience function to load a prc file from\n"
    "//               an explicit string, which represents the contents of\n"
    "//               the prc file.\n"
    "//\n"
    "//               The first parameter is an arbitrary name to assign to\n"
    "//               this in-memory prc file.  Supply a filename if the\n"
    "//               data was read from a file, or use any other name that\n"
    "//               is meaningful to you.  The name is only used when the\n"
    "//               set of loaded prc files is listed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_prc_file_data\n"
    "//  Description: Another convenience function to load a prc file from\n"
    "//               an explicit string, which represents the contents of\n"
    "//               the prc file.\n"
    "//\n"
    "//               The first parameter is an arbitrary name to assign to\n"
    "//               this in-memory prc file.  Supply a filename if the\n"
    "//               data was read from a file, or use any other name that\n"
    "//               is meaningful to you.  The name is only used when the\n"
    "//               set of loaded prc files is listed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_load_prc_file_data_657_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool unload_prc_file(ConfigPage *page)
 *******************************************************************/
static PyObject *Dtool_unload_prc_file_658(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool unload_prc_file(ConfigPage *page)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"page", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unloadPrcFile", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:unloadPrcFile", &param0));
            if(!PyErr_Occurred())
            {
                ConfigPage *param0_this = (ConfigPage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConfigPage, 0, "unloadPrcFile", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    bool return_value = unload_prc_file(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unloadPrcFile(non-const ConfigPage page)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_unload_prc_file_658_comment =
    "C++ Interface:\n"
    "unloadPrcFile(non-const ConfigPage page)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: unload_prc_file\n"
    "//  Description: Unloads (and deletes) a ConfigPage that represents a\n"
    "//               prc file that was previously loaded by\n"
    "//               load_prc_file().  Returns true if successful, false\n"
    "//               if the file was unknown.\n"
    "//\n"
    "//               After this function has been called, the ConfigPage\n"
    "//               pointer is no longer valid and should not be used\n"
    "//               again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: unload_prc_file\n"
    "//  Description: Unloads (and deletes) a ConfigPage that represents a\n"
    "//               prc file that was previously loaded by\n"
    "//               load_prc_file().  Returns true if successful, false\n"
    "//               if the file was unknown.\n"
    "//\n"
    "//               After this function has been called, the ConfigPage\n"
    "//               pointer is no longer valid and should not be used\n"
    "//               again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_unload_prc_file_658_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void hash_prc_variables(HashVal &hash)
 *******************************************************************/
static PyObject *Dtool_hash_prc_variables_659(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void hash_prc_variables(HashVal &hash)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"hash", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hashPrcVariables", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:hashPrcVariables", &param0));
            if(!PyErr_Occurred())
            {
                HashVal *param0_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_HashVal, 0, "hashPrcVariables", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    hash_prc_variables(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hashPrcVariables(non-const HashVal hash)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_hash_prc_variables_659_comment =
    "C++ Interface:\n"
    "hashPrcVariables(non-const HashVal hash)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: hash_prc_variables\n"
    "//  Description: Fills HashVal with the hash from the current prc file\n"
    "//               state as reported by\n"
    "//               ConfigVariableManager::write_prc_variables().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: hash_prc_variables\n"
    "//  Description: Fills HashVal with the hash from the current prc file\n"
    "//               state as reported by\n"
    "//               ConfigVariableManager::write_prc_variables().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_hash_prc_variables_659_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. ConstPointerToArray< double > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< double >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_size_9(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< double >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< double >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_size_9_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_size_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double const &::ConstPointerToArray< double >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_get_element_10(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double const &::ConstPointerToArray< double >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                double return_value = ((const ConstPointerToArray< double >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_get_element_10_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_get_element_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double const &::ConstPointerToArray< double >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_getitem_11(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double const &::ConstPointerToArray< double >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< double >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                double return_value = ((const ConstPointerToArray< double >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_getitem_11_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_getitem_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< double >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_get_data_12(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< double >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< double >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_get_data_12_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_get_data_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< double >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_get_subdata_13(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< double >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< double >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_get_subdata_13_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_get_subdata_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< double >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_get_ref_count_14(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< double >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< double >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_get_ref_count_14_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_get_ref_count_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< double >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_double_get_node_ref_count_15(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< double >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< double >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_double_get_node_ref_count_15_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_double_get_node_ref_count_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
 * inline ::ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_double(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< double > *param0_this = (ConstPointerToArray< double > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_double, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_double,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< double > *param0_this = (PointerToArray< double > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_double, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_double,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_double(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_double)
    {
        printf("ConstPointerToArray_double ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< double > * local_this = (ConstPointerToArray< double > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_double)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_double)
        return ( PointerToArrayBase< double > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
        return ( PointerToBase< ReferenceCountedVector< double > > *)( PointerToArrayBase< double > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< double > > *)( PointerToArrayBase< double > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_double(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_double)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_double)
    {
          PointerToArrayBase< double >* other_this = (PointerToArrayBase< double >*)from_this;
          return (ConstPointerToArray< double >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
    {
          PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
          return (ConstPointerToArray< double >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< double >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< double > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_double(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< double >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_double(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_double)
    {
        printf("PointerToArrayBase_double ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< double > * local_this = (PointerToArrayBase< double > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_double)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
        return ( PointerToBase< ReferenceCountedVector< double > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< double > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_double(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_double)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
    {
          PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
          return (PointerToArrayBase< double >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< double >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< double > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< double > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_double_clear_5(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< double > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< double > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_double_clear_5_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_double_clear_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< double > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_double_output_6(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< double > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< double > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< double > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_double_output_6_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_double_output_6_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_double(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< double > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_double(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_double)
    {
        printf("PointerToBase_ReferenceCountedVector_double ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< double > > * local_this = (PointerToBase< ReferenceCountedVector< double > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_double(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< double > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< unsigned short int > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< unsigned short int >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_size_24(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< unsigned short int >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_size_24_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_size_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int const &::ConstPointerToArray< unsigned short int >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_get_element_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int const &::ConstPointerToArray< unsigned short int >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                unsigned short int return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_element_25_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_element_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int const &::ConstPointerToArray< unsigned short int >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_getitem_26(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int const &::ConstPointerToArray< unsigned short int >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< unsigned short int >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                unsigned short int return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_getitem_26_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_getitem_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< unsigned short int >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_get_data_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< unsigned short int >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_data_27_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_data_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< unsigned short int >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_get_subdata_28(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< unsigned short int >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_subdata_28_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_subdata_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< unsigned short int >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_get_ref_count_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< unsigned short int >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_ref_count_29_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_ref_count_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< unsigned short int >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_short_int_get_node_ref_count_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< unsigned short int >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< unsigned short int >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_node_ref_count_30_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_short_int_get_node_ref_count_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< unsigned short int >::ConstPointerToArray(ConstPointerToArray< unsigned short int > const &copy)
 * inline ::ConstPointerToArray< unsigned short int >::ConstPointerToArray(PointerToArray< unsigned short int > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_unsigned_short_int(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< unsigned short int >::ConstPointerToArray(PointerToArray< unsigned short int > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< unsigned short int > *param0_this = (PointerToArray< unsigned short int > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_unsigned_short_int, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< unsigned short int > *return_value = new ConstPointerToArray< unsigned short int >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_unsigned_short_int,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< unsigned short int >::ConstPointerToArray(ConstPointerToArray< unsigned short int > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< unsigned short int > *param0_this = (ConstPointerToArray< unsigned short int > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_unsigned_short_int, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< unsigned short int > *return_value = new ConstPointerToArray< unsigned short int >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_unsigned_short_int,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_unsigned_short_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_unsigned_short_int)
    {
        printf("ConstPointerToArray_unsigned_short_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< unsigned short int > * local_this = (ConstPointerToArray< unsigned short int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_unsigned_short_int)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_unsigned_short_int)
        return ( PointerToArrayBase< unsigned short int > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
        return ( PointerToBase< ReferenceCountedVector< unsigned short int > > *)( PointerToArrayBase< unsigned short int > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< unsigned short int > > *)( PointerToArrayBase< unsigned short int > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_unsigned_short_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_unsigned_short_int)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_unsigned_short_int)
    {
          PointerToArrayBase< unsigned short int >* other_this = (PointerToArrayBase< unsigned short int >*)from_this;
          return (ConstPointerToArray< unsigned short int >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
    {
          PointerToBase< ReferenceCountedVector< unsigned short int > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned short int > >*)from_this;
          return (ConstPointerToArray< unsigned short int >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< unsigned short int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< unsigned short int > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_unsigned_short_int(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< unsigned short int >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_unsigned_short_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_unsigned_short_int)
    {
        printf("PointerToArrayBase_unsigned_short_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< unsigned short int > * local_this = (PointerToArrayBase< unsigned short int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_unsigned_short_int)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
        return ( PointerToBase< ReferenceCountedVector< unsigned short int > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< unsigned short int > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_unsigned_short_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_unsigned_short_int)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
    {
          PointerToBase< ReferenceCountedVector< unsigned short int > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned short int > >*)from_this;
          return (PointerToArrayBase< unsigned short int >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< unsigned short int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< unsigned short int > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< unsigned short int > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_clear_20(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< unsigned short int > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< unsigned short int > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_clear_20_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_clear_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< unsigned short int > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_output_21(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< unsigned short int > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< unsigned short int > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< unsigned short int > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_output_21_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_output_21_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_unsigned_short_int(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< unsigned short int > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_unsigned_short_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
    {
        printf("PointerToBase_ReferenceCountedVector_unsigned_short_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< unsigned short int > > * local_this = (PointerToBase< ReferenceCountedVector< unsigned short int > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_unsigned_short_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< unsigned short int > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DoubleBitMask< BitMask< unsigned int, 32 > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > &::DoubleBitMask< BitMask< unsigned int, 32 > >::operator =(DoubleBitMask< BitMask< unsigned int, 32 > > const &copy)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_34(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > &::DoubleBitMask< BitMask< unsigned int, 32 > >::operator =(DoubleBitMask< BitMask< unsigned int, 32 > > const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const DoubleBitMask this, const DoubleBitMask copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_34_comment =
    "C++ Interface:\n"
    "assign(non-const DoubleBitMask this, const DoubleBitMask copy)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::all_on(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_on_35(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::all_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOn", key_word_list))
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ::DoubleBitMask< BitMask< unsigned int, 32 > >::all_on();
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_on_35_comment =
    "C++ Interface:\n"
    "allOn()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_on_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::all_off(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_off_36(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::all_off(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOff", key_word_list))
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ::DoubleBitMask< BitMask< unsigned int, 32 > >::all_off();
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOff()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_off_36_comment =
    "C++ Interface:\n"
    "allOff()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_off_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::lower_on(int on_bits)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_lower_on_37(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::lower_on(int on_bits)
        int param0;
        static char * key_word_list[] = {(char *)"on_bits", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:lowerOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:lowerOn", &param0));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ::DoubleBitMask< BitMask< unsigned int, 32 > >::lower_on((int)param0);
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lowerOn(int on_bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_lower_on_37_comment =
    "C++ Interface:\n"
    "lowerOn(int on_bits)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_lower_on_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::bit(int index)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_bit_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::bit(int index)
        int param0;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:bit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:bit", &param0));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ::DoubleBitMask< BitMask< unsigned int, 32 > >::bit((int)param0);
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bit(int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_bit_38_comment =
    "C++ Interface:\n"
    "bit(int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_bit_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_range_39(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::range(int low_bit, int size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:range", key_word_list, &param0, &param1))
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ::DoubleBitMask< BitMask< unsigned int, 32 > >::range((int)param0, (int)param1);
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "range(int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_range_39_comment =
    "C++ Interface:\n"
    "range(int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_range_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_41(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxNumBits", key_word_list))
        {
            bool return_value = ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_41_comment =
    "C++ Interface:\n"
    "hasMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_42(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxNumBits", key_word_list))
        {
            int return_value = ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_42_comment =
    "C++ Interface:\n"
    "getMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_43(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBits", key_word_list))
        {
            int return_value = ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_43_comment =
    "C++ Interface:\n"
    "getNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_bit_44(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_bit(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBit(const DoubleBitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_bit_44_comment =
    "C++ Interface:\n"
    "getBit(const DoubleBitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_bit_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_bit(int index)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_45(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBit(non-const DoubleBitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_45_comment =
    "C++ Interface:\n"
    "setBit(non-const DoubleBitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::clear_bit(int index)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_46(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::clear_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.clearBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBit(non-const DoubleBitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_46_comment =
    "C++ Interface:\n"
    "clearBit(non-const DoubleBitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_bit_to(int index, bool value)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_47(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_bit_to(int index, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBitTo", key_word_list, &param1, &param2))
        {
            (local_this)->set_bit_to((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setBitTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBitTo(non-const DoubleBitMask this, int index, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_47_comment =
    "C++ Interface:\n"
    "setBitTo(non-const DoubleBitMask this, int index, bool value)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::is_zero(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_zero_48(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::is_zero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isZero", key_word_list));
        else
            (PyArg_Parse(args, ":isZero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->is_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isZero(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_zero_48_comment =
    "C++ Interface:\n"
    "isZero(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_zero_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::is_all_on(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_49(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::is_all_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAllOn", key_word_list));
        else
            (PyArg_Parse(args, ":isAllOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->is_all_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAllOn(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_49_comment =
    "C++ Interface:\n"
    "isAllOn(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::DoubleBitMask< BitMask< unsigned int, 32 > >::extract(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_extract_50(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::DoubleBitMask< BitMask< unsigned int, 32 > >::extract(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:extract", key_word_list, &param1, &param2))
        {
            unsigned int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->extract((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extract(const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_extract_50_comment =
    "C++ Interface:\n"
    "extract(const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_extract_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::store(unsigned int value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_store_51(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::store(unsigned int value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:store", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->store(PyLong_AsUnsignedLong(param1_uint), (int)param2, (int)param3);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.store() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store(non-const DoubleBitMask this, unsigned int value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_store_51_comment =
    "C++ Interface:\n"
    "store(non-const DoubleBitMask this, unsigned int value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_store_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_any_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_52(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_any_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAnyOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->has_any_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnyOf(const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_52_comment =
    "C++ Interface:\n"
    "hasAnyOf(const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_all_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_53(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_all_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAllOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->has_all_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAllOf(const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_53_comment =
    "C++ Interface:\n"
    "hasAllOf(const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_54(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_54_comment =
    "C++ Interface:\n"
    "setRange(non-const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::clear_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_range_55(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::clear_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clearRange", key_word_list, &param1, &param2))
        {
            (local_this)->clear_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.clearRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRange(non-const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_range_55_comment =
    "C++ Interface:\n"
    "clearRange(non-const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_range_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_range_to(bool value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_56(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::set_range_to(bool value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setRangeTo", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_range_to((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setRangeTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRangeTo(non-const DoubleBitMask this, bool value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_56_comment =
    "C++ Interface:\n"
    "setRangeTo(non-const DoubleBitMask this, bool value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_on_bits(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_57(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_on_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOnBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOnBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_num_on_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOnBits(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_57_comment =
    "C++ Interface:\n"
    "getNumOnBits(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_off_bits(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_58(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_num_off_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOffBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOffBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_num_off_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOffBits(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_58_comment =
    "C++ Interface:\n"
    "getNumOffBits(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_lowest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_59(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_lowest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_lowest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOnBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_59_comment =
    "C++ Interface:\n"
    "getLowestOnBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_lowest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_60(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_lowest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_lowest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOffBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_60_comment =
    "C++ Interface:\n"
    "getLowestOffBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_highest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_61(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_highest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_highest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOnBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_61_comment =
    "C++ Interface:\n"
    "getHighestOnBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_highest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_62(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_highest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_highest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOffBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_62_comment =
    "C++ Interface:\n"
    "getHighestOffBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_next_higher_different_bit(int low_bit) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_63(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_next_higher_different_bit(int low_bit) const
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNextHigherDifferentBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNextHigherDifferentBit", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->get_next_higher_different_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextHigherDifferentBit(const DoubleBitMask this, int low_bit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_63_comment =
    "C++ Interface:\n"
    "getNextHigherDifferentBit(const DoubleBitMask this, int low_bit)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::invert_in_place(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_64(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::invert_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":invertInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":invertInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->invert_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.invertInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "invertInPlace(non-const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_64_comment =
    "C++ Interface:\n"
    "invertInPlace(non-const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_bits_in_common(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_65(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::has_bits_in_common(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasBitsInCommon", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasBitsInCommon", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.hasBitsInCommon", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->has_bits_in_common(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBitsInCommon(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_65_comment =
    "C++ Interface:\n"
    "hasBitsInCommon(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_66(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_66_comment =
    "C++ Interface:\n"
    "clear(non-const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_67(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DoubleBitMask this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_67_comment =
    "C++ Interface:\n"
    "output(const DoubleBitMask this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_binary(ostream &out, int spaces_every) const
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_binary(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_binary_68(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_binary(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBinary", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputBinary", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->output_binary(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_binary(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputBinary", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->output_binary(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputBinary() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputBinary(const DoubleBitMask this, non-const Ostream out)\n"
          "outputBinary(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_binary_68_comment =
    "C++ Interface:\n"
    "outputBinary(const DoubleBitMask this, non-const Ostream out)\n"
    "outputBinary(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_binary_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_hex(ostream &out, int spaces_every) const
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_hex(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_hex_69(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_hex(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputHex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputHex", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->output_hex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::output_hex(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputHex", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->output_hex(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputHex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputHex(const DoubleBitMask this, non-const Ostream out)\n"
          "outputHex(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_hex_69_comment =
    "C++ Interface:\n"
    "outputHex(const DoubleBitMask this, non-const Ostream out)\n"
    "outputHex(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_hex_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::write(ostream &out, int indent_level) const
 * void ::DoubleBitMask< BitMask< unsigned int, 32 > >::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_write_70(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< BitMask< unsigned int, 32 > >::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DoubleBitMask this, non-const Ostream out)\n"
          "write(const DoubleBitMask this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_write_70_comment =
    "C++ Interface:\n"
    "write(const DoubleBitMask this, non-const Ostream out)\n"
    "write(const DoubleBitMask this, non-const Ostream out, int indent_level)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_write_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ==(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_71(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ==(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_71_comment =
    "C++ Interface:\n"
    "eq(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator !=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_72(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator !=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_72_comment =
    "C++ Interface:\n"
    "ne(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator <(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_73(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator <(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_73_comment =
    "C++ Interface:\n"
    "lessThan(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::compare_to(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_compare_to_74(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int ::DoubleBitMask< BitMask< unsigned int, 32 > >::compare_to(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_compare_to_74_comment =
    "C++ Interface:\n"
    "compareTo(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_compare_to_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator &(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator &(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    DoubleBitMask< BitMask< unsigned int, 32 > > result = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator &(*param1_this);
                    DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75_comment =
    "C++ Interface:\n"
    "__and__(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator |(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator |(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    DoubleBitMask< BitMask< unsigned int, 32 > > result = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator |(*param1_this);
                    DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76_comment =
    "C++ Interface:\n"
    "__or__(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ^(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ^(DoubleBitMask< BitMask< unsigned int, 32 > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__xor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__xor__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__xor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    DoubleBitMask< BitMask< unsigned int, 32 > > result = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator ^(*param1_this);
                    DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__xor__(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77_comment =
    "C++ Interface:\n"
    "__xor__(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ~(void) const
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator ~();
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78_comment =
    "C++ Interface:\n"
    "__invert__(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator <<(int shift) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator <<(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__lshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__lshift__", &param1));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator <<((int)param1);
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__lshift__(const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79_comment =
    "C++ Interface:\n"
    "__lshift__(const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator >>(int shift) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline DoubleBitMask< BitMask< unsigned int, 32 > > ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator >>(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__rshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__rshift__", &param1));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< BitMask< unsigned int, 32 > > result = ((const DoubleBitMask< BitMask< unsigned int, 32 > >*)local_this)->operator >>((int)param1);
            DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__rshift__(const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80_comment =
    "C++ Interface:\n"
    "__rshift__(const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator &=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator &=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81_comment =
    "C++ Interface:\n"
    "__iand__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator |=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_82(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator |=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_82_comment =
    "C++ Interface:\n"
    "__ior__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ^=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator ^=(DoubleBitMask< BitMask< unsigned int, 32 > > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ixor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ixor__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *param1_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__ixor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator ^=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.__ixor__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ixor__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83_comment =
    "C++ Interface:\n"
    "__ixor__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator <<=(int shift)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator <<=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__ilshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__ilshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator <<=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.__ilshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ilshift__(non-const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84_comment =
    "C++ Interface:\n"
    "__ilshift__(non-const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator >>=(int shift)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< BitMask< unsigned int, 32 > >::operator >>=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__irshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__irshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator >>=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.__irshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__irshift__(non-const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85_comment =
    "C++ Interface:\n"
    "__irshift__(non-const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_86(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::DoubleBitMask< BitMask< unsigned int, 32 > >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_86_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::DoubleBitMask< BitMask< unsigned int, 32 > >::DoubleBitMask(void)
 * inline ::DoubleBitMask< BitMask< unsigned int, 32 > >::DoubleBitMask(DoubleBitMask< BitMask< unsigned int, 32 > > const &copy)
 *******************************************************************/
int  Dtool_Init_DoubleBitMask_BitMask_unsigned_int_32(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::DoubleBitMask< BitMask< unsigned int, 32 > >::DoubleBitMask(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DoubleBitMask", key_word_list))
            {
                DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline ::DoubleBitMask< BitMask< unsigned int, 32 > >::DoubleBitMask(DoubleBitMask< BitMask< unsigned int, 32 > > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DoubleBitMask", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DoubleBitMask", &param0));
                if(!PyErr_Occurred())
                {
                    DoubleBitMask< BitMask< unsigned int, 32 > > *param0_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DoubleBitMask_BitMask_unsigned_int_32, 0, "DoubleBitMask.DoubleBitMask", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DoubleBitMask< BitMask< unsigned int, 32 > > *return_value = new DoubleBitMask< BitMask< unsigned int, 32 > >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DoubleBitMask() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DoubleBitMask()\n"
          "DoubleBitMask(const DoubleBitMask copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DoubleBitMask_BitMask_unsigned_int_32(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DoubleBitMask_BitMask_unsigned_int_32)
    {
        printf("DoubleBitMask_BitMask_unsigned_int_32 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = (DoubleBitMask< BitMask< unsigned int, 32 > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DoubleBitMask_BitMask_unsigned_int_32)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DoubleBitMask_BitMask_unsigned_int_32(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DoubleBitMask_BitMask_unsigned_int_32)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > &::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator =(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &copy)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_89(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > &::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator =(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const DoubleBitMask this, const DoubleBitMask copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_89_comment =
    "C++ Interface:\n"
    "assign(non-const DoubleBitMask this, const DoubleBitMask copy)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::all_on(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_on_90(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::all_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOn", key_word_list))
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::all_on();
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_on_90_comment =
    "C++ Interface:\n"
    "allOn()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_on_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::all_off(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_off_91(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::all_off(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOff", key_word_list))
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::all_off();
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOff()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_off_91_comment =
    "C++ Interface:\n"
    "allOff()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_off_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::lower_on(int on_bits)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_lower_on_92(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::lower_on(int on_bits)
        int param0;
        static char * key_word_list[] = {(char *)"on_bits", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:lowerOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:lowerOn", &param0));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::lower_on((int)param0);
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lowerOn(int on_bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_lower_on_92_comment =
    "C++ Interface:\n"
    "lowerOn(int on_bits)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_lower_on_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::bit(int index)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_bit_93(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::bit(int index)
        int param0;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:bit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:bit", &param0));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::bit((int)param0);
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bit(int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_bit_93_comment =
    "C++ Interface:\n"
    "bit(int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_bit_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_range_94(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::range(int low_bit, int size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:range", key_word_list, &param0, &param1))
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::range((int)param0, (int)param1);
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "range(int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_range_94_comment =
    "C++ Interface:\n"
    "range(int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_range_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_96(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxNumBits", key_word_list))
        {
            bool return_value = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_96_comment =
    "C++ Interface:\n"
    "hasMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_97(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxNumBits", key_word_list))
        {
            int return_value = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_97_comment =
    "C++ Interface:\n"
    "getMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_98(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBits", key_word_list))
        {
            int return_value = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_98_comment =
    "C++ Interface:\n"
    "getNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_bit_99(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_bit(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBit(const DoubleBitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_bit_99_comment =
    "C++ Interface:\n"
    "getBit(const DoubleBitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_bit_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_bit(int index)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_100(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBit(non-const DoubleBitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_100_comment =
    "C++ Interface:\n"
    "setBit(non-const DoubleBitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::clear_bit(int index)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_101(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::clear_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.clearBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBit(non-const DoubleBitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_101_comment =
    "C++ Interface:\n"
    "clearBit(non-const DoubleBitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_bit_to(int index, bool value)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_102(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_bit_to(int index, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBitTo", key_word_list, &param1, &param2))
        {
            (local_this)->set_bit_to((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setBitTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBitTo(non-const DoubleBitMask this, int index, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_102_comment =
    "C++ Interface:\n"
    "setBitTo(non-const DoubleBitMask this, int index, bool value)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::is_zero(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_zero_103(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::is_zero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isZero", key_word_list));
        else
            (PyArg_Parse(args, ":isZero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->is_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isZero(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_zero_103_comment =
    "C++ Interface:\n"
    "isZero(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_zero_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::is_all_on(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_104(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::is_all_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAllOn", key_word_list));
        else
            (PyArg_Parse(args, ":isAllOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->is_all_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAllOn(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_104_comment =
    "C++ Interface:\n"
    "isAllOn(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::extract(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_extract_105(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::extract(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:extract", key_word_list, &param1, &param2))
        {
            unsigned int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->extract((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extract(const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_extract_105_comment =
    "C++ Interface:\n"
    "extract(const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_extract_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::store(unsigned int value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_store_106(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::store(unsigned int value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:store", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->store(PyLong_AsUnsignedLong(param1_uint), (int)param2, (int)param3);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.store() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store(non-const DoubleBitMask this, unsigned int value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_store_106_comment =
    "C++ Interface:\n"
    "store(non-const DoubleBitMask this, unsigned int value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_store_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_any_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_107(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_any_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAnyOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->has_any_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnyOf(const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_107_comment =
    "C++ Interface:\n"
    "hasAnyOf(const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_all_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_108(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_all_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAllOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->has_all_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAllOf(const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_108_comment =
    "C++ Interface:\n"
    "hasAllOf(const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_109(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_109_comment =
    "C++ Interface:\n"
    "setRange(non-const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::clear_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_range_110(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::clear_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clearRange", key_word_list, &param1, &param2))
        {
            (local_this)->clear_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.clearRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRange(non-const DoubleBitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_range_110_comment =
    "C++ Interface:\n"
    "clearRange(non-const DoubleBitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_range_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_range_to(bool value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_111(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::set_range_to(bool value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setRangeTo", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_range_to((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.setRangeTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRangeTo(non-const DoubleBitMask this, bool value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_111_comment =
    "C++ Interface:\n"
    "setRangeTo(non-const DoubleBitMask this, bool value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_on_bits(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_112(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_on_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOnBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOnBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_num_on_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOnBits(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_112_comment =
    "C++ Interface:\n"
    "getNumOnBits(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_off_bits(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_113(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_num_off_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOffBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOffBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_num_off_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOffBits(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_113_comment =
    "C++ Interface:\n"
    "getNumOffBits(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_lowest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_114(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_lowest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_lowest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOnBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_114_comment =
    "C++ Interface:\n"
    "getLowestOnBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_lowest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_115(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_lowest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_lowest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOffBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_115_comment =
    "C++ Interface:\n"
    "getLowestOffBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_highest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_116(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_highest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_highest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOnBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_116_comment =
    "C++ Interface:\n"
    "getHighestOnBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_highest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_117(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_highest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_highest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOffBit(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_117_comment =
    "C++ Interface:\n"
    "getHighestOffBit(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_next_higher_different_bit(int low_bit) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_118(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_next_higher_different_bit(int low_bit) const
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNextHigherDifferentBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNextHigherDifferentBit", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->get_next_higher_different_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextHigherDifferentBit(const DoubleBitMask this, int low_bit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_118_comment =
    "C++ Interface:\n"
    "getNextHigherDifferentBit(const DoubleBitMask this, int low_bit)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::invert_in_place(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_119(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::invert_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":invertInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":invertInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->invert_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.invertInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "invertInPlace(non-const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_119_comment =
    "C++ Interface:\n"
    "invertInPlace(non-const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_bits_in_common(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_120(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::has_bits_in_common(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasBitsInCommon", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasBitsInCommon", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.hasBitsInCommon", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->has_bits_in_common(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBitsInCommon(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_120_comment =
    "C++ Interface:\n"
    "hasBitsInCommon(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_121(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_121_comment =
    "C++ Interface:\n"
    "clear(non-const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_122(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DoubleBitMask this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_122_comment =
    "C++ Interface:\n"
    "output(const DoubleBitMask this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_binary(ostream &out, int spaces_every) const
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_binary(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_binary_123(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_binary(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBinary", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputBinary", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->output_binary(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_binary(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputBinary", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->output_binary(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputBinary() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputBinary(const DoubleBitMask this, non-const Ostream out)\n"
          "outputBinary(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_binary_123_comment =
    "C++ Interface:\n"
    "outputBinary(const DoubleBitMask this, non-const Ostream out)\n"
    "outputBinary(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_binary_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_hex(ostream &out, int spaces_every) const
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_hex(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_hex_124(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_hex(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputHex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputHex", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->output_hex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::output_hex(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputHex", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->output_hex(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputHex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputHex(const DoubleBitMask this, non-const Ostream out)\n"
          "outputHex(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_hex_124_comment =
    "C++ Interface:\n"
    "outputHex(const DoubleBitMask this, non-const Ostream out)\n"
    "outputHex(const DoubleBitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_hex_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::write(ostream &out, int indent_level) const
 * void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_write_125(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DoubleBitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DoubleBitMask this, non-const Ostream out)\n"
          "write(const DoubleBitMask this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_write_125_comment =
    "C++ Interface:\n"
    "write(const DoubleBitMask this, non-const Ostream out)\n"
    "write(const DoubleBitMask this, non-const Ostream out, int indent_level)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_write_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ==(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_126(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ==(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_126_comment =
    "C++ Interface:\n"
    "eq(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator !=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator !=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_127_comment =
    "C++ Interface:\n"
    "ne(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator <(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_128(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator <(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_128_comment =
    "C++ Interface:\n"
    "lessThan(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::compare_to(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_compare_to_129(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::compare_to(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_compare_to_129_comment =
    "C++ Interface:\n"
    "compareTo(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_compare_to_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator &(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator &(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator &(*param1_this);
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130_comment =
    "C++ Interface:\n"
    "__and__(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator |(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator |(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator |(*param1_this);
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131_comment =
    "C++ Interface:\n"
    "__or__(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ^(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ^(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__xor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__xor__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__xor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator ^(*param1_this);
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__xor__(const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132_comment =
    "C++ Interface:\n"
    "__xor__(const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ~(void) const
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator ~();
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const DoubleBitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133_comment =
    "C++ Interface:\n"
    "__invert__(const DoubleBitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator <<(int shift) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator <<(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__lshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__lshift__", &param1));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator <<((int)param1);
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__lshift__(const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134_comment =
    "C++ Interface:\n"
    "__lshift__(const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator >>(int shift) const
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator >>(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__rshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__rshift__", &param1));
        if(!PyErr_Occurred())
        {
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > result = ((const DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >*)local_this)->operator >>((int)param1);
            DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__rshift__(const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135_comment =
    "C++ Interface:\n"
    "__rshift__(const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator &=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator &=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136_comment =
    "C++ Interface:\n"
    "__iand__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator |=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_137(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator |=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_137_comment =
    "C++ Interface:\n"
    "__ior__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ^=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator ^=(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ixor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ixor__", &param1));
            if(!PyErr_Occurred())
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param1_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 1, "DoubleBitMask.__ixor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator ^=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DoubleBitMask.__ixor__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ixor__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138_comment =
    "C++ Interface:\n"
    "__ixor__(non-const DoubleBitMask this, const DoubleBitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator <<=(int shift)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator <<=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__ilshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__ilshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator <<=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.__ilshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ilshift__(non-const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139_comment =
    "C++ Interface:\n"
    "__ilshift__(non-const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator >>=(int shift)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140(PyObject *self, PyObject *args,PyObject *kwds) {
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::operator >>=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__irshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__irshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator >>=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DoubleBitMask.__irshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__irshift__(non-const DoubleBitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140_comment =
    "C++ Interface:\n"
    "__irshift__(non-const DoubleBitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_141(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_141_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::DoubleBitMask(void)
 * inline ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::DoubleBitMask(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &copy)
 *******************************************************************/
int  Dtool_Init_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::DoubleBitMask(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DoubleBitMask", key_word_list))
            {
                DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline ::DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::DoubleBitMask(DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DoubleBitMask", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DoubleBitMask", &param0));
                if(!PyErr_Occurred())
                {
                    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *param0_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32, 0, "DoubleBitMask.DoubleBitMask", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *return_value = new DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DoubleBitMask() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DoubleBitMask()\n"
          "DoubleBitMask(const DoubleBitMask copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32)
    {
        printf("DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = (DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< double > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< double > ::PointerToArray< double >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< double > ::PointerToArray< double >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((double const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_empty_array_144(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< double > ::PointerToArray< double >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((double const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< double > result = ::PointerToArray< double >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< double > *return_value = new PointerToArray< double >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_double,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< double > ::PointerToArray< double >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< double > result = ::PointerToArray< double >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< double > *return_value = new PointerToArray< double >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_double,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_empty_array_144_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_empty_array_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< double >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_size_145(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< double >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< double >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_size_145_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_size_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< double >::push_back(double const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_push_back_146(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< double >::push_back(double const &x)
        double param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:pushBack", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:pushBack", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->push_back((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.pushBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, float x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_push_back_146_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, float x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_push_back_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< double >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_pop_back_147(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< double >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_pop_back_147_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_pop_back_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double const &::PointerToArray< double >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_get_element_148(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double const &::PointerToArray< double >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                double return_value = ((const PointerToArray< double >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_get_element_148_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_get_element_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< double >::set_element(unsigned int n, double const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_set_element_149(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< double >::set_element(unsigned int n, double const &value)
        PyObject *param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setElement", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), (double)param2);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setElement() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_set_element_149_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_set_element_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double const &::PointerToArray< double >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_getitem_150(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double const &::PointerToArray< double >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< double >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                double return_value = ((const PointerToArray< double >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_getitem_150_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_getitem_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< double >::__setitem__(unsigned int n, double const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_setitem_151(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< double >::__setitem__(unsigned int n, double const &value)
        PyObject *param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:Setitem", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), (double)param2);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.Setitem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_setitem_151_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_setitem_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< double >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_get_data_152(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< double >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< double >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_get_data_152_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_get_data_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< double >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_set_data_153(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< double >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_set_data_153_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_set_data_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< double >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_get_subdata_154(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< double >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< double >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_get_subdata_154_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_get_subdata_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< double >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_set_subdata_155(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< double >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_set_subdata_155_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_set_subdata_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< double >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_get_ref_count_156(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< double >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< double >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_get_ref_count_156_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_get_ref_count_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< double >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_double_get_node_ref_count_157(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< double > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_double,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< double >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< double >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_double_get_node_ref_count_157_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_double_get_node_ref_count_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
 * ::PointerToArray< double >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< double >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< double >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((double const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_double(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< double >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((double const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< double > *return_value = new PointerToArray< double >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_double,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< double > *param0_this = (PointerToArray< double > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_double, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_double,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< double >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_double,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< double >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_double, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< double > *return_value = new PointerToArray< double >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_double,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_double(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_double)
    {
        printf("PointerToArray_double ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< double > * local_this = (PointerToArray< double > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_double)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_double)
        return ( PointerToArrayBase< double > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
        return ( PointerToBase< ReferenceCountedVector< double > > *)( PointerToArrayBase< double > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< double > > *)( PointerToArrayBase< double > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_double(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_double)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_double)
    {
          PointerToArrayBase< double >* other_this = (PointerToArrayBase< double >*)from_this;
          return (PointerToArray< double >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_double)
    {
          PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
          return (PointerToArray< double >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< double >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< unsigned short int > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< unsigned short int > ::PointerToArray< unsigned short int >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< unsigned short int > ::PointerToArray< unsigned short int >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((unsigned short int const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_empty_array_161(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< unsigned short int > ::PointerToArray< unsigned short int >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((unsigned short int const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< unsigned short int > result = ::PointerToArray< unsigned short int >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< unsigned short int > *return_value = new PointerToArray< unsigned short int >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_unsigned_short_int,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< unsigned short int > ::PointerToArray< unsigned short int >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< unsigned short int > result = ::PointerToArray< unsigned short int >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< unsigned short int > *return_value = new PointerToArray< unsigned short int >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_unsigned_short_int,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_empty_array_161_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_empty_array_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< unsigned short int >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_size_162(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< unsigned short int >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< unsigned short int >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_size_162_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_size_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned short int >::push_back(unsigned short int const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_push_back_163(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned short int >::push_back(unsigned short int const &x)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:pushBack", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->push_back(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.pushBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, unsigned int x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_push_back_163_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, unsigned int x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_push_back_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned short int >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_pop_back_164(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned short int >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_pop_back_164_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_pop_back_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int const &::PointerToArray< unsigned short int >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_get_element_165(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int const &::PointerToArray< unsigned short int >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                unsigned short int return_value = ((const PointerToArray< unsigned short int >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_get_element_165_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_get_element_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned short int >::set_element(unsigned int n, unsigned short int const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_set_element_166(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned short int >::set_element(unsigned int n, unsigned short int const &value)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setElement() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_set_element_166_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_set_element_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int const &::PointerToArray< unsigned short int >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_getitem_167(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int const &::PointerToArray< unsigned short int >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< unsigned short int >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                unsigned short int return_value = ((const PointerToArray< unsigned short int >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_getitem_167_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_getitem_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned short int >::__setitem__(unsigned int n, unsigned short int const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_setitem_168(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned short int >::__setitem__(unsigned int n, unsigned short int const &value)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.Setitem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_setitem_168_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_setitem_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< unsigned short int >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_get_data_169(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< unsigned short int >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< unsigned short int >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_get_data_169_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_get_data_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned short int >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_set_data_170(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned short int >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_set_data_170_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_set_data_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< unsigned short int >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_get_subdata_171(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< unsigned short int >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< unsigned short int >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_get_subdata_171_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_get_subdata_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned short int >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_set_subdata_172(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned short int >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_set_subdata_172_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_set_subdata_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< unsigned short int >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_get_ref_count_173(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< unsigned short int >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< unsigned short int >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_get_ref_count_173_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_get_ref_count_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< unsigned short int >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_short_int_get_node_ref_count_174(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned short int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< unsigned short int >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< unsigned short int >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_short_int_get_node_ref_count_174_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_short_int_get_node_ref_count_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< unsigned short int >::PointerToArray(PointerToArray< unsigned short int > const &copy)
 * ::PointerToArray< unsigned short int >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< unsigned short int >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< unsigned short int >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((unsigned short int const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_unsigned_short_int(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< unsigned short int >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((unsigned short int const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< unsigned short int > *return_value = new PointerToArray< unsigned short int >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_short_int,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< unsigned short int >::PointerToArray(PointerToArray< unsigned short int > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< unsigned short int > *param0_this = (PointerToArray< unsigned short int > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_unsigned_short_int, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< unsigned short int > *return_value = new PointerToArray< unsigned short int >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_short_int,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< unsigned short int >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< unsigned short int > *return_value = new PointerToArray< unsigned short int >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_short_int,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< unsigned short int >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_unsigned_short_int, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< unsigned short int > *return_value = new PointerToArray< unsigned short int >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_short_int,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_unsigned_short_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_unsigned_short_int)
    {
        printf("PointerToArray_unsigned_short_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< unsigned short int > * local_this = (PointerToArray< unsigned short int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_unsigned_short_int)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_unsigned_short_int)
        return ( PointerToArrayBase< unsigned short int > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
        return ( PointerToBase< ReferenceCountedVector< unsigned short int > > *)( PointerToArrayBase< unsigned short int > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< unsigned short int > > *)( PointerToArrayBase< unsigned short int > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_unsigned_short_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_unsigned_short_int)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_unsigned_short_int)
    {
          PointerToArrayBase< unsigned short int >* other_this = (PointerToArrayBase< unsigned short int >*)from_this;
          return (PointerToArray< unsigned short int >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int)
    {
          PointerToBase< ReferenceCountedVector< unsigned short int > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned short int > >*)from_this;
          return (PointerToArray< unsigned short int >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< unsigned short int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. basic_string< char > 
//********************************************************************
int  Dtool_Init_basic_string_char(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (basic_string< char >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_basic_string_char(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_basic_string_char)
    {
        printf("basic_string_char ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    basic_string< char > * local_this = (basic_string< char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_basic_string_char)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_basic_string_char(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_basic_string_char)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimInterface 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void AnimInterface::play(void)
 * inline void AnimInterface::play(double from, double to)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_play_179(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimInterface::play(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":play", key_word_list));
            else
                (PyArg_Parse(args, ":play"));
            if(!PyErr_Occurred())
            {
                (local_this)->play();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimInterface.play() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimInterface::play(double from, double to)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:play", key_word_list, &param1, &param2))
            {
                (local_this)->play((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimInterface.play() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "play() takes 1 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "play(non-const AnimInterface this)\n"
          "play(non-const AnimInterface this, float from, float to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_play_179_comment =
    "C++ Interface:\n"
    "play(non-const AnimInterface this)\n"
    "play(non-const AnimInterface this, float from, float to)\n"
    "\n"
    "// Filename: animInterface.I\n"
    "// Created by:  drose (20Sep05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::play\n"
    "//       Access: Published\n"
    "//  Description: Runs the entire animation from beginning to end and\n"
    "//               stops.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::play\n"
    "//       Access: Published\n"
    "//  Description: Runs the animation from the frame \"from\" to and\n"
    "//               including the frame \"to\", at which point the\n"
    "//               animation is stopped.  Both \"from\" and \"to\" frame\n"
    "//               numbers may be outside the range (0,\n"
    "//               get_num_frames()) and the animation will follow the\n"
    "//               range correctly, reporting numbers modulo\n"
    "//               get_num_frames().  For instance, play(0,\n"
    "//               get_num_frames() * 2) will play the animation twice\n"
    "//               and then stop.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_play_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimInterface::loop(bool restart)
 * inline void AnimInterface::loop(bool restart, double from, double to)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_loop_180(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimInterface::loop(bool restart)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"restart", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:loop", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:loop", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->loop((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimInterface.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimInterface::loop(bool restart, double from, double to)
            PyObject *param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"restart", (char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:loop", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->loop((PyObject_IsTrue(param1)!=0), (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimInterface.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "loop() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "loop(non-const AnimInterface this, bool restart)\n"
          "loop(non-const AnimInterface this, bool restart, float from, float to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_loop_180_comment =
    "C++ Interface:\n"
    "loop(non-const AnimInterface this, bool restart)\n"
    "loop(non-const AnimInterface this, bool restart, float from, float to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::loop\n"
    "//       Access: Published\n"
    "//  Description: Starts the entire animation looping.  If restart is\n"
    "//               true, the animation is restarted from the beginning;\n"
    "//               otherwise, it continues from the current frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::loop\n"
    "//       Access: Published\n"
    "//  Description: Loops the animation from the frame \"from\" to and\n"
    "//               including the frame \"to\", indefinitely.  If restart\n"
    "//               is true, the animation is restarted from the\n"
    "//               beginning; otherwise, it continues from the current\n"
    "//               frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_loop_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimInterface::pingpong(bool restart)
 * inline void AnimInterface::pingpong(bool restart, double from, double to)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_pingpong_181(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimInterface::pingpong(bool restart)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"restart", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pingpong", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pingpong", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->pingpong((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimInterface.pingpong() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimInterface::pingpong(bool restart, double from, double to)
            PyObject *param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"restart", (char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:pingpong", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->pingpong((PyObject_IsTrue(param1)!=0), (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimInterface.pingpong() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "pingpong() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "pingpong(non-const AnimInterface this, bool restart)\n"
          "pingpong(non-const AnimInterface this, bool restart, float from, float to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_pingpong_181_comment =
    "C++ Interface:\n"
    "pingpong(non-const AnimInterface this, bool restart)\n"
    "pingpong(non-const AnimInterface this, bool restart, float from, float to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::pingpong\n"
    "//       Access: Published\n"
    "//  Description: Starts the entire animation bouncing back and forth\n"
    "//               between its first frame and last frame.  If restart\n"
    "//               is true, the animation is restarted from the\n"
    "//               beginning; otherwise, it continues from the current\n"
    "//               frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::pingpong\n"
    "//       Access: Published\n"
    "//  Description: Loops the animation from the frame \"from\" to and\n"
    "//               including the frame \"to\", and then back in the\n"
    "//               opposite direction, indefinitely.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_pingpong_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimInterface::stop(void)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_stop_182(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnimInterface::stop(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stop", key_word_list));
        else
            (PyArg_Parse(args, ":stop"));
        if(!PyErr_Occurred())
        {
            (local_this)->stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimInterface.stop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stop(non-const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_stop_182_comment =
    "C++ Interface:\n"
    "stop(non-const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::stop\n"
    "//       Access: Published\n"
    "//  Description: Stops a currently playing or looping animation right\n"
    "//               where it is.  The animation remains posed at the\n"
    "//               current frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_stop_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimInterface::pose(double frame)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_pose_183(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnimInterface::pose(double frame)
        double param1;
        static char * key_word_list[] = {(char *)"frame", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:pose", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:pose", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->pose((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimInterface.pose() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pose(non-const AnimInterface this, float frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_pose_183_comment =
    "C++ Interface:\n"
    "pose(non-const AnimInterface this, float frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::pose\n"
    "//       Access: Published\n"
    "//  Description: Sets the animation to the indicated frame and holds\n"
    "//               it there.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_pose_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimInterface::set_play_rate(double play_rate)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_set_play_rate_184(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnimInterface::set_play_rate(double play_rate)
        double param1;
        static char * key_word_list[] = {(char *)"play_rate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPlayRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPlayRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_play_rate((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimInterface.setPlayRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlayRate(non-const AnimInterface this, float play_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_set_play_rate_184_comment =
    "C++ Interface:\n"
    "setPlayRate(non-const AnimInterface this, float play_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::set_play_rate\n"
    "//       Access: Published\n"
    "//  Description: Changes the rate at which the animation plays.  1.0\n"
    "//               is the normal speed, 2.0 is twice normal speed, and\n"
    "//               0.5 is half normal speed.  0.0 is legal to pause the\n"
    "//               animation, and a negative value will play the\n"
    "//               animation backwards.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_set_play_rate_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AnimInterface::get_play_rate(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_play_rate_185(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AnimInterface::get_play_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlayRate", key_word_list));
        else
            (PyArg_Parse(args, ":getPlayRate"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AnimInterface*)local_this)->get_play_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlayRate(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_play_rate_185_comment =
    "C++ Interface:\n"
    "getPlayRate(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_play_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the rate at which the animation plays.  See\n"
    "//               set_play_rate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_play_rate_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AnimInterface::get_frame_rate(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_frame_rate_186(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AnimInterface::get_frame_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameRate", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameRate"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AnimInterface*)local_this)->get_frame_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameRate(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_frame_rate_186_comment =
    "C++ Interface:\n"
    "getFrameRate(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_frame_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the native frame rate of the animation.  This\n"
    "//               is the number of frames per second that will elapse\n"
    "//               when the play_rate is set to 1.0.  It is a fixed\n"
    "//               property of the animation and may not be adjusted by\n"
    "//               the user.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_frame_rate_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int AnimInterface::get_num_frames(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_num_frames_187(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int AnimInterface::get_num_frames(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFrames", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFrames"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimInterface*)local_this)->get_num_frames();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFrames(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_num_frames_187_comment =
    "C++ Interface:\n"
    "getNumFrames(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_num_frames\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the number of frames in the animation.  This\n"
    "//               is a property of the animation and may not be\n"
    "//               directly adjusted by the user (although it may change\n"
    "//               without warning with certain kinds of animations,\n"
    "//               since this is a virtual method that may be\n"
    "//               overridden).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_num_frames_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimInterface::get_frame(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_frame_188(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnimInterface::get_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getFrame"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimInterface*)local_this)->get_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrame(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_frame_188_comment =
    "C++ Interface:\n"
    "getFrame(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the current integer frame number.\n"
    "//               This number will be in the range 0 <= f <\n"
    "//               get_num_frames().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_frame_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimInterface::get_next_frame(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_next_frame_189(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnimInterface::get_next_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNextFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getNextFrame"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimInterface*)local_this)->get_next_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextFrame(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_next_frame_189_comment =
    "C++ Interface:\n"
    "getNextFrame(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_next_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the current integer frame number + 1,\n"
    "//               constrained to the range 0 <= f < get_num_frames().\n"
    "//\n"
    "//               If the play mode is PM_play, this will clamp to the\n"
    "//               same value as get_frame() at the end of the\n"
    "//               animation.  If the play mode is any other value, this\n"
    "//               will wrap around to frame 0 at the end of the\n"
    "//               animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_next_frame_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AnimInterface::get_frac(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_frac_190(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AnimInterface::get_frac(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrac", key_word_list));
        else
            (PyArg_Parse(args, ":getFrac"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AnimInterface*)local_this)->get_frac();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrac(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_frac_190_comment =
    "C++ Interface:\n"
    "getFrac(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_frac\n"
    "//       Access: Published\n"
    "//  Description: Returns the fractional part of the current frame.\n"
    "//               Normally, this is in the range 0.0 <= f < 1.0, but in\n"
    "//               the one special case of an animation playing to its\n"
    "//               end frame and stopping, it might exactly equal 1.0.\n"
    "//\n"
    "//               It will always be true that get_full_frame() +\n"
    "//               get_frac() == get_full_fframe().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_frac_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimInterface::get_full_frame(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_full_frame_191(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnimInterface::get_full_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getFullFrame"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimInterface*)local_this)->get_full_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullFrame(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_full_frame_191_comment =
    "C++ Interface:\n"
    "getFullFrame(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_full_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the current integer frame number.\n"
    "//\n"
    "//               Unlike the value returned by get_frame(), this frame\n"
    "//               number may extend beyond the range of\n"
    "//               get_num_frames() if the frame range passed to play(),\n"
    "//               loop(), etc. did.\n"
    "//\n"
    "//               Unlike the value returned by get_full_fframe(), this\n"
    "//               return value will never exceed the value passed to\n"
    "//               to_frame in the play() method.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_full_frame_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AnimInterface::get_full_fframe(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_full_fframe_192(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AnimInterface::get_full_fframe(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullFframe", key_word_list));
        else
            (PyArg_Parse(args, ":getFullFframe"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AnimInterface*)local_this)->get_full_fframe();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullFframe(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_full_fframe_192_comment =
    "C++ Interface:\n"
    "getFullFframe(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::get_full_fframe\n"
    "//       Access: Published\n"
    "//  Description: Returns the current floating-point frame number.\n"
    "//\n"
    "//               Unlike the value returned by get_frame(), this frame\n"
    "//               number may extend beyond the range of\n"
    "//               get_num_frames() if the frame range passed to play(),\n"
    "//               loop(), etc. did.\n"
    "//\n"
    "//               Unlike the value returned by get_full_frame(), this\n"
    "//               return value may equal (to_frame + 1.0), when the\n"
    "//               animation has played to its natural end.  However, in\n"
    "//               this case the return value of get_full_frame() will\n"
    "//               be to_frame, not (to_frame + 1).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_get_full_fframe_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimInterface::is_playing(void) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_is_playing_193(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnimInterface::is_playing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPlaying", key_word_list));
        else
            (PyArg_Parse(args, ":isPlaying"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnimInterface*)local_this)->is_playing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPlaying(const AnimInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_is_playing_193_comment =
    "C++ Interface:\n"
    "isPlaying(const AnimInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::is_playing\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the animation is currently playing,\n"
    "//               false if it is stopped (e.g. because stop() or pose()\n"
    "//               was called, or because it reached the end of the\n"
    "//               animation after play() was called).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_is_playing_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AnimInterface::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AnimInterface_output_194(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AnimInterface::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimInterface.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimInterface*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AnimInterface this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_output_194_comment =
    "C++ Interface:\n"
    "output(const AnimInterface this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimInterface::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimInterface_output_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimInterface::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimInterface_get_class_type_195(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimInterface::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimInterface::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimInterface_get_class_type_195_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimInterface_get_class_type_195_comment = NULL;
#endif

int  Dtool_Init_AnimInterface(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimInterface)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimInterface(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimInterface)
    {
        printf("AnimInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimInterface * local_this = (AnimInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimInterface)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimInterface(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimInterface)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. UpdateSeq 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline UpdateSeq UpdateSeq::initial(void)
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_initial_198(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline UpdateSeq UpdateSeq::initial(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":initial", key_word_list))
        {
            UpdateSeq result = UpdateSeq::initial();
            UpdateSeq *return_value = new UpdateSeq(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initial()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_initial_198_comment =
    "C++ Interface:\n"
    "initial()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::initial (named constructor)\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns an UpdateSeq in the 'initial' state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_initial_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline UpdateSeq UpdateSeq::old(void)
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_old_199(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline UpdateSeq UpdateSeq::old(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":old", key_word_list))
        {
            UpdateSeq result = UpdateSeq::old();
            UpdateSeq *return_value = new UpdateSeq(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "old()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_old_199_comment =
    "C++ Interface:\n"
    "old()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::old (named constructor)\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns an UpdateSeq in the 'old' state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_old_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline UpdateSeq UpdateSeq::fresh(void)
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_fresh_200(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline UpdateSeq UpdateSeq::fresh(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":fresh", key_word_list))
        {
            UpdateSeq result = UpdateSeq::fresh();
            UpdateSeq *return_value = new UpdateSeq(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fresh()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_fresh_200_comment =
    "C++ Interface:\n"
    "fresh()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::fresh (named constructor)\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns an UpdateSeq in the 'fresh' state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_fresh_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline UpdateSeq &UpdateSeq::operator =(UpdateSeq const &copy)
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_201(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline UpdateSeq &UpdateSeq::operator =(UpdateSeq const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    UpdateSeq *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call UpdateSeq.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const UpdateSeq this, const UpdateSeq copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_201_comment =
    "C++ Interface:\n"
    "assign(non-const UpdateSeq this, const UpdateSeq copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Copy Assignment operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void UpdateSeq::clear(void)
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_clear_202(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void UpdateSeq::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UpdateSeq.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const UpdateSeq this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_clear_202_comment =
    "C++ Interface:\n"
    "clear(non-const UpdateSeq this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::clear\n"
    "//       Access: Published\n"
    "//  Description: Resets the UpdateSeq to the 'initial' state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_clear_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::is_initial(void) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_is_initial_203(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool UpdateSeq::is_initial(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isInitial", key_word_list));
        else
            (PyArg_Parse(args, ":isInitial"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const UpdateSeq*)local_this)->is_initial();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isInitial(const UpdateSeq this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_is_initial_203_comment =
    "C++ Interface:\n"
    "isInitial(const UpdateSeq this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::is_initial\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the UpdateSeq is in the 'initial'\n"
    "//               state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_is_initial_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::is_old(void) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_is_old_204(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool UpdateSeq::is_old(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOld", key_word_list));
        else
            (PyArg_Parse(args, ":isOld"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const UpdateSeq*)local_this)->is_old();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOld(const UpdateSeq this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_is_old_204_comment =
    "C++ Interface:\n"
    "isOld(const UpdateSeq this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::is_old\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the UpdateSeq is in the 'old' state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_is_old_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::is_fresh(void) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_is_fresh_205(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool UpdateSeq::is_fresh(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isFresh", key_word_list));
        else
            (PyArg_Parse(args, ":isFresh"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const UpdateSeq*)local_this)->is_fresh();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFresh(const UpdateSeq this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_is_fresh_205_comment =
    "C++ Interface:\n"
    "isFresh(const UpdateSeq this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::is_fresh\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the UpdateSeq is in the 'fresh'\n"
    "//               state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_is_fresh_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::is_special(void) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_is_special_206(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool UpdateSeq::is_special(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSpecial", key_word_list));
        else
            (PyArg_Parse(args, ":isSpecial"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const UpdateSeq*)local_this)->is_special();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSpecial(const UpdateSeq this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_is_special_206_comment =
    "C++ Interface:\n"
    "isSpecial(const UpdateSeq this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::is_special\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the UpdateSeq is in any special\n"
    "//               states, i.e. 'initial', 'old', or 'fresh'.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_is_special_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::operator ==(UpdateSeq const &other) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_207(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool UpdateSeq::operator ==(UpdateSeq const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const UpdateSeq*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const UpdateSeq this, const UpdateSeq other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_207_comment =
    "C++ Interface:\n"
    "eq(const UpdateSeq this, const UpdateSeq other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Equality operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::operator !=(UpdateSeq const &other) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_208(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool UpdateSeq::operator !=(UpdateSeq const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const UpdateSeq*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const UpdateSeq this, const UpdateSeq other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_208_comment =
    "C++ Interface:\n"
    "ne(const UpdateSeq this, const UpdateSeq other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Inequality operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::operator <(UpdateSeq const &other) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_209(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool UpdateSeq::operator <(UpdateSeq const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const UpdateSeq*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const UpdateSeq this, const UpdateSeq other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_209_comment =
    "C++ Interface:\n"
    "lessThan(const UpdateSeq this, const UpdateSeq other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Comparison operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::operator <=(UpdateSeq const &other) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_210(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool UpdateSeq::operator <=(UpdateSeq const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThanOrEqual", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThanOrEqual", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.lessThanOrEqual", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const UpdateSeq*)local_this)->operator <=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThanOrEqual(const UpdateSeq this, const UpdateSeq other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_210_comment =
    "C++ Interface:\n"
    "lessThanOrEqual(const UpdateSeq this, const UpdateSeq other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Comparison operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::operator >(UpdateSeq const &other) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_211(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool UpdateSeq::operator >(UpdateSeq const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:greaterThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:greaterThan", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.greaterThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const UpdateSeq*)local_this)->operator >(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "greaterThan(const UpdateSeq this, const UpdateSeq other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_211_comment =
    "C++ Interface:\n"
    "greaterThan(const UpdateSeq this, const UpdateSeq other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Comparison operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool UpdateSeq::operator >=(UpdateSeq const &other) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_212(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool UpdateSeq::operator >=(UpdateSeq const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:greaterThanOrEqual", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:greaterThanOrEqual", &param1));
            if(!PyErr_Occurred())
            {
                UpdateSeq *param1_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_UpdateSeq, 1, "UpdateSeq.greaterThanOrEqual", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const UpdateSeq*)local_this)->operator >=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "greaterThanOrEqual(const UpdateSeq this, const UpdateSeq other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_212_comment =
    "C++ Interface:\n"
    "greaterThanOrEqual(const UpdateSeq this, const UpdateSeq other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Comparison operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline UpdateSeq UpdateSeq::operator ++(void)
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_213(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline UpdateSeq UpdateSeq::operator ++(void)
        {
            UpdateSeq result = (local_this)->operator ++();
            UpdateSeq *return_value = new UpdateSeq(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UpdateSeq.increment() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "increment(non-const UpdateSeq this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_213_comment =
    "C++ Interface:\n"
    "increment(non-const UpdateSeq this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Preincrement operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline UpdateSeq UpdateSeq::operator ++(int )
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_operator_214(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline UpdateSeq UpdateSeq::operator ++(int )
        int param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:increment", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:increment", &param1));
        if(!PyErr_Occurred())
        {
            UpdateSeq result = (local_this)->operator ++((int)param1);
            UpdateSeq *return_value = new UpdateSeq(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UpdateSeq.increment() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "increment(non-const UpdateSeq this, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_operator_214_comment =
    "C++ Interface:\n"
    "increment(non-const UpdateSeq this, int)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::Postincrement operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_operator_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void UpdateSeq::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_UpdateSeq_output_215(PyObject *self, PyObject *args,PyObject *kwds) {
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void UpdateSeq::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "UpdateSeq.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const UpdateSeq*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const UpdateSeq this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UpdateSeq_output_215_comment =
    "C++ Interface:\n"
    "output(const UpdateSeq this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UpdateSeq::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UpdateSeq_output_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline UpdateSeq::UpdateSeq(void)
 * inline UpdateSeq::UpdateSeq(UpdateSeq const &copy)
 *******************************************************************/
int  Dtool_Init_UpdateSeq(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline UpdateSeq::UpdateSeq(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":UpdateSeq", key_word_list))
            {
                UpdateSeq *return_value = new UpdateSeq();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_UpdateSeq,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline UpdateSeq::UpdateSeq(UpdateSeq const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:UpdateSeq", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:UpdateSeq", &param0));
                if(!PyErr_Occurred())
                {
                    UpdateSeq *param0_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_UpdateSeq, 0, "UpdateSeq.UpdateSeq", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        UpdateSeq *return_value = new UpdateSeq(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_UpdateSeq,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "UpdateSeq() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "UpdateSeq()\n"
          "UpdateSeq(const UpdateSeq copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_UpdateSeq(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_UpdateSeq)
    {
        printf("UpdateSeq ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    UpdateSeq * local_this = (UpdateSeq *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_UpdateSeq)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_UpdateSeq(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_UpdateSeq)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypedWritable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void TypedWritable::mark_bam_modified(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritable_mark_bam_modified_219(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TypedWritable::mark_bam_modified(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":markBamModified", key_word_list));
        else
            (PyArg_Parse(args, ":markBamModified"));
        if(!PyErr_Occurred())
        {
            (local_this)->mark_bam_modified();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedWritable.markBamModified() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "markBamModified(non-const TypedWritable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_mark_bam_modified_219_comment =
    "C++ Interface:\n"
    "markBamModified(non-const TypedWritable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritable::mark_bam_modified\n"
    "//       Access: Public\n"
    "//  Description: Increments the bam_modified counter, so that this\n"
    "//               object will be invalidated and retransmitted on any\n"
    "//               open bam streams.  This should normally not need to\n"
    "//               be called by user code; it should be called\n"
    "//               internally when the object has been changed in a way\n"
    "//               that legitimately requires its retransmission to any\n"
    "//               connected clients.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedWritable_mark_bam_modified_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline UpdateSeq TypedWritable::get_bam_modified(void) const
 *******************************************************************/
static PyObject *Dtool_TypedWritable_get_bam_modified_220(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline UpdateSeq TypedWritable::get_bam_modified(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBamModified", key_word_list));
        else
            (PyArg_Parse(args, ":getBamModified"));
        if(!PyErr_Occurred())
        {
            UpdateSeq result = ((const TypedWritable*)local_this)->get_bam_modified();
            UpdateSeq *return_value = new UpdateSeq(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_UpdateSeq,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBamModified(const TypedWritable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_get_bam_modified_220_comment =
    "C++ Interface:\n"
    "getBamModified(const TypedWritable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritable::get_bam_modified\n"
    "//       Access: Public\n"
    "//  Description: Returns the current bam_modified counter.  This\n"
    "//               counter is normally incremented automatically\n"
    "//               whenever the object is modified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedWritable_get_bam_modified_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *TypedWritable::__reduce__(PyObject *self) const
 *******************************************************************/
static PyObject *Dtool_TypedWritable_reduce_221(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *TypedWritable::__reduce__(PyObject *self) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__reduce__", key_word_list));
        else
            (PyArg_Parse(args, ":__reduce__"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const TypedWritable*)local_this)->__reduce__(self);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__reduce__(const TypedWritable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_reduce_221_comment =
    "C++ Interface:\n"
    "__reduce__(const TypedWritable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritable::__reduce__\n"
    "//       Access: Published\n"
    "//  Description: This special Python method is implement to provide\n"
    "//               support for the pickle module.\n"
    "//\n"
    "//               This hooks into the native pickle and cPickle\n"
    "//               modules, but it cannot properly handle\n"
    "//               self-referential BAM objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedWritable_reduce_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const
 *******************************************************************/
static PyObject *Dtool_TypedWritable_reduce_persist_222(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"pickler", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:__reduce_persist__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:__reduce_persist__", &param1));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const TypedWritable*)local_this)->__reduce_persist__(self, param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__reduce_persist__(const TypedWritable this, any pickler)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_reduce_persist_222_comment =
    "C++ Interface:\n"
    "__reduce_persist__(const TypedWritable this, any pickler)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritable::__reduce_persist__\n"
    "//       Access: Published\n"
    "//  Description: This special Python method is implement to provide\n"
    "//               support for the pickle module.\n"
    "//\n"
    "//               This is similar to __reduce__, but it provides\n"
    "//               additional support for the missing persistent-state\n"
    "//               object needed to properly support self-referential\n"
    "//               BAM objects written to the pickle stream.  This hooks\n"
    "//               into the pickle and cPickle modules implemented in\n"
    "//               direct/src/stdpy.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedWritable_reduce_persist_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TypedWritable::encode_to_bam_stream(void) const
 * bool TypedWritable::encode_to_bam_stream(basic_string< char > &data, BamWriter *writer) const
 * bool TypedWritable::encode_to_bam_stream(basic_string< char > &data, BamWriter *writer = ((void *)(0))) const
 *******************************************************************/
static PyObject *Dtool_TypedWritable_encode_to_bam_stream_223(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline basic_string< char > TypedWritable::encode_to_bam_stream(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":encodeToBamStream", key_word_list));
            else
                (PyArg_Parse(args, ":encodeToBamStream"));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const TypedWritable*)local_this)->encode_to_bam_stream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool TypedWritable::encode_to_bam_stream(basic_string< char > &data, BamWriter *writer = ((void *)(0))) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"data", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:encodeToBamStream", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:encodeToBamStream", &param1));
                if(!PyErr_Occurred())
                {
                    basic_string< char > *param1_this = (basic_string< char > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_basic_string_char, 1, "TypedWritable.encodeToBamStream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const TypedWritable*)local_this)->encode_to_bam_stream(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool TypedWritable::encode_to_bam_stream(basic_string< char > &data, BamWriter *writer) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"data", (char *)"writer", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:encodeToBamStream", key_word_list, &param1, &param2))
                {
                    basic_string< char > *param1_this = (basic_string< char > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_basic_string_char, 1, "TypedWritable.encodeToBamStream", 0, coerced_ptr, report_errors);
BamWriter *param2_this = (BamWriter *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_BamWriter, 2, "TypedWritable.encodeToBamStream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = ((const TypedWritable*)local_this)->encode_to_bam_stream(*param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "encodeToBamStream() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "encodeToBamStream(const TypedWritable this)\n"
          "encodeToBamStream(const TypedWritable this, non-const BasicString data)\n"
          "encodeToBamStream(const TypedWritable this, non-const BasicString data, non-const BamWriter writer)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_encode_to_bam_stream_223_comment =
    "C++ Interface:\n"
    "encodeToBamStream(const TypedWritable this)\n"
    "encodeToBamStream(const TypedWritable this, non-const BasicString data)\n"
    "encodeToBamStream(const TypedWritable this, non-const BasicString data, non-const BamWriter writer)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritable::encode_to_bam_stream\n"
    "//       Access: Published\n"
    "//  Description: Converts the TypedWritable object into a single\n"
    "//               stream of data using a BamWriter, and returns that\n"
    "//               data as a string string.  Returns empty string on\n"
    "//               failure.\n"
    "//\n"
    "//               This is a convenience method particularly useful for\n"
    "//               cases when you are only serializing a single object.\n"
    "//               If you have many objects to process, it is more\n"
    "//               efficient to use the same BamWriter to serialize all\n"
    "//               of them together.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "// HAVE_PYTHON\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritable::encode_to_bam_stream\n"
    "//       Access: Published\n"
    "//  Description: Converts the TypedWritable object into a single\n"
    "//               stream of data using a BamWriter, and stores that\n"
    "//               data in the indicated string.  Returns true on\n"
    "//               success, false on failure.\n"
    "//\n"
    "//               This is a convenience method particularly useful for\n"
    "//               cases when you are only serializing a single object.\n"
    "//               If you have many objects to process, it is more\n"
    "//               efficient to use the same BamWriter to serialize all\n"
    "//               of them together.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedWritable_encode_to_bam_stream_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TypedWritable::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritable_get_class_type_225(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TypedWritable::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TypedWritable::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_get_class_type_225_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TypedWritable_get_class_type_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_230(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedWritable.downcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToTypedWritableReferenceCount(non-const TypedWritable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_230_comment =
    "C++ Interface:\n"
    "downcastToTypedWritableReferenceCount(non-const TypedWritable this)\n"
    "\n"
    "downcast from TypedWritable to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_230_comment = NULL;
#endif

int  Dtool_Init_TypedWritable(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TypedWritable)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TypedWritable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypedWritable)
    {
        printf("TypedWritable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypedWritable * local_this = (TypedWritable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypedWritable)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypedWritable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypedWritable)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TypedWritable*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypedWritableReferenceCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(basic_string< char > const &data, BamReader *reader)
 * static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(basic_string< char > const &data, BamReader *reader = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_234(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(basic_string< char > const &data, BamReader *reader = ((void *)(0)))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:decodeFromBamStream", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:decodeFromBamStream", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PointerTo< TypedWritableReferenceCount > return_value = TypedWritableReferenceCount::decode_from_bam_stream(basic_string<char>(param0_str, param0_len));
                if (return_value != (TypedWritableReferenceCount *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_TypedWritableReferenceCount,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(basic_string< char > const &data, BamReader *reader)
                char *param0_str; int param0_len;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"data", (char *)"reader", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:decodeFromBamStream", key_word_list, &param0_str, &param0_len, &param1))
                {
                    BamReader *param1_this = (BamReader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BamReader, 1, "TypedWritableReferenceCount.decodeFromBamStream", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< TypedWritableReferenceCount > return_value = TypedWritableReferenceCount::decode_from_bam_stream(basic_string<char>(param0_str, param0_len), param1_this);
                        if (return_value != (TypedWritableReferenceCount *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_TypedWritableReferenceCount,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "decodeFromBamStream() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "decodeFromBamStream(string data)\n"
          "decodeFromBamStream(string data, non-const BamReader reader)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritableReferenceCount_decode_from_bam_stream_234_comment =
    "C++ Interface:\n"
    "decodeFromBamStream(string data)\n"
    "decodeFromBamStream(string data, non-const BamReader reader)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedWritableReferenceCount::decode_from_bam_stream\n"
    "//       Access: Published, Static\n"
    "//  Description: Reads the string created by a previous call to\n"
    "//               encode_to_bam_stream(), and extracts and returns the\n"
    "//               single object on that string.  Returns NULL on error.\n"
    "//\n"
    "//               This method is intended to replace\n"
    "//               decode_raw_from_bam_stream() when you know the stream\n"
    "//               in question returns an object of type\n"
    "//               TypedWritableReferenceCount, allowing for easier\n"
    "//               reference count management.  Note that the caller is\n"
    "//               still responsible for maintaining the reference count\n"
    "//               on the return value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedWritableReferenceCount_decode_from_bam_stream_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TypedWritableReferenceCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritableReferenceCount_get_class_type_235(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TypedWritableReferenceCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TypedWritableReferenceCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritableReferenceCount_get_class_type_235_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TypedWritableReferenceCount_get_class_type_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_229(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritable"));
        if(!PyErr_Occurred())
        {
            TypedWritable *return_value = (TypedWritable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritable,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedWritableReferenceCount.upcastToTypedWritable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritable(non-const TypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_229_comment =
    "C++ Interface:\n"
    "upcastToTypedWritable(non-const TypedWritableReferenceCount this)\n"
    "\n"
    "upcast from TypedWritableReferenceCount to TypedWritable\n"
    "";
#else
static const char * Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_232(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToReferenceCount"));
        if(!PyErr_Occurred())
        {
            ReferenceCount *return_value = (ReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ReferenceCount,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedWritableReferenceCount.upcastToReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToReferenceCount(non-const TypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_232_comment =
    "C++ Interface:\n"
    "upcastToReferenceCount(non-const TypedWritableReferenceCount this)\n"
    "\n"
    "upcast from TypedWritableReferenceCount to ReferenceCount\n"
    "";
#else
static const char * Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void)
 *******************************************************************/
static PyObject *Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_239(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToBamCacheRecord", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToBamCacheRecord"));
        if(!PyErr_Occurred())
        {
            BamCacheRecord *return_value = (BamCacheRecord *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_BamCacheRecord,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedWritableReferenceCount.downcastToBamCacheRecord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToBamCacheRecord(non-const TypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_239_comment =
    "C++ Interface:\n"
    "downcastToBamCacheRecord(non-const TypedWritableReferenceCount this)\n"
    "\n"
    "downcast from TypedWritableReferenceCount to BamCacheRecord\n"
    "";
#else
static const char * Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_239_comment = NULL;
#endif

int  Dtool_Init_TypedWritableReferenceCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TypedWritableReferenceCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TypedWritableReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypedWritableReferenceCount)
    {
        printf("TypedWritableReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypedWritableReferenceCount * local_this = (TypedWritableReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypedWritableReferenceCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypedWritableReferenceCount)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (TypedWritableReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TypedWritableReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (TypedWritableReferenceCount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BamCacheRecord 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_make_copy_244(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            PointerTo< BamCacheRecord > return_value = ((const BamCacheRecord*)local_this)->make_copy();
            if (return_value != (BamCacheRecord *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_BamCacheRecord,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_make_copy_244_comment =
    "C++ Interface:\n"
    "makeCopy(const BamCacheRecord this)\n"
    "\n"
    "// Filename: bamCacheRecord.I\n"
    "// Created by:  drose (09Jun06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::make_copy\n"
    "//       Access: Published\n"
    "//  Description: Returns a duplicate of the BamCacheRecord.  The\n"
    "//               duplicate will not have a data pointer set, even\n"
    "//               though one may have been assigned to the original via\n"
    "//               set_data().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_make_copy_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_operator_245(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                BamCacheRecord *param1_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BamCacheRecord, 1, "BamCacheRecord.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BamCacheRecord*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const BamCacheRecord this, const BamCacheRecord other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_operator_245_comment =
    "C++ Interface:\n"
    "eq(const BamCacheRecord this, const BamCacheRecord other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::operator == \n"
    "//       Access: Published\n"
    "//  Description: Returns true if the record matches the other record\n"
    "//               in those attributes which get written to disk.  Does\n"
    "//               not compare the data pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_operator_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &BamCacheRecord::get_source_pathname(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_source_pathname_246(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &BamCacheRecord::get_source_pathname(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSourcePathname", key_word_list));
        else
            (PyArg_Parse(args, ":getSourcePathname"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const BamCacheRecord*)local_this)->get_source_pathname());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSourcePathname(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_source_pathname_246_comment =
    "C++ Interface:\n"
    "getSourcePathname(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::get_source_pathname\n"
    "//       Access: Published\n"
    "//  Description: Returns the full pathname to the source file that\n"
    "//               originally generated this cache request.  In some\n"
    "//               cases, for instance in the case of a of a multipage\n"
    "//               texture like \"cube_#.png\", this may not not a true\n"
    "//               filename on disk.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_source_pathname_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &BamCacheRecord::get_cache_filename(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_cache_filename_247(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &BamCacheRecord::get_cache_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const BamCacheRecord*)local_this)->get_cache_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheFilename(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_cache_filename_247_comment =
    "C++ Interface:\n"
    "getCacheFilename(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::get_cache_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the cache file as hashed from the\n"
    "//               source_pathname.  This will be relative to the root\n"
    "//               of the cache directory, and it will not include any\n"
    "//               suffixes that may be appended to resolve hash\n"
    "//               conflicts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_cache_filename_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int BamCacheRecord::get_recorded_time(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_recorded_time_248(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int BamCacheRecord::get_recorded_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRecordedTime", key_word_list));
        else
            (PyArg_Parse(args, ":getRecordedTime"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const BamCacheRecord*)local_this)->get_recorded_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRecordedTime(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_recorded_time_248_comment =
    "C++ Interface:\n"
    "getRecordedTime(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::get_recorded_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time at which this particular record was\n"
    "//               recorded or updated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_recorded_time_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamCacheRecord::get_num_dependent_files(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_num_dependent_files_249(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamCacheRecord::get_num_dependent_files(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDependentFiles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDependentFiles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamCacheRecord*)local_this)->get_num_dependent_files();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDependentFiles(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_num_dependent_files_249_comment =
    "C++ Interface:\n"
    "getNumDependentFiles(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::get_num_dependent_files\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of source files that contribute to\n"
    "//               the cache.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_num_dependent_files_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_dependent_pathname_250(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDependentPathname", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDependentPathname", &param1));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const BamCacheRecord*)local_this)->get_dependent_pathname((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDependentPathname(const BamCacheRecord this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_dependent_pathname_250_comment =
    "C++ Interface:\n"
    "getDependentPathname(const BamCacheRecord this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::get_dependent_pathname\n"
    "//       Access: Published\n"
    "//  Description: Returns the full pathname of the nth source files\n"
    "//               that contributes to the cache.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_dependent_pathname_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamCacheRecord::dependents_unchanged(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_dependents_unchanged_251(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool BamCacheRecord::dependents_unchanged(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":dependentsUnchanged", key_word_list));
        else
            (PyArg_Parse(args, ":dependentsUnchanged"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCacheRecord*)local_this)->dependents_unchanged();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "dependentsUnchanged(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_dependents_unchanged_251_comment =
    "C++ Interface:\n"
    "dependentsUnchanged(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::dependents_unchanged\n"
    "//       Access: Published\n"
    "//  Description: Returns true if all of the dependent files are still\n"
    "//               the same as when the cache was recorded, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_dependents_unchanged_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCacheRecord::clear_dependent_files(void)
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_clear_dependent_files_252(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BamCacheRecord::clear_dependent_files(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDependentFiles", key_word_list));
        else
            (PyArg_Parse(args, ":clearDependentFiles"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_dependent_files();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCacheRecord.clearDependentFiles() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDependentFiles(non-const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_clear_dependent_files_252_comment =
    "C++ Interface:\n"
    "clearDependentFiles(non-const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::clear_dependent_files\n"
    "//       Access: Published\n"
    "//  Description: Empties the list of files that contribute to the data\n"
    "//               in this record.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_clear_dependent_files_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCacheRecord::add_dependent_file(Filename const &pathname)
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_add_dependent_file_253(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BamCacheRecord::add_dependent_file(Filename const &pathname)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pathname", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addDependentFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addDependentFile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "BamCacheRecord.addDependentFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_dependent_file(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamCacheRecord.addDependentFile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addDependentFile(non-const BamCacheRecord this, const Filename pathname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_add_dependent_file_253_comment =
    "C++ Interface:\n"
    "addDependentFile(non-const BamCacheRecord this, const Filename pathname)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::add_dependent_file\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated file to the list of files that\n"
    "//               will be loaded to generate the data in this record.\n"
    "//               This should be called once for the primary source\n"
    "//               file, and again for each secondary source file, if\n"
    "//               any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_add_dependent_file_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCacheRecord::has_data(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_has_data_254(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamCacheRecord::has_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasData", key_word_list));
        else
            (PyArg_Parse(args, ":hasData"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCacheRecord*)local_this)->has_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasData(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_has_data_254_comment =
    "C++ Interface:\n"
    "hasData(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::has_data\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this cache record has an in-memory\n"
    "//               data object associated--that is, the object stored in\n"
    "//               the cache.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_has_data_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCacheRecord::clear_data(void)
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_clear_data_255(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCacheRecord::clear_data(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearData", key_word_list));
        else
            (PyArg_Parse(args, ":clearData"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCacheRecord.clearData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearData(non-const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_clear_data_255_comment =
    "C++ Interface:\n"
    "clearData(non-const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::clear_data\n"
    "//       Access: Published\n"
    "//  Description: Removes the in-memory data object associated with\n"
    "//               this record, if any.  This does not affect the\n"
    "//               on-disk representation of the record.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_clear_data_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypedWritable *BamCacheRecord::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_data_256(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypedWritable *BamCacheRecord::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            TypedWritable *return_value = ((const BamCacheRecord*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritable,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_data_256_comment =
    "C++ Interface:\n"
    "getData(const BamCacheRecord this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::get_data\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the data stored in the\n"
    "//               record, or NULL if there is no data.  The pointer is\n"
    "//               not removed from the record.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_data_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
 * inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_set_data_258(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"ptr", (char *)"ref_ptr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setData", key_word_list, &param1, &param2))
            {
                TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedWritable, 1, "BamCacheRecord.setData", 0, coerced_ptr, report_errors);
ReferenceCount *param2_this = (ReferenceCount *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ReferenceCount, 2, "BamCacheRecord.setData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_data(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"ptr", (char *)"dummy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setData", key_word_list, &param1, &param2))
            {
                TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedWritable, 1, "BamCacheRecord.setData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_data(param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const BamCacheRecord this, non-const TypedWritable ptr, non-const ReferenceCount ref_ptr)\n"
          "setData(non-const BamCacheRecord this, non-const TypedWritable ptr, int dummy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_set_data_258_comment =
    "C++ Interface:\n"
    "setData(non-const BamCacheRecord this, non-const TypedWritable ptr, non-const ReferenceCount ref_ptr)\n"
    "setData(non-const BamCacheRecord this, non-const TypedWritable ptr, int dummy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::set_data\n"
    "//       Access: Published\n"
    "//  Description: Stores a new data object on the record.  You should\n"
    "//               pass the same pointer twice, to both parameters; this\n"
    "//               allows the C++ typecasting to automatically convert\n"
    "//               the pointer into both a TypedWritable and a\n"
    "//               ReferenceCount pointer, so that the BamCacheRecord\n"
    "//               object can reliably manage the reference counts.\n"
    "//\n"
    "//               You may pass 0 or NULL as the second parameter.  If\n"
    "//               you do this, the BamCacheRecord will not manage the\n"
    "//               object's reference count; it will be up to you to\n"
    "//               ensure the object is not deleted during the lifetime\n"
    "//               of the BamCacheRecord object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::set_data\n"
    "//       Access: Published\n"
    "//  Description: This variant on set_data() is provided just to allow\n"
    "//               Python code to pass a 0 as the second parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_set_data_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCacheRecord::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_output_259(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void BamCacheRecord::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BamCacheRecord.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BamCacheRecord*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BamCacheRecord this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_output_259_comment =
    "C++ Interface:\n"
    "output(const BamCacheRecord this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_output_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCacheRecord::write(ostream &out, int indent_level) const
 * void BamCacheRecord::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_write_260(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BamCacheRecord::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BamCacheRecord.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BamCacheRecord*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BamCacheRecord::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BamCacheRecord.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BamCacheRecord*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BamCacheRecord this, non-const Ostream out)\n"
          "write(const BamCacheRecord this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_write_260_comment =
    "C++ Interface:\n"
    "write(const BamCacheRecord this, non-const Ostream out)\n"
    "write(const BamCacheRecord this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCacheRecord::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCacheRecord_write_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BamCacheRecord::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_get_class_type_261(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BamCacheRecord::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BamCacheRecord::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_get_class_type_261_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BamCacheRecord_get_class_type_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_238(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCacheRecord.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const BamCacheRecord this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_238_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const BamCacheRecord this)\n"
    "\n"
    "upcast from BamCacheRecord to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_238_comment = NULL;
#endif

int  Dtool_Init_BamCacheRecord(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BamCacheRecord)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BamCacheRecord(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BamCacheRecord)
    {
        printf("BamCacheRecord ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BamCacheRecord * local_this = (BamCacheRecord *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BamCacheRecord)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BamCacheRecord(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BamCacheRecord)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BamCacheRecord*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BamCacheRecord*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (BamCacheRecord*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (BamCacheRecord*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BamCache 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_active(bool flag)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_active_265(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_active(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const BamCache this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_active_265_comment =
    "C++ Interface:\n"
    "setActive(non-const BamCache this, bool flag)\n"
    "\n"
    "// Filename: bamCache.I\n"
    "// Created by:  drose (09Jun06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_active\n"
    "//       Access: Published\n"
    "//  Description: Changes the state of the active flag.  \"active\" means\n"
    "//               that the cache should be consulted automatically on\n"
    "//               loads, \"not active\" means that objects should be\n"
    "//               loaded directly without consulting the cache.\n"
    "//\n"
    "//               This represents the global flag.  Also see the\n"
    "//               individual cache_models, cache_textures,\n"
    "//               cache_compressed_textures flags.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_active_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCache::get_active(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_active_266(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamCache::get_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCache*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_active_266_comment =
    "C++ Interface:\n"
    "getActive(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_active\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the BamCache is currently active,\n"
    "//               false if it is not.  \"active\" means that the cache\n"
    "//               should be consulted automatically on loads, \"not\n"
    "//               active\" means that objects should be loaded directly\n"
    "//               without consulting the cache.\n"
    "//\n"
    "//               This represents the global flag.  Also see the\n"
    "//               individual cache_models, cache_textures,\n"
    "//               cache_compressed_textures flags.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_active_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_cache_models(bool flag)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_cache_models_267(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_cache_models(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCacheModels", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCacheModels", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cache_models((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setCacheModels() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCacheModels(non-const BamCache this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_cache_models_267_comment =
    "C++ Interface:\n"
    "setCacheModels(non-const BamCache this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_cache_models\n"
    "//       Access: Published\n"
    "//  Description: Indicates whether model files (e.g. egg files and bam\n"
    "//               files) will be stored in the cache, as bam files.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_cache_models_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCache::get_cache_models(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_cache_models_268(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamCache::get_cache_models(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheModels", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheModels"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCache*)local_this)->get_cache_models();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheModels(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_cache_models_268_comment =
    "C++ Interface:\n"
    "getCacheModels(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_cache_models\n"
    "//       Access: Published\n"
    "//  Description: Returns whether model files (e.g. egg files and bam\n"
    "//               files) will be stored in the cache, as bam files.\n"
    "//\n"
    "//               This also returns false if get_active() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_cache_models_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_cache_textures(bool flag)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_cache_textures_269(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_cache_textures(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCacheTextures", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCacheTextures", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cache_textures((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setCacheTextures() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCacheTextures(non-const BamCache this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_cache_textures_269_comment =
    "C++ Interface:\n"
    "setCacheTextures(non-const BamCache this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_cache_textures\n"
    "//       Access: Published\n"
    "//  Description: Indicates whether texture files will be stored in the\n"
    "//               cache, as uncompressed txo files.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_cache_textures_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCache::get_cache_textures(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_cache_textures_270(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamCache::get_cache_textures(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheTextures", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheTextures"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCache*)local_this)->get_cache_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheTextures(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_cache_textures_270_comment =
    "C++ Interface:\n"
    "getCacheTextures(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_cache_textures\n"
    "//       Access: Published\n"
    "//  Description: Returns whether texture files (e.g. egg files and bam\n"
    "//               files) will be stored in the cache, as txo files.\n"
    "//\n"
    "//               This also returns false if get_active() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_cache_textures_270_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_cache_compressed_textures(bool flag)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_cache_compressed_textures_271(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_cache_compressed_textures(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCacheCompressedTextures", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCacheCompressedTextures", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cache_compressed_textures((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setCacheCompressedTextures() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCacheCompressedTextures(non-const BamCache this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_cache_compressed_textures_271_comment =
    "C++ Interface:\n"
    "setCacheCompressedTextures(non-const BamCache this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_cache_compressed_textures\n"
    "//       Access: Published\n"
    "//  Description: Indicates whether compressed texture files will be\n"
    "//               stored in the cache, as compressed txo files.  The\n"
    "//               compressed data may either be generated in-CPU, via\n"
    "//               the squish library, or it may be extracted from the\n"
    "//               GSG after the texture has been loaded.\n"
    "//\n"
    "//               This may be set in conjunction with\n"
    "//               set_cache_textures(), or independently of it.  If\n"
    "//               set_cache_textures() is true and this is false, all\n"
    "//               textures will be cached in their uncompressed form.\n"
    "//               If set_cache_textures() is false and this is true,\n"
    "//               only compressed textures will be cached, and they\n"
    "//               will be cached in their compressed form.  If both are\n"
    "//               true, all textures will be cached, in their\n"
    "//               uncompressed or compressed form appropriately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_cache_compressed_textures_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCache::get_cache_compressed_textures(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_cache_compressed_textures_272(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamCache::get_cache_compressed_textures(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheCompressedTextures", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheCompressedTextures"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCache*)local_this)->get_cache_compressed_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheCompressedTextures(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_cache_compressed_textures_272_comment =
    "C++ Interface:\n"
    "getCacheCompressedTextures(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_cache_compressed_textures\n"
    "//       Access: Published\n"
    "//  Description: Returns whether compressed texture files will be\n"
    "//               stored in the cache, as compressed txo files.  See\n"
    "//               set_cache_compressed_textures().\n"
    "//\n"
    "//               This also returns false if get_active() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_cache_compressed_textures_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCache::set_root(Filename const &root)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_root_273(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BamCache::set_root(Filename const &root)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"root", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRoot", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRoot", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "BamCache.setRoot", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_root(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamCache.setRoot() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRoot(non-const BamCache this, const Filename root)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_root_273_comment =
    "C++ Interface:\n"
    "setRoot(non-const BamCache this, const Filename root)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_root\n"
    "//       Access: Published\n"
    "//  Description: Changes the current root pathname of the cache.  This\n"
    "//               specifies where the cache files are stored on disk.\n"
    "//               This should name a directory that is on a disk local\n"
    "//               to the machine (not on a network-mounted disk), for\n"
    "//               instance, /tmp/panda-cache or /c/panda-cache.\n"
    "//\n"
    "//               If the directory does not already exist, it will be\n"
    "//               created as a result of this call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_root_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename BamCache::get_root(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_root_274(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename BamCache::get_root(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRoot", key_word_list));
        else
            (PyArg_Parse(args, ":getRoot"));
        if(!PyErr_Occurred())
        {
            Filename result = ((const BamCache*)local_this)->get_root();
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRoot(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_root_274_comment =
    "C++ Interface:\n"
    "getRoot(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_root\n"
    "//       Access: Published\n"
    "//  Description: Returns the current root pathname of the cache.  See\n"
    "//               set_root().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_root_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_flush_time(int flush_time)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_flush_time_275(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_flush_time(int flush_time)
        int param1;
        static char * key_word_list[] = {(char *)"flush_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFlushTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFlushTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_flush_time((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setFlushTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFlushTime(non-const BamCache this, int flush_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_flush_time_275_comment =
    "C++ Interface:\n"
    "setFlushTime(non-const BamCache this, int flush_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_flush_time\n"
    "//       Access: Published\n"
    "//  Description: Specifies the time in seconds between automatic\n"
    "//               flushes of the cache index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_flush_time_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamCache::get_flush_time(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_flush_time_276(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamCache::get_flush_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFlushTime", key_word_list));
        else
            (PyArg_Parse(args, ":getFlushTime"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamCache*)local_this)->get_flush_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFlushTime(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_flush_time_276_comment =
    "C++ Interface:\n"
    "getFlushTime(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_flush_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time in seconds between automatic\n"
    "//               flushes of the cache index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_flush_time_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_cache_max_kbytes(int max_kbytes)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_cache_max_kbytes_277(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_cache_max_kbytes(int max_kbytes)
        int param1;
        static char * key_word_list[] = {(char *)"max_kbytes", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCacheMaxKbytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCacheMaxKbytes", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cache_max_kbytes((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setCacheMaxKbytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCacheMaxKbytes(non-const BamCache this, int max_kbytes)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_cache_max_kbytes_277_comment =
    "C++ Interface:\n"
    "setCacheMaxKbytes(non-const BamCache this, int max_kbytes)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_cache_max_kbytes\n"
    "//       Access: Published\n"
    "//  Description: Specifies the maximum size, in kilobytes, which the\n"
    "//               cache is allowed to grow to.  If a newly cached file\n"
    "//               would exceed this size, an older file is removed from\n"
    "//               the cache.\n"
    "//\n"
    "//               Note that in the case of multiple different processes\n"
    "//               simultaneously operating on the same cache directory,\n"
    "//               the actual cache size may slightly exceed this value\n"
    "//               from time to time due to latency in checking between\n"
    "//               the processes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_cache_max_kbytes_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamCache::get_cache_max_kbytes(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_cache_max_kbytes_278(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamCache::get_cache_max_kbytes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheMaxKbytes", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheMaxKbytes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamCache*)local_this)->get_cache_max_kbytes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheMaxKbytes(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_cache_max_kbytes_278_comment =
    "C++ Interface:\n"
    "getCacheMaxKbytes(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_cache_max_kbytes\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum size, in kilobytes, which the\n"
    "//               cache is allowed to grow to.  See\n"
    "//               set_cache_max_kbytes().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_cache_max_kbytes_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamCache::set_read_only(bool ro)
 *******************************************************************/
static PyObject *Dtool_BamCache_set_read_only_279(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamCache::set_read_only(bool ro)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"ro", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setReadOnly", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setReadOnly", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_read_only((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.setReadOnly() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReadOnly(non-const BamCache this, bool ro)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_set_read_only_279_comment =
    "C++ Interface:\n"
    "setReadOnly(non-const BamCache this, bool ro)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::set_read_only\n"
    "//       Access: Published\n"
    "//  Description: Can be used to put the cache in read-only mode,\n"
    "//               or take it out of read-only mode.  Note that if you\n"
    "//               put it into read-write mode, and it discovers that\n"
    "//               it does not have write access, it will put itself\n"
    "//               right back into read-only mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_set_read_only_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamCache::get_read_only(void) const
 *******************************************************************/
static PyObject *Dtool_BamCache_get_read_only_280(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamCache::get_read_only(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReadOnly", key_word_list));
        else
            (PyArg_Parse(args, ":getReadOnly"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamCache*)local_this)->get_read_only();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReadOnly(const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_read_only_280_comment =
    "C++ Interface:\n"
    "getReadOnly(const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_read_only\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the cache is in read-only mode.\n"
    "//               Normally, the cache starts in read-write mode.  It\n"
    "//               can put itself into read-only mode automatically if\n"
    "//               it discovers that it does not have write access to\n"
    "//               the cache.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_read_only_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, basic_string< char > const &cache_extension)
 *******************************************************************/
static PyObject *Dtool_BamCache_lookup_281(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, basic_string< char > const &cache_extension)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"source_filename", (char *)"cache_extension", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:lookup", key_word_list, &param1, &param2_str, &param2_len))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "BamCache.lookup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< BamCacheRecord > return_value = (local_this)->lookup(*param1_this, basic_string<char>(param2_str, param2_len));
                    if (return_value != (BamCacheRecord *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_BamCacheRecord,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamCache.lookup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lookup(non-const BamCache this, const Filename source_filename, string cache_extension)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_lookup_281_comment =
    "C++ Interface:\n"
    "lookup(non-const BamCache this, const Filename source_filename, string cache_extension)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::lookup\n"
    "//       Access: Published\n"
    "//  Description: Looks up a file in the cache.  \n"
    "//\n"
    "//               If the file is cacheable, then regardless of whether\n"
    "//               the file is found in the cache or not, this returns a\n"
    "//               BamCacheRecord.  On the other hand, if the file\n"
    "//               cannot be cached, returns NULL.\n"
    "//\n"
    "//               If record->has_data() returns true, then the file was\n"
    "//               found in the cache, and you may call\n"
    "//               record->extract_data() to get the object.  If\n"
    "//               record->has_data() returns false, then the file was\n"
    "//               not found in the cache or the cache was stale; and\n"
    "//               you should reload the source file (calling\n"
    "//               record->add_dependent_file() for each file loaded,\n"
    "//               including the original source file), and then call\n"
    "//               record->set_data() to record the resulting loaded\n"
    "//               object; and finally, you should call store() to write\n"
    "//               the cached record to disk.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_lookup_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamCache::store(BamCacheRecord *record)
 *******************************************************************/
static PyObject *Dtool_BamCache_store_282(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool BamCache::store(BamCacheRecord *record)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"record", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:store", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:store", &param1));
            if(!PyErr_Occurred())
            {
                BamCacheRecord *param1_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BamCacheRecord, 1, "BamCache.store", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->store(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamCache.store() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store(non-const BamCache this, non-const BamCacheRecord record)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_store_282_comment =
    "C++ Interface:\n"
    "store(non-const BamCache this, non-const BamCacheRecord record)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::store\n"
    "//       Access: Published\n"
    "//  Description: Flushes a cache entry to disk.  You must have\n"
    "//               retrieved the cache record via a prior call to\n"
    "//               lookup(), and then stored the data via\n"
    "//               record->set_data().  Returns true on success, false\n"
    "//               on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_store_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCache::consider_flush_index(void)
 *******************************************************************/
static PyObject *Dtool_BamCache_consider_flush_index_283(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BamCache::consider_flush_index(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":considerFlushIndex", key_word_list));
        else
            (PyArg_Parse(args, ":considerFlushIndex"));
        if(!PyErr_Occurred())
        {
            (local_this)->consider_flush_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.considerFlushIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "considerFlushIndex(non-const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_consider_flush_index_283_comment =
    "C++ Interface:\n"
    "considerFlushIndex(non-const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::consider_flush_index\n"
    "//       Access: Published\n"
    "//  Description: Flushes the index if enough time has elapsed since\n"
    "//               the index was last flushed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_consider_flush_index_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamCache::flush_index(void)
 *******************************************************************/
static PyObject *Dtool_BamCache_flush_index_284(PyObject *self, PyObject *args,PyObject *kwds) {
    BamCache * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCache,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BamCache::flush_index(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flushIndex", key_word_list));
        else
            (PyArg_Parse(args, ":flushIndex"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamCache.flushIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flushIndex(non-const BamCache this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_flush_index_284_comment =
    "C++ Interface:\n"
    "flushIndex(non-const BamCache this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::flush_index\n"
    "//       Access: Published\n"
    "//  Description: Ensures the index is written to disk.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_flush_index_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BamCache *BamCache::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_BamCache_get_global_ptr_285(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BamCache *BamCache::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            BamCache *return_value = BamCache::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BamCache,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamCache_get_global_ptr_285_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamCache::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the global BamCache object,\n"
    "//               which is used automatically by the ModelPool and\n"
    "//               TexturePool.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamCache_get_global_ptr_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BamCache::BamCache(void)
 *******************************************************************/
int  Dtool_Init_BamCache(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-BamCache::BamCache(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":BamCache", key_word_list))
        {
            BamCache *return_value = new BamCache();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_BamCache,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "BamCache()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BamCache(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BamCache)
    {
        printf("BamCache ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BamCache * local_this = (BamCache *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BamCache)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BamCache(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BamCache)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BamEnums 
//********************************************************************
int  Dtool_Init_BamEnums(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BamEnums)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BamEnums(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BamEnums)
    {
        printf("BamEnums ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BamEnums * local_this = (BamEnums *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BamEnums)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BamEnums(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BamEnums)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LoaderOptions 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LoaderOptions::operator =(LoaderOptions const &copy)
 *******************************************************************/
static PyObject *Dtool_LoaderOptions_operator_295(PyObject *self, PyObject *args,PyObject *kwds) {
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LoaderOptions::operator =(LoaderOptions const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                LoaderOptions *param1_this = (LoaderOptions *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LoaderOptions, 1, "LoaderOptions.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    LoaderOptions *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LoaderOptions,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LoaderOptions.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const LoaderOptions this, const LoaderOptions copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LoaderOptions_operator_295_comment =
    "C++ Interface:\n"
    "assign(non-const LoaderOptions this, const LoaderOptions copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LoaderOptions::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LoaderOptions_operator_295_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LoaderOptions::set_flags(int flags)
 *******************************************************************/
static PyObject *Dtool_LoaderOptions_set_flags_296(PyObject *self, PyObject *args,PyObject *kwds) {
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LoaderOptions::set_flags(int flags)
        int param1;
        static char * key_word_list[] = {(char *)"flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFlags", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFlags", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_flags((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LoaderOptions.setFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFlags(non-const LoaderOptions this, int flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LoaderOptions_set_flags_296_comment =
    "C++ Interface:\n"
    "setFlags(non-const LoaderOptions this, int flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LoaderOptions::set_flags\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LoaderOptions_set_flags_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LoaderOptions::get_flags(void) const
 *******************************************************************/
static PyObject *Dtool_LoaderOptions_get_flags_297(PyObject *self, PyObject *args,PyObject *kwds) {
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int LoaderOptions::get_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const LoaderOptions*)local_this)->get_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFlags(const LoaderOptions this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LoaderOptions_get_flags_297_comment =
    "C++ Interface:\n"
    "getFlags(const LoaderOptions this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LoaderOptions::get_flags\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LoaderOptions_get_flags_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LoaderOptions::set_texture_flags(int flags)
 *******************************************************************/
static PyObject *Dtool_LoaderOptions_set_texture_flags_298(PyObject *self, PyObject *args,PyObject *kwds) {
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LoaderOptions::set_texture_flags(int flags)
        int param1;
        static char * key_word_list[] = {(char *)"flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTextureFlags", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTextureFlags", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_texture_flags((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LoaderOptions.setTextureFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextureFlags(non-const LoaderOptions this, int flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LoaderOptions_set_texture_flags_298_comment =
    "C++ Interface:\n"
    "setTextureFlags(non-const LoaderOptions this, int flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LoaderOptions::set_texture_flags\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LoaderOptions_set_texture_flags_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LoaderOptions::get_texture_flags(void) const
 *******************************************************************/
static PyObject *Dtool_LoaderOptions_get_texture_flags_299(PyObject *self, PyObject *args,PyObject *kwds) {
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int LoaderOptions::get_texture_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const LoaderOptions*)local_this)->get_texture_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureFlags(const LoaderOptions this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LoaderOptions_get_texture_flags_299_comment =
    "C++ Interface:\n"
    "getTextureFlags(const LoaderOptions this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LoaderOptions::get_texture_flags\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LoaderOptions_get_texture_flags_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LoaderOptions::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_LoaderOptions_output_300(PyObject *self, PyObject *args,PyObject *kwds) {
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void LoaderOptions::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LoaderOptions.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const LoaderOptions*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const LoaderOptions this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LoaderOptions_output_300_comment =
    "C++ Interface:\n"
    "output(const LoaderOptions this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LoaderOptions::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LoaderOptions_output_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LoaderOptions::LoaderOptions(LoaderOptions const &copy)
 * LoaderOptions::LoaderOptions(int flags)
 * LoaderOptions::LoaderOptions(int flags = ((LF_search | LF_report_errors)))
 * inline LoaderOptions::LoaderOptions(int flags, int texture_flags)
 *******************************************************************/
int  Dtool_Init_LoaderOptions(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LoaderOptions::LoaderOptions(int flags = ((LF_search | LF_report_errors)))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LoaderOptions", key_word_list))
            {
                LoaderOptions *return_value = new LoaderOptions();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LoaderOptions,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline LoaderOptions::LoaderOptions(LoaderOptions const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LoaderOptions", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LoaderOptions", &param0));
                if(!PyErr_Occurred())
                {
                    LoaderOptions *param0_this = (LoaderOptions *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LoaderOptions, 0, "LoaderOptions.LoaderOptions", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LoaderOptions *return_value = new LoaderOptions(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LoaderOptions,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LoaderOptions::LoaderOptions(int flags)
                int param0;
                static char * key_word_list[] = {(char *)"flags", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:LoaderOptions", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:LoaderOptions", &param0));
                if(!PyErr_Occurred())
                {
                    LoaderOptions *return_value = new LoaderOptions((int)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LoaderOptions,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline LoaderOptions::LoaderOptions(int flags, int texture_flags)
            int param0;
            int param1;
            static char * key_word_list[] = {(char *)"flags", (char *)"texture_flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:LoaderOptions", key_word_list, &param0, &param1))
            {
                LoaderOptions *return_value = new LoaderOptions((int)param0, (int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LoaderOptions,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LoaderOptions() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LoaderOptions()\n"
          "LoaderOptions(const LoaderOptions copy)\n"
          "LoaderOptions(int flags)\n"
          "LoaderOptions(int flags, int texture_flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LoaderOptions(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LoaderOptions)
    {
        printf("LoaderOptions ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LoaderOptions * local_this = (LoaderOptions *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LoaderOptions)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LoaderOptions(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LoaderOptions)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BamReader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void BamReader::set_source(DatagramGenerator *source)
 *******************************************************************/
static PyObject *Dtool_BamReader_set_source_305(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BamReader::set_source(DatagramGenerator *source)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSource", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSource", &param1));
            if(!PyErr_Occurred())
            {
                DatagramGenerator *param1_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramGenerator, 1, "BamReader.setSource", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_source(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamReader.setSource() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSource(non-const BamReader this, non-const DatagramGenerator source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_set_source_305_comment =
    "C++ Interface:\n"
    "setSource(non-const BamReader this, non-const DatagramGenerator source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::set_source\n"
    "//       Access: Published\n"
    "//  Description: Changes the source of future datagrams for this\n"
    "//               BamReader.  This also implicitly calls init() if it\n"
    "//               has not already been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_set_source_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamReader::init(void)
 *******************************************************************/
static PyObject *Dtool_BamReader_init_306(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool BamReader::init(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":init", key_word_list));
        else
            (PyArg_Parse(args, ":init"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->init();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamReader.init() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "init(non-const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_init_306_comment =
    "C++ Interface:\n"
    "init(non-const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::init\n"
    "//       Access: Published\n"
    "//  Description: Initializes the BamReader prior to reading any\n"
    "//               objects from its source.  This includes reading the\n"
    "//               Bam header.\n"
    "//\n"
    "//               This returns true if the BamReader successfully\n"
    "//               initialized, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_init_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &BamReader::get_filename(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_filename_309(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &BamReader::get_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const BamReader*)local_this)->get_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilename(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_filename_309_comment =
    "C++ Interface:\n"
    "getFilename(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_filename\n"
    "//       Access: Published\n"
    "//  Description: If a BAM is a file, then the BamReader should\n"
    "//               contain the name of the file.  This enables the\n"
    "//               reader to interpret pathnames in the BAM as relative\n"
    "//               to the directory containing the BAM.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_filename_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LoaderOptions const &BamReader::get_loader_options(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_loader_options_310(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LoaderOptions const &BamReader::get_loader_options(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLoaderOptions", key_word_list));
        else
            (PyArg_Parse(args, ":getLoaderOptions"));
        if(!PyErr_Occurred())
        {
            LoaderOptions const *return_value = &(((const BamReader*)local_this)->get_loader_options());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LoaderOptions,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLoaderOptions(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_loader_options_310_comment =
    "C++ Interface:\n"
    "getLoaderOptions(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_loader_options\n"
    "//       Access: Published\n"
    "//  Description: Returns the LoaderOptions passed to the loader when\n"
    "//               the model was requested, if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_loader_options_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamReader::set_loader_options(LoaderOptions const &options)
 *******************************************************************/
static PyObject *Dtool_BamReader_set_loader_options_311(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BamReader::set_loader_options(LoaderOptions const &options)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"options", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLoaderOptions", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLoaderOptions", &param1));
            if(!PyErr_Occurred())
            {
                LoaderOptions *param1_this = (LoaderOptions *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LoaderOptions, 1, "BamReader.setLoaderOptions", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_loader_options(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamReader.setLoaderOptions() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLoaderOptions(non-const BamReader this, const LoaderOptions options)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_set_loader_options_311_comment =
    "C++ Interface:\n"
    "setLoaderOptions(non-const BamReader this, const LoaderOptions options)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::set_loader_options\n"
    "//       Access: Published\n"
    "//  Description: Specifies the LoaderOptions for this BamReader.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_set_loader_options_311_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritable *BamReader::read_object(void)
 *******************************************************************/
static PyObject *Dtool_BamReader_read_object_312(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritable *BamReader::read_object(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":readObject", key_word_list));
        else
            (PyArg_Parse(args, ":readObject"));
        if(!PyErr_Occurred())
        {
            TypedWritable *return_value = (local_this)->read_object();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritable,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamReader.readObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readObject(non-const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_read_object_312_comment =
    "C++ Interface:\n"
    "readObject(non-const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::read_object\n"
    "//       Access: Published\n"
    "//  Description: Reads a single object from the Bam file.  If the\n"
    "//               object type is known, a new object of the appropriate\n"
    "//               type is created and returned; otherwise, NULL is\n"
    "//               returned.  NULL is also returned when the end of the\n"
    "//               file is reached.  is_eof() may be called to\n"
    "//               differentiate between these two cases.\n"
    "//\n"
    "//               This may be called repeatedly to extract out all the\n"
    "//               objects in the Bam file, but typically (especially\n"
    "//               for scene graph files, indicated with the .bam\n"
    "//               extension), only one object is retrieved directly\n"
    "//               from the Bam file: the root of the scene graph.  The\n"
    "//               remaining objects will all be retrieved recursively\n"
    "//               by the first object.\n"
    "//\n"
    "//               Note that the object returned may not yet be\n"
    "//               complete.  In particular, some of its pointers may\n"
    "//               not be filled in; you must call resolve() to fill in\n"
    "//               all the available pointers before you can safely use\n"
    "//               any objects returned by read_object().\n"
    "//\n"
    "//               This flavor of read_object() requires the caller to\n"
    "//               know what type of object it has received in order to\n"
    "//               properly manage the reference counts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::read_object\n"
    "//       Access: Published\n"
    "//  Description: Reads a single object from the Bam file.  \n"
    "//\n"
    "//               This flavor of read_object() returns both a\n"
    "//               TypedWritable and a ReferenceCount pointer to the\n"
    "//               same object, so the reference count may be tracked\n"
    "//               reliably, without having to know precisely what type\n"
    "//               of object we have.  It returns true on success, or\n"
    "//               false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_read_object_312_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BamReader::is_eof(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_is_eof_313(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BamReader::is_eof(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEof", key_word_list));
        else
            (PyArg_Parse(args, ":isEof"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BamReader*)local_this)->is_eof();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEof(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_is_eof_313_comment =
    "C++ Interface:\n"
    "isEof(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::is_eof\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the reader has reached end-of-file,\n"
    "//               false otherwise.  This call is only valid after a\n"
    "//               call to read_object().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_is_eof_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamReader::resolve(void)
 *******************************************************************/
static PyObject *Dtool_BamReader_resolve_314(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool BamReader::resolve(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resolve", key_word_list));
        else
            (PyArg_Parse(args, ":resolve"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->resolve();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamReader.resolve() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resolve(non-const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_resolve_314_comment =
    "C++ Interface:\n"
    "resolve(non-const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::resolve\n"
    "//       Access: Published\n"
    "//  Description: This may be called at any time during processing of\n"
    "//               the Bam file to resolve all the known pointers so\n"
    "//               far.  It is usually called at the end of the\n"
    "//               processing, after all objects have been read, which\n"
    "//               is generally the best time to call it.\n"
    "//\n"
    "//               This must be called at least once after reading a\n"
    "//               particular object via get_object() in order to\n"
    "//               validate that object.\n"
    "//\n"
    "//               The return value is true if all objects have been\n"
    "//               resolved, or false if some objects are still\n"
    "//               outstanding (in which case you will need to call\n"
    "//               resolve() again later).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_resolve_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer)
 *******************************************************************/
static PyObject *Dtool_BamReader_change_pointer_315(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"orig_pointer", (char *)"new_pointer", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:changePointer", key_word_list, &param1, &param2))
            {
                TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedWritable, 1, "BamReader.changePointer", 1, coerced_ptr, report_errors);
TypedWritable *param2_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypedWritable, 2, "BamReader.changePointer", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->change_pointer(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamReader.changePointer() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "changePointer(non-const BamReader this, const TypedWritable orig_pointer, const TypedWritable new_pointer)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_change_pointer_315_comment =
    "C++ Interface:\n"
    "changePointer(non-const BamReader this, const TypedWritable orig_pointer, const TypedWritable new_pointer)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::change_pointer\n"
    "//       Access: Published\n"
    "//  Description: Indicates that an object recently read from the bam\n"
    "//               stream should be replaced with a new object.  Any\n"
    "//               future occurrences of the original object in the\n"
    "//               stream will henceforth return the new object instead.\n"
    "//\n"
    "//               The return value is true if the replacement was\n"
    "//               successfully made, or false if the object was not\n"
    "//               read from the stream (or if change_pointer had\n"
    "//               already been called on it).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_change_pointer_315_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamReader::get_file_major_ver(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_file_major_ver_316(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamReader::get_file_major_ver(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileMajorVer", key_word_list));
        else
            (PyArg_Parse(args, ":getFileMajorVer"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamReader*)local_this)->get_file_major_ver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileMajorVer(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_file_major_ver_316_comment =
    "C++ Interface:\n"
    "getFileMajorVer(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_file_major_ver\n"
    "//       Access: Published\n"
    "//  Description: Returns the major version number of the Bam file\n"
    "//               currently being read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_file_major_ver_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamReader::get_file_minor_ver(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_file_minor_ver_317(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamReader::get_file_minor_ver(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileMinorVer", key_word_list));
        else
            (PyArg_Parse(args, ":getFileMinorVer"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamReader*)local_this)->get_file_minor_ver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileMinorVer(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_file_minor_ver_317_comment =
    "C++ Interface:\n"
    "getFileMinorVer(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_file_minor_ver\n"
    "//       Access: Published\n"
    "//  Description: Returns the minor version number of the Bam file\n"
    "//               currently being read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_file_minor_ver_317_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BamEnums::BamEndian BamReader::get_file_endian(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_file_endian_318(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BamEnums::BamEndian BamReader::get_file_endian(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileEndian", key_word_list));
        else
            (PyArg_Parse(args, ":getFileEndian"));
        if(!PyErr_Occurred())
        {
            BamEnums::BamEndian return_value = ((const BamReader*)local_this)->get_file_endian();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileEndian(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_file_endian_318_comment =
    "C++ Interface:\n"
    "getFileEndian(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_file_endian\n"
    "//       Access: Published\n"
    "//  Description: Returns the endian preference indicated by the Bam\n"
    "//               file currently being read.  This does not imply that\n"
    "//               every number is stored using the indicated\n"
    "//               convention, but individual objects may choose to\n"
    "//               respect this flag when recording data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_file_endian_318_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamReader::get_current_major_ver(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_current_major_ver_319(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamReader::get_current_major_ver(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentMajorVer", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentMajorVer"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamReader*)local_this)->get_current_major_ver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentMajorVer(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_current_major_ver_319_comment =
    "C++ Interface:\n"
    "getCurrentMajorVer(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_current_major_ver\n"
    "//       Access: Published\n"
    "//  Description: Returns the major version number of Bam files\n"
    "//               supported by the current code base.  This must match\n"
    "//               get_file_major_ver() in order to successfully read a\n"
    "//               file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_current_major_ver_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BamReader::get_current_minor_ver(void) const
 *******************************************************************/
static PyObject *Dtool_BamReader_get_current_minor_ver_320(PyObject *self, PyObject *args,PyObject *kwds) {
    BamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BamReader::get_current_minor_ver(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentMinorVer", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentMinorVer"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BamReader*)local_this)->get_current_minor_ver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentMinorVer(const BamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamReader_get_current_minor_ver_320_comment =
    "C++ Interface:\n"
    "getCurrentMinorVer(const BamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamReader::get_current_minor_ver\n"
    "//       Access: Published\n"
    "//  Description: Returns the minor version number of Bam files\n"
    "//               supported by the current code base.  This must match\n"
    "//               or exceed get_file_minor_ver() in order to\n"
    "//               successfully read a file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamReader_get_current_minor_ver_320_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BamReader::BamReader(DatagramGenerator *source, Filename const &name)
 * BamReader::BamReader(DatagramGenerator *source, Filename const &name = (""))
 * BamReader::BamReader(DatagramGenerator *source = ((void *)(0)), Filename const &name = (""))
 *******************************************************************/
int  Dtool_Init_BamReader(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-BamReader::BamReader(DatagramGenerator *source = ((void *)(0)), Filename const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BamReader", key_word_list))
            {
                BamReader *return_value = new BamReader();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BamReader,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BamReader::BamReader(DatagramGenerator *source, Filename const &name = (""))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"source", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BamReader", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BamReader", &param0));
                if(!PyErr_Occurred())
                {
                    DatagramGenerator *param0_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DatagramGenerator, 0, "BamReader.BamReader", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BamReader *return_value = new BamReader(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BamReader,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BamReader::BamReader(DatagramGenerator *source, Filename const &name)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"source", (char *)"name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:BamReader", key_word_list, &param0, &param1))
                {
                    DatagramGenerator *param0_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DatagramGenerator, 0, "BamReader.BamReader", 0, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "BamReader.BamReader", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        BamReader *return_value = new BamReader(param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BamReader,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BamReader() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BamReader()\n"
          "BamReader(non-const DatagramGenerator source)\n"
          "BamReader(non-const DatagramGenerator source, const Filename name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BamReader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BamReader)
    {
        printf("BamReader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BamReader * local_this = (BamReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BamReader)
        return local_this;
    if(requested_type == &Dtool_BamEnums)
        return ( BamEnums *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BamReader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BamReader)
        return from_this;
    if(from_type == &Dtool_BamEnums)
    {
          BamEnums* other_this = (BamEnums*)from_this;
          return (BamReader*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BamWriter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void BamWriter::set_target(DatagramSink *target)
 *******************************************************************/
static PyObject *Dtool_BamWriter_set_target_324(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BamWriter::set_target(DatagramSink *target)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"target", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTarget", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTarget", &param1));
            if(!PyErr_Occurred())
            {
                DatagramSink *param1_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramSink, 1, "BamWriter.setTarget", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_target(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamWriter.setTarget() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTarget(non-const BamWriter this, non-const DatagramSink target)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_set_target_324_comment =
    "C++ Interface:\n"
    "setTarget(non-const BamWriter this, non-const DatagramSink target)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::set_target\n"
    "//       Access: Published\n"
    "//  Description: Changes the destination of future datagrams written\n"
    "//               by the BamWriter.  This also implicitly calls init()\n"
    "//               if it has not already been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_set_target_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamWriter::init(void)
 *******************************************************************/
static PyObject *Dtool_BamWriter_init_325(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool BamWriter::init(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":init", key_word_list));
        else
            (PyArg_Parse(args, ":init"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->init();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamWriter.init() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "init(non-const BamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_init_325_comment =
    "C++ Interface:\n"
    "init(non-const BamWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::init\n"
    "//       Access: Published\n"
    "//  Description: Initializes the BamWriter prior to writing any\n"
    "//               objects to its output stream.  This includes writing\n"
    "//               out the Bam header.\n"
    "//\n"
    "//               This returns true if the BamWriter successfully\n"
    "//               initialized, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_init_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &BamWriter::get_filename(void) const
 *******************************************************************/
static PyObject *Dtool_BamWriter_get_filename_326(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &BamWriter::get_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const BamWriter*)local_this)->get_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilename(const BamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_get_filename_326_comment =
    "C++ Interface:\n"
    "getFilename(const BamWriter this)\n"
    "\n"
    "// Filename: bamWriter.I\n"
    "// Created by:  jason (08Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::get_filename\n"
    "//       Access: Published\n"
    "//  Description: If a BAM is a file, then the BamWriter should\n"
    "//               contain the name of the file.  This enables the\n"
    "//               writer to convert pathnames in the BAM to relative\n"
    "//               to the directory containing the BAM.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_get_filename_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamWriter::write_object(TypedWritable const *obj)
 *******************************************************************/
static PyObject *Dtool_BamWriter_write_object_327(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool BamWriter::write_object(TypedWritable const *obj)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"obj", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeObject", &param1));
            if(!PyErr_Occurred())
            {
                TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedWritable, 1, "BamWriter.writeObject", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->write_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BamWriter.writeObject() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeObject(non-const BamWriter this, const TypedWritable obj)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_write_object_327_comment =
    "C++ Interface:\n"
    "writeObject(non-const BamWriter this, const TypedWritable obj)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::write_object\n"
    "//       Access: Published\n"
    "//  Description: Writes a single object to the Bam file, so that the\n"
    "//               BamReader::read_object() can later correctly restore\n"
    "//               the object and all its pointers.\n"
    "//\n"
    "//               This implicitly also writes any additional objects\n"
    "//               this object references (if they haven't already been\n"
    "//               written), so that pointers may be fully resolved.\n"
    "//\n"
    "//               This may be called repeatedly to write a sequence of\n"
    "//               objects to the Bam file, but typically (especially\n"
    "//               for scene graph files, indicated with the .bam\n"
    "//               extension), only one object is written directly from\n"
    "//               the Bam file: the root of the scene graph.  The\n"
    "//               remaining objects will all be written recursively by\n"
    "//               the first object.\n"
    "//\n"
    "//               Returns true if the object is successfully written,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_write_object_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BamWriter::has_object(TypedWritable const *obj) const
 *******************************************************************/
static PyObject *Dtool_BamWriter_has_object_328(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool BamWriter::has_object(TypedWritable const *obj) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"obj", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasObject", &param1));
            if(!PyErr_Occurred())
            {
                TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedWritable, 1, "BamWriter.hasObject", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BamWriter*)local_this)->has_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasObject(const BamWriter this, const TypedWritable obj)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_has_object_328_comment =
    "C++ Interface:\n"
    "hasObject(const BamWriter this, const TypedWritable obj)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::has_object\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the object has previously been\n"
    "//               written (or at least requested to be written) to the\n"
    "//               bam file, or false if we've never heard of it before.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_has_object_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BamWriter::flush(void)
 *******************************************************************/
static PyObject *Dtool_BamWriter_flush_329(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BamWriter::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamWriter.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const BamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_flush_329_comment =
    "C++ Interface:\n"
    "flush(non-const BamWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::flush\n"
    "//       Access: Published\n"
    "//  Description: Ensures that all data written thus far is manifested\n"
    "//               on the output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_flush_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
 *******************************************************************/
static PyObject *Dtool_BamWriter_get_file_endian_330(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileEndian", key_word_list));
        else
            (PyArg_Parse(args, ":getFileEndian"));
        if(!PyErr_Occurred())
        {
            BamEnums::BamEndian return_value = ((const BamWriter*)local_this)->get_file_endian();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileEndian(const BamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_get_file_endian_330_comment =
    "C++ Interface:\n"
    "getFileEndian(const BamWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::get_file_endian\n"
    "//       Access: Published\n"
    "//  Description: Returns the endian preference indicated by the Bam\n"
    "//               file currently being written.  This does not imply\n"
    "//               that every number is stored using the indicated\n"
    "//               convention, but individual objects may choose to\n"
    "//               respect this flag when recording data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_get_file_endian_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
 *******************************************************************/
static PyObject *Dtool_BamWriter_get_file_texture_mode_331(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileTextureMode", key_word_list));
        else
            (PyArg_Parse(args, ":getFileTextureMode"));
        if(!PyErr_Occurred())
        {
            BamEnums::BamTextureMode return_value = ((const BamWriter*)local_this)->get_file_texture_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileTextureMode(const BamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_get_file_texture_mode_331_comment =
    "C++ Interface:\n"
    "getFileTextureMode(const BamWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::get_file_texture_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the BamTextureMode preference indicated by\n"
    "//               the Bam file currently being written.  Texture\n"
    "//               objects written to this Bam file will be encoded\n"
    "//               according to the specified mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_get_file_texture_mode_331_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode)
 *******************************************************************/
static PyObject *Dtool_BamWriter_set_file_texture_mode_332(PyObject *self, PyObject *args,PyObject *kwds) {
    BamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode)
        int param1;
        static char * key_word_list[] = {(char *)"file_texture_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFileTextureMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFileTextureMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_file_texture_mode((BamEnums::BamTextureMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BamWriter.setFileTextureMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFileTextureMode(non-const BamWriter this, int file_texture_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BamWriter_set_file_texture_mode_332_comment =
    "C++ Interface:\n"
    "setFileTextureMode(non-const BamWriter this, int file_texture_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BamWriter::set_file_texture_mode\n"
    "//       Access: Published\n"
    "//  Description: Changes the BamTextureMode preference for\n"
    "//               the Bam file currently being written.  Texture\n"
    "//               objects written to this Bam file will be encoded\n"
    "//               according to the specified mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BamWriter_set_file_texture_mode_332_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BamWriter::BamWriter(DatagramSink *target, Filename const &name)
 * BamWriter::BamWriter(DatagramSink *target, Filename const &name = (""))
 * BamWriter::BamWriter(DatagramSink *target = ((void *)(0)), Filename const &name = (""))
 *******************************************************************/
int  Dtool_Init_BamWriter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-BamWriter::BamWriter(DatagramSink *target = ((void *)(0)), Filename const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BamWriter", key_word_list))
            {
                BamWriter *return_value = new BamWriter();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BamWriter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BamWriter::BamWriter(DatagramSink *target, Filename const &name = (""))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"target", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BamWriter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BamWriter", &param0));
                if(!PyErr_Occurred())
                {
                    DatagramSink *param0_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DatagramSink, 0, "BamWriter.BamWriter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BamWriter *return_value = new BamWriter(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BamWriter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BamWriter::BamWriter(DatagramSink *target, Filename const &name)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"target", (char *)"name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:BamWriter", key_word_list, &param0, &param1))
                {
                    DatagramSink *param0_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DatagramSink, 0, "BamWriter.BamWriter", 0, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "BamWriter.BamWriter", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        BamWriter *return_value = new BamWriter(param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BamWriter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BamWriter() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BamWriter()\n"
          "BamWriter(non-const DatagramSink target)\n"
          "BamWriter(non-const DatagramSink target, const Filename name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BamWriter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BamWriter)
    {
        printf("BamWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BamWriter * local_this = (BamWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BamWriter)
        return local_this;
    if(requested_type == &Dtool_BamEnums)
        return ( BamEnums *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BamWriter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BamWriter)
        return from_this;
    if(from_type == &Dtool_BamEnums)
    {
          BamEnums* other_this = (BamEnums*)from_this;
          return (BamWriter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BitMask< unsigned int, 32 > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > &::BitMask< unsigned int, 32 >::operator =(BitMask< unsigned int, 32 > const &copy)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_335(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline BitMask< unsigned int, 32 > &::BitMask< unsigned int, 32 >::operator =(BitMask< unsigned int, 32 > const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    BitMask< unsigned int, 32 > *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const BitMask this, const BitMask copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_335_comment =
    "C++ Interface:\n"
    "assign(non-const BitMask this, const BitMask copy)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::all_on(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_all_on_336(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::all_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOn", key_word_list))
        {
            BitMask< unsigned int, 32 > result = ::BitMask< unsigned int, 32 >::all_on();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_all_on_336_comment =
    "C++ Interface:\n"
    "allOn()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_all_on_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::all_off(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_all_off_337(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::all_off(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOff", key_word_list))
        {
            BitMask< unsigned int, 32 > result = ::BitMask< unsigned int, 32 >::all_off();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOff()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_all_off_337_comment =
    "C++ Interface:\n"
    "allOff()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_all_off_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::lower_on(int on_bits)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_lower_on_338(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::lower_on(int on_bits)
        int param0;
        static char * key_word_list[] = {(char *)"on_bits", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:lowerOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:lowerOn", &param0));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ::BitMask< unsigned int, 32 >::lower_on((int)param0);
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lowerOn(int on_bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_lower_on_338_comment =
    "C++ Interface:\n"
    "lowerOn(int on_bits)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_lower_on_338_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_bit_339(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::bit(int index)
        int param0;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:bit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:bit", &param0));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ::BitMask< unsigned int, 32 >::bit((int)param0);
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bit(int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_bit_339_comment =
    "C++ Interface:\n"
    "bit(int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_bit_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_range_340(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::range(int low_bit, int size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:range", key_word_list, &param0, &param1))
        {
            BitMask< unsigned int, 32 > result = ::BitMask< unsigned int, 32 >::range((int)param0, (int)param1);
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "range(int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_range_340_comment =
    "C++ Interface:\n"
    "range(int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_range_340_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool ::BitMask< unsigned int, 32 >::has_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_has_max_num_bits_342(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool ::BitMask< unsigned int, 32 >::has_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxNumBits", key_word_list))
        {
            bool return_value = ::BitMask< unsigned int, 32 >::has_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_has_max_num_bits_342_comment =
    "C++ Interface:\n"
    "hasMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_has_max_num_bits_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::BitMask< unsigned int, 32 >::get_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_max_num_bits_343(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::BitMask< unsigned int, 32 >::get_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxNumBits", key_word_list))
        {
            int return_value = ::BitMask< unsigned int, 32 >::get_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_max_num_bits_343_comment =
    "C++ Interface:\n"
    "getMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_max_num_bits_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::BitMask< unsigned int, 32 >::get_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_num_bits_344(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::BitMask< unsigned int, 32 >::get_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBits", key_word_list))
        {
            int return_value = ::BitMask< unsigned int, 32 >::get_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_num_bits_344_comment =
    "C++ Interface:\n"
    "getNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_num_bits_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::get_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_bit_345(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned int, 32 >::get_bit(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBit(const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_bit_345_comment =
    "C++ Interface:\n"
    "getBit(const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_bit_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::set_bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_set_bit_346(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::set_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBit(non-const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_set_bit_346_comment =
    "C++ Interface:\n"
    "setBit(non-const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_set_bit_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::clear_bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_clear_bit_347(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::clear_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.clearBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBit(non-const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_clear_bit_347_comment =
    "C++ Interface:\n"
    "clearBit(non-const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_clear_bit_347_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::set_bit_to(int index, bool value)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_set_bit_to_348(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::set_bit_to(int index, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBitTo", key_word_list, &param1, &param2))
        {
            (local_this)->set_bit_to((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setBitTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBitTo(non-const BitMask this, int index, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_set_bit_to_348_comment =
    "C++ Interface:\n"
    "setBitTo(non-const BitMask this, int index, bool value)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_set_bit_to_348_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::is_zero(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_is_zero_349(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned int, 32 >::is_zero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isZero", key_word_list));
        else
            (PyArg_Parse(args, ":isZero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->is_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isZero(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_is_zero_349_comment =
    "C++ Interface:\n"
    "isZero(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_is_zero_349_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::is_all_on(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_is_all_on_350(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned int, 32 >::is_all_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAllOn", key_word_list));
        else
            (PyArg_Parse(args, ":isAllOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->is_all_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAllOn(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_is_all_on_350_comment =
    "C++ Interface:\n"
    "isAllOn(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_is_all_on_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::BitMask< unsigned int, 32 >::extract(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_extract_351(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::BitMask< unsigned int, 32 >::extract(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:extract", key_word_list, &param1, &param2))
        {
            unsigned int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->extract((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extract(const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_extract_351_comment =
    "C++ Interface:\n"
    "extract(const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_extract_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::store(unsigned int value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_store_352(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::store(unsigned int value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:store", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->store(PyLong_AsUnsignedLong(param1_uint), (int)param2, (int)param3);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.store() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store(non-const BitMask this, unsigned int value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_store_352_comment =
    "C++ Interface:\n"
    "store(non-const BitMask this, unsigned int value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_store_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::has_any_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_has_any_of_353(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned int, 32 >::has_any_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAnyOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->has_any_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnyOf(const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_has_any_of_353_comment =
    "C++ Interface:\n"
    "hasAnyOf(const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_has_any_of_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::has_all_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_has_all_of_354(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned int, 32 >::has_all_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAllOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->has_all_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAllOf(const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_has_all_of_354_comment =
    "C++ Interface:\n"
    "hasAllOf(const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_has_all_of_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::set_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_set_range_355(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::set_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_set_range_355_comment =
    "C++ Interface:\n"
    "setRange(non-const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_set_range_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::clear_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_clear_range_356(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::clear_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clearRange", key_word_list, &param1, &param2))
        {
            (local_this)->clear_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.clearRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRange(non-const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_clear_range_356_comment =
    "C++ Interface:\n"
    "clearRange(non-const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_clear_range_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::set_range_to(bool value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_set_range_to_357(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::set_range_to(bool value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setRangeTo", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_range_to((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setRangeTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRangeTo(non-const BitMask this, bool value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_set_range_to_357_comment =
    "C++ Interface:\n"
    "setRangeTo(non-const BitMask this, bool value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_set_range_to_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::BitMask< unsigned int, 32 >::get_word(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_word_358(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::BitMask< unsigned int, 32 >::get_word(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWord", key_word_list));
        else
            (PyArg_Parse(args, ":getWord"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_word();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_word_358_comment =
    "C++ Interface:\n"
    "getWord(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_word_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::set_word(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_set_word_359(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::set_word(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setWord", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_word(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const BitMask this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_set_word_359_comment =
    "C++ Interface:\n"
    "setWord(non-const BitMask this, unsigned int value)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_set_word_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_num_on_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_num_on_bits_360(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_num_on_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOnBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOnBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_num_on_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOnBits(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_num_on_bits_360_comment =
    "C++ Interface:\n"
    "getNumOnBits(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_num_on_bits_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_num_off_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_num_off_bits_361(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_num_off_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOffBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOffBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_num_off_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOffBits(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_num_off_bits_361_comment =
    "C++ Interface:\n"
    "getNumOffBits(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_num_off_bits_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_lowest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_lowest_on_bit_362(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_lowest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_lowest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOnBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_lowest_on_bit_362_comment =
    "C++ Interface:\n"
    "getLowestOnBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_lowest_on_bit_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_lowest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_lowest_off_bit_363(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_lowest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_lowest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOffBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_lowest_off_bit_363_comment =
    "C++ Interface:\n"
    "getLowestOffBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_lowest_off_bit_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_highest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_highest_on_bit_364(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_highest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_highest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOnBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_highest_on_bit_364_comment =
    "C++ Interface:\n"
    "getHighestOnBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_highest_on_bit_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_highest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_highest_off_bit_365(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_highest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_highest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOffBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_highest_off_bit_365_comment =
    "C++ Interface:\n"
    "getHighestOffBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_highest_off_bit_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_next_higher_different_bit(int low_bit) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_next_higher_different_bit_366(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_next_higher_different_bit(int low_bit) const
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNextHigherDifferentBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNextHigherDifferentBit", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_next_higher_different_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextHigherDifferentBit(const BitMask this, int low_bit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_next_higher_different_bit_366_comment =
    "C++ Interface:\n"
    "getNextHigherDifferentBit(const BitMask this, int low_bit)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_next_higher_different_bit_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::invert_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_invert_in_place_367(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::invert_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":invertInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":invertInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->invert_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.invertInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "invertInPlace(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_invert_in_place_367_comment =
    "C++ Interface:\n"
    "invertInPlace(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_invert_in_place_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::has_bits_in_common(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_has_bits_in_common_368(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned int, 32 >::has_bits_in_common(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasBitsInCommon", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasBitsInCommon", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.hasBitsInCommon", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->has_bits_in_common(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBitsInCommon(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_has_bits_in_common_368_comment =
    "C++ Interface:\n"
    "hasBitsInCommon(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_has_bits_in_common_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::clear(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_clear_369(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_clear_369_comment =
    "C++ Interface:\n"
    "clear(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_clear_369_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned int, 32 >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_output_370(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::BitMask< unsigned int, 32 >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BitMask< unsigned int, 32 >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BitMask this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_output_370_comment =
    "C++ Interface:\n"
    "output(const BitMask this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_output_370_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned int, 32 >::output_binary(ostream &out, int spaces_every) const
 * void ::BitMask< unsigned int, 32 >::output_binary(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_output_binary_371(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned int, 32 >::output_binary(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBinary", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputBinary", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned int, 32 >*)local_this)->output_binary(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned int, 32 >::output_binary(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputBinary", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned int, 32 >*)local_this)->output_binary(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputBinary() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputBinary(const BitMask this, non-const Ostream out)\n"
          "outputBinary(const BitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_output_binary_371_comment =
    "C++ Interface:\n"
    "outputBinary(const BitMask this, non-const Ostream out)\n"
    "outputBinary(const BitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_output_binary_371_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned int, 32 >::output_hex(ostream &out, int spaces_every) const
 * void ::BitMask< unsigned int, 32 >::output_hex(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_output_hex_372(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned int, 32 >::output_hex(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputHex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputHex", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned int, 32 >*)local_this)->output_hex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned int, 32 >::output_hex(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputHex", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned int, 32 >*)local_this)->output_hex(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputHex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputHex(const BitMask this, non-const Ostream out)\n"
          "outputHex(const BitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_output_hex_372_comment =
    "C++ Interface:\n"
    "outputHex(const BitMask this, non-const Ostream out)\n"
    "outputHex(const BitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_output_hex_372_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned int, 32 >::write(ostream &out, int indent_level) const
 * void ::BitMask< unsigned int, 32 >::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_write_373(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned int, 32 >::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned int, 32 >*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned int, 32 >::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned int, 32 >*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BitMask this, non-const Ostream out)\n"
          "write(const BitMask this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_write_373_comment =
    "C++ Interface:\n"
    "write(const BitMask this, non-const Ostream out)\n"
    "write(const BitMask this, non-const Ostream out, int indent_level)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_write_373_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::operator ==(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_374(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned int, 32 >::operator ==(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_374_comment =
    "C++ Interface:\n"
    "eq(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_374_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::operator !=(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_375(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned int, 32 >::operator !=(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_375_comment =
    "C++ Interface:\n"
    "ne(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_375_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned int, 32 >::operator <(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_376(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned int, 32 >::operator <(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned int, 32 >*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_376_comment =
    "C++ Interface:\n"
    "lessThan(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_376_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::compare_to(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_compare_to_377(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int ::BitMask< unsigned int, 32 >::compare_to(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_compare_to_377_comment =
    "C++ Interface:\n"
    "compareTo(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_compare_to_377_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator &(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_378(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator &(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->operator &(*param1_this);
                    BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_378_comment =
    "C++ Interface:\n"
    "__and__(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_378_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator |(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_379(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator |(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->operator |(*param1_this);
                    BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_379_comment =
    "C++ Interface:\n"
    "__or__(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_379_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator ^(BitMask< unsigned int, 32 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_380(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator ^(BitMask< unsigned int, 32 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__xor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__xor__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.__xor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->operator ^(*param1_this);
                    BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__xor__(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_380_comment =
    "C++ Interface:\n"
    "__xor__(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_380_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_381(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator ~(void) const
        {
            BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->operator ~();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_381_comment =
    "C++ Interface:\n"
    "__invert__(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_381_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator <<(int shift) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_382(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator <<(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__lshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__lshift__", &param1));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->operator <<((int)param1);
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__lshift__(const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_382_comment =
    "C++ Interface:\n"
    "__lshift__(const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_382_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator >>(int shift) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_383(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::operator >>(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__rshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__rshift__", &param1));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->operator >>((int)param1);
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__rshift__(const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_383_comment =
    "C++ Interface:\n"
    "__rshift__(const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_383_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::operator &=(BitMask< unsigned int, 32 > const &other)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_384(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::BitMask< unsigned int, 32 >::operator &=(BitMask< unsigned int, 32 > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_384_comment =
    "C++ Interface:\n"
    "__iand__(non-const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_384_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::operator |=(BitMask< unsigned int, 32 > const &other)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_385(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::BitMask< unsigned int, 32 >::operator |=(BitMask< unsigned int, 32 > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_385_comment =
    "C++ Interface:\n"
    "__ior__(non-const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_385_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::operator ^=(BitMask< unsigned int, 32 > const &other)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_386(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::BitMask< unsigned int, 32 >::operator ^=(BitMask< unsigned int, 32 > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ixor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ixor__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.__ixor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator ^=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.__ixor__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ixor__(non-const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_386_comment =
    "C++ Interface:\n"
    "__ixor__(non-const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_386_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::operator <<=(int shift)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_387(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::operator <<=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__ilshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__ilshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator <<=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.__ilshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ilshift__(non-const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_387_comment =
    "C++ Interface:\n"
    "__ilshift__(non-const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_387_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::operator >>=(int shift)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_operator_388(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::operator >>=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__irshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__irshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator >>=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.__irshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__irshift__(non-const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_operator_388_comment =
    "C++ Interface:\n"
    "__irshift__(non-const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_operator_388_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::flood_down_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_flood_down_in_place_389(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::flood_down_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodDownInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":floodDownInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->flood_down_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.floodDownInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodDownInPlace(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_flood_down_in_place_389_comment =
    "C++ Interface:\n"
    "floodDownInPlace(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_flood_down_in_place_389_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned int, 32 >::flood_up_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_flood_up_in_place_390(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned int, 32 >::flood_up_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodUpInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":floodUpInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->flood_up_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.floodUpInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodUpInPlace(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_flood_up_in_place_390_comment =
    "C++ Interface:\n"
    "floodUpInPlace(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_flood_up_in_place_390_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::flood_bits_down(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_flood_bits_down_391(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::flood_bits_down(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodBitsDown", key_word_list));
        else
            (PyArg_Parse(args, ":floodBitsDown"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->flood_bits_down();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodBitsDown(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_flood_bits_down_391_comment =
    "C++ Interface:\n"
    "floodBitsDown(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_flood_bits_down_391_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::flood_bits_up(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_flood_bits_up_392(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::flood_bits_up(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodBitsUp", key_word_list));
        else
            (PyArg_Parse(args, ":floodBitsUp"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->flood_bits_up();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodBitsUp(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_flood_bits_up_392_comment =
    "C++ Interface:\n"
    "floodBitsUp(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_flood_bits_up_392_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_highest_bit(void) const
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_highest_bit(BitMask< unsigned int, 32 > const &other) const
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_highest_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_keep_next_highest_bit_393(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_highest_bit(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":keepNextHighestBit", key_word_list));
            else
                (PyArg_Parse(args, ":keepNextHighestBit"));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->keep_next_highest_bit();
                BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_highest_bit(BitMask< unsigned int, 32 > const &other) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:keepNextHighestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:keepNextHighestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.keepNextHighestBit", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->keep_next_highest_bit(*param1_this);
                        BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_highest_bit(int index) const
                int param1;
                static char * key_word_list[] = {(char *)"index", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:keepNextHighestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "i:keepNextHighestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->keep_next_highest_bit((int)param1);
                    BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "keepNextHighestBit() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "keepNextHighestBit(const BitMask this)\n"
          "keepNextHighestBit(const BitMask this, const BitMask other)\n"
          "keepNextHighestBit(const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_keep_next_highest_bit_393_comment =
    "C++ Interface:\n"
    "keepNextHighestBit(const BitMask this)\n"
    "keepNextHighestBit(const BitMask this, const BitMask other)\n"
    "keepNextHighestBit(const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_keep_next_highest_bit_393_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_lowest_bit(void) const
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_lowest_bit(BitMask< unsigned int, 32 > const &other) const
 * inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_lowest_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_keep_next_lowest_bit_394(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_lowest_bit(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":keepNextLowestBit", key_word_list));
            else
                (PyArg_Parse(args, ":keepNextLowestBit"));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->keep_next_lowest_bit();
                BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_lowest_bit(BitMask< unsigned int, 32 > const &other) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:keepNextLowestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:keepNextLowestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "BitMask.keepNextLowestBit", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->keep_next_lowest_bit(*param1_this);
                        BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline BitMask< unsigned int, 32 > ::BitMask< unsigned int, 32 >::keep_next_lowest_bit(int index) const
                int param1;
                static char * key_word_list[] = {(char *)"index", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:keepNextLowestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "i:keepNextLowestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned int, 32 > result = ((const BitMask< unsigned int, 32 >*)local_this)->keep_next_lowest_bit((int)param1);
                    BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "keepNextLowestBit() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "keepNextLowestBit(const BitMask this)\n"
          "keepNextLowestBit(const BitMask this, const BitMask other)\n"
          "keepNextLowestBit(const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_keep_next_lowest_bit_394_comment =
    "C++ Interface:\n"
    "keepNextLowestBit(const BitMask this)\n"
    "keepNextLowestBit(const BitMask this, const BitMask other)\n"
    "keepNextLowestBit(const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_keep_next_lowest_bit_394_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned int, 32 >::get_key(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_key_395(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned int, 32 >::get_key(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKey", key_word_list));
        else
            (PyArg_Parse(args, ":getKey"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned int, 32 >*)local_this)->get_key();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKey(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_key_395_comment =
    "C++ Interface:\n"
    "getKey(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_key_395_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::BitMask< unsigned int, 32 >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int_32_get_class_type_396(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::BitMask< unsigned int, 32 >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::BitMask< unsigned int, 32 >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int_32_get_class_type_396_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int_32_get_class_type_396_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::BitMask< unsigned int, 32 >::BitMask(void)
 * inline ::BitMask< unsigned int, 32 >::BitMask(BitMask< unsigned int, 32 > const &copy)
 * inline ::BitMask< unsigned int, 32 >::BitMask(unsigned int init_value)
 *******************************************************************/
int  Dtool_Init_BitMask_unsigned_int_32(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::BitMask< unsigned int, 32 >::BitMask(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BitMask", key_word_list))
            {
                BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BitMask_unsigned_int_32,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::BitMask< unsigned int, 32 >::BitMask(BitMask< unsigned int, 32 > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitMask", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitMask", &param0));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned int, 32 > *param0_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_BitMask_unsigned_int_32, 0, "BitMask.BitMask", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitMask_unsigned_int_32,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::BitMask< unsigned int, 32 >::BitMask(unsigned int init_value)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"init_value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitMask", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitMask", &param0));
                if(!PyErr_Occurred())
                {
                     PyObject *param0_uint = PyNumber_Long(param0);
                    if (!((param0_uint == NULL)))
                    {
                        BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(PyLong_AsUnsignedLong(param0_uint));
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitMask_unsigned_int_32,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BitMask() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BitMask()\n"
          "BitMask(const BitMask copy)\n"
          "BitMask(unsigned int init_value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BitMask_unsigned_int_32(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BitMask_unsigned_int_32)
    {
        printf("BitMask_unsigned_int_32 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BitMask< unsigned int, 32 > * local_this = (BitMask< unsigned int, 32 > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BitMask_unsigned_int_32)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BitMask_unsigned_int_32(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BitMask_unsigned_int_32)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BitMask< unsigned __int64, 64 > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > &::BitMask< unsigned __int64, 64 >::operator =(BitMask< unsigned __int64, 64 > const &copy)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_399(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline BitMask< unsigned __int64, 64 > &::BitMask< unsigned __int64, 64 >::operator =(BitMask< unsigned __int64, 64 > const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    BitMask< unsigned __int64, 64 > *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const BitMask this, const BitMask copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_399_comment =
    "C++ Interface:\n"
    "assign(non-const BitMask this, const BitMask copy)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_399_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::all_on(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_all_on_400(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::all_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOn", key_word_list))
        {
            BitMask< unsigned __int64, 64 > result = ::BitMask< unsigned __int64, 64 >::all_on();
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_all_on_400_comment =
    "C++ Interface:\n"
    "allOn()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_all_on_400_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::all_off(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_all_off_401(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::all_off(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOff", key_word_list))
        {
            BitMask< unsigned __int64, 64 > result = ::BitMask< unsigned __int64, 64 >::all_off();
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOff()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_all_off_401_comment =
    "C++ Interface:\n"
    "allOff()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_all_off_401_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::lower_on(int on_bits)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_lower_on_402(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::lower_on(int on_bits)
        int param0;
        static char * key_word_list[] = {(char *)"on_bits", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:lowerOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:lowerOn", &param0));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned __int64, 64 > result = ::BitMask< unsigned __int64, 64 >::lower_on((int)param0);
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lowerOn(int on_bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_lower_on_402_comment =
    "C++ Interface:\n"
    "lowerOn(int on_bits)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_lower_on_402_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_bit_403(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::bit(int index)
        int param0;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:bit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:bit", &param0));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned __int64, 64 > result = ::BitMask< unsigned __int64, 64 >::bit((int)param0);
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bit(int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_bit_403_comment =
    "C++ Interface:\n"
    "bit(int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_bit_403_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_range_404(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::range(int low_bit, int size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:range", key_word_list, &param0, &param1))
        {
            BitMask< unsigned __int64, 64 > result = ::BitMask< unsigned __int64, 64 >::range((int)param0, (int)param1);
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "range(int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_range_404_comment =
    "C++ Interface:\n"
    "range(int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_range_404_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool ::BitMask< unsigned __int64, 64 >::has_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_has_max_num_bits_406(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool ::BitMask< unsigned __int64, 64 >::has_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxNumBits", key_word_list))
        {
            bool return_value = ::BitMask< unsigned __int64, 64 >::has_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_has_max_num_bits_406_comment =
    "C++ Interface:\n"
    "hasMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_has_max_num_bits_406_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::BitMask< unsigned __int64, 64 >::get_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_max_num_bits_407(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::BitMask< unsigned __int64, 64 >::get_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxNumBits", key_word_list))
        {
            int return_value = ::BitMask< unsigned __int64, 64 >::get_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_max_num_bits_407_comment =
    "C++ Interface:\n"
    "getMaxNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_max_num_bits_407_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ::BitMask< unsigned __int64, 64 >::get_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_num_bits_408(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ::BitMask< unsigned __int64, 64 >::get_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBits", key_word_list))
        {
            int return_value = ::BitMask< unsigned __int64, 64 >::get_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_num_bits_408_comment =
    "C++ Interface:\n"
    "getNumBits()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_num_bits_408_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::get_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_bit_409(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned __int64, 64 >::get_bit(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBit(const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_bit_409_comment =
    "C++ Interface:\n"
    "getBit(const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_bit_409_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::set_bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_set_bit_410(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::set_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBit(non-const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_set_bit_410_comment =
    "C++ Interface:\n"
    "setBit(non-const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_set_bit_410_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::clear_bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_clear_bit_411(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::clear_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.clearBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBit(non-const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_clear_bit_411_comment =
    "C++ Interface:\n"
    "clearBit(non-const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_clear_bit_411_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::set_bit_to(int index, bool value)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_set_bit_to_412(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::set_bit_to(int index, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBitTo", key_word_list, &param1, &param2))
        {
            (local_this)->set_bit_to((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setBitTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBitTo(non-const BitMask this, int index, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_set_bit_to_412_comment =
    "C++ Interface:\n"
    "setBitTo(non-const BitMask this, int index, bool value)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_set_bit_to_412_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::is_zero(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_is_zero_413(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned __int64, 64 >::is_zero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isZero", key_word_list));
        else
            (PyArg_Parse(args, ":isZero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->is_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isZero(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_is_zero_413_comment =
    "C++ Interface:\n"
    "isZero(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_is_zero_413_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::is_all_on(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_is_all_on_414(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned __int64, 64 >::is_all_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAllOn", key_word_list));
        else
            (PyArg_Parse(args, ":isAllOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->is_all_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAllOn(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_is_all_on_414_comment =
    "C++ Interface:\n"
    "isAllOn(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_is_all_on_414_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 ::BitMask< unsigned __int64, 64 >::extract(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_extract_415(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned __int64 ::BitMask< unsigned __int64, 64 >::extract(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:extract", key_word_list, &param1, &param2))
        {
            unsigned __int64 return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->extract((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extract(const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_extract_415_comment =
    "C++ Interface:\n"
    "extract(const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_extract_415_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::store(unsigned __int64 value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_store_416(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::store(unsigned __int64 value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:store", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->store(PyLong_AsUnsignedLongLong(param1_long), (int)param2, (int)param3);
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.store() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store(non-const BitMask this, unsigned long long value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_store_416_comment =
    "C++ Interface:\n"
    "store(non-const BitMask this, unsigned long long value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_store_416_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::has_any_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_has_any_of_417(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned __int64, 64 >::has_any_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAnyOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->has_any_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnyOf(const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_has_any_of_417_comment =
    "C++ Interface:\n"
    "hasAnyOf(const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_has_any_of_417_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::has_all_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_has_all_of_418(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::BitMask< unsigned __int64, 64 >::has_all_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAllOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->has_all_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAllOf(const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_has_all_of_418_comment =
    "C++ Interface:\n"
    "hasAllOf(const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_has_all_of_418_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::set_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_set_range_419(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::set_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_set_range_419_comment =
    "C++ Interface:\n"
    "setRange(non-const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_set_range_419_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::clear_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_clear_range_420(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::clear_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clearRange", key_word_list, &param1, &param2))
        {
            (local_this)->clear_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.clearRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRange(non-const BitMask this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_clear_range_420_comment =
    "C++ Interface:\n"
    "clearRange(non-const BitMask this, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_clear_range_420_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::set_range_to(bool value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_set_range_to_421(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::set_range_to(bool value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setRangeTo", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_range_to((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setRangeTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRangeTo(non-const BitMask this, bool value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_set_range_to_421_comment =
    "C++ Interface:\n"
    "setRangeTo(non-const BitMask this, bool value, int low_bit, int size)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_set_range_to_421_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 ::BitMask< unsigned __int64, 64 >::get_word(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_word_422(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned __int64 ::BitMask< unsigned __int64, 64 >::get_word(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWord", key_word_list));
        else
            (PyArg_Parse(args, ":getWord"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_word();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_word_422_comment =
    "C++ Interface:\n"
    "getWord(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_word_422_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::set_word(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_set_word_423(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::set_word(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setWord", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->set_word(PyLong_AsUnsignedLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const BitMask this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_set_word_423_comment =
    "C++ Interface:\n"
    "setWord(non-const BitMask this, unsigned long long value)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_set_word_423_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_num_on_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_num_on_bits_424(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_num_on_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOnBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOnBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_num_on_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOnBits(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_num_on_bits_424_comment =
    "C++ Interface:\n"
    "getNumOnBits(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_num_on_bits_424_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_num_off_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_num_off_bits_425(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_num_off_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOffBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOffBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_num_off_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOffBits(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_num_off_bits_425_comment =
    "C++ Interface:\n"
    "getNumOffBits(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_num_off_bits_425_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_lowest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_lowest_on_bit_426(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_lowest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_lowest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOnBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_lowest_on_bit_426_comment =
    "C++ Interface:\n"
    "getLowestOnBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_lowest_on_bit_426_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_lowest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_lowest_off_bit_427(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_lowest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_lowest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOffBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_lowest_off_bit_427_comment =
    "C++ Interface:\n"
    "getLowestOffBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_lowest_off_bit_427_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_highest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_highest_on_bit_428(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_highest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_highest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOnBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_highest_on_bit_428_comment =
    "C++ Interface:\n"
    "getHighestOnBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_highest_on_bit_428_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_highest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_highest_off_bit_429(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_highest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_highest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOffBit(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_highest_off_bit_429_comment =
    "C++ Interface:\n"
    "getHighestOffBit(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_highest_off_bit_429_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_next_higher_different_bit(int low_bit) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_next_higher_different_bit_430(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_next_higher_different_bit(int low_bit) const
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNextHigherDifferentBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNextHigherDifferentBit", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_next_higher_different_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextHigherDifferentBit(const BitMask this, int low_bit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_next_higher_different_bit_430_comment =
    "C++ Interface:\n"
    "getNextHigherDifferentBit(const BitMask this, int low_bit)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_next_higher_different_bit_430_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::invert_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_invert_in_place_431(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::invert_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":invertInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":invertInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->invert_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.invertInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "invertInPlace(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_invert_in_place_431_comment =
    "C++ Interface:\n"
    "invertInPlace(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_invert_in_place_431_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::has_bits_in_common(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_has_bits_in_common_432(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned __int64, 64 >::has_bits_in_common(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasBitsInCommon", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasBitsInCommon", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.hasBitsInCommon", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->has_bits_in_common(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBitsInCommon(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_has_bits_in_common_432_comment =
    "C++ Interface:\n"
    "hasBitsInCommon(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_has_bits_in_common_432_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::clear(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_clear_433(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_clear_433_comment =
    "C++ Interface:\n"
    "clear(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_clear_433_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned __int64, 64 >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_output_434(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::BitMask< unsigned __int64, 64 >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BitMask< unsigned __int64, 64 >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BitMask this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_output_434_comment =
    "C++ Interface:\n"
    "output(const BitMask this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_output_434_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned __int64, 64 >::output_binary(ostream &out, int spaces_every) const
 * void ::BitMask< unsigned __int64, 64 >::output_binary(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_output_binary_435(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned __int64, 64 >::output_binary(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBinary", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputBinary", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned __int64, 64 >*)local_this)->output_binary(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned __int64, 64 >::output_binary(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputBinary", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned __int64, 64 >*)local_this)->output_binary(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputBinary() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputBinary(const BitMask this, non-const Ostream out)\n"
          "outputBinary(const BitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_output_binary_435_comment =
    "C++ Interface:\n"
    "outputBinary(const BitMask this, non-const Ostream out)\n"
    "outputBinary(const BitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_output_binary_435_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned __int64, 64 >::output_hex(ostream &out, int spaces_every) const
 * void ::BitMask< unsigned __int64, 64 >::output_hex(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_output_hex_436(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned __int64, 64 >::output_hex(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputHex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputHex", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned __int64, 64 >*)local_this)->output_hex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned __int64, 64 >::output_hex(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputHex", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned __int64, 64 >*)local_this)->output_hex(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputHex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputHex(const BitMask this, non-const Ostream out)\n"
          "outputHex(const BitMask this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_output_hex_436_comment =
    "C++ Interface:\n"
    "outputHex(const BitMask this, non-const Ostream out)\n"
    "outputHex(const BitMask this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_output_hex_436_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::BitMask< unsigned __int64, 64 >::write(ostream &out, int indent_level) const
 * void ::BitMask< unsigned __int64, 64 >::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_write_437(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned __int64, 64 >::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned __int64, 64 >*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ::BitMask< unsigned __int64, 64 >::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitMask.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitMask< unsigned __int64, 64 >*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BitMask this, non-const Ostream out)\n"
          "write(const BitMask this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_write_437_comment =
    "C++ Interface:\n"
    "write(const BitMask this, non-const Ostream out)\n"
    "write(const BitMask this, non-const Ostream out, int indent_level)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_write_437_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::operator ==(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_438(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned __int64, 64 >::operator ==(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_438_comment =
    "C++ Interface:\n"
    "eq(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_438_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::operator !=(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_439(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned __int64, 64 >::operator !=(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_439_comment =
    "C++ Interface:\n"
    "ne(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_439_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::BitMask< unsigned __int64, 64 >::operator <(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_440(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ::BitMask< unsigned __int64, 64 >::operator <(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_440_comment =
    "C++ Interface:\n"
    "lessThan(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_440_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::compare_to(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_compare_to_441(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int ::BitMask< unsigned __int64, 64 >::compare_to(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_compare_to_441_comment =
    "C++ Interface:\n"
    "compareTo(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_compare_to_441_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator &(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_442(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator &(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator &(*param1_this);
                    BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_442_comment =
    "C++ Interface:\n"
    "__and__(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_442_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator |(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_443(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator |(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator |(*param1_this);
                    BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_443_comment =
    "C++ Interface:\n"
    "__or__(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_443_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator ^(BitMask< unsigned __int64, 64 > const &other) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_444(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator ^(BitMask< unsigned __int64, 64 > const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__xor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__xor__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.__xor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator ^(*param1_this);
                    BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__xor__(const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_444_comment =
    "C++ Interface:\n"
    "__xor__(const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_444_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_445(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator ~(void) const
        {
            BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator ~();
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_445_comment =
    "C++ Interface:\n"
    "__invert__(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_445_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator <<(int shift) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_446(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator <<(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__lshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__lshift__", &param1));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator <<((int)param1);
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__lshift__(const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_446_comment =
    "C++ Interface:\n"
    "__lshift__(const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_446_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator >>(int shift) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_447(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::operator >>(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__rshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__rshift__", &param1));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->operator >>((int)param1);
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__rshift__(const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_447_comment =
    "C++ Interface:\n"
    "__rshift__(const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_447_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::operator &=(BitMask< unsigned __int64, 64 > const &other)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_448(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::BitMask< unsigned __int64, 64 >::operator &=(BitMask< unsigned __int64, 64 > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_448_comment =
    "C++ Interface:\n"
    "__iand__(non-const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_448_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::operator |=(BitMask< unsigned __int64, 64 > const &other)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_449(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::BitMask< unsigned __int64, 64 >::operator |=(BitMask< unsigned __int64, 64 > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_449_comment =
    "C++ Interface:\n"
    "__ior__(non-const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_449_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::operator ^=(BitMask< unsigned __int64, 64 > const &other)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_450(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::BitMask< unsigned __int64, 64 >::operator ^=(BitMask< unsigned __int64, 64 > const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ixor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ixor__", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.__ixor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator ^=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitMask.__ixor__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ixor__(non-const BitMask this, const BitMask other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_450_comment =
    "C++ Interface:\n"
    "__ixor__(non-const BitMask this, const BitMask other)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_450_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::operator <<=(int shift)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_451(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::operator <<=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__ilshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__ilshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator <<=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.__ilshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ilshift__(non-const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_451_comment =
    "C++ Interface:\n"
    "__ilshift__(non-const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_451_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::operator >>=(int shift)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_452(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::operator >>=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__irshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__irshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator >>=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.__irshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__irshift__(non-const BitMask this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_operator_452_comment =
    "C++ Interface:\n"
    "__irshift__(non-const BitMask this, int shift)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_operator_452_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::flood_down_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_flood_down_in_place_453(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::flood_down_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodDownInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":floodDownInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->flood_down_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.floodDownInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodDownInPlace(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_flood_down_in_place_453_comment =
    "C++ Interface:\n"
    "floodDownInPlace(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_flood_down_in_place_453_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::BitMask< unsigned __int64, 64 >::flood_up_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_flood_up_in_place_454(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::BitMask< unsigned __int64, 64 >::flood_up_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodUpInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":floodUpInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->flood_up_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitMask.floodUpInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodUpInPlace(non-const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_flood_up_in_place_454_comment =
    "C++ Interface:\n"
    "floodUpInPlace(non-const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_flood_up_in_place_454_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::flood_bits_down(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_flood_bits_down_455(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::flood_bits_down(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodBitsDown", key_word_list));
        else
            (PyArg_Parse(args, ":floodBitsDown"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->flood_bits_down();
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodBitsDown(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_flood_bits_down_455_comment =
    "C++ Interface:\n"
    "floodBitsDown(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_flood_bits_down_455_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::flood_bits_up(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_flood_bits_up_456(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::flood_bits_up(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":floodBitsUp", key_word_list));
        else
            (PyArg_Parse(args, ":floodBitsUp"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->flood_bits_up();
            BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "floodBitsUp(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_flood_bits_up_456_comment =
    "C++ Interface:\n"
    "floodBitsUp(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_flood_bits_up_456_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_highest_bit(void) const
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_highest_bit(BitMask< unsigned __int64, 64 > const &other) const
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_highest_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_keep_next_highest_bit_457(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_highest_bit(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":keepNextHighestBit", key_word_list));
            else
                (PyArg_Parse(args, ":keepNextHighestBit"));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->keep_next_highest_bit();
                BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_highest_bit(BitMask< unsigned __int64, 64 > const &other) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:keepNextHighestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:keepNextHighestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.keepNextHighestBit", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->keep_next_highest_bit(*param1_this);
                        BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_highest_bit(int index) const
                int param1;
                static char * key_word_list[] = {(char *)"index", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:keepNextHighestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "i:keepNextHighestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->keep_next_highest_bit((int)param1);
                    BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "keepNextHighestBit() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "keepNextHighestBit(const BitMask this)\n"
          "keepNextHighestBit(const BitMask this, const BitMask other)\n"
          "keepNextHighestBit(const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_keep_next_highest_bit_457_comment =
    "C++ Interface:\n"
    "keepNextHighestBit(const BitMask this)\n"
    "keepNextHighestBit(const BitMask this, const BitMask other)\n"
    "keepNextHighestBit(const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_keep_next_highest_bit_457_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_lowest_bit(void) const
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_lowest_bit(BitMask< unsigned __int64, 64 > const &other) const
 * inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_lowest_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_keep_next_lowest_bit_458(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_lowest_bit(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":keepNextLowestBit", key_word_list));
            else
                (PyArg_Parse(args, ":keepNextLowestBit"));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->keep_next_lowest_bit();
                BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_lowest_bit(BitMask< unsigned __int64, 64 > const &other) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:keepNextLowestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:keepNextLowestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned __int64, 64 > *param1_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int64_64, 1, "BitMask.keepNextLowestBit", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->keep_next_lowest_bit(*param1_this);
                        BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline BitMask< unsigned __int64, 64 > ::BitMask< unsigned __int64, 64 >::keep_next_lowest_bit(int index) const
                int param1;
                static char * key_word_list[] = {(char *)"index", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:keepNextLowestBit", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "i:keepNextLowestBit", &param1));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned __int64, 64 > result = ((const BitMask< unsigned __int64, 64 >*)local_this)->keep_next_lowest_bit((int)param1);
                    BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int64_64,true, false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "keepNextLowestBit() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "keepNextLowestBit(const BitMask this)\n"
          "keepNextLowestBit(const BitMask this, const BitMask other)\n"
          "keepNextLowestBit(const BitMask this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_keep_next_lowest_bit_458_comment =
    "C++ Interface:\n"
    "keepNextLowestBit(const BitMask this)\n"
    "keepNextLowestBit(const BitMask this, const BitMask other)\n"
    "keepNextLowestBit(const BitMask this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_keep_next_lowest_bit_458_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::BitMask< unsigned __int64, 64 >::get_key(void) const
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_key_459(PyObject *self, PyObject *args,PyObject *kwds) {
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::BitMask< unsigned __int64, 64 >::get_key(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKey", key_word_list));
        else
            (PyArg_Parse(args, ":getKey"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitMask< unsigned __int64, 64 >*)local_this)->get_key();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKey(const BitMask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_key_459_comment =
    "C++ Interface:\n"
    "getKey(const BitMask this)\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_key_459_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::BitMask< unsigned __int64, 64 >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BitMask_unsigned_int64_64_get_class_type_460(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::BitMask< unsigned __int64, 64 >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::BitMask< unsigned __int64, 64 >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitMask_unsigned_int64_64_get_class_type_460_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BitMask_unsigned_int64_64_get_class_type_460_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::BitMask< unsigned __int64, 64 >::BitMask(void)
 * inline ::BitMask< unsigned __int64, 64 >::BitMask(BitMask< unsigned __int64, 64 > const &copy)
 * inline ::BitMask< unsigned __int64, 64 >::BitMask(unsigned __int64 init_value)
 *******************************************************************/
int  Dtool_Init_BitMask_unsigned_int64_64(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::BitMask< unsigned __int64, 64 >::BitMask(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BitMask", key_word_list))
            {
                BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BitMask_unsigned_int64_64,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::BitMask< unsigned __int64, 64 >::BitMask(BitMask< unsigned __int64, 64 > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitMask", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitMask", &param0));
                if(!PyErr_Occurred())
                {
                    BitMask< unsigned __int64, 64 > *param0_this = (BitMask< unsigned __int64, 64 > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_BitMask_unsigned_int64_64, 0, "BitMask.BitMask", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitMask_unsigned_int64_64,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::BitMask< unsigned __int64, 64 >::BitMask(unsigned __int64 init_value)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"init_value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitMask", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitMask", &param0));
                if(!PyErr_Occurred())
                {
                     PyObject *param0_long = PyNumber_Long(param0);
                    if (!((param0_long == NULL)))
                    {
                        BitMask< unsigned __int64, 64 > *return_value = new BitMask< unsigned __int64, 64 >(PyLong_AsUnsignedLongLong(param0_long));
                         Py_XDECREF(param0_long);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitMask_unsigned_int64_64,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BitMask() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BitMask()\n"
          "BitMask(const BitMask copy)\n"
          "BitMask(unsigned long long init_value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BitMask_unsigned_int64_64(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BitMask_unsigned_int64_64)
    {
        printf("BitMask_unsigned_int64_64 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BitMask< unsigned __int64, 64 > * local_this = (BitMask< unsigned __int64, 64 > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BitMask_unsigned_int64_64)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BitMask_unsigned_int64_64(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BitMask_unsigned_int64_64)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BitArray 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline BitArray &BitArray::operator =(BitArray const &copy)
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_463(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline BitArray &BitArray::operator =(BitArray const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    BitArray *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitArray.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const BitArray this, const BitArray copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_463_comment =
    "C++ Interface:\n"
    "assign(non-const BitArray this, const BitArray copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_463_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitArray BitArray::all_on(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_all_on_464(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitArray BitArray::all_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOn", key_word_list))
        {
            BitArray result = BitArray::all_on();
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_all_on_464_comment =
    "C++ Interface:\n"
    "allOn()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::Named all_on constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a BitArray with an infinite array of bits,\n"
    "//               all on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_all_on_464_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitArray BitArray::all_off(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_all_off_465(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitArray BitArray::all_off(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOff", key_word_list))
        {
            BitArray result = BitArray::all_off();
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOff()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_all_off_465_comment =
    "C++ Interface:\n"
    "allOff()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::Named all_on constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a BitArray whose bits are all off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_all_off_465_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitArray BitArray::lower_on(int on_bits)
 *******************************************************************/
static PyObject *Dtool_BitArray_lower_on_466(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitArray BitArray::lower_on(int on_bits)
        int param0;
        static char * key_word_list[] = {(char *)"on_bits", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:lowerOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:lowerOn", &param0));
        if(!PyErr_Occurred())
        {
            BitArray result = BitArray::lower_on((int)param0);
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lowerOn(int on_bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_lower_on_466_comment =
    "C++ Interface:\n"
    "lowerOn(int on_bits)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::Named lower_on constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a BitArray whose lower on_bits bits are on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_lower_on_466_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitArray BitArray::bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitArray_bit_467(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitArray BitArray::bit(int index)
        int param0;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:bit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:bit", &param0));
        if(!PyErr_Occurred())
        {
            BitArray result = BitArray::bit((int)param0);
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bit(int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_bit_467_comment =
    "C++ Interface:\n"
    "bit(int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::Named bit constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a BitArray with only the indicated bit on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_bit_467_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitArray BitArray::range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitArray_range_468(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitArray BitArray::range(int low_bit, int size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:range", key_word_list, &param0, &param1))
        {
            BitArray result = BitArray::range((int)param0, (int)param1);
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "range(int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_range_468_comment =
    "C++ Interface:\n"
    "range(int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::Named range constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a BitArray whose size bits, beginning at\n"
    "//               low_bit, are on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_range_468_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool BitArray::has_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_has_max_num_bits_470(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool BitArray::has_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxNumBits", key_word_list))
        {
            bool return_value = BitArray::has_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_has_max_num_bits_470_comment =
    "C++ Interface:\n"
    "hasMaxNumBits()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::has_max_num_bits\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if there is a maximum number of bits\n"
    "//               that may be stored in this structure, false\n"
    "//               otherwise.  If this returns true, the number may be\n"
    "//               queried in get_max_num_bits().\n"
    "//\n"
    "//               This method always returns false.  The BitArray has\n"
    "//               no maximum number of bits.  This method is defined so\n"
    "//               generic programming algorithms can use BitMask or\n"
    "//               BitArray interchangeably.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_has_max_num_bits_470_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int BitArray::get_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_get_max_num_bits_471(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int BitArray::get_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxNumBits", key_word_list))
        {
            int return_value = BitArray::get_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_max_num_bits_471_comment =
    "C++ Interface:\n"
    "getMaxNumBits()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_max_num_bits\n"
    "//       Access: Published, Static\n"
    "//  Description: If get_max_num_bits() returned true, this method may\n"
    "//               be called to return the maximum number of bits that\n"
    "//               may be stored in this structure.  It is an error to\n"
    "//               call this if get_max_num_bits() return false.\n"
    "//\n"
    "//               It is always an error to call this method.  The\n"
    "//               BitArray has no maximum number of bits.  This method\n"
    "//               is defined so generic programming algorithms can use\n"
    "//               BitMask or BitArray interchangeably.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_max_num_bits_471_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int BitArray::get_num_bits_per_word(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_get_num_bits_per_word_472(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int BitArray::get_num_bits_per_word(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBitsPerWord", key_word_list))
        {
            int return_value = BitArray::get_num_bits_per_word();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBitsPerWord()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_num_bits_per_word_472_comment =
    "C++ Interface:\n"
    "getNumBitsPerWord()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_num_bits_per_word\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the number of bits stored per word\n"
    "//               internally.  This is of interest only in that it\n"
    "//               limits the maximum number of bits that may be queried\n"
    "//               or set at once by extract() and store().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_num_bits_per_word_472_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BitArray::get_num_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_num_bits_473(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BitArray::get_num_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBits(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_num_bits_473_comment =
    "C++ Interface:\n"
    "getNumBits(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_num_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the current number of possibly different bits\n"
    "//               in this array.  There are actually an infinite number\n"
    "//               of bits, but every bit higher than this bit will have\n"
    "//               the same value, either 0 or 1 (see\n"
    "//               get_highest_bits()).\n"
    "//\n"
    "//               This number may grow and/or shrink automatically as\n"
    "//               needed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_num_bits_473_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BitArray::get_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_bit_474(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BitArray::get_bit(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitArray*)local_this)->get_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBit(const BitArray this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_bit_474_comment =
    "C++ Interface:\n"
    "getBit(const BitArray this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the nth bit is set, false if it is\n"
    "//               cleared.  It is valid for n to increase beyond\n"
    "//               get_num_bits(), but the return value get_num_bits()\n"
    "//               will always be the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_bit_474_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::set_bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitArray_set_bit_475(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BitArray::set_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.setBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBit(non-const BitArray this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_set_bit_475_comment =
    "C++ Interface:\n"
    "setBit(non-const BitArray this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::set_bit\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth bit on.  If n >= get_num_bits(), this\n"
    "//               automatically extends the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_set_bit_475_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::clear_bit(int index)
 *******************************************************************/
static PyObject *Dtool_BitArray_clear_bit_476(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BitArray::clear_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.clearBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBit(non-const BitArray this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_clear_bit_476_comment =
    "C++ Interface:\n"
    "clearBit(non-const BitArray this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::clear_bit\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth bit off.  If n >= get_num_bits(), this\n"
    "//               automatically extends the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_clear_bit_476_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::set_bit_to(int index, bool value)
 *******************************************************************/
static PyObject *Dtool_BitArray_set_bit_to_477(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BitArray::set_bit_to(int index, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBitTo", key_word_list, &param1, &param2))
        {
            (local_this)->set_bit_to((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.setBitTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBitTo(non-const BitArray this, int index, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_set_bit_to_477_comment =
    "C++ Interface:\n"
    "setBitTo(non-const BitArray this, int index, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::set_bit_to\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth bit either on or off, according to the\n"
    "//               indicated bool value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_set_bit_to_477_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BitArray::get_highest_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_highest_bits_478(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BitArray::get_highest_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestBits", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestBits"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitArray*)local_this)->get_highest_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestBits(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_highest_bits_478_comment =
    "C++ Interface:\n"
    "getHighestBits(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_highest_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the infinite set of bits beyond\n"
    "//               get_num_bits() are all on, or false of they are all\n"
    "//               off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_highest_bits_478_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BitArray::is_zero(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_is_zero_479(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool BitArray::is_zero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isZero", key_word_list));
        else
            (PyArg_Parse(args, ":isZero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitArray*)local_this)->is_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isZero(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_is_zero_479_comment =
    "C++ Interface:\n"
    "isZero(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::is_zero\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the entire bitmask is zero, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_is_zero_479_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BitArray::is_all_on(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_is_all_on_480(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool BitArray::is_all_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAllOn", key_word_list));
        else
            (PyArg_Parse(args, ":isAllOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BitArray*)local_this)->is_all_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAllOn(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_is_all_on_480_comment =
    "C++ Interface:\n"
    "isAllOn(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::is_all_on\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the entire bitmask is one, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_is_all_on_480_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int BitArray::extract(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitArray_extract_481(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int BitArray::extract(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:extract", key_word_list, &param1, &param2))
        {
            unsigned int return_value = ((const BitArray*)local_this)->extract((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extract(const BitArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_extract_481_comment =
    "C++ Interface:\n"
    "extract(const BitArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::extract\n"
    "//       Access: Published\n"
    "//  Description: Returns a word that represents only the indicated\n"
    "//               range of bits within this BitArray, shifted to the\n"
    "//               least-significant position.  size must be <=\n"
    "//               get_num_bits_per_word().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_extract_481_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::store(unsigned int value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitArray_store_482(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BitArray::store(unsigned int value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:store", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->store(PyLong_AsUnsignedLong(param1_uint), (int)param2, (int)param3);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.store() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "store(non-const BitArray this, unsigned int value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_store_482_comment =
    "C++ Interface:\n"
    "store(non-const BitArray this, unsigned int value, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::store\n"
    "//       Access: Published\n"
    "//  Description: Stores the indicated word into the indicated range of\n"
    "//               bits with this BitArray.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_store_482_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BitArray::has_any_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitArray_has_any_of_483(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool BitArray::has_any_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAnyOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const BitArray*)local_this)->has_any_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnyOf(const BitArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_has_any_of_483_comment =
    "C++ Interface:\n"
    "hasAnyOf(const BitArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::has_any_of\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any bit in the indicated range is\n"
    "//               set, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_has_any_of_483_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BitArray::has_all_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_BitArray_has_all_of_484(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool BitArray::has_all_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAllOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const BitArray*)local_this)->has_all_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAllOf(const BitArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_has_all_of_484_comment =
    "C++ Interface:\n"
    "hasAllOf(const BitArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::has_all_of\n"
    "//       Access: Published\n"
    "//  Description: Returns true if all bits in the indicated range are\n"
    "//               set, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_has_all_of_484_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::set_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitArray_set_range_485(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BitArray::set_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const BitArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_set_range_485_comment =
    "C++ Interface:\n"
    "setRange(non-const BitArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::set_range\n"
    "//       Access: Published\n"
    "//  Description: Sets the indicated range of bits on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_set_range_485_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::clear_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitArray_clear_range_486(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BitArray::clear_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clearRange", key_word_list, &param1, &param2))
        {
            (local_this)->clear_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.clearRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRange(non-const BitArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_clear_range_486_comment =
    "C++ Interface:\n"
    "clearRange(non-const BitArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::clear_range\n"
    "//       Access: Published\n"
    "//  Description: Sets the indicated range of bits off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_clear_range_486_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::set_range_to(bool value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_BitArray_set_range_to_487(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BitArray::set_range_to(bool value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setRangeTo", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_range_to((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.setRangeTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRangeTo(non-const BitArray this, bool value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_set_range_to_487_comment =
    "C++ Interface:\n"
    "setRangeTo(non-const BitArray this, bool value, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::set_range_to\n"
    "//       Access: Published\n"
    "//  Description: Sets the indicated range of bits to either on or off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_set_range_to_487_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_num_on_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_num_on_bits_488(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_num_on_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOnBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOnBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_num_on_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOnBits(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_num_on_bits_488_comment =
    "C++ Interface:\n"
    "getNumOnBits(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_num_on_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bits that are set to 1 in the\n"
    "//               array.  Returns -1 if there are an infinite number of\n"
    "//               1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_num_on_bits_488_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_num_off_bits(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_num_off_bits_489(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_num_off_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOffBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOffBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_num_off_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOffBits(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_num_off_bits_489_comment =
    "C++ Interface:\n"
    "getNumOffBits(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_num_off_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bits that are set to 0 in the\n"
    "//               array.  Returns -1 if there are an infinite number of\n"
    "//               0 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_num_off_bits_489_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_lowest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_lowest_on_bit_490(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_lowest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_lowest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOnBit(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_lowest_on_bit_490_comment =
    "C++ Interface:\n"
    "getLowestOnBit(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_lowest_on_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the lowest 1 bit in the array.\n"
    "//               Returns -1 if there are no 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_lowest_on_bit_490_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_lowest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_lowest_off_bit_491(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_lowest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_lowest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOffBit(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_lowest_off_bit_491_comment =
    "C++ Interface:\n"
    "getLowestOffBit(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_lowest_off_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the lowest 0 bit in the array.\n"
    "//               Returns -1 if there are no 0 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_lowest_off_bit_491_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_highest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_highest_on_bit_492(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_highest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_highest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOnBit(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_highest_on_bit_492_comment =
    "C++ Interface:\n"
    "getHighestOnBit(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_highest_on_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the highest 1 bit in the array.\n"
    "//               Returns -1 if there are no 1 bits or if there an\n"
    "//               infinite number of 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_highest_on_bit_492_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_highest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_highest_off_bit_493(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_highest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_highest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOffBit(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_highest_off_bit_493_comment =
    "C++ Interface:\n"
    "getHighestOffBit(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_highest_off_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the highest 0 bit in the array.\n"
    "//               Returns -1 if there are no 0 bits or if there an\n"
    "//               infinite number of 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_highest_off_bit_493_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::get_next_higher_different_bit(int low_bit) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_next_higher_different_bit_494(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int BitArray::get_next_higher_different_bit(int low_bit) const
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNextHigherDifferentBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNextHigherDifferentBit", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_next_higher_different_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextHigherDifferentBit(const BitArray this, int low_bit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_next_higher_different_bit_494_comment =
    "C++ Interface:\n"
    "getNextHigherDifferentBit(const BitArray this, int low_bit)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_next_higher_different_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the next bit in the array, above\n"
    "//               low_bit, whose value is different that the value of\n"
    "//               low_bit.  Returns low_bit again if all bits higher\n"
    "//               than low_bit have the same value.\n"
    "//\n"
    "//               This can be used to quickly iterate through all of\n"
    "//               the bits in the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_next_higher_different_bit_494_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BitArray::get_num_words(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_num_words_495(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BitArray::get_num_words(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumWords", key_word_list));
        else
            (PyArg_Parse(args, ":getNumWords"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BitArray*)local_this)->get_num_words();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumWords(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_num_words_495_comment =
    "C++ Interface:\n"
    "getNumWords(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_num_words\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of possibly-unique words stored in\n"
    "//               the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_num_words_495_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > BitArray::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_BitArray_get_word_496(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > BitArray::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const BitArray*)local_this)->get_word((int)param1);
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const BitArray this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_word_496_comment =
    "C++ Interface:\n"
    "getWord(const BitArray this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth word in the array.  It is valid for n\n"
    "//               to be greater than get_num_words(), but the return\n"
    "//               value beyond get_num_words() will always be the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_get_word_496_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::set_word(int n, BitMask< unsigned int, 32 > value)
 *******************************************************************/
static PyObject *Dtool_BitArray_set_word_497(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BitArray::set_word(int n, BitMask< unsigned int, 32 > value)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setWord", key_word_list, &param1, &param2))
            {
                BitMask< unsigned int, 32 > *param2_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_BitMask_unsigned_int_32, 2, "BitArray.setWord", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_word((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitArray.setWord() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const BitArray this, int n, const BitMask value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_set_word_497_comment =
    "C++ Interface:\n"
    "setWord(non-const BitArray this, int n, const BitMask value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::set_word\n"
    "//       Access: Published\n"
    "//  Description: Replaces the nth word in the array.  If n >=\n"
    "//               get_num_words(), this automatically extends the\n"
    "//               array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_set_word_497_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::invert_in_place(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_invert_in_place_498(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BitArray::invert_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":invertInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":invertInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->invert_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.invertInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "invertInPlace(non-const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_invert_in_place_498_comment =
    "C++ Interface:\n"
    "invertInPlace(non-const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::invert_in_place\n"
    "//       Access: Published\n"
    "//  Description: Inverts all the bits in the BitArray.  This is\n"
    "//               equivalent to array = ~array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_invert_in_place_498_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool BitArray::has_bits_in_common(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_has_bits_in_common_499(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool BitArray::has_bits_in_common(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasBitsInCommon", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasBitsInCommon", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.hasBitsInCommon", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitArray*)local_this)->has_bits_in_common(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBitsInCommon(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_has_bits_in_common_499_comment =
    "C++ Interface:\n"
    "hasBitsInCommon(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::has_bits_in_common\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this BitArray has any \"one\" bits in\n"
    "//               common with the other one, false otherwise.\n"
    "//\n"
    "//               This is equivalent to (array & other) != 0, but may\n"
    "//               be faster.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_has_bits_in_common_499_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BitArray::clear(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_clear_500(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BitArray::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_clear_500_comment =
    "C++ Interface:\n"
    "clear(non-const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::clear\n"
    "//       Access: Published\n"
    "//  Description: Sets all the bits in the BitArray off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_clear_500_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BitArray_output_501(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void BitArray::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BitArray*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BitArray this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_output_501_comment =
    "C++ Interface:\n"
    "output(const BitArray this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::output\n"
    "//       Access: Published\n"
    "//  Description: Writes the BitArray out as a hex number.  For a\n"
    "//               BitArray, this is always the same as output_hex();\n"
    "//               it's too confusing for the output format to change\n"
    "//               back and forth at runtime.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_output_501_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::output_binary(ostream &out, int spaces_every) const
 * void BitArray::output_binary(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_BitArray_output_binary_502(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BitArray::output_binary(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBinary", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputBinary", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitArray*)local_this)->output_binary(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BitArray::output_binary(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputBinary", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.outputBinary", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitArray*)local_this)->output_binary(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputBinary() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputBinary(const BitArray this, non-const Ostream out)\n"
          "outputBinary(const BitArray this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_output_binary_502_comment =
    "C++ Interface:\n"
    "outputBinary(const BitArray this, non-const Ostream out)\n"
    "outputBinary(const BitArray this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::output_binary\n"
    "//       Access: Published\n"
    "//  Description: Writes the BitArray out as a binary number, with\n"
    "//               spaces every four bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_output_binary_502_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::output_hex(ostream &out, int spaces_every) const
 * void BitArray::output_hex(ostream &out, int spaces_every = (4)) const
 *******************************************************************/
static PyObject *Dtool_BitArray_output_hex_503(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BitArray::output_hex(ostream &out, int spaces_every = (4)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputHex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:outputHex", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitArray*)local_this)->output_hex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BitArray::output_hex(ostream &out, int spaces_every) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"spaces_every", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:outputHex", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.outputHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitArray*)local_this)->output_hex(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "outputHex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "outputHex(const BitArray this, non-const Ostream out)\n"
          "outputHex(const BitArray this, non-const Ostream out, int spaces_every)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_output_hex_503_comment =
    "C++ Interface:\n"
    "outputHex(const BitArray this, non-const Ostream out)\n"
    "outputHex(const BitArray this, non-const Ostream out, int spaces_every)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::output_hex\n"
    "//       Access: Published\n"
    "//  Description: Writes the BitArray out as a hexadecimal number, with\n"
    "//               spaces every four digits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_output_hex_503_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::write(ostream &out, int indent_level) const
 * void BitArray::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_BitArray_write_504(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BitArray::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitArray*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void BitArray::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BitArray.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BitArray*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BitArray this, non-const Ostream out)\n"
          "write(const BitArray this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_write_504_comment =
    "C++ Interface:\n"
    "write(const BitArray this, non-const Ostream out)\n"
    "write(const BitArray this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::write\n"
    "//       Access: Published\n"
    "//  Description: Writes the BitArray out as a binary or a hex number,\n"
    "//               according to the number of bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_write_504_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BitArray::operator ==(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_505(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool BitArray::operator ==(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitArray*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_505_comment =
    "C++ Interface:\n"
    "eq(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_505_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BitArray::operator !=(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_506(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool BitArray::operator !=(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitArray*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_506_comment =
    "C++ Interface:\n"
    "ne(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_506_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BitArray::operator <(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_507(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool BitArray::operator <(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const BitArray*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_507_comment =
    "C++ Interface:\n"
    "lessThan(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator <\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the unsigned integer which is\n"
    "//               represented by this BitArray is less than that of the\n"
    "//               other one, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_507_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BitArray::compare_to(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_compare_to_508(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int BitArray::compare_to(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const BitArray*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_compare_to_508_comment =
    "C++ Interface:\n"
    "compareTo(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::compare_to\n"
    "//       Access: Published\n"
    "//  Description: Returns a number less than zero if this BitArray sorts\n"
    "//               before the indicated other BitArray, greater than zero\n"
    "//               if it sorts after, or 0 if they are equivalent.  This\n"
    "//               is based on the same ordering defined by operator <.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_compare_to_508_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray BitArray::operator &(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_509(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitArray BitArray::operator &(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitArray result = ((const BitArray*)local_this)->operator &(*param1_this);
                    BitArray *return_value = new BitArray(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_509_comment =
    "C++ Interface:\n"
    "__and__(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator &\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_509_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray BitArray::operator |(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_510(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitArray BitArray::operator |(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitArray result = ((const BitArray*)local_this)->operator |(*param1_this);
                    BitArray *return_value = new BitArray(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_510_comment =
    "C++ Interface:\n"
    "__or__(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator |\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_510_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray BitArray::operator ^(BitArray const &other) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_511(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BitArray BitArray::operator ^(BitArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__xor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__xor__", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.__xor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    BitArray result = ((const BitArray*)local_this)->operator ^(*param1_this);
                    BitArray *return_value = new BitArray(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__xor__(const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_511_comment =
    "C++ Interface:\n"
    "__xor__(const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator ^\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_511_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray BitArray::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_512(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitArray BitArray::operator ~(void) const
        {
            BitArray result = ((const BitArray*)local_this)->operator ~();
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const BitArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_512_comment =
    "C++ Interface:\n"
    "__invert__(const BitArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator ~\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_512_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray BitArray::operator <<(int shift) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_513(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline BitArray BitArray::operator <<(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__lshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__lshift__", &param1));
        if(!PyErr_Occurred())
        {
            BitArray result = ((const BitArray*)local_this)->operator <<((int)param1);
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__lshift__(const BitArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_513_comment =
    "C++ Interface:\n"
    "__lshift__(const BitArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator <<\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_513_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray BitArray::operator >>(int shift) const
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_514(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline BitArray BitArray::operator >>(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__rshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__rshift__", &param1));
        if(!PyErr_Occurred())
        {
            BitArray result = ((const BitArray*)local_this)->operator >>((int)param1);
            BitArray *return_value = new BitArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__rshift__(const BitArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_514_comment =
    "C++ Interface:\n"
    "__rshift__(const BitArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator >>\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_514_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::operator &=(BitArray const &other)
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_515(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BitArray::operator &=(BitArray const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitArray.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_515_comment =
    "C++ Interface:\n"
    "__iand__(non-const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator &=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_515_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::operator |=(BitArray const &other)
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_516(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BitArray::operator |=(BitArray const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitArray.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_516_comment =
    "C++ Interface:\n"
    "__ior__(non-const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator |=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_516_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::operator ^=(BitArray const &other)
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_517(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BitArray::operator ^=(BitArray const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ixor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ixor__", &param1));
            if(!PyErr_Occurred())
            {
                BitArray *param1_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitArray, 1, "BitArray.__ixor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator ^=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BitArray.__ixor__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ixor__(non-const BitArray this, const BitArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_517_comment =
    "C++ Interface:\n"
    "__ixor__(non-const BitArray this, const BitArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator ^=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_517_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::operator <<=(int shift)
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_518(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BitArray::operator <<=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__ilshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__ilshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator <<=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.__ilshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ilshift__(non-const BitArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_518_comment =
    "C++ Interface:\n"
    "__ilshift__(non-const BitArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator <<=\n"
    "//       Access: Published\n"
    "//  Description: Logical left shift.  The rightmost bits are filled in\n"
    "//               with zeroes.  Since this is an infinite bit array,\n"
    "//               none of the bits on the left are lost.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_518_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BitArray::operator >>=(int shift)
 *******************************************************************/
static PyObject *Dtool_BitArray_operator_519(PyObject *self, PyObject *args,PyObject *kwds) {
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BitArray::operator >>=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__irshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__irshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator >>=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BitArray.__irshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__irshift__(non-const BitArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_operator_519_comment =
    "C++ Interface:\n"
    "__irshift__(non-const BitArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BitArray::operator >>=\n"
    "//       Access: Published\n"
    "//  Description: Logical right shift.  The rightmost bits are lost.\n"
    "//               Since this is an infinite bit array, there is no\n"
    "//               question of sign extension; there is no need to\n"
    "//               synthesize bits on the left.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BitArray_operator_519_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BitArray::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BitArray_get_class_type_520(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BitArray::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BitArray::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BitArray_get_class_type_520_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BitArray_get_class_type_520_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray::BitArray(void)
 * inline BitArray::BitArray(BitArray const &copy)
 * BitArray::BitArray(SparseArray const &from)
 * inline BitArray::BitArray(unsigned int init_value)
 *******************************************************************/
int  Dtool_Init_BitArray(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BitArray::BitArray(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BitArray", key_word_list))
            {
                BitArray *return_value = new BitArray();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BitArray,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 BitArray::BitArray(SparseArray const &from)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"from", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitArray", &param0));
                if(!PyErr_Occurred())
                {
                    SparseArray *param0_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SparseArray, 0, "BitArray.BitArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BitArray *return_value = new BitArray(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitArray,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline BitArray::BitArray(BitArray const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitArray", &param0));
                if(!PyErr_Occurred())
                {
                    BitArray *param0_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_BitArray, 0, "BitArray.BitArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        BitArray *return_value = new BitArray(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitArray,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline BitArray::BitArray(unsigned int init_value)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"init_value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BitArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BitArray", &param0));
                if(!PyErr_Occurred())
                {
                     PyObject *param0_uint = PyNumber_Long(param0);
                    if (!((param0_uint == NULL)))
                    {
                        BitArray *return_value = new BitArray(PyLong_AsUnsignedLong(param0_uint));
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BitArray,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BitArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BitArray()\n"
          "BitArray(const SparseArray from)\n"
          "BitArray(const BitArray copy)\n"
          "BitArray(unsigned int init_value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BitArray(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BitArray)
    {
        printf("BitArray ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BitArray * local_this = (BitArray *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BitArray)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BitArray(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BitArray)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ButtonHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * basic_string< char > ButtonHandle::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_get_name_523(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > ButtonHandle::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ButtonHandle*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const ButtonHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_get_name_523_comment =
    "C++ Interface:\n"
    "getName(const ButtonHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::get_name\n"
    "//       Access: Public\n"
    "//  Description: Returns the name of the button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_get_name_523_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonHandle::has_ascii_equivalent(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_has_ascii_equivalent_524(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonHandle::has_ascii_equivalent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAsciiEquivalent", key_word_list));
        else
            (PyArg_Parse(args, ":hasAsciiEquivalent"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonHandle*)local_this)->has_ascii_equivalent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAsciiEquivalent(const ButtonHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_has_ascii_equivalent_524_comment =
    "C++ Interface:\n"
    "hasAsciiEquivalent(const ButtonHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::has_ascii_equivalent\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the button was created with an ASCII\n"
    "//               equivalent code (e.g. for a standard keyboard\n"
    "//               button).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_has_ascii_equivalent_524_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char ButtonHandle::get_ascii_equivalent(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_get_ascii_equivalent_525(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char ButtonHandle::get_ascii_equivalent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAsciiEquivalent", key_word_list));
        else
            (PyArg_Parse(args, ":getAsciiEquivalent"));
        if(!PyErr_Occurred())
        {
            char return_value = ((const ButtonHandle*)local_this)->get_ascii_equivalent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAsciiEquivalent(const ButtonHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_get_ascii_equivalent_525_comment =
    "C++ Interface:\n"
    "getAsciiEquivalent(const ButtonHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::get_ascii_equivalent\n"
    "//       Access: Published\n"
    "//  Description: Returns the character code associated with the\n"
    "//               button, or '\\0' if no ASCII code was associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_get_ascii_equivalent_525_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ButtonHandle ButtonHandle::get_alias(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_get_alias_526(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ButtonHandle ButtonHandle::get_alias(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlias", key_word_list));
        else
            (PyArg_Parse(args, ":getAlias"));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = ((const ButtonHandle*)local_this)->get_alias();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlias(const ButtonHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_get_alias_526_comment =
    "C++ Interface:\n"
    "getAlias(const ButtonHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::get_alias\n"
    "//       Access: Published\n"
    "//  Description: Returns the alias (alternate name) associated with\n"
    "//               the button, if any, or ButtonHandle::none() if the\n"
    "//               button has no alias.\n"
    "//\n"
    "//               Each button is allowed to have one alias, and\n"
    "//               multiple different buttons can refer to the same\n"
    "//               alias.  The alias should be the more general name for\n"
    "//               the button, for instance, shift is an alias for\n"
    "//               lshift, but not vice-versa.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_get_alias_526_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonHandle::matches(ButtonHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_matches_527(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ButtonHandle::matches(ButtonHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:matches", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:matches", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ButtonHandle.matches", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ButtonHandle*)local_this)->matches(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matches(const ButtonHandle this, const ButtonHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_matches_527_comment =
    "C++ Interface:\n"
    "matches(const ButtonHandle this, const ButtonHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::matches\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this ButtonHandle is the same as the\n"
    "//               other one, or if the other one is an alias for this\n"
    "//               one.  (Does not return true if this button is an\n"
    "//               alias for the other one, however.)\n"
    "//\n"
    "//               This is a more general comparison than operator ==.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_matches_527_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ButtonHandle::get_index(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_get_index_528(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ButtonHandle::get_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ButtonHandle*)local_this)->get_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndex(const ButtonHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_get_index_528_comment =
    "C++ Interface:\n"
    "getIndex(const ButtonHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::get_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the integer index associated with this\n"
    "//               ButtonHandle. Each different ButtonHandle will have a\n"
    "//               different index.  However, you probably shouldn't be\n"
    "//               using this method; you should just treat the\n"
    "//               ButtonHandles as opaque classes.  This is provided\n"
    "//               for the convenience of non-C++ scripting languages to\n"
    "//               build a hashtable of ButtonHandles.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_get_index_528_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonHandle::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_output_529(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void ButtonHandle::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ButtonHandle.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ButtonHandle*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ButtonHandle this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_output_529_comment =
    "C++ Interface:\n"
    "output(const ButtonHandle this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_output_529_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ButtonHandle ButtonHandle::none(void)
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_none_530(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ButtonHandle ButtonHandle::none(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":none", key_word_list))
        {
            ButtonHandle result = ButtonHandle::none();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "none()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_none_530_comment =
    "C++ Interface:\n"
    "none()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonHandle::none\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a special zero-valued ButtonHandle that is\n"
    "//               used to indicate no button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonHandle_none_530_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ButtonHandle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ButtonHandle_get_class_type_531(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ButtonHandle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ButtonHandle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonHandle_get_class_type_531_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ButtonHandle_get_class_type_531_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ButtonHandle::ButtonHandle(void)
 * inline ButtonHandle::ButtonHandle(int index)
 *******************************************************************/
int  Dtool_Init_ButtonHandle(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ButtonHandle::ButtonHandle(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ButtonHandle", key_word_list))
            {
                ButtonHandle *return_value = new ButtonHandle();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ButtonHandle,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ButtonHandle::ButtonHandle(int index)
            int param0;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:ButtonHandle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:ButtonHandle", &param0));
            if(!PyErr_Occurred())
            {
                ButtonHandle *return_value = new ButtonHandle((int)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ButtonHandle,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ButtonHandle() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ButtonHandle()\n"
          "ButtonHandle(int index)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ButtonHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ButtonHandle)
    {
        printf("ButtonHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ButtonHandle * local_this = (ButtonHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ButtonHandle)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ButtonHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ButtonHandle)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ButtonRegistry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * ButtonHandle ButtonRegistry::get_button(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_ButtonRegistry_get_button_534(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ButtonHandle ButtonRegistry::get_button(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getButton", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getButton", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = (local_this)->get_button(basic_string<char>(param1_str, param1_len));
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonRegistry.getButton() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButton(non-const ButtonRegistry this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonRegistry_get_button_534_comment =
    "C++ Interface:\n"
    "getButton(non-const ButtonRegistry this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonRegistry::get_button\n"
    "//       Access: Published\n"
    "//  Description: Finds a ButtonHandle in the registry matching the\n"
    "//               indicated name.  If there is no such ButtonHandle,\n"
    "//               registers a new one and returns it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonRegistry_get_button_534_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const
 *******************************************************************/
static PyObject *Dtool_ButtonRegistry_find_ascii_button_535(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const
        int param1;
        static char * key_word_list[] = {(char *)"ascii_equivalent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:findAsciiButton", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:findAsciiButton", &param1));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = ((const ButtonRegistry*)local_this)->find_ascii_button((char)param1);
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findAsciiButton(const ButtonRegistry this, int ascii_equivalent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonRegistry_find_ascii_button_535_comment =
    "C++ Interface:\n"
    "findAsciiButton(const ButtonRegistry this, int ascii_equivalent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonRegistry::find_ascii_button\n"
    "//       Access: Published\n"
    "//  Description: Finds a ButtonHandle in the registry matching the\n"
    "//               indicated ASCII equivalent character.  If there is no\n"
    "//               such ButtonHandle, returns ButtonHandle::none().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonRegistry_find_ascii_button_535_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ButtonRegistry::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ButtonRegistry_write_536(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ButtonRegistry::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ButtonRegistry.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ButtonRegistry*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ButtonRegistry this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonRegistry_write_536_comment =
    "C++ Interface:\n"
    "write(const ButtonRegistry this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonRegistry::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonRegistry_write_536_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ButtonRegistry *ButtonRegistry::ptr(void)
 *******************************************************************/
static PyObject *Dtool_ButtonRegistry_ptr_537(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ButtonRegistry *ButtonRegistry::ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ptr", key_word_list))
        {
            ButtonRegistry *return_value = ButtonRegistry::ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonRegistry,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ptr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonRegistry_ptr_537_comment =
    "C++ Interface:\n"
    "ptr()\n"
    "\n"
    "// ptr() returns the pointer to the global ButtonRegistry object.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonRegistry::ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the pointer to the global ButtonRegistry\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonRegistry_ptr_537_comment = NULL;
#endif

int  Dtool_Init_ButtonRegistry(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ButtonRegistry)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ButtonRegistry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ButtonRegistry)
    {
        printf("ButtonRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ButtonRegistry * local_this = (ButtonRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ButtonRegistry)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ButtonRegistry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ButtonRegistry)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CallbackObject 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void CallbackObject::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CallbackObject_output_541(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void CallbackObject::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CallbackObject.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CallbackObject*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CallbackObject this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackObject_output_541_comment =
    "C++ Interface:\n"
    "output(const CallbackObject this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackObject::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackObject_output_541_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CallbackObject::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CallbackObject_get_class_type_542(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CallbackObject::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CallbackObject::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackObject_get_class_type_542_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CallbackObject_get_class_type_542_comment = NULL;
#endif

int  Dtool_Init_CallbackObject(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CallbackObject)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CallbackObject(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CallbackObject)
    {
        printf("CallbackObject ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CallbackObject * local_this = (CallbackObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CallbackObject)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CallbackObject(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CallbackObject)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CallbackObject*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CallbackObject*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CallbackObject*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CachedTypedWritableReferenceCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_545(PyObject *self, PyObject *args,PyObject *kwds) {
    CachedTypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CachedTypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CachedTypedWritableReferenceCount*)local_this)->get_cache_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheRefCount(const CachedTypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_545_comment =
    "C++ Interface:\n"
    "getCacheRefCount(const CachedTypedWritableReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CachedTypedWritableReferenceCount::get_cache_ref_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the current reference count.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_545_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CachedTypedWritableReferenceCount::cache_ref(void) const
 *******************************************************************/
static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_ref_546(PyObject *self, PyObject *args,PyObject *kwds) {
    CachedTypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CachedTypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void CachedTypedWritableReferenceCount::cache_ref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cacheRef", key_word_list));
        else
            (PyArg_Parse(args, ":cacheRef"));
        if(!PyErr_Occurred())
        {
            ((const CachedTypedWritableReferenceCount*)local_this)->cache_ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cacheRef(const CachedTypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CachedTypedWritableReferenceCount_cache_ref_546_comment =
    "C++ Interface:\n"
    "cacheRef(const CachedTypedWritableReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CachedTypedWritableReferenceCount::cache_ref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly increments the cache reference count and\n"
    "//               the normal reference count simultaneously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CachedTypedWritableReferenceCount_cache_ref_546_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CachedTypedWritableReferenceCount::cache_unref(void) const
 *******************************************************************/
static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_unref_547(PyObject *self, PyObject *args,PyObject *kwds) {
    CachedTypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CachedTypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CachedTypedWritableReferenceCount::cache_unref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cacheUnref", key_word_list));
        else
            (PyArg_Parse(args, ":cacheUnref"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CachedTypedWritableReferenceCount*)local_this)->cache_unref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cacheUnref(const CachedTypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CachedTypedWritableReferenceCount_cache_unref_547_comment =
    "C++ Interface:\n"
    "cacheUnref(const CachedTypedWritableReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CachedTypedWritableReferenceCount::cache_unref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly decrements the cache reference count and\n"
    "//               the normal reference count simultaneously.\n"
    "//\n"
    "//               The return value is true if the new reference count\n"
    "//               is nonzero, false if it is zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CachedTypedWritableReferenceCount_cache_unref_547_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const
 *******************************************************************/
static PyObject *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_548(PyObject *self, PyObject *args,PyObject *kwds) {
    CachedTypedWritableReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CachedTypedWritableReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":testRefCountIntegrity", key_word_list));
        else
            (PyArg_Parse(args, ":testRefCountIntegrity"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CachedTypedWritableReferenceCount*)local_this)->test_ref_count_integrity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "testRefCountIntegrity(const CachedTypedWritableReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_548_comment =
    "C++ Interface:\n"
    "testRefCountIntegrity(const CachedTypedWritableReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CachedTypedWritableReferenceCount::test_ref_count_integrity\n"
    "//       Access: Published\n"
    "//  Description: Does some easy checks to make sure that the reference\n"
    "//               count isn't completely bogus.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_548_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CachedTypedWritableReferenceCount_get_class_type_549(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CachedTypedWritableReferenceCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CachedTypedWritableReferenceCount_get_class_type_549_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CachedTypedWritableReferenceCount_get_class_type_549_comment = NULL;
#endif

int  Dtool_Init_CachedTypedWritableReferenceCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CachedTypedWritableReferenceCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CachedTypedWritableReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CachedTypedWritableReferenceCount)
    {
        printf("CachedTypedWritableReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CachedTypedWritableReferenceCount * local_this = (CachedTypedWritableReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CachedTypedWritableReferenceCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CachedTypedWritableReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CachedTypedWritableReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CachedTypedWritableReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CachedTypedWritableReferenceCount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CallbackData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void CallbackData::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CallbackData_output_551(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void CallbackData::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CallbackData.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CallbackData*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CallbackData this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackData_output_551_comment =
    "C++ Interface:\n"
    "output(const CallbackData this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackData::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackData_output_551_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CallbackData::upcall(void)
 *******************************************************************/
static PyObject *Dtool_CallbackData_upcall_552(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CallbackData::upcall(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcall", key_word_list));
        else
            (PyArg_Parse(args, ":upcall"));
        if(!PyErr_Occurred())
        {
            (local_this)->upcall();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CallbackData.upcall() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcall(non-const CallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackData_upcall_552_comment =
    "C++ Interface:\n"
    "upcall(non-const CallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackData::upcall\n"
    "//       Access: Published, Virtual\n"
    "//  Description: You should make this call during the callback if you\n"
    "//               want to continue the normal function that would have\n"
    "//               been done in the absence of a callback.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackData_upcall_552_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CallbackData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CallbackData_get_class_type_553(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CallbackData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CallbackData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackData_get_class_type_553_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CallbackData_get_class_type_553_comment = NULL;
#endif

int  Dtool_Init_CallbackData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CallbackData)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CallbackData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CallbackData)
    {
        printf("CallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CallbackData * local_this = (CallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CallbackData)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CallbackData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CallbackData)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CallbackData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TimeVal 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned long int TimeVal::get_sec(void) const
 *******************************************************************/
static PyObject *Dtool_TimeVal_get_sec_557(PyObject *self, PyObject *args,PyObject *kwds) {
    TimeVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TimeVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned long int TimeVal::get_sec(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSec", key_word_list));
        else
            (PyArg_Parse(args, ":getSec"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = ((const TimeVal*)local_this)->get_sec();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSec(const TimeVal this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TimeVal_get_sec_557_comment =
    "C++ Interface:\n"
    "getSec(const TimeVal this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TimeVal::get_sec\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TimeVal_get_sec_557_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned long int TimeVal::get_usec(void) const
 *******************************************************************/
static PyObject *Dtool_TimeVal_get_usec_558(PyObject *self, PyObject *args,PyObject *kwds) {
    TimeVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TimeVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned long int TimeVal::get_usec(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUsec", key_word_list));
        else
            (PyArg_Parse(args, ":getUsec"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = ((const TimeVal*)local_this)->get_usec();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUsec(const TimeVal this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TimeVal_get_usec_558_comment =
    "C++ Interface:\n"
    "getUsec(const TimeVal this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TimeVal::get_usec\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TimeVal_get_usec_558_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TimeVal::TimeVal(void)
 *******************************************************************/
int  Dtool_Init_TimeVal(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline TimeVal::TimeVal(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":TimeVal", key_word_list))
        {
            TimeVal *return_value = new TimeVal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_TimeVal,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TimeVal()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TimeVal(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TimeVal)
    {
        printf("TimeVal ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TimeVal * local_this = (TimeVal *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TimeVal)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TimeVal(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TimeVal)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ClockObject 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ClockObject::set_mode(ClockObject::Mode mode)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_mode_564(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ClockObject::set_mode(ClockObject::Mode mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mode((ClockObject::Mode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMode(non-const ClockObject this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_mode_564_comment =
    "C++ Interface:\n"
    "setMode(non-const ClockObject this, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_mode\n"
    "//       Access: Published\n"
    "//  Description: Changes the mode of the clock.  Normally, the clock\n"
    "//               is in mode M_normal. In this mode, each call to\n"
    "//               tick() will set the value returned by\n"
    "//               get_frame_time() to the current real time; thus, the\n"
    "//               clock simply reports time advancing.\n"
    "//\n"
    "//               Other possible modes:\n"
    "//\n"
    "//               M_non_real_time - the clock ignores real time\n"
    "//               completely; at each call to tick(), it pretends that\n"
    "//               exactly dt seconds have elapsed since the last call\n"
    "//               to tick().  You may set the value of dt with\n"
    "//               set_dt() or set_frame_rate().\n"
    "//\n"
    "//               M_limited - the clock will run as fast as it can, as\n"
    "//               in M_normal, but will not run faster than the rate\n"
    "//               specified by set_frame_rate().  If the application\n"
    "//               would run faster than this rate, the clock will slow\n"
    "//               down the application.\n"
    "//\n"
    "//               M_integer - the clock will run as fast as it can, but\n"
    "//               the rate will be constrained to be an integer\n"
    "//               multiple or divisor of the rate specified by\n"
    "//               set_frame_rate().  The clock will slow down the\n"
    "//               application a bit to guarantee this.\n"
    "//\n"
    "//               M_integer_limited - a combination of M_limited and\n"
    "//               M_integer; the clock will not run faster than\n"
    "//               set_frame_rate(), and if it runs slower, it will run\n"
    "//               at a integer divisor of that rate.\n"
    "//\n"
    "//               M_forced - the clock forces the application to run at\n"
    "//               the rate specified by set_frame_rate().  If the\n"
    "//               application would run faster than this rate, the\n"
    "//               clock will slow down the application; if the\n"
    "//               application would run slower than this rate, the\n"
    "//               clock slows down time so that the application\n"
    "//               believes it is running at the given rate.\n"
    "//\n"
    "//               M_degrade - the clock runs at real time, but the\n"
    "//               application is slowed down by a set factor of its\n"
    "//               frame rate, specified by set_degrade_factor().\n"
    "//\n"
    "//               M_slave - the clock does not advance, but relies on\n"
    "//               the user to call set_frame_time() and/or\n"
    "//               set_frame_count() each frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_mode_564_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ClockObject::Mode ClockObject::get_mode(void) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_mode_565(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ClockObject::Mode ClockObject::get_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMode", key_word_list));
        else
            (PyArg_Parse(args, ":getMode"));
        if(!PyErr_Occurred())
        {
            ClockObject::Mode return_value = ((const ClockObject*)local_this)->get_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMode(const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_mode_565_comment =
    "C++ Interface:\n"
    "getMode(const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the current mode of the clock.  See\n"
    "//               set_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_mode_565_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_frame_time(Thread *current_thread) const
 * inline double ClockObject::get_frame_time(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_frame_time_566(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline double ClockObject::get_frame_time(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameTime", key_word_list));
            else
                (PyArg_Parse(args, ":getFrameTime"));
            if(!PyErr_Occurred())
            {
                double return_value = ((const ClockObject*)local_this)->get_frame_time();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline double ClockObject::get_frame_time(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getFrameTime", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getFrameTime", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.getFrameTime", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const ClockObject*)local_this)->get_frame_time(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getFrameTime() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getFrameTime(const ClockObject this)\n"
          "getFrameTime(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_frame_time_566_comment =
    "C++ Interface:\n"
    "getFrameTime(const ClockObject this)\n"
    "getFrameTime(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_frame_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time in seconds as of the last time\n"
    "//               tick() was called (typically, this will be as of the\n"
    "//               start of the current frame).\n"
    "//\n"
    "//               This is generally the kind of time you want to ask\n"
    "//               for in most rendering and animation contexts, since\n"
    "//               it's important that all of the animation for a given\n"
    "//               frame remains in sync with each other.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_frame_time_566_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_real_time(void) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_real_time_567(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ClockObject::get_real_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRealTime", key_word_list));
        else
            (PyArg_Parse(args, ":getRealTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ClockObject*)local_this)->get_real_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRealTime(const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_real_time_567_comment =
    "C++ Interface:\n"
    "getRealTime(const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_real_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual number of seconds elapsed since\n"
    "//               the ClockObject was created, or since it was last\n"
    "//               reset.  This is useful for doing real timing\n"
    "//               measurements, e.g. for performance statistics.\n"
    "//\n"
    "//               This returns the most precise timer we have for short\n"
    "//               time intervals, but it may tend to drift over the\n"
    "//               long haul.  If more accurate timekeeping is needed\n"
    "//               over a long period of time, use get_long_time()\n"
    "//               instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_real_time_567_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_long_time(void) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_long_time_568(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ClockObject::get_long_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLongTime", key_word_list));
        else
            (PyArg_Parse(args, ":getLongTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ClockObject*)local_this)->get_long_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLongTime(const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_long_time_568_comment =
    "C++ Interface:\n"
    "getLongTime(const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_long_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual number of seconds elapsed since\n"
    "//               the ClockObject was created, or since it was last\n"
    "//               reset.\n"
    "//\n"
    "//               This is similar to get_real_time(), except that it\n"
    "//               uses the most accurate counter we have over a long\n"
    "//               period of time, and so it is less likely to drift.\n"
    "//               However, it may not be very precise for measuring\n"
    "//               short intervals.  On Windows, for instace, this is\n"
    "//               only accurate to within about 55 milliseconds.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_long_time_568_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ClockObject::reset(void)
 *******************************************************************/
static PyObject *Dtool_ClockObject_reset_569(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ClockObject::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_reset_569_comment =
    "C++ Interface:\n"
    "reset(non-const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::reset\n"
    "//       Access: Published\n"
    "//  Description: Simultaneously resets both the time and the frame\n"
    "//               count to zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_reset_569_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::set_real_time(double time)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_real_time_570(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ClockObject::set_real_time(double time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRealTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRealTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_real_time((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setRealTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRealTime(non-const ClockObject this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_real_time_570_comment =
    "C++ Interface:\n"
    "setRealTime(non-const ClockObject this, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_real_time\n"
    "//       Access: Published\n"
    "//  Description: Resets the clock to the indicated time.  This\n"
    "//               changes only the real time of the clock as reported\n"
    "//               by get_real_time(), but does not immediately change\n"
    "//               the time reported by get_frame_time()--that will\n"
    "//               change after the next call to tick().  Also see\n"
    "//               reset(), set_frame_time(), and set_frame_count().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_real_time_570_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::set_frame_time(double time, Thread *current_thread)
 * void ClockObject::set_frame_time(double time, Thread *current_thread = ((get_current_thread())))
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_frame_time_571(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ClockObject::set_frame_time(double time, Thread *current_thread = ((get_current_thread())))
            double param1;
            static char * key_word_list[] = {(char *)"time", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFrameTime", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setFrameTime", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_frame_time((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ClockObject.setFrameTime() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ClockObject::set_frame_time(double time, Thread *current_thread)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"time", (char *)"current_thread", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:setFrameTime", key_word_list, &param1, &param2))
                {
                    Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Thread, 2, "ClockObject.setFrameTime", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_frame_time((double)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ClockObject.setFrameTime() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrameTime() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrameTime(non-const ClockObject this, float time)\n"
          "setFrameTime(non-const ClockObject this, float time, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_frame_time_571_comment =
    "C++ Interface:\n"
    "setFrameTime(non-const ClockObject this, float time)\n"
    "setFrameTime(non-const ClockObject this, float time, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_frame_time\n"
    "//       Access: Published\n"
    "//  Description: Changes the time as reported for the current frame to\n"
    "//               the indicated time.  Normally, the way to adjust the\n"
    "//               frame time is via tick(); this function is provided\n"
    "//               only for occasional special adjustments.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_frame_time_571_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::set_frame_count(int frame_count, Thread *current_thread)
 * void ClockObject::set_frame_count(int frame_count, Thread *current_thread = ((get_current_thread())))
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_frame_count_572(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread = ((get_current_thread())))
            int param1;
            static char * key_word_list[] = {(char *)"frame_count", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFrameCount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:setFrameCount", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_frame_count((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ClockObject.setFrameCount() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"frame_count", (char *)"current_thread", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setFrameCount", key_word_list, &param1, &param2))
                {
                    Thread *param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Thread, 2, "ClockObject.setFrameCount", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_frame_count((int)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ClockObject.setFrameCount() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrameCount() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrameCount(non-const ClockObject this, int frame_count)\n"
          "setFrameCount(non-const ClockObject this, int frame_count, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_frame_count_572_comment =
    "C++ Interface:\n"
    "setFrameCount(non-const ClockObject this, int frame_count)\n"
    "setFrameCount(non-const ClockObject this, int frame_count, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_frame_count\n"
    "//       Access: Published\n"
    "//  Description: Resets the number of frames counted to the indicated\n"
    "//               number.  Also see reset(), set_real_time(), and\n"
    "//               set_frame_time().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_frame_count_572_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ClockObject::get_frame_count(Thread *current_thread) const
 * inline int ClockObject::get_frame_count(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_frame_count_573(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline int ClockObject::get_frame_count(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameCount", key_word_list));
            else
                (PyArg_Parse(args, ":getFrameCount"));
            if(!PyErr_Occurred())
            {
                int return_value = ((const ClockObject*)local_this)->get_frame_count();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline int ClockObject::get_frame_count(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getFrameCount", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getFrameCount", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.getFrameCount", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const ClockObject*)local_this)->get_frame_count(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getFrameCount() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getFrameCount(const ClockObject this)\n"
          "getFrameCount(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_frame_count_573_comment =
    "C++ Interface:\n"
    "getFrameCount(const ClockObject this)\n"
    "getFrameCount(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_frame_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of times tick() has been called\n"
    "//               since the ClockObject was created, or since it was\n"
    "//               last reset.  This is generally the number of frames\n"
    "//               that have been rendered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_frame_count_573_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_net_frame_rate(Thread *current_thread) const
 * inline double ClockObject::get_net_frame_rate(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_net_frame_rate_574(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline double ClockObject::get_net_frame_rate(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getNetFrameRate", key_word_list));
            else
                (PyArg_Parse(args, ":getNetFrameRate"));
            if(!PyErr_Occurred())
            {
                double return_value = ((const ClockObject*)local_this)->get_net_frame_rate();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline double ClockObject::get_net_frame_rate(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNetFrameRate", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getNetFrameRate", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.getNetFrameRate", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const ClockObject*)local_this)->get_net_frame_rate(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getNetFrameRate() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getNetFrameRate(const ClockObject this)\n"
          "getNetFrameRate(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_net_frame_rate_574_comment =
    "C++ Interface:\n"
    "getNetFrameRate(const ClockObject this)\n"
    "getNetFrameRate(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_net_frame_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the average frame rate since the last reset.\n"
    "//               This is simply the total number of frames divided by\n"
    "//               the total elapsed time.  This reports the virtual\n"
    "//               frame rate if the clock is in (or has been in)\n"
    "//               M_non_real_time mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_net_frame_rate_574_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_dt(Thread *current_thread) const
 * inline double ClockObject::get_dt(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_dt_575(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline double ClockObject::get_dt(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getDt", key_word_list));
            else
                (PyArg_Parse(args, ":getDt"));
            if(!PyErr_Occurred())
            {
                double return_value = ((const ClockObject*)local_this)->get_dt();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline double ClockObject::get_dt(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDt", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getDt", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.getDt", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const ClockObject*)local_this)->get_dt(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getDt() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getDt(const ClockObject this)\n"
          "getDt(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_dt_575_comment =
    "C++ Interface:\n"
    "getDt(const ClockObject this)\n"
    "getDt(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns the elapsed time for the previous frame: the\n"
    "//               number of seconds elapsed between the last two calls\n"
    "//               to tick().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_dt_575_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::set_dt(double dt)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_dt_576(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ClockObject::set_dt(double dt)
        double param1;
        static char * key_word_list[] = {(char *)"dt", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDt", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_dt((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setDt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDt(non-const ClockObject this, float dt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_dt_576_comment =
    "C++ Interface:\n"
    "setDt(non-const ClockObject this, float dt)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_dt\n"
    "//       Access: Published\n"
    "//  Description: In non-real-time mode, sets the number of seconds\n"
    "//               that should appear to elapse between frames.  In\n"
    "//               forced mode or limited mode, sets our target dt.  In\n"
    "//               normal mode, this has no effect.  \n"
    "//\n"
    "//               Also see set_frame_rate(), which is a different way\n"
    "//               to specify the same quantity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_dt_576_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::set_frame_rate(double frame_rate)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_frame_rate_577(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ClockObject::set_frame_rate(double frame_rate)
        double param1;
        static char * key_word_list[] = {(char *)"frame_rate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFrameRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFrameRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_rate((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setFrameRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameRate(non-const ClockObject this, float frame_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_frame_rate_577_comment =
    "C++ Interface:\n"
    "setFrameRate(non-const ClockObject this, float frame_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_frame_rate\n"
    "//       Access: Published\n"
    "//  Description: In non-real-time mode, sets the number of frames per\n"
    "//               second that we should appear to be running.  In forced\n"
    "//               mode or limited mode, sets our target frame rate.  In\n"
    "//               normal mode, this has no effect.\n"
    "//\n"
    "//               Also see set_dt(), which is a different way to\n"
    "//               specify the same quantity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_frame_rate_577_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_max_dt(void) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_max_dt_578(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ClockObject::get_max_dt(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxDt", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxDt"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ClockObject*)local_this)->get_max_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxDt(const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_max_dt_578_comment =
    "C++ Interface:\n"
    "getMaxDt(const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_max_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns the current maximum allowable time elapsed\n"
    "//               between any two frames.  See set_max_dt().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_max_dt_578_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ClockObject::set_max_dt(double max_dt)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_max_dt_579(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ClockObject::set_max_dt(double max_dt)
        double param1;
        static char * key_word_list[] = {(char *)"max_dt", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxDt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxDt", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_dt((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setMaxDt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxDt(non-const ClockObject this, float max_dt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_max_dt_579_comment =
    "C++ Interface:\n"
    "setMaxDt(non-const ClockObject this, float max_dt)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_max_dt\n"
    "//       Access: Published\n"
    "//  Description: Sets a limit on the value returned by get_dt().  If\n"
    "//               this value is less than zero, no limit is imposed;\n"
    "//               otherwise, this is the maximum value that will ever\n"
    "//               be returned by get_dt(), regardless of how much time\n"
    "//               has actually elapsed between frames.\n"
    "//\n"
    "//               This limit is only imposed in real-time mode; in\n"
    "//               non-real-time mode, the dt is fixed anyway and max_dt\n"
    "//               is ignored.\n"
    "//\n"
    "//               This is generally used to guarantee reasonable\n"
    "//               behavior even in the presence of a very slow or\n"
    "//               chuggy frame rame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_max_dt_579_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_degrade_factor(void) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_degrade_factor_580(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ClockObject::get_degrade_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDegradeFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getDegradeFactor"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ClockObject*)local_this)->get_degrade_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDegradeFactor(const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_degrade_factor_580_comment =
    "C++ Interface:\n"
    "getDegradeFactor(const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_degrade_factor\n"
    "//       Access: Published\n"
    "//  Description: In degrade mode, returns the ratio by which the\n"
    "//               performance is degraded.  A value of 2.0 causes the\n"
    "//               clock to be slowed down by a factor of two (reducing\n"
    "//               performance to 1/2 what would be otherwise).\n"
    "//\n"
    "//               This has no effect if mode is not M_degrade.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_degrade_factor_580_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ClockObject::set_degrade_factor(double degrade_factor)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_degrade_factor_581(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ClockObject::set_degrade_factor(double degrade_factor)
        double param1;
        static char * key_word_list[] = {(char *)"degrade_factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDegradeFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDegradeFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_degrade_factor((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setDegradeFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDegradeFactor(non-const ClockObject this, float degrade_factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_degrade_factor_581_comment =
    "C++ Interface:\n"
    "setDegradeFactor(non-const ClockObject this, float degrade_factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_degrade_factor\n"
    "//       Access: Published\n"
    "//  Description: In degrade mode, sets the ratio by which the\n"
    "//               performance is degraded.  A value of 2.0 causes the\n"
    "//               clock to be slowed down by a factor of two (reducing\n"
    "//               performance to 1/2 what would be otherwise).\n"
    "//\n"
    "//               This has no effect if mode is not M_degrade.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_degrade_factor_581_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ClockObject::set_average_frame_rate_interval(double time)
 *******************************************************************/
static PyObject *Dtool_ClockObject_set_average_frame_rate_interval_582(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ClockObject::set_average_frame_rate_interval(double time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAverageFrameRateInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAverageFrameRateInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_average_frame_rate_interval((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClockObject.setAverageFrameRateInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAverageFrameRateInterval(non-const ClockObject this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_set_average_frame_rate_interval_582_comment =
    "C++ Interface:\n"
    "setAverageFrameRateInterval(non-const ClockObject this, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::set_average_frame_rate_interval\n"
    "//       Access: Published\n"
    "//  Description: Specifies the interval of time (in seconds) over\n"
    "//               which get_average_frame_rate() averages the number of\n"
    "//               frames per second to compute the frame rate.\n"
    "//               Changing this does not necessarily immediately change\n"
    "//               the result of get_average_frame_rate(), until this\n"
    "//               interval of time has elapsed again.\n"
    "//\n"
    "//               Setting this to zero disables the computation of\n"
    "//               get_average_frame_rate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_set_average_frame_rate_interval_582_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClockObject::get_average_frame_rate_interval(void) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_average_frame_rate_interval_583(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ClockObject::get_average_frame_rate_interval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAverageFrameRateInterval", key_word_list));
        else
            (PyArg_Parse(args, ":getAverageFrameRateInterval"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ClockObject*)local_this)->get_average_frame_rate_interval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAverageFrameRateInterval(const ClockObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_average_frame_rate_interval_583_comment =
    "C++ Interface:\n"
    "getAverageFrameRateInterval(const ClockObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_average_frame_rate_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the interval of time (in seconds) over\n"
    "//               which get_average_frame_rate() averages the number of frames\n"
    "//               per second to compute the frame rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_average_frame_rate_interval_583_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double ClockObject::get_average_frame_rate(Thread *current_thread) const
 * double ClockObject::get_average_frame_rate(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_average_frame_rate_584(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-double ClockObject::get_average_frame_rate(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getAverageFrameRate", key_word_list));
            else
                (PyArg_Parse(args, ":getAverageFrameRate"));
            if(!PyErr_Occurred())
            {
                double return_value = ((const ClockObject*)local_this)->get_average_frame_rate();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-double ClockObject::get_average_frame_rate(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getAverageFrameRate", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getAverageFrameRate", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.getAverageFrameRate", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const ClockObject*)local_this)->get_average_frame_rate(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getAverageFrameRate() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getAverageFrameRate(const ClockObject this)\n"
          "getAverageFrameRate(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_average_frame_rate_584_comment =
    "C++ Interface:\n"
    "getAverageFrameRate(const ClockObject this)\n"
    "getAverageFrameRate(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_average_frame_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the average frame rate in number of frames\n"
    "//               per second over the last\n"
    "//               get_average_frame_rate_interval() seconds.  This\n"
    "//               measures the virtual frame rate if the clock is in\n"
    "//               M_non_real_time mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_average_frame_rate_584_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double ClockObject::get_max_frame_duration(Thread *current_thread) const
 * double ClockObject::get_max_frame_duration(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_max_frame_duration_585(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-double ClockObject::get_max_frame_duration(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxFrameDuration", key_word_list));
            else
                (PyArg_Parse(args, ":getMaxFrameDuration"));
            if(!PyErr_Occurred())
            {
                double return_value = ((const ClockObject*)local_this)->get_max_frame_duration();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-double ClockObject::get_max_frame_duration(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getMaxFrameDuration", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getMaxFrameDuration", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.getMaxFrameDuration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const ClockObject*)local_this)->get_max_frame_duration(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getMaxFrameDuration() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getMaxFrameDuration(const ClockObject this)\n"
          "getMaxFrameDuration(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_max_frame_duration_585_comment =
    "C++ Interface:\n"
    "getMaxFrameDuration(const ClockObject this)\n"
    "getMaxFrameDuration(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_max_frame_duration\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum frame duration over the last\n"
    "//               get_average_frame_rate_interval() seconds.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_max_frame_duration_585_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double ClockObject::calc_frame_rate_deviation(Thread *current_thread) const
 * double ClockObject::calc_frame_rate_deviation(Thread *current_thread = ((get_current_thread()))) const
 *******************************************************************/
static PyObject *Dtool_ClockObject_calc_frame_rate_deviation_586(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-double ClockObject::calc_frame_rate_deviation(Thread *current_thread = ((get_current_thread()))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":calcFrameRateDeviation", key_word_list));
            else
                (PyArg_Parse(args, ":calcFrameRateDeviation"));
            if(!PyErr_Occurred())
            {
                double return_value = ((const ClockObject*)local_this)->calc_frame_rate_deviation();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-double ClockObject::calc_frame_rate_deviation(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:calcFrameRateDeviation", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:calcFrameRateDeviation", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.calcFrameRateDeviation", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const ClockObject*)local_this)->calc_frame_rate_deviation(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "calcFrameRateDeviation() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "calcFrameRateDeviation(const ClockObject this)\n"
          "calcFrameRateDeviation(const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_calc_frame_rate_deviation_586_comment =
    "C++ Interface:\n"
    "calcFrameRateDeviation(const ClockObject this)\n"
    "calcFrameRateDeviation(const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::calc_frame_time_deviation\n"
    "//       Access: Published\n"
    "//  Description: Returns the standard deviation of the frame times of\n"
    "//               the frames rendered over the past\n"
    "//               get_average_frame_rate_interval() seconds.  This\n"
    "//               number gives an estimate of the chugginess of the\n"
    "//               frame rate; if it is large, there is a large\n"
    "//               variation in the frame rate; if is small, all of the\n"
    "//               frames are consistent in length.\n"
    "//\n"
    "//               A large value might also represent just a recent\n"
    "//               change in frame rate, for instance, because the\n"
    "//               camera has just rotated from looking at a simple\n"
    "//               scene to looking at a more complex scene.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_calc_frame_rate_deviation_586_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::tick(Thread *current_thread)
 * void ClockObject::tick(Thread *current_thread = ((get_current_thread())))
 *******************************************************************/
static PyObject *Dtool_ClockObject_tick_587(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ClockObject::tick(Thread *current_thread = ((get_current_thread())))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":tick", key_word_list));
            else
                (PyArg_Parse(args, ":tick"));
            if(!PyErr_Occurred())
            {
                (local_this)->tick();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ClockObject.tick() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ClockObject::tick(Thread *current_thread)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:tick", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:tick", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.tick", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->tick(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ClockObject.tick() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "tick() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "tick(non-const ClockObject this)\n"
          "tick(non-const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_tick_587_comment =
    "C++ Interface:\n"
    "tick(non-const ClockObject this)\n"
    "tick(non-const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::tick\n"
    "//       Access: Published\n"
    "//  Description: Instructs the clock that a new frame has just begun.\n"
    "//               In normal, real-time mode, get_frame_time() will\n"
    "//               henceforth report the time as of this instant as the\n"
    "//               current start-of-frame time.  In non-real-time mode,\n"
    "//               get_frame_time() will be incremented by the value of\n"
    "//               dt.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_tick_587_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ClockObject::sync_frame_time(Thread *current_thread)
 * void ClockObject::sync_frame_time(Thread *current_thread = ((get_current_thread())))
 *******************************************************************/
static PyObject *Dtool_ClockObject_sync_frame_time_588(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ClockObject::sync_frame_time(Thread *current_thread = ((get_current_thread())))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":syncFrameTime", key_word_list));
            else
                (PyArg_Parse(args, ":syncFrameTime"));
            if(!PyErr_Occurred())
            {
                (local_this)->sync_frame_time();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ClockObject.syncFrameTime() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ClockObject::sync_frame_time(Thread *current_thread)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:syncFrameTime", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:syncFrameTime", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.syncFrameTime", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->sync_frame_time(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ClockObject.syncFrameTime() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "syncFrameTime() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "syncFrameTime(non-const ClockObject this)\n"
          "syncFrameTime(non-const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_sync_frame_time_588_comment =
    "C++ Interface:\n"
    "syncFrameTime(non-const ClockObject this)\n"
    "syncFrameTime(non-const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::sync_frame_time\n"
    "//       Access: Published\n"
    "//  Description: Resets the frame time to the current real time.  This\n"
    "//               is similar to tick(), except that it does not advance\n"
    "//               the frame counter and does not affect dt.  This is\n"
    "//               intended to be used in the middle of a particularly\n"
    "//               long frame to compensate for the time that has\n"
    "//               already elapsed.\n"
    "//\n"
    "//               In non-real-time mode, this function has no effect\n"
    "//               (because in this mode all frames take the same length\n"
    "//               of time).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_sync_frame_time_588_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ClockObject::check_errors(Thread *current_thread)
 *******************************************************************/
static PyObject *Dtool_ClockObject_check_errors_589(PyObject *self, PyObject *args,PyObject *kwds) {
    ClockObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClockObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool ClockObject::check_errors(Thread *current_thread)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"current_thread", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:checkErrors", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:checkErrors", &param1));
            if(!PyErr_Occurred())
            {
                Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ClockObject.checkErrors", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->check_errors(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ClockObject.checkErrors() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "checkErrors(non-const ClockObject this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_check_errors_589_comment =
    "C++ Interface:\n"
    "checkErrors(non-const ClockObject this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::check_errors\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a clock error was detected since the\n"
    "//               last time check_errors() was called.  A clock error\n"
    "//               means that something happened, an OS or BIOS bug, for\n"
    "//               instance, that makes the current value of the clock\n"
    "//               somewhat suspect, and an application may wish to\n"
    "//               resynchronize with any external clocks.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_check_errors_589_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ClockObject *ClockObject::get_global_clock(void)
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_global_clock_590(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ClockObject *ClockObject::get_global_clock(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalClock", key_word_list))
        {
            ClockObject *return_value = ClockObject::get_global_clock();
            if (return_value != (ClockObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ClockObject,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalClock()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_global_clock_590_comment =
    "C++ Interface:\n"
    "getGlobalClock()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClockObject::get_global_clock\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the global ClockObject.  This is\n"
    "//               the ClockObject that most code should use for\n"
    "//               handling scene graph rendering and animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClockObject_get_global_clock_590_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ClockObject::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ClockObject_get_class_type_591(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ClockObject::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ClockObject::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClockObject_get_class_type_591_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ClockObject_get_class_type_591_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ClockObject::ClockObject(void)
 *******************************************************************/
int  Dtool_Init_ClockObject(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ClockObject::ClockObject(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ClockObject", key_word_list))
        {
            ClockObject *return_value = new ClockObject();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ClockObject,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ClockObject()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ClockObject(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ClockObject)
    {
        printf("ClockObject ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ClockObject * local_this = (ClockObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ClockObject)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ClockObject(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ClockObject)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ClockObject*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CopyOnWriteObject 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CopyOnWriteObject::cache_ref(void) const
 *******************************************************************/
static PyObject *Dtool_CopyOnWriteObject_cache_ref_595(PyObject *self, PyObject *args,PyObject *kwds) {
    CopyOnWriteObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CopyOnWriteObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void CopyOnWriteObject::cache_ref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cacheRef", key_word_list));
        else
            (PyArg_Parse(args, ":cacheRef"));
        if(!PyErr_Occurred())
        {
            ((const CopyOnWriteObject*)local_this)->cache_ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cacheRef(const CopyOnWriteObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CopyOnWriteObject_cache_ref_595_comment =
    "C++ Interface:\n"
    "cacheRef(const CopyOnWriteObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CopyOnWriteObject::cache_ref\n"
    "//       Access: Published\n"
    "//  Description: See CachedTypedWritableReferenceCount::cache_ref().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CopyOnWriteObject_cache_ref_595_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CopyOnWriteObject::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CopyOnWriteObject_get_class_type_596(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CopyOnWriteObject::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CopyOnWriteObject::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CopyOnWriteObject_get_class_type_596_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CopyOnWriteObject_get_class_type_596_comment = NULL;
#endif

int  Dtool_Init_CopyOnWriteObject(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CopyOnWriteObject)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CopyOnWriteObject(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CopyOnWriteObject)
    {
        printf("CopyOnWriteObject ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CopyOnWriteObject * local_this = (CopyOnWriteObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CopyOnWriteObject(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CopyOnWriteObject)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CopyOnWriteObject*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CopyOnWriteObject*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CopyOnWriteObject*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CopyOnWriteObject*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CopyOnWriteObject*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. KeyboardButton 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::ascii_key(basic_string< char > const &ascii_equivalent)
 * static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_ascii_key_599(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // -2 static ButtonHandle KeyboardButton::ascii_key(basic_string< char > const &ascii_equivalent)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"ascii_equivalent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:asciiKey", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:asciiKey", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = KeyboardButton::ascii_key(basic_string<char>(param0_str, param0_len));
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent)
        int param0;
        static char * key_word_list[] = {(char *)"ascii_equivalent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:asciiKey", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:asciiKey", &param0));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = KeyboardButton::ascii_key((char)param0);
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asciiKey(string ascii_equivalent)\n"
          "asciiKey(int ascii_equivalent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_ascii_key_599_comment =
    "C++ Interface:\n"
    "asciiKey(string ascii_equivalent)\n"
    "asciiKey(int ascii_equivalent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: KeyboardButton::ascii_key\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               particular ASCII character, if there is one, or\n"
    "//               ButtonHandle::none() if there is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: KeyboardButton::ascii_key\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               particular ASCII character (taken from the first\n"
    "//               character of the indicated string), if there is one,\n"
    "//               or ButtonHandle::none() if there is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_KeyboardButton_ascii_key_599_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::space(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_space_600(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::space(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":space", key_word_list))
        {
            ButtonHandle result = KeyboardButton::space();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "space()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_space_600_comment =
    "C++ Interface:\n"
    "space()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_space_600_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::backspace(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_backspace_601(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::backspace(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":backspace", key_word_list))
        {
            ButtonHandle result = KeyboardButton::backspace();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "backspace()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_backspace_601_comment =
    "C++ Interface:\n"
    "backspace()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_backspace_601_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::tab(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_tab_602(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::tab(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":tab", key_word_list))
        {
            ButtonHandle result = KeyboardButton::tab();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tab()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_tab_602_comment =
    "C++ Interface:\n"
    "tab()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_tab_602_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::enter(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_enter_603(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::enter(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":enter", key_word_list))
        {
            ButtonHandle result = KeyboardButton::enter();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enter()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_enter_603_comment =
    "C++ Interface:\n"
    "enter()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_enter_603_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::escape(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_escape_604(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::escape(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":escape", key_word_list))
        {
            ButtonHandle result = KeyboardButton::escape();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "escape()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_escape_604_comment =
    "C++ Interface:\n"
    "escape()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_escape_604_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f1(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f1_605(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f1(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f1", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f1();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f1()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f1_605_comment =
    "C++ Interface:\n"
    "f1()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f1_605_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f2(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f2_606(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f2(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f2", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f2();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f2()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f2_606_comment =
    "C++ Interface:\n"
    "f2()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f2_606_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f3(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f3_607(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f3(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f3", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f3();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f3()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f3_607_comment =
    "C++ Interface:\n"
    "f3()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f3_607_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f4(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f4_608(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f4(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f4", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f4();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f4()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f4_608_comment =
    "C++ Interface:\n"
    "f4()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f4_608_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f5(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f5_609(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f5(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f5", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f5();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f5()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f5_609_comment =
    "C++ Interface:\n"
    "f5()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f5_609_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f6(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f6_610(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f6(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f6", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f6();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f6()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f6_610_comment =
    "C++ Interface:\n"
    "f6()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f6_610_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f7(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f7_611(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f7(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f7", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f7();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f7()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f7_611_comment =
    "C++ Interface:\n"
    "f7()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f7_611_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f8(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f8_612(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f8(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f8", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f8();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f8()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f8_612_comment =
    "C++ Interface:\n"
    "f8()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f8_612_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f9(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f9_613(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f9(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f9", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f9();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f9()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f9_613_comment =
    "C++ Interface:\n"
    "f9()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f9_613_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f10(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f10_614(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f10(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f10", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f10();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f10()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f10_614_comment =
    "C++ Interface:\n"
    "f10()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f10_614_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f11(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f11_615(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f11(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f11", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f11();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f11()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f11_615_comment =
    "C++ Interface:\n"
    "f11()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f11_615_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f12(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f12_616(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f12(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f12", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f12();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f12()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f12_616_comment =
    "C++ Interface:\n"
    "f12()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f12_616_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f13(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f13_617(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f13(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f13", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f13();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f13()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f13_617_comment =
    "C++ Interface:\n"
    "f13()\n"
    "\n"
    "// PC keyboards don't have these four buttons, but Macs do.\n"
    "";
#else
static const char * Dtool_KeyboardButton_f13_617_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f14(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f14_618(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f14(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f14", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f14();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f14()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f14_618_comment =
    "C++ Interface:\n"
    "f14()\n"
    "\n"
    "// PC keyboards don't have these four buttons, but Macs do.\n"
    "";
#else
static const char * Dtool_KeyboardButton_f14_618_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f15(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f15_619(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f15(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f15", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f15();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f15()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f15_619_comment =
    "C++ Interface:\n"
    "f15()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f15_619_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::f16(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_f16_620(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::f16(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":f16", key_word_list))
        {
            ButtonHandle result = KeyboardButton::f16();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "f16()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_f16_620_comment =
    "C++ Interface:\n"
    "f16()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_f16_620_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::left(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_left_621(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::left(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":left", key_word_list))
        {
            ButtonHandle result = KeyboardButton::left();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "left()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_left_621_comment =
    "C++ Interface:\n"
    "left()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_left_621_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::right(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_right_622(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::right(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":right", key_word_list))
        {
            ButtonHandle result = KeyboardButton::right();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "right()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_right_622_comment =
    "C++ Interface:\n"
    "right()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_right_622_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::up(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_up_623(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::up(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":up", key_word_list))
        {
            ButtonHandle result = KeyboardButton::up();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "up()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_up_623_comment =
    "C++ Interface:\n"
    "up()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_up_623_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::down(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_down_624(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::down(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":down", key_word_list))
        {
            ButtonHandle result = KeyboardButton::down();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "down()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_down_624_comment =
    "C++ Interface:\n"
    "down()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_down_624_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::page_up(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_page_up_625(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::page_up(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":pageUp", key_word_list))
        {
            ButtonHandle result = KeyboardButton::page_up();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pageUp()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_page_up_625_comment =
    "C++ Interface:\n"
    "pageUp()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_page_up_625_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::page_down(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_page_down_626(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::page_down(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":pageDown", key_word_list))
        {
            ButtonHandle result = KeyboardButton::page_down();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pageDown()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_page_down_626_comment =
    "C++ Interface:\n"
    "pageDown()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_page_down_626_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::home(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_home_627(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::home(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":home", key_word_list))
        {
            ButtonHandle result = KeyboardButton::home();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "home()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_home_627_comment =
    "C++ Interface:\n"
    "home()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_home_627_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::end(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_end_628(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::end(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":end", key_word_list))
        {
            ButtonHandle result = KeyboardButton::end();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "end()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_end_628_comment =
    "C++ Interface:\n"
    "end()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_end_628_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::insert(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_insert_629(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::insert(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":insert", key_word_list))
        {
            ButtonHandle result = KeyboardButton::insert();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "insert()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_insert_629_comment =
    "C++ Interface:\n"
    "insert()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_insert_629_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::del(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_del_630(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::del(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":_del", key_word_list))
        {
            ButtonHandle result = KeyboardButton::del();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "_del()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_del_630_comment =
    "C++ Interface:\n"
    "_del()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_del_630_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::help(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_help_631(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::help(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":help", key_word_list))
        {
            ButtonHandle result = KeyboardButton::help();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "help()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_help_631_comment =
    "C++ Interface:\n"
    "help()\n"
    "\n"
    "// delete is a C++ keyword.\n"
    "";
#else
static const char * Dtool_KeyboardButton_help_631_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::shift(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_shift_632(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::shift(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":shift", key_word_list))
        {
            ButtonHandle result = KeyboardButton::shift();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shift()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_shift_632_comment =
    "C++ Interface:\n"
    "shift()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_shift_632_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::control(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_control_633(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::control(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":control", key_word_list))
        {
            ButtonHandle result = KeyboardButton::control();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "control()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_control_633_comment =
    "C++ Interface:\n"
    "control()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_control_633_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::alt(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_alt_634(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::alt(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":alt", key_word_list))
        {
            ButtonHandle result = KeyboardButton::alt();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "alt()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_alt_634_comment =
    "C++ Interface:\n"
    "alt()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_alt_634_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::meta(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_meta_635(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::meta(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":meta", key_word_list))
        {
            ButtonHandle result = KeyboardButton::meta();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "meta()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_meta_635_comment =
    "C++ Interface:\n"
    "meta()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_meta_635_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::caps_lock(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_caps_lock_636(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::caps_lock(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":capsLock", key_word_list))
        {
            ButtonHandle result = KeyboardButton::caps_lock();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "capsLock()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_caps_lock_636_comment =
    "C++ Interface:\n"
    "capsLock()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_caps_lock_636_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::shift_lock(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_shift_lock_637(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::shift_lock(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":shiftLock", key_word_list))
        {
            ButtonHandle result = KeyboardButton::shift_lock();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shiftLock()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_shift_lock_637_comment =
    "C++ Interface:\n"
    "shiftLock()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_shift_lock_637_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::num_lock(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_num_lock_638(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::num_lock(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":numLock", key_word_list))
        {
            ButtonHandle result = KeyboardButton::num_lock();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "numLock()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_num_lock_638_comment =
    "C++ Interface:\n"
    "numLock()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_num_lock_638_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::scroll_lock(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_scroll_lock_639(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::scroll_lock(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":scrollLock", key_word_list))
        {
            ButtonHandle result = KeyboardButton::scroll_lock();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "scrollLock()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_scroll_lock_639_comment =
    "C++ Interface:\n"
    "scrollLock()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_scroll_lock_639_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::print_screen(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_print_screen_640(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::print_screen(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":printScreen", key_word_list))
        {
            ButtonHandle result = KeyboardButton::print_screen();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printScreen()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_print_screen_640_comment =
    "C++ Interface:\n"
    "printScreen()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_print_screen_640_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::pause(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_pause_641(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::pause(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":pause", key_word_list))
        {
            ButtonHandle result = KeyboardButton::pause();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pause()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_pause_641_comment =
    "C++ Interface:\n"
    "pause()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_pause_641_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::lshift(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_lshift_642(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::lshift(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":lshift", key_word_list))
        {
            ButtonHandle result = KeyboardButton::lshift();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lshift()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_lshift_642_comment =
    "C++ Interface:\n"
    "lshift()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_lshift_642_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::rshift(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_rshift_643(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::rshift(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":rshift", key_word_list))
        {
            ButtonHandle result = KeyboardButton::rshift();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rshift()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_rshift_643_comment =
    "C++ Interface:\n"
    "rshift()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_rshift_643_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::lcontrol(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_lcontrol_644(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::lcontrol(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":lcontrol", key_word_list))
        {
            ButtonHandle result = KeyboardButton::lcontrol();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lcontrol()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_lcontrol_644_comment =
    "C++ Interface:\n"
    "lcontrol()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_lcontrol_644_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::rcontrol(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_rcontrol_645(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::rcontrol(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":rcontrol", key_word_list))
        {
            ButtonHandle result = KeyboardButton::rcontrol();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rcontrol()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_rcontrol_645_comment =
    "C++ Interface:\n"
    "rcontrol()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_rcontrol_645_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::lalt(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_lalt_646(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::lalt(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":lalt", key_word_list))
        {
            ButtonHandle result = KeyboardButton::lalt();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lalt()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_lalt_646_comment =
    "C++ Interface:\n"
    "lalt()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_lalt_646_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle KeyboardButton::ralt(void)
 *******************************************************************/
static PyObject *Dtool_KeyboardButton_ralt_647(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle KeyboardButton::ralt(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ralt", key_word_list))
        {
            ButtonHandle result = KeyboardButton::ralt();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ralt()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_KeyboardButton_ralt_647_comment =
    "C++ Interface:\n"
    "ralt()\n"
    "\n"
    "";
#else
static const char * Dtool_KeyboardButton_ralt_647_comment = NULL;
#endif

int  Dtool_Init_KeyboardButton(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (KeyboardButton)");
       return -1;
}
inline void  * Dtool_UpcastInterface_KeyboardButton(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_KeyboardButton)
    {
        printf("KeyboardButton ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    KeyboardButton * local_this = (KeyboardButton *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_KeyboardButton)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_KeyboardButton(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_KeyboardButton)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LineStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool LineStream::is_text_available(void) const
 *******************************************************************/
static PyObject *Dtool_LineStream_is_text_available_652(PyObject *self, PyObject *args,PyObject *kwds) {
    LineStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LineStream::is_text_available(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isTextAvailable", key_word_list));
        else
            (PyArg_Parse(args, ":isTextAvailable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LineStream*)local_this)->is_text_available();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTextAvailable(const LineStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineStream_is_text_available_652_comment =
    "C++ Interface:\n"
    "isTextAvailable(const LineStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineStream::is_text_available\n"
    "//       Access: Public\n"
    "//  Description: Returns true if there is at least one line of text\n"
    "//               (or even a partial line) available in the LineStream\n"
    "//               object.  If this returns true, the line may then be\n"
    "//               retrieved via get_line().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineStream_is_text_available_652_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > LineStream::get_line(void)
 *******************************************************************/
static PyObject *Dtool_LineStream_get_line_653(PyObject *self, PyObject *args,PyObject *kwds) {
    LineStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > LineStream::get_line(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLine", key_word_list));
        else
            (PyArg_Parse(args, ":getLine"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_line();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LineStream.getLine() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLine(non-const LineStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineStream_get_line_653_comment =
    "C++ Interface:\n"
    "getLine(non-const LineStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineStream::get_line\n"
    "//       Access: Public\n"
    "//  Description: Extracts and returns the next line (or partial line)\n"
    "//               of text available in the LineStream object.  Once the\n"
    "//               line has been extracted, you may call has_newline()\n"
    "//               to determine whether or not there was an explicit\n"
    "//               newline character written following this line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineStream_get_line_653_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LineStream::has_newline(void) const
 *******************************************************************/
static PyObject *Dtool_LineStream_has_newline_654(PyObject *self, PyObject *args,PyObject *kwds) {
    LineStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LineStream::has_newline(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasNewline", key_word_list));
        else
            (PyArg_Parse(args, ":hasNewline"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LineStream*)local_this)->has_newline();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasNewline(const LineStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineStream_has_newline_654_comment =
    "C++ Interface:\n"
    "hasNewline(const LineStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineStream::has_newline\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the line of text most recently\n"
    "//               returned by get_line() was written out with a\n"
    "//               terminating newline, or false if a newline character\n"
    "//               has not yet been written to the LineStream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineStream_has_newline_654_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LineStream::LineStream(void)
 *******************************************************************/
int  Dtool_Init_LineStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline LineStream::LineStream(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":LineStream", key_word_list))
        {
            LineStream *return_value = new LineStream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_LineStream,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "LineStream()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LineStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LineStream)
    {
        printf("LineStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LineStream * local_this = (LineStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LineStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LineStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LineStream)
        return from_this;
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (LineStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ModifierButtons 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ModifierButtons::operator =(ModifierButtons const &copy)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_663(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ModifierButtons::operator =(ModifierButtons const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    ModifierButtons *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ModifierButtons,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ModifierButtons this, const ModifierButtons copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_663_comment =
    "C++ Interface:\n"
    "assign(non-const ModifierButtons this, const ModifierButtons copy)\n"
    "\n"
    "// Filename: modifierButtons.I\n"
    "// Created by:  drose (01Mar00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_663_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ModifierButtons::operator ==(ModifierButtons const &other) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_664(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ModifierButtons::operator ==(ModifierButtons const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ModifierButtons*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_664_comment =
    "C++ Interface:\n"
    "eq(const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::Equality Operator\n"
    "//       Access: Published\n"
    "//  Description: The equality operator is an exact comparision: the\n"
    "//               two ModifierButtons are equal if they share the same\n"
    "//               button list--indeed, the same pointer--and they all\n"
    "//               the buttons have the same state.  Use matches() if a\n"
    "//               less exact equality test is needed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_664_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ModifierButtons::operator !=(ModifierButtons const &other) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_665(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ModifierButtons::operator !=(ModifierButtons const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ModifierButtons*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_665_comment =
    "C++ Interface:\n"
    "ne(const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::Inequality Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_665_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ModifierButtons::operator <(ModifierButtons const &other) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_666(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ModifierButtons::operator <(ModifierButtons const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ModifierButtons*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_666_comment =
    "C++ Interface:\n"
    "lessThan(const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::Ordering Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_666_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_667(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ModifierButtons result = ((const ModifierButtons*)local_this)->operator &(*param1_this);
                    ModifierButtons *return_value = new ModifierButtons(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ModifierButtons,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_667_comment =
    "C++ Interface:\n"
    "__and__(const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::operator &\n"
    "//       Access: Published\n"
    "//  Description: Returns a new ModifierButtons object for which\n"
    "//               is_down() will be true only if it is true on both\n"
    "//               source objects.  The set of buttons reported by\n"
    "//               has_button() is not completely defined if both source\n"
    "//               objects have a different set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_667_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_668(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ModifierButtons result = ((const ModifierButtons*)local_this)->operator |(*param1_this);
                    ModifierButtons *return_value = new ModifierButtons(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ModifierButtons,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_668_comment =
    "C++ Interface:\n"
    "__or__(const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::operator |\n"
    "//       Access: Published\n"
    "//  Description: Returns a new ModifierButtons object for which\n"
    "//               is_down() will be true if it is true on either of the\n"
    "//               source objects.  The set of buttons reported by\n"
    "//               has_button() is not completely defined if both source\n"
    "//               objects have a different set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_668_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ModifierButtons::operator &=(ModifierButtons const &other)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_669(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ModifierButtons::operator &=(ModifierButtons const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_669_comment =
    "C++ Interface:\n"
    "__iand__(non-const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::operator &=\n"
    "//       Access: Published\n"
    "//  Description: Sets is_down() true for any button that is already\n"
    "//               true for this object and the other object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_669_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ModifierButtons::operator |=(ModifierButtons const &other)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_operator_670(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ModifierButtons::operator |=(ModifierButtons const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_operator_670_comment =
    "C++ Interface:\n"
    "__ior__(non-const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::operator |=\n"
    "//       Access: Published\n"
    "//  Description: Sets is_down() true for any button that is already\n"
    "//               true for this object and the other object.  Adds\n"
    "//               whatever buttons are necessary to the list to make\n"
    "//               this so\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_operator_670_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ModifierButtons::set_button_list(ModifierButtons const &other)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_set_button_list_671(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ModifierButtons::set_button_list(ModifierButtons const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setButtonList", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setButtonList", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.setButtonList", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_button_list(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.setButtonList() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonList(non-const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_set_button_list_671_comment =
    "C++ Interface:\n"
    "setButtonList(non-const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::set_button_list\n"
    "//       Access: Published\n"
    "//  Description: Sets the list of buttons to watch to be the same as\n"
    "//               that of the other ModifierButtons object.  This makes\n"
    "//               the lists pointer equivalent (until one or the other\n"
    "//               is later modified).\n"
    "//\n"
    "//               This will preserve the state of any button that was\n"
    "//               on the original list and is also on the new lists.\n"
    "//               Any other buttons will get reset to the default state\n"
    "//               of \"up\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_set_button_list_671_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::matches(ModifierButtons const &other) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_matches_672(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool ModifierButtons::matches(ModifierButtons const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:matches", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:matches", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ModifierButtons.matches", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ModifierButtons*)local_this)->matches(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matches(const ModifierButtons this, const ModifierButtons other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_matches_672_comment =
    "C++ Interface:\n"
    "matches(const ModifierButtons this, const ModifierButtons other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::matches\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the set of buttons indicated as down\n"
    "//               by this ModifierButtons object is the same set of\n"
    "//               buttons indicated as down by the other\n"
    "//               ModifierButtons object.  The buttons indicated as up\n"
    "//               are not relevant.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_matches_672_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::add_button(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_add_button_673(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ModifierButtons::add_button(ButtonHandle button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ModifierButtons.addButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.addButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addButton(non-const ModifierButtons this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_add_button_673_comment =
    "C++ Interface:\n"
    "addButton(non-const ModifierButtons this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::add_button\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated button to the set of buttons that\n"
    "//               will be monitored for upness and downness.  Returns\n"
    "//               true if the button was added, false if it was already\n"
    "//               being monitored or if too many buttons are currently\n"
    "//               being monitored.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_add_button_673_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::has_button(ButtonHandle button) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_has_button_674(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool ModifierButtons::has_button(ButtonHandle button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ModifierButtons.hasButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ModifierButtons*)local_this)->has_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasButton(const ModifierButtons this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_has_button_674_comment =
    "C++ Interface:\n"
    "hasButton(const ModifierButtons this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::has_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button is in the set of\n"
    "//               buttons being monitored, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_has_button_674_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::remove_button(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_remove_button_675(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ModifierButtons::remove_button(ButtonHandle button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ModifierButtons.removeButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.removeButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeButton(non-const ModifierButtons this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_remove_button_675_comment =
    "C++ Interface:\n"
    "removeButton(non-const ModifierButtons this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::remove_button\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated button from the set of buttons\n"
    "//               being monitored.  Returns true if the button was\n"
    "//               removed, false if it was not being monitored in the\n"
    "//               first place.\n"
    "//\n"
    "//               Unlike the other methods, you cannot remove a button\n"
    "//               by removing its alias; you have to remove exactly the\n"
    "//               button itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_remove_button_675_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ModifierButtons::get_num_buttons(void) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_get_num_buttons_676(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ModifierButtons::get_num_buttons(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumButtons", key_word_list));
        else
            (PyArg_Parse(args, ":getNumButtons"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ModifierButtons*)local_this)->get_num_buttons();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumButtons(const ModifierButtons this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_get_num_buttons_676_comment =
    "C++ Interface:\n"
    "getNumButtons(const ModifierButtons this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::get_num_buttons\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of buttons that the\n"
    "//               ModifierButtons object is monitoring (e.g. the number\n"
    "//               of buttons passed to add_button()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_get_num_buttons_676_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ButtonHandle ModifierButtons::get_button(int index) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_get_button_677(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ButtonHandle ModifierButtons::get_button(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getButton", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getButton", &param1));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = ((const ModifierButtons*)local_this)->get_button((int)param1);
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButton(const ModifierButtons this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_get_button_677_comment =
    "C++ Interface:\n"
    "getButton(const ModifierButtons this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::get_button\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth button that the ModifierButtons\n"
    "//               object is monitoring (the nth button passed to\n"
    "//               add_button()).  This must be in the range 0 <= index\n"
    "//               < get_num_buttons().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_get_button_677_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::button_down(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_button_down_678(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ModifierButtons::button_down(ButtonHandle button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:buttonDown", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:buttonDown", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ModifierButtons.buttonDown", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->button_down(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.buttonDown() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "buttonDown(non-const ModifierButtons this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_button_down_678_comment =
    "C++ Interface:\n"
    "buttonDown(non-const ModifierButtons this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::button_down\n"
    "//       Access: Published\n"
    "//  Description: Records that a particular button has been pressed.\n"
    "//               If the given button is one of the buttons that is\n"
    "//               currently being monitored, this will update the\n"
    "//               internal state appropriately; otherwise, it will do\n"
    "//               nothing.  Returns true if the button is one that was\n"
    "//               monitored, or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_button_down_678_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::button_up(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_button_up_679(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ModifierButtons::button_up(ButtonHandle button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:buttonUp", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:buttonUp", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ModifierButtons.buttonUp", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->button_up(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ModifierButtons.buttonUp() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "buttonUp(non-const ModifierButtons this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_button_up_679_comment =
    "C++ Interface:\n"
    "buttonUp(non-const ModifierButtons this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::button_up\n"
    "//       Access: Published\n"
    "//  Description: Records that a particular button has been released.\n"
    "//               If the given button is one of the buttons that is\n"
    "//               currently being monitored, this will update the\n"
    "//               internal state appropriately; otherwise, it will do\n"
    "//               nothing.  Returns true if the button is one that was\n"
    "//               monitored, or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_button_up_679_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ModifierButtons::all_buttons_up(void)
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_all_buttons_up_680(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ModifierButtons::all_buttons_up(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":allButtonsUp", key_word_list));
        else
            (PyArg_Parse(args, ":allButtonsUp"));
        if(!PyErr_Occurred())
        {
            (local_this)->all_buttons_up();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ModifierButtons.allButtonsUp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allButtonsUp(non-const ModifierButtons this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_all_buttons_up_680_comment =
    "C++ Interface:\n"
    "allButtonsUp(non-const ModifierButtons this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::all_buttons_up\n"
    "//       Access: Published\n"
    "//  Description: Marks all monitored buttons as being in the \"up\"\n"
    "//               state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_all_buttons_up_680_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ModifierButtons::is_down(ButtonHandle button) const
 * inline bool ModifierButtons::is_down(int index) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_is_down_681(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool ModifierButtons::is_down(ButtonHandle button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isDown", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isDown", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ModifierButtons.isDown", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ModifierButtons*)local_this)->is_down(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline bool ModifierButtons::is_down(int index) const
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:isDown", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:isDown", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const ModifierButtons*)local_this)->is_down((int)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDown(const ModifierButtons this, const ButtonHandle button)\n"
          "isDown(const ModifierButtons this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_is_down_681_comment =
    "C++ Interface:\n"
    "isDown(const ModifierButtons this, const ButtonHandle button)\n"
    "isDown(const ModifierButtons this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::is_down\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button is known to be\n"
    "//               down, or false if it is known to be up.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::is_down\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button is known to be\n"
    "//               down, or false if it is known to be up or if it is\n"
    "//               not in the set of buttons being tracked.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_is_down_681_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ModifierButtons::is_any_down(void) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_is_any_down_682(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ModifierButtons::is_any_down(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAnyDown", key_word_list));
        else
            (PyArg_Parse(args, ":isAnyDown"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ModifierButtons*)local_this)->is_any_down();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAnyDown(const ModifierButtons this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_is_any_down_682_comment =
    "C++ Interface:\n"
    "isAnyDown(const ModifierButtons this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::is_any_down\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any of the tracked button are known\n"
    "//               to be down, or false if all of them are up.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_is_any_down_682_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > ModifierButtons::get_prefix(void) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_get_prefix_683(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > ModifierButtons::get_prefix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPrefix", key_word_list));
        else
            (PyArg_Parse(args, ":getPrefix"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ModifierButtons*)local_this)->get_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrefix(const ModifierButtons this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_get_prefix_683_comment =
    "C++ Interface:\n"
    "getPrefix(const ModifierButtons this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::get_prefix\n"
    "//       Access: Published\n"
    "//  Description: Returns a string which can be used to prefix any\n"
    "//               button name or event name with the unique set of\n"
    "//               modifier buttons currently being held.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_get_prefix_683_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ModifierButtons::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_output_684(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ModifierButtons::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ModifierButtons.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ModifierButtons*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ModifierButtons this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_output_684_comment =
    "C++ Interface:\n"
    "output(const ModifierButtons this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::output\n"
    "//       Access: Published\n"
    "//  Description: Writes a one-line summary of the buttons known to be\n"
    "//               down.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_output_684_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ModifierButtons::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ModifierButtons_write_685(PyObject *self, PyObject *args,PyObject *kwds) {
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ModifierButtons::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ModifierButtons.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ModifierButtons*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ModifierButtons this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ModifierButtons_write_685_comment =
    "C++ Interface:\n"
    "write(const ModifierButtons this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ModifierButtons::write\n"
    "//       Access: Published\n"
    "//  Description: Writes a multi-line summary including all of the\n"
    "//               buttons being monitored and which ones are known to\n"
    "//               be down.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ModifierButtons_write_685_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ModifierButtons::ModifierButtons(void)
 * ModifierButtons::ModifierButtons(ModifierButtons const &copy)
 *******************************************************************/
int  Dtool_Init_ModifierButtons(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ModifierButtons::ModifierButtons(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ModifierButtons", key_word_list))
            {
                ModifierButtons *return_value = new ModifierButtons();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ModifierButtons,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ModifierButtons::ModifierButtons(ModifierButtons const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ModifierButtons", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ModifierButtons", &param0));
                if(!PyErr_Occurred())
                {
                    ModifierButtons *param0_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ModifierButtons, 0, "ModifierButtons.ModifierButtons", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ModifierButtons *return_value = new ModifierButtons(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ModifierButtons,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ModifierButtons() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ModifierButtons()\n"
          "ModifierButtons(const ModifierButtons copy)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_ModifierButtons_get_buttons(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumButtons", "getButton");
}
inline void  * Dtool_UpcastInterface_ModifierButtons(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ModifierButtons)
    {
        printf("ModifierButtons ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ModifierButtons * local_this = (ModifierButtons *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ModifierButtons)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ModifierButtons(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ModifierButtons)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseButton 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::button(int button_number)
 *******************************************************************/
static PyObject *Dtool_MouseButton_button_687(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::button(int button_number)
        int param0;
        static char * key_word_list[] = {(char *)"button_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:button", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:button", &param0));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = MouseButton::button((int)param0);
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "button(int button_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_button_687_comment =
    "C++ Interface:\n"
    "button(int button_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::button\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               particular numbered mouse button (zero-based), if\n"
    "//               there is one, or ButtonHandle::none() if there is\n"
    "//               not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_button_687_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::one(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_one_688(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::one(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":one", key_word_list))
        {
            ButtonHandle result = MouseButton::one();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "one()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_one_688_comment =
    "C++ Interface:\n"
    "one()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::one\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               first mouse button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_one_688_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::two(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_two_689(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::two(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":two", key_word_list))
        {
            ButtonHandle result = MouseButton::two();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "two()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_two_689_comment =
    "C++ Interface:\n"
    "two()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::two\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               second mouse button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_two_689_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::three(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_three_690(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::three(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":three", key_word_list))
        {
            ButtonHandle result = MouseButton::three();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "three()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_three_690_comment =
    "C++ Interface:\n"
    "three()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::three\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               third mouse button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_three_690_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::four(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_four_691(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::four(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":four", key_word_list))
        {
            ButtonHandle result = MouseButton::four();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "four()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_four_691_comment =
    "C++ Interface:\n"
    "four()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::four\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               fourth mouse button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_four_691_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::five(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_five_692(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::five(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":five", key_word_list))
        {
            ButtonHandle result = MouseButton::five();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "five()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_five_692_comment =
    "C++ Interface:\n"
    "five()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::five\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle associated with the\n"
    "//               fifth mouse button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_five_692_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::wheel_up(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_wheel_up_693(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::wheel_up(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":wheelUp", key_word_list))
        {
            ButtonHandle result = MouseButton::wheel_up();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wheelUp()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_wheel_up_693_comment =
    "C++ Interface:\n"
    "wheelUp()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::wheel_up\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle generated when the mouse\n"
    "//               wheel is rolled one notch upwards.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_wheel_up_693_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::wheel_down(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_wheel_down_694(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::wheel_down(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":wheelDown", key_word_list))
        {
            ButtonHandle result = MouseButton::wheel_down();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wheelDown()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_wheel_down_694_comment =
    "C++ Interface:\n"
    "wheelDown()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::wheel_down\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle generated when the mouse\n"
    "//               wheel is rolled one notch downwards.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_wheel_down_694_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::wheel_left(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_wheel_left_695(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::wheel_left(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":wheelLeft", key_word_list))
        {
            ButtonHandle result = MouseButton::wheel_left();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wheelLeft()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_wheel_left_695_comment =
    "C++ Interface:\n"
    "wheelLeft()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::wheel_left\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle generated when the mouse\n"
    "//               is scrolled to the left. Usually, you'll only\n"
    "//               find the horizontal scroll on laptops.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_wheel_left_695_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ButtonHandle MouseButton::wheel_right(void)
 *******************************************************************/
static PyObject *Dtool_MouseButton_wheel_right_696(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ButtonHandle MouseButton::wheel_right(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":wheelRight", key_word_list))
        {
            ButtonHandle result = MouseButton::wheel_right();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wheelRight()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_wheel_right_696_comment =
    "C++ Interface:\n"
    "wheelRight()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::wheel_right\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the ButtonHandle generated when the mouse\n"
    "//               is scrolled to the right. Usually, you'll only\n"
    "//               find the horizontal scroll on laptops.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_wheel_right_696_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool MouseButton::is_mouse_button(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_MouseButton_is_mouse_button_697(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static bool MouseButton::is_mouse_button(ButtonHandle button)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isMouseButton", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:isMouseButton", &param0));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param0_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ButtonHandle, 0, "MouseButton.isMouseButton", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    bool return_value = MouseButton::is_mouse_button(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isMouseButton(const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseButton_is_mouse_button_697_comment =
    "C++ Interface:\n"
    "isMouseButton(const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseButton::is_mouse_button\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns true if the indicated ButtonHandle is a mouse\n"
    "//               button, false if it is some other kind of button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseButton_is_mouse_button_697_comment = NULL;
#endif

int  Dtool_Init_MouseButton(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MouseButton)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MouseButton(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseButton)
    {
        printf("MouseButton ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseButton * local_this = (MouseButton *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseButton)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseButton(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseButton)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void MouseData::operator =(MouseData const &copy)
 *******************************************************************/
static PyObject *Dtool_MouseData_operator_701(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseData::operator =(MouseData const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                MouseData *param1_this = (MouseData *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseData, 1, "MouseData.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    MouseData *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_MouseData,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseData.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const MouseData this, const MouseData copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseData_operator_701_comment =
    "C++ Interface:\n"
    "assign(non-const MouseData this, const MouseData copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseData::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseData_operator_701_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MouseData::get_x(void) const
 *******************************************************************/
static PyObject *Dtool_MouseData_get_x_702(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MouseData::get_x(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getX", key_word_list));
        else
            (PyArg_Parse(args, ":getX"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseData*)local_this)->get_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getX(const MouseData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseData_get_x_702_comment =
    "C++ Interface:\n"
    "getX(const MouseData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseData::get_x\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseData_get_x_702_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MouseData::get_y(void) const
 *******************************************************************/
static PyObject *Dtool_MouseData_get_y_703(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MouseData::get_y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getY", key_word_list));
        else
            (PyArg_Parse(args, ":getY"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseData*)local_this)->get_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getY(const MouseData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseData_get_y_703_comment =
    "C++ Interface:\n"
    "getY(const MouseData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseData::get_y\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseData_get_y_703_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseData::get_in_window(void) const
 *******************************************************************/
static PyObject *Dtool_MouseData_get_in_window_704(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseData::get_in_window(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInWindow", key_word_list));
        else
            (PyArg_Parse(args, ":getInWindow"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseData*)local_this)->get_in_window();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInWindow(const MouseData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseData_get_in_window_704_comment =
    "C++ Interface:\n"
    "getInWindow(const MouseData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseData::get_in_window\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseData_get_in_window_704_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseData::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_MouseData_output_705(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void MouseData::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseData.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MouseData*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const MouseData this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseData_output_705_comment =
    "C++ Interface:\n"
    "output(const MouseData this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseData::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseData_output_705_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MouseData::MouseData(void)
 * inline MouseData::MouseData(MouseData const &copy)
 *******************************************************************/
int  Dtool_Init_MouseData(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline MouseData::MouseData(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":MouseData", key_word_list))
            {
                MouseData *return_value = new MouseData();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseData,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline MouseData::MouseData(MouseData const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:MouseData", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:MouseData", &param0));
                if(!PyErr_Occurred())
                {
                    MouseData *param0_this = (MouseData *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_MouseData, 0, "MouseData.MouseData", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        MouseData *return_value = new MouseData(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseData,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "MouseData() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "MouseData()\n"
          "MouseData(const MouseData copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MouseData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseData)
    {
        printf("MouseData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseData * local_this = (MouseData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseData)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseData)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NodeCachedReferenceCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int NodeCachedReferenceCount::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCachedReferenceCount_get_node_ref_count_708(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCachedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCachedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NodeCachedReferenceCount::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NodeCachedReferenceCount*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const NodeCachedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCachedReferenceCount_get_node_ref_count_708_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const NodeCachedReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCachedReferenceCount::get_node_ref_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the current reference count.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCachedReferenceCount_get_node_ref_count_708_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NodeCachedReferenceCount::node_ref(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCachedReferenceCount_node_ref_709(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCachedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCachedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void NodeCachedReferenceCount::node_ref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":nodeRef", key_word_list));
        else
            (PyArg_Parse(args, ":nodeRef"));
        if(!PyErr_Occurred())
        {
            ((const NodeCachedReferenceCount*)local_this)->node_ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "nodeRef(const NodeCachedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCachedReferenceCount_node_ref_709_comment =
    "C++ Interface:\n"
    "nodeRef(const NodeCachedReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCachedReferenceCount::node_ref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly increments the reference count.\n"
    "//\n"
    "//               This function is const, even though it changes the\n"
    "//               object, because generally fiddling with an object's\n"
    "//               reference count isn't considered part of fiddling\n"
    "//               with the object.  An object might be const in other\n"
    "//               ways, but we still need to accurately count the\n"
    "//               number of references to it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCachedReferenceCount_node_ref_709_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NodeCachedReferenceCount::node_unref(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCachedReferenceCount_node_unref_710(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCachedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCachedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NodeCachedReferenceCount::node_unref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":nodeUnref", key_word_list));
        else
            (PyArg_Parse(args, ":nodeUnref"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NodeCachedReferenceCount*)local_this)->node_unref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "nodeUnref(const NodeCachedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCachedReferenceCount_node_unref_710_comment =
    "C++ Interface:\n"
    "nodeUnref(const NodeCachedReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCachedReferenceCount::node_unref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly decrements the node reference count and\n"
    "//               the normal reference count simultaneously.\n"
    "//\n"
    "//               The return value is true if the new reference count\n"
    "//               is nonzero, false if it is zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCachedReferenceCount_node_unref_710_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_711(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCachedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCachedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":testRefCountIntegrity", key_word_list));
        else
            (PyArg_Parse(args, ":testRefCountIntegrity"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NodeCachedReferenceCount*)local_this)->test_ref_count_integrity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "testRefCountIntegrity(const NodeCachedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCachedReferenceCount_test_ref_count_integrity_711_comment =
    "C++ Interface:\n"
    "testRefCountIntegrity(const NodeCachedReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCachedReferenceCount::test_ref_count_integrity\n"
    "//       Access: Published\n"
    "//  Description: Does some easy checks to make sure that the reference\n"
    "//               count isn't completely bogus.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCachedReferenceCount_test_ref_count_integrity_711_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NodeCachedReferenceCount::get_referenced_bits(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCachedReferenceCount_get_referenced_bits_713(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCachedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCachedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NodeCachedReferenceCount::get_referenced_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReferencedBits", key_word_list));
        else
            (PyArg_Parse(args, ":getReferencedBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NodeCachedReferenceCount*)local_this)->get_referenced_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReferencedBits(const NodeCachedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCachedReferenceCount_get_referenced_bits_713_comment =
    "C++ Interface:\n"
    "getReferencedBits(const NodeCachedReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCachedReferenceCount::get_referenced_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the union of the values defined in the\n"
    "//               Referenced enum that represents the various things\n"
    "//               that appear to be holding a pointer to this object.\n"
    "//\n"
    "//               If R_node is included, at least one node is holding a\n"
    "//               pointer; if R_cache is included, at least one cache\n"
    "//               element is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCachedReferenceCount_get_referenced_bits_713_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NodeCachedReferenceCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NodeCachedReferenceCount_get_class_type_714(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NodeCachedReferenceCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NodeCachedReferenceCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCachedReferenceCount_get_class_type_714_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NodeCachedReferenceCount_get_class_type_714_comment = NULL;
#endif

int  Dtool_Init_NodeCachedReferenceCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NodeCachedReferenceCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NodeCachedReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NodeCachedReferenceCount)
    {
        printf("NodeCachedReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NodeCachedReferenceCount * local_this = (NodeCachedReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NodeCachedReferenceCount)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NodeCachedReferenceCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NodeCachedReferenceCount)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (NodeCachedReferenceCount*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NodeCachedReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NodeCachedReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (NodeCachedReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (NodeCachedReferenceCount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SparseArray 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline SparseArray &SparseArray::operator =(SparseArray const &copy)
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_717(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline SparseArray &SparseArray::operator =(SparseArray const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    SparseArray *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SparseArray.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const SparseArray this, const SparseArray copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_717_comment =
    "C++ Interface:\n"
    "assign(non-const SparseArray this, const SparseArray copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_717_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline SparseArray SparseArray::all_on(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_all_on_718(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline SparseArray SparseArray::all_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOn", key_word_list))
        {
            SparseArray result = SparseArray::all_on();
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_all_on_718_comment =
    "C++ Interface:\n"
    "allOn()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::Named all_on constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a SparseArray with an infinite array of bits,\n"
    "//               all on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_all_on_718_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline SparseArray SparseArray::all_off(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_all_off_719(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline SparseArray SparseArray::all_off(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":allOff", key_word_list))
        {
            SparseArray result = SparseArray::all_off();
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allOff()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_all_off_719_comment =
    "C++ Interface:\n"
    "allOff()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::Named all_on constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a SparseArray whose bits are all off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_all_off_719_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline SparseArray SparseArray::lower_on(int on_bits)
 *******************************************************************/
static PyObject *Dtool_SparseArray_lower_on_720(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline SparseArray SparseArray::lower_on(int on_bits)
        int param0;
        static char * key_word_list[] = {(char *)"on_bits", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:lowerOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:lowerOn", &param0));
        if(!PyErr_Occurred())
        {
            SparseArray result = SparseArray::lower_on((int)param0);
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lowerOn(int on_bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_lower_on_720_comment =
    "C++ Interface:\n"
    "lowerOn(int on_bits)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::Named lower_on constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a SparseArray whose lower on_bits bits are on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_lower_on_720_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline SparseArray SparseArray::bit(int index)
 *******************************************************************/
static PyObject *Dtool_SparseArray_bit_721(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline SparseArray SparseArray::bit(int index)
        int param0;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:bit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:bit", &param0));
        if(!PyErr_Occurred())
        {
            SparseArray result = SparseArray::bit((int)param0);
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bit(int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_bit_721_comment =
    "C++ Interface:\n"
    "bit(int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::Named bit constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a SparseArray with only the indicated bit on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_bit_721_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline SparseArray SparseArray::range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_SparseArray_range_722(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline SparseArray SparseArray::range(int low_bit, int size)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:range", key_word_list, &param0, &param1))
        {
            SparseArray result = SparseArray::range((int)param0, (int)param1);
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "range(int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_range_722_comment =
    "C++ Interface:\n"
    "range(int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::Named range constructor\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a SparseArray whose size bits, beginning at\n"
    "//               low_bit, are on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_range_722_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool SparseArray::has_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_has_max_num_bits_724(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool SparseArray::has_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxNumBits", key_word_list))
        {
            bool return_value = SparseArray::has_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_has_max_num_bits_724_comment =
    "C++ Interface:\n"
    "hasMaxNumBits()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::has_max_num_bits\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if there is a maximum number of bits\n"
    "//               that may be stored in this structure, false\n"
    "//               otherwise.  If this returns true, the number may be\n"
    "//               queried in get_max_num_bits().\n"
    "//\n"
    "//               This method always returns false.  The SparseArray has\n"
    "//               no maximum number of bits.  This method is defined so\n"
    "//               generic programming algorithms can use BitMask or\n"
    "//               SparseArray interchangeably.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_has_max_num_bits_724_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int SparseArray::get_max_num_bits(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_max_num_bits_725(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int SparseArray::get_max_num_bits(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxNumBits", key_word_list))
        {
            int return_value = SparseArray::get_max_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxNumBits()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_max_num_bits_725_comment =
    "C++ Interface:\n"
    "getMaxNumBits()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_max_num_bits\n"
    "//       Access: Published, Static\n"
    "//  Description: If get_max_num_bits() returned true, this method may\n"
    "//               be called to return the maximum number of bits that\n"
    "//               may be stored in this structure.  It is an error to\n"
    "//               call this if get_max_num_bits() return false.\n"
    "//\n"
    "//               It is always an error to call this method.  The\n"
    "//               SparseArray has no maximum number of bits.  This method\n"
    "//               is defined so generic programming algorithms can use\n"
    "//               BitMask or SparseArray interchangeably.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_max_num_bits_725_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SparseArray::get_num_bits(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_num_bits_726(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SparseArray::get_num_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_num_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBits(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_num_bits_726_comment =
    "C++ Interface:\n"
    "getNumBits(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_num_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the current number of possibly different bits\n"
    "//               in this array.  There are actually an infinite number\n"
    "//               of bits, but every bit higher than this bit will have\n"
    "//               the same value, either 0 or 1 (see\n"
    "//               get_highest_bits()).\n"
    "//\n"
    "//               This number may grow and/or shrink automatically as\n"
    "//               needed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_num_bits_726_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::get_bit(int index) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_bit_727(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::get_bit(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SparseArray*)local_this)->get_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBit(const SparseArray this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_bit_727_comment =
    "C++ Interface:\n"
    "getBit(const SparseArray this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the nth bit is set, false if it is\n"
    "//               cleared.  It is valid for n to increase beyond\n"
    "//               get_num_bits(), but the return value get_num_bits()\n"
    "//               will always be the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_bit_727_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::set_bit(int index)
 *******************************************************************/
static PyObject *Dtool_SparseArray_set_bit_728(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::set_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.setBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBit(non-const SparseArray this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_set_bit_728_comment =
    "C++ Interface:\n"
    "setBit(non-const SparseArray this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::set_bit\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth bit on.  If n >= get_num_bits(), this\n"
    "//               automatically extends the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_set_bit_728_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::clear_bit(int index)
 *******************************************************************/
static PyObject *Dtool_SparseArray_clear_bit_729(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::clear_bit(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearBit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.clearBit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBit(non-const SparseArray this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_clear_bit_729_comment =
    "C++ Interface:\n"
    "clearBit(non-const SparseArray this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::clear_bit\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth bit off.  If n >= get_num_bits(), this\n"
    "//               automatically extends the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_clear_bit_729_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::set_bit_to(int index, bool value)
 *******************************************************************/
static PyObject *Dtool_SparseArray_set_bit_to_730(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::set_bit_to(int index, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBitTo", key_word_list, &param1, &param2))
        {
            (local_this)->set_bit_to((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.setBitTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBitTo(non-const SparseArray this, int index, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_set_bit_to_730_comment =
    "C++ Interface:\n"
    "setBitTo(non-const SparseArray this, int index, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::set_bit_to\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth bit either on or off, according to the\n"
    "//               indicated bool value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_set_bit_to_730_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::get_highest_bits(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_highest_bits_731(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::get_highest_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestBits", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestBits"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SparseArray*)local_this)->get_highest_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestBits(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_highest_bits_731_comment =
    "C++ Interface:\n"
    "getHighestBits(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_highest_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the infinite set of bits beyond\n"
    "//               get_num_bits() are all on, or false of they are all\n"
    "//               off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_highest_bits_731_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::is_zero(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_is_zero_732(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::is_zero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isZero", key_word_list));
        else
            (PyArg_Parse(args, ":isZero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SparseArray*)local_this)->is_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isZero(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_is_zero_732_comment =
    "C++ Interface:\n"
    "isZero(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::is_zero\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the entire bitmask is zero, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_is_zero_732_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::is_all_on(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_is_all_on_733(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::is_all_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAllOn", key_word_list));
        else
            (PyArg_Parse(args, ":isAllOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SparseArray*)local_this)->is_all_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAllOn(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_is_all_on_733_comment =
    "C++ Interface:\n"
    "isAllOn(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::is_all_on\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the entire bitmask is one, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_is_all_on_733_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::has_any_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_has_any_of_734(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::has_any_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAnyOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const SparseArray*)local_this)->has_any_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnyOf(const SparseArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_has_any_of_734_comment =
    "C++ Interface:\n"
    "hasAnyOf(const SparseArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::has_any_of\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any bit in the indicated range is\n"
    "//               set, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_has_any_of_734_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::has_all_of(int low_bit, int size) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_has_all_of_735(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::has_all_of(int low_bit, int size) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:hasAllOf", key_word_list, &param1, &param2))
        {
            bool return_value = ((const SparseArray*)local_this)->has_all_of((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAllOf(const SparseArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_has_all_of_735_comment =
    "C++ Interface:\n"
    "hasAllOf(const SparseArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::has_all_of\n"
    "//       Access: Published\n"
    "//  Description: Returns true if all bits in the indicated range are\n"
    "//               set, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_has_all_of_735_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::set_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_SparseArray_set_range_736(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::set_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const SparseArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_set_range_736_comment =
    "C++ Interface:\n"
    "setRange(non-const SparseArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::set_range\n"
    "//       Access: Published\n"
    "//  Description: Sets the indicated range of bits on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_set_range_736_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::clear_range(int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_SparseArray_clear_range_737(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::clear_range(int low_bit, int size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clearRange", key_word_list, &param1, &param2))
        {
            (local_this)->clear_range((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.clearRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRange(non-const SparseArray this, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_clear_range_737_comment =
    "C++ Interface:\n"
    "clearRange(non-const SparseArray this, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::clear_range\n"
    "//       Access: Published\n"
    "//  Description: Sets the indicated range of bits off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_clear_range_737_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::set_range_to(bool value, int low_bit, int size)
 *******************************************************************/
static PyObject *Dtool_SparseArray_set_range_to_738(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::set_range_to(bool value, int low_bit, int size)
        PyObject *param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"value", (char *)"low_bit", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setRangeTo", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_range_to((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.setRangeTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRangeTo(non-const SparseArray this, bool value, int low_bit, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_set_range_to_738_comment =
    "C++ Interface:\n"
    "setRangeTo(non-const SparseArray this, bool value, int low_bit, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::set_range_to\n"
    "//       Access: Published\n"
    "//  Description: Sets the indicated range of bits to either on or off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_set_range_to_738_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_num_on_bits(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_num_on_bits_739(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_num_on_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOnBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOnBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_num_on_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOnBits(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_num_on_bits_739_comment =
    "C++ Interface:\n"
    "getNumOnBits(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_num_on_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bits that are set to 1 in the\n"
    "//               array.  Returns -1 if there are an infinite number of\n"
    "//               1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_num_on_bits_739_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_num_off_bits(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_num_off_bits_740(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_num_off_bits(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOffBits", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOffBits"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_num_off_bits();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOffBits(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_num_off_bits_740_comment =
    "C++ Interface:\n"
    "getNumOffBits(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_num_off_bits\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bits that are set to 0 in the\n"
    "//               array.  Returns -1 if there are an infinite number of\n"
    "//               0 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_num_off_bits_740_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_lowest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_lowest_on_bit_741(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_lowest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_lowest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOnBit(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_lowest_on_bit_741_comment =
    "C++ Interface:\n"
    "getLowestOnBit(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_lowest_on_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the lowest 1 bit in the array.\n"
    "//               Returns -1 if there are no 1 bits or if there are an\n"
    "//               infinite number of 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_lowest_on_bit_741_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_lowest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_lowest_off_bit_742(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_lowest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_lowest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestOffBit(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_lowest_off_bit_742_comment =
    "C++ Interface:\n"
    "getLowestOffBit(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_lowest_off_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the lowest 0 bit in the array.\n"
    "//               Returns -1 if there are no 0 bits or if there are an\n"
    "//               infinite number of 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_lowest_off_bit_742_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_highest_on_bit(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_highest_on_bit_743(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_highest_on_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOnBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOnBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_highest_on_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOnBit(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_highest_on_bit_743_comment =
    "C++ Interface:\n"
    "getHighestOnBit(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_highest_on_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the highest 1 bit in the array.\n"
    "//               Returns -1 if there are no 1 bits or if there an\n"
    "//               infinite number of 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_highest_on_bit_743_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_highest_off_bit(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_highest_off_bit_744(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_highest_off_bit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestOffBit", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestOffBit"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_highest_off_bit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestOffBit(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_highest_off_bit_744_comment =
    "C++ Interface:\n"
    "getHighestOffBit(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_highest_off_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the highest 0 bit in the array.\n"
    "//               Returns -1 if there are no 0 bits or if there an\n"
    "//               infinite number of 1 bits.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_highest_off_bit_744_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::get_next_higher_different_bit(int low_bit) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_next_higher_different_bit_745(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SparseArray::get_next_higher_different_bit(int low_bit) const
        int param1;
        static char * key_word_list[] = {(char *)"low_bit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNextHigherDifferentBit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNextHigherDifferentBit", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_next_higher_different_bit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextHigherDifferentBit(const SparseArray this, int low_bit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_next_higher_different_bit_745_comment =
    "C++ Interface:\n"
    "getNextHigherDifferentBit(const SparseArray this, int low_bit)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_next_higher_different_bit\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the next bit in the array, above\n"
    "//               low_bit, whose value is different that the value of\n"
    "//               low_bit.  Returns low_bit again if all bits higher\n"
    "//               than low_bit have the same value.\n"
    "//\n"
    "//               This can be used to quickly iterate through all of\n"
    "//               the bits in the array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_next_higher_different_bit_745_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::invert_in_place(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_invert_in_place_746(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::invert_in_place(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":invertInPlace", key_word_list));
        else
            (PyArg_Parse(args, ":invertInPlace"));
        if(!PyErr_Occurred())
        {
            (local_this)->invert_in_place();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.invertInPlace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "invertInPlace(non-const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_invert_in_place_746_comment =
    "C++ Interface:\n"
    "invertInPlace(non-const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::invert_in_place\n"
    "//       Access: Published\n"
    "//  Description: Inverts all the bits in the SparseArray.  This is\n"
    "//               equivalent to array = ~array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_invert_in_place_746_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool SparseArray::has_bits_in_common(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_has_bits_in_common_747(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool SparseArray::has_bits_in_common(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasBitsInCommon", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasBitsInCommon", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.hasBitsInCommon", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const SparseArray*)local_this)->has_bits_in_common(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBitsInCommon(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_has_bits_in_common_747_comment =
    "C++ Interface:\n"
    "hasBitsInCommon(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::has_bits_in_common\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this SparseArray has any \"one\" bits in\n"
    "//               common with the other one, false otherwise.\n"
    "//\n"
    "//               This is equivalent to (array & other) != 0, but may\n"
    "//               be faster.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_has_bits_in_common_747_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::clear(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_clear_748(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_clear_748_comment =
    "C++ Interface:\n"
    "clear(non-const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::clear\n"
    "//       Access: Published\n"
    "//  Description: Sets all the bits in the SparseArray off.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_clear_748_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SparseArray::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_output_749(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void SparseArray::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SparseArray.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SparseArray*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const SparseArray this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_output_749_comment =
    "C++ Interface:\n"
    "output(const SparseArray this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_output_749_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::operator ==(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_750(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool SparseArray::operator ==(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const SparseArray*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_750_comment =
    "C++ Interface:\n"
    "eq(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_750_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::operator !=(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_751(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool SparseArray::operator !=(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const SparseArray*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_751_comment =
    "C++ Interface:\n"
    "ne(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_751_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::operator <(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_752(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool SparseArray::operator <(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const SparseArray*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_752_comment =
    "C++ Interface:\n"
    "lessThan(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator <\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the unsigned integer which is\n"
    "//               represented by this SparseArray is less than that of the\n"
    "//               other one, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_752_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SparseArray::compare_to(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_compare_to_753(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int SparseArray::compare_to(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const SparseArray*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_compare_to_753_comment =
    "C++ Interface:\n"
    "compareTo(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::compare_to\n"
    "//       Access: Published\n"
    "//  Description: Returns a number less than zero if this SparseArray\n"
    "//               sorts before the indicated other SparseArray, greater\n"
    "//               than zero if it sorts after, or 0 if they are\n"
    "//               equivalent.  This is based on the same ordering\n"
    "//               defined by operator <.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_compare_to_753_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray SparseArray::operator &(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_754(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline SparseArray SparseArray::operator &(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__and__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__and__", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.__and__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    SparseArray result = ((const SparseArray*)local_this)->operator &(*param1_this);
                    SparseArray *return_value = new SparseArray(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__and__(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_754_comment =
    "C++ Interface:\n"
    "__and__(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator &\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_754_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray SparseArray::operator |(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_755(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline SparseArray SparseArray::operator |(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__or__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__or__", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.__or__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    SparseArray result = ((const SparseArray*)local_this)->operator |(*param1_this);
                    SparseArray *return_value = new SparseArray(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__or__(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_755_comment =
    "C++ Interface:\n"
    "__or__(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator |\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_755_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray SparseArray::operator ^(SparseArray const &other) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_756(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline SparseArray SparseArray::operator ^(SparseArray const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__xor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__xor__", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.__xor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    SparseArray result = ((const SparseArray*)local_this)->operator ^(*param1_this);
                    SparseArray *return_value = new SparseArray(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__xor__(const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_756_comment =
    "C++ Interface:\n"
    "__xor__(const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator ^\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_756_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray SparseArray::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_757(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SparseArray SparseArray::operator ~(void) const
        {
            SparseArray result = ((const SparseArray*)local_this)->operator ~();
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_757_comment =
    "C++ Interface:\n"
    "__invert__(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator ~\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_757_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray SparseArray::operator <<(int shift) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_758(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline SparseArray SparseArray::operator <<(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__lshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__lshift__", &param1));
        if(!PyErr_Occurred())
        {
            SparseArray result = ((const SparseArray*)local_this)->operator <<((int)param1);
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__lshift__(const SparseArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_758_comment =
    "C++ Interface:\n"
    "__lshift__(const SparseArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator <<\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_758_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray SparseArray::operator >>(int shift) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_759(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline SparseArray SparseArray::operator >>(int shift) const
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__rshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__rshift__", &param1));
        if(!PyErr_Occurred())
        {
            SparseArray result = ((const SparseArray*)local_this)->operator >>((int)param1);
            SparseArray *return_value = new SparseArray(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SparseArray,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__rshift__(const SparseArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_759_comment =
    "C++ Interface:\n"
    "__rshift__(const SparseArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator >>\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_759_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SparseArray::operator &=(SparseArray const &other)
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_760(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SparseArray::operator &=(SparseArray const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iand__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iand__", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.__iand__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator &=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SparseArray.__iand__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iand__(non-const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_760_comment =
    "C++ Interface:\n"
    "__iand__(non-const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator &=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_760_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SparseArray::operator |=(SparseArray const &other)
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_761(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SparseArray::operator |=(SparseArray const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ior__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ior__", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.__ior__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator |=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SparseArray.__ior__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ior__(non-const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_761_comment =
    "C++ Interface:\n"
    "__ior__(non-const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator |=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_761_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SparseArray::operator ^=(SparseArray const &other)
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_762(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SparseArray::operator ^=(SparseArray const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__ixor__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__ixor__", &param1));
            if(!PyErr_Occurred())
            {
                SparseArray *param1_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SparseArray, 1, "SparseArray.__ixor__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator ^=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SparseArray.__ixor__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ixor__(non-const SparseArray this, const SparseArray other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_762_comment =
    "C++ Interface:\n"
    "__ixor__(non-const SparseArray this, const SparseArray other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator ^=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_762_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::operator <<=(int shift)
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_763(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::operator <<=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__ilshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__ilshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator <<=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.__ilshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__ilshift__(non-const SparseArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_763_comment =
    "C++ Interface:\n"
    "__ilshift__(non-const SparseArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator <<=\n"
    "//       Access: Published\n"
    "//  Description: Logical left shift.  Since negative bit positions\n"
    "//               have meaning in a SparseArray, real bit values are\n"
    "//               rotated in on the left (not necessarily zero).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_763_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparseArray::operator >>=(int shift)
 *******************************************************************/
static PyObject *Dtool_SparseArray_operator_764(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparseArray::operator >>=(int shift)
        int param1;
        static char * key_word_list[] = {(char *)"shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__irshift__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__irshift__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator >>=((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparseArray.__irshift__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__irshift__(non-const SparseArray this, int shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_operator_764_comment =
    "C++ Interface:\n"
    "__irshift__(non-const SparseArray this, int shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::operator >>=\n"
    "//       Access: Published\n"
    "//  Description: Logical right shift.  The rightmost bits become\n"
    "//               negative, but are not lost; they will reappear into\n"
    "//               the zero position if the array is later left-shifted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_operator_764_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SparseArray::is_inverse(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_is_inverse_765(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SparseArray::is_inverse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isInverse", key_word_list));
        else
            (PyArg_Parse(args, ":isInverse"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SparseArray*)local_this)->is_inverse();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isInverse(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_is_inverse_765_comment =
    "C++ Interface:\n"
    "isInverse(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::is_inverse\n"
    "//       Access: Published\n"
    "//  Description: If this is true, the SparseArray is actually defined\n"
    "//               as a list of subranges of integers that are *not* in\n"
    "//               the set.  If this is false (the default), then the\n"
    "//               subranges define the integers that *are* in the set.\n"
    "//               This affects the interpretation of the values\n"
    "//               returned by iterating through get_num_subranges().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_is_inverse_765_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SparseArray::get_num_subranges(void) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_num_subranges_766(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SparseArray::get_num_subranges(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSubranges", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSubranges"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_num_subranges();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSubranges(const SparseArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_num_subranges_766_comment =
    "C++ Interface:\n"
    "getNumSubranges(const SparseArray this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_num_subranges\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of separate subranges stored in\n"
    "//               the SparseArray.  You can use this limit to iterate\n"
    "//               through the subranges, calling get_subrange_begin()\n"
    "//               and get_subrange_end() for each one.\n"
    "//\n"
    "//               Also see is_inverse().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_num_subranges_766_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SparseArray::get_subrange_begin(int n) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_subrange_begin_767(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SparseArray::get_subrange_begin(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubrangeBegin", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubrangeBegin", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_subrange_begin((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubrangeBegin(const SparseArray this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_subrange_begin_767_comment =
    "C++ Interface:\n"
    "getSubrangeBegin(const SparseArray this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_subrange_begin\n"
    "//       Access: Published\n"
    "//  Description: Returns the first numeric element in the nth\n"
    "//               subrange.\n"
    "//\n"
    "//               Also see is_inverse().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_subrange_begin_767_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SparseArray::get_subrange_end(int n) const
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_subrange_end_768(PyObject *self, PyObject *args,PyObject *kwds) {
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SparseArray::get_subrange_end(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubrangeEnd", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubrangeEnd", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SparseArray*)local_this)->get_subrange_end((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubrangeEnd(const SparseArray this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_subrange_end_768_comment =
    "C++ Interface:\n"
    "getSubrangeEnd(const SparseArray this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SparseArray::get_subrange_end\n"
    "//       Access: Published\n"
    "//  Description: Returns the last numeric element, plus one, in the\n"
    "//               nth subrange.\n"
    "//\n"
    "//               Also see is_inverse().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparseArray_get_subrange_end_768_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SparseArray::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SparseArray_get_class_type_769(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SparseArray::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SparseArray::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparseArray_get_class_type_769_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SparseArray_get_class_type_769_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparseArray::SparseArray(void)
 * SparseArray::SparseArray(BitArray const &from)
 * inline SparseArray::SparseArray(SparseArray const &copy)
 *******************************************************************/
int  Dtool_Init_SparseArray(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline SparseArray::SparseArray(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SparseArray", key_word_list))
            {
                SparseArray *return_value = new SparseArray();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_SparseArray,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline SparseArray::SparseArray(SparseArray const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SparseArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SparseArray", &param0));
                if(!PyErr_Occurred())
                {
                    SparseArray *param0_this = (SparseArray *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SparseArray, 0, "SparseArray.SparseArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        SparseArray *return_value = new SparseArray(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SparseArray,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 SparseArray::SparseArray(BitArray const &from)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"from", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SparseArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SparseArray", &param0));
                if(!PyErr_Occurred())
                {
                    BitArray *param0_this = (BitArray *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_BitArray, 0, "SparseArray.SparseArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        SparseArray *return_value = new SparseArray(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SparseArray,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SparseArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SparseArray()\n"
          "SparseArray(const SparseArray copy)\n"
          "SparseArray(const BitArray from)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SparseArray(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SparseArray)
    {
        printf("SparseArray ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SparseArray * local_this = (SparseArray *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SparseArray)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SparseArray(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SparseArray)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PythonCallbackObject 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PythonCallbackObject::set_function(PyObject *function)
 *******************************************************************/
static PyObject *Dtool_PythonCallbackObject_set_function_775(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonCallbackObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonCallbackObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PythonCallbackObject::set_function(PyObject *function)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"function", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFunction", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFunction", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_function(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonCallbackObject.setFunction() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFunction(non-const PythonCallbackObject this, any function)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonCallbackObject_set_function_775_comment =
    "C++ Interface:\n"
    "setFunction(non-const PythonCallbackObject this, any function)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonCallbackObject::set_function\n"
    "//       Access: Published\n"
    "//  Description: Replaces the function that is called for the callback.\n"
    "//               runs.  The parameter should be a Python callable\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonCallbackObject_set_function_775_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonCallbackObject::get_function(void)
 *******************************************************************/
static PyObject *Dtool_PythonCallbackObject_get_function_776(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonCallbackObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonCallbackObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *PythonCallbackObject::get_function(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFunction", key_word_list));
        else
            (PyArg_Parse(args, ":getFunction"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = (local_this)->get_function();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonCallbackObject.getFunction() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFunction(non-const PythonCallbackObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonCallbackObject_get_function_776_comment =
    "C++ Interface:\n"
    "getFunction(non-const PythonCallbackObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonCallbackObject::get_function\n"
    "//       Access: Published\n"
    "//  Description: Returns the function that is called for the callback.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonCallbackObject_get_function_776_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PythonCallbackObject::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PythonCallbackObject_get_class_type_777(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PythonCallbackObject::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PythonCallbackObject::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonCallbackObject_get_class_type_777_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PythonCallbackObject_get_class_type_777_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PythonCallbackObject::PythonCallbackObject(PyObject *function)
 * PythonCallbackObject::PythonCallbackObject(PyObject *function = (Py_None))
 *******************************************************************/
int  Dtool_Init_PythonCallbackObject(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function = (Py_None))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PythonCallbackObject", key_word_list))
            {
                PythonCallbackObject *return_value = new PythonCallbackObject();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PythonCallbackObject,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"function", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:PythonCallbackObject", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:PythonCallbackObject", &param0));
            if(!PyErr_Occurred())
            {
                PythonCallbackObject *return_value = new PythonCallbackObject(param0);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PythonCallbackObject,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PythonCallbackObject() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PythonCallbackObject()\n"
          "PythonCallbackObject(any function)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PythonCallbackObject(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PythonCallbackObject)
    {
        printf("PythonCallbackObject ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PythonCallbackObject * local_this = (PythonCallbackObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PythonCallbackObject)
        return local_this;
    if(requested_type == &Dtool_CallbackObject)
        return ( CallbackObject *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CallbackObject *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CallbackObject *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CallbackObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PythonCallbackObject(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PythonCallbackObject)
        return from_this;
    if(from_type == &Dtool_CallbackObject)
    {
          CallbackObject* other_this = (CallbackObject*)from_this;
          return (PythonCallbackObject*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PythonCallbackObject*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PythonCallbackObject*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (PythonCallbackObject*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WritableConfigurable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle WritableConfigurable::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_WritableConfigurable_get_class_type_779(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle WritableConfigurable::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = WritableConfigurable::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WritableConfigurable_get_class_type_779_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_WritableConfigurable_get_class_type_779_comment = NULL;
#endif

int  Dtool_Init_WritableConfigurable(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (WritableConfigurable)");
       return -1;
}
inline void  * Dtool_UpcastInterface_WritableConfigurable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WritableConfigurable)
    {
        printf("WritableConfigurable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WritableConfigurable * local_this = (WritableConfigurable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WritableConfigurable)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WritableConfigurable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WritableConfigurable)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (WritableConfigurable*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (WritableConfigurable*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. UniqueIdAllocator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * unsigned int UniqueIdAllocator::allocate(void)
 *******************************************************************/
static PyObject *Dtool_UniqueIdAllocator_allocate_784(PyObject *self, PyObject *args,PyObject *kwds) {
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int UniqueIdAllocator::allocate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":allocate", key_word_list));
        else
            (PyArg_Parse(args, ":allocate"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->allocate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UniqueIdAllocator.allocate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allocate(non-const UniqueIdAllocator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UniqueIdAllocator_allocate_784_comment =
    "C++ Interface:\n"
    "allocate(non-const UniqueIdAllocator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UniqueIdAllocator::allocate\n"
    "//       Access: Published\n"
    "//  Description: Returns an id between _min and _max (that were passed\n"
    "//               to the constructor).\n"
    "//               IndexEnd is returned if no ids are available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UniqueIdAllocator_allocate_784_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void UniqueIdAllocator::initial_reserve_id(unsigned int id)
 *******************************************************************/
static PyObject *Dtool_UniqueIdAllocator_initial_reserve_id_785(PyObject *self, PyObject *args,PyObject *kwds) {
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void UniqueIdAllocator::initial_reserve_id(unsigned int id)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:initialReserveId", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:initialReserveId", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->initial_reserve_id(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UniqueIdAllocator.initialReserveId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initialReserveId(non-const UniqueIdAllocator this, unsigned int id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UniqueIdAllocator_initial_reserve_id_785_comment =
    "C++ Interface:\n"
    "initialReserveId(non-const UniqueIdAllocator this, unsigned int id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UniqueIdAllocator::initial_reserve_id\n"
    "//       Access: Published\n"
    "//  Description: This may be called to mark a particular id as having\n"
    "//               already been allocated (for instance, by a prior\n"
    "//               pass).  The specified id is removed from the\n"
    "//               available pool.\n"
    "//\n"
    "//               Because of the limitations of this algorithm, this is\n"
    "//               most efficient when it is called before the first\n"
    "//               call to allocate(), and when all the calls to\n"
    "//               initial_reserve_id() are made in descending order by\n"
    "//               id.  However, this is a performance warning only; if\n"
    "//               performance is not an issue, any id may be reserved\n"
    "//               at any time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UniqueIdAllocator_initial_reserve_id_785_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void UniqueIdAllocator::free(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_UniqueIdAllocator_free_786(PyObject *self, PyObject *args,PyObject *kwds) {
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void UniqueIdAllocator::free(unsigned int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:free", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:free", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->free(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UniqueIdAllocator.free() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "free(non-const UniqueIdAllocator this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UniqueIdAllocator_free_786_comment =
    "C++ Interface:\n"
    "free(non-const UniqueIdAllocator this, unsigned int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UniqueIdAllocator::free\n"
    "//       Access: Published\n"
    "//  Description: Free an allocated index (index must be between _min\n"
    "//               and _max that were passed to the constructor).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UniqueIdAllocator_free_786_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float UniqueIdAllocator::fraction_used(void) const
 *******************************************************************/
static PyObject *Dtool_UniqueIdAllocator_fraction_used_787(PyObject *self, PyObject *args,PyObject *kwds) {
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float UniqueIdAllocator::fraction_used(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":fractionUsed", key_word_list));
        else
            (PyArg_Parse(args, ":fractionUsed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const UniqueIdAllocator*)local_this)->fraction_used();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fractionUsed(const UniqueIdAllocator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UniqueIdAllocator_fraction_used_787_comment =
    "C++ Interface:\n"
    "fractionUsed(const UniqueIdAllocator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UniqueIdAllocator::fraction_used\n"
    "//       Access: Published\n"
    "//  Description: return the decimal fraction of the pool that is used.\n"
    "//               The range is 0 to 1.0 (e.g. 75% would be 0.75).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UniqueIdAllocator_fraction_used_787_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void UniqueIdAllocator::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_UniqueIdAllocator_output_788(PyObject *self, PyObject *args,PyObject *kwds) {
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void UniqueIdAllocator::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "UniqueIdAllocator.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const UniqueIdAllocator*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const UniqueIdAllocator this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UniqueIdAllocator_output_788_comment =
    "C++ Interface:\n"
    "output(const UniqueIdAllocator this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UniqueIdAllocator::output\n"
    "//       Access: Published\n"
    "//  Description: ...intended for debugging only.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UniqueIdAllocator_output_788_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void UniqueIdAllocator::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_UniqueIdAllocator_write_789(PyObject *self, PyObject *args,PyObject *kwds) {
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void UniqueIdAllocator::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "UniqueIdAllocator.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const UniqueIdAllocator*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const UniqueIdAllocator this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UniqueIdAllocator_write_789_comment =
    "C++ Interface:\n"
    "write(const UniqueIdAllocator this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UniqueIdAllocator::write\n"
    "//       Access: Published\n"
    "//  Description: ...intended for debugging only.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UniqueIdAllocator_write_789_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * UniqueIdAllocator::UniqueIdAllocator(unsigned int min, unsigned int max)
 * UniqueIdAllocator::UniqueIdAllocator(unsigned int min, unsigned int max = (20))
 * UniqueIdAllocator::UniqueIdAllocator(unsigned int min = (0), unsigned int max = (20))
 *******************************************************************/
int  Dtool_Init_UniqueIdAllocator(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-UniqueIdAllocator::UniqueIdAllocator(unsigned int min = (0), unsigned int max = (20))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":UniqueIdAllocator", key_word_list))
            {
                UniqueIdAllocator *return_value = new UniqueIdAllocator();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_UniqueIdAllocator,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-UniqueIdAllocator::UniqueIdAllocator(unsigned int min, unsigned int max = (20))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"min", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:UniqueIdAllocator", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:UniqueIdAllocator", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    UniqueIdAllocator *return_value = new UniqueIdAllocator(PyLong_AsUnsignedLong(param0_uint));
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_UniqueIdAllocator,true,false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-UniqueIdAllocator::UniqueIdAllocator(unsigned int min, unsigned int max)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"min", (char *)"max", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:UniqueIdAllocator", key_word_list, &param0, &param1))
            {
                 PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param0_uint == NULL)|| (param1_uint == NULL)))
                {
                    UniqueIdAllocator *return_value = new UniqueIdAllocator(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param0_uint); Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_UniqueIdAllocator,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "UniqueIdAllocator() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "UniqueIdAllocator()\n"
          "UniqueIdAllocator(unsigned int min)\n"
          "UniqueIdAllocator(unsigned int min, unsigned int max)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_UniqueIdAllocator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_UniqueIdAllocator)
    {
        printf("UniqueIdAllocator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    UniqueIdAllocator * local_this = (UniqueIdAllocator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_UniqueIdAllocator)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_UniqueIdAllocator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_UniqueIdAllocator)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_double | CPTADouble
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_double[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_double_size_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_size_9_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_double_get_element_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_get_element_10_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_double_getitem_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_getitem_11_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_double_get_data_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_get_data_12_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_double_get_subdata_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_get_subdata_13_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_double_get_ref_count_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_get_ref_count_14_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_double_get_node_ref_count_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_double_get_node_ref_count_15_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_double ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_double_size_9size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_double_size_9(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_double ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_double_getitem_11Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_double_getitem_11(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_double(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_double._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_double.As_PyTypeObject());
        Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_double_size_9size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_double_getitem_11Getitem;
        if(PyType_Ready(&Dtool_ConstPointerToArray_double.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_double)");
             printf(" Error In PyType_ReadyConstPointerToArray_double");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_double.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_double.As_PyTypeObject().tp_dict,"CPTADouble",&Dtool_ConstPointerToArray_double.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_double,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_double.As_PyTypeObject());
        PyModule_AddObject(module, "CPTADouble",(PyObject *)&Dtool_ConstPointerToArray_double.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_double | PointerToArrayBaseDouble
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_double[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_double(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_double._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_double.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject());
        Dtool_PointerToArrayBase_double.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_double.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_double.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_double.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_double)");
             printf(" Error In PyType_ReadyPointerToArrayBase_double");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_double.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_double.As_PyTypeObject().tp_dict,"PointerToArrayBaseDouble",&Dtool_PointerToArrayBase_double.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_double,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_double.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseDouble",(PyObject *)&Dtool_PointerToArrayBase_double.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_double | PointerToBaseReferenceCountedVectorDouble
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_double[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_double_clear_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_double_clear_5_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_double_output_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_double_output_6_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_double
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_double(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< double > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_double,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_double;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_double;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_double)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_double");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorDouble",&Dtool_PointerToBase_ReferenceCountedVector_double.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_double,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorDouble",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_double.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_unsigned_short_int | CPTAUshort
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_unsigned_short_int[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_size_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_size_24_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_get_element_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_get_element_25_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_getitem_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_getitem_26_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_get_data_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_get_data_27_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_get_subdata_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_get_subdata_28_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_get_ref_count_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_get_ref_count_29_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_short_int_get_node_ref_count_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_short_int_get_node_ref_count_30_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_unsigned_short_int ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_unsigned_short_int_size_24size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_unsigned_short_int_size_24(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_unsigned_short_int ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_unsigned_short_int_getitem_26Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_unsigned_short_int_getitem_26(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_short_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_unsigned_short_int._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject());
        Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_unsigned_short_int_size_24size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_unsigned_short_int_getitem_26Getitem;
        if(PyType_Ready(&Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_unsigned_short_int)");
             printf(" Error In PyType_ReadyConstPointerToArray_unsigned_short_int");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict,"CPTAUshort",&Dtool_ConstPointerToArray_unsigned_short_int.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_unsigned_short_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject());
        PyModule_AddObject(module, "CPTAUshort",(PyObject *)&Dtool_ConstPointerToArray_unsigned_short_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_unsigned_short_int | PointerToArrayBaseUnsignedShortInt
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_unsigned_short_int[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_short_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject());
        Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_unsigned_short_int)");
             printf(" Error In PyType_ReadyPointerToArrayBase_unsigned_short_int");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject().tp_dict,"PointerToArrayBaseUnsignedShortInt",&Dtool_PointerToArrayBase_unsigned_short_int.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_unsigned_short_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseUnsignedShortInt",(PyObject *)&Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_unsigned_short_int | PointerToBaseReferenceCountedVectorUnsignedShortInt
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_unsigned_short_int[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_clear_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_clear_20_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_output_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int_output_21_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_unsigned_short_int
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_short_int(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< unsigned short int > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_short_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_short_int;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_short_int;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_unsigned_short_int)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_unsigned_short_int");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorUnsignedShortInt",&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnsignedShortInt",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_short_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DoubleBitMask_BitMask_unsigned_int_32 | DoubleBitMaskNative
//********************************************************************
PyMethodDef Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[]= {
  { "assign",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_34_comment},
  { "allOn",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_on_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_on_35_comment},
  { "allOff",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_off_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_all_off_36_comment},
  { "lowerOn",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_lower_on_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_lower_on_37_comment},
  { "bit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_bit_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_bit_38_comment},
  { "range",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_range_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_range_39_comment},
  { "hasMaxNumBits",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_41_comment},
  { "getMaxNumBits",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_42_comment},
  { "getNumBits",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_43_comment},
  { "getBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_bit_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_bit_44_comment},
  { "setBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_45_comment},
  { "clearBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_46_comment},
  { "setBitTo",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_47_comment},
  { "isZero",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_zero_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_zero_48_comment},
  { "isAllOn",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_49_comment},
  { "extract",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_extract_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_extract_50_comment},
  { "store",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_store_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_store_51_comment},
  { "hasAnyOf",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_52_comment},
  { "hasAllOf",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_53_comment},
  { "setRange",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_54_comment},
  { "clearRange",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_range_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_range_55_comment},
  { "setRangeTo",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_56_comment},
  { "getNumOnBits",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_57_comment},
  { "getNumOffBits",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_58_comment},
  { "getLowestOnBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_59_comment},
  { "getLowestOffBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_60_comment},
  { "getHighestOnBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_61_comment},
  { "getHighestOffBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_62_comment},
  { "getNextHigherDifferentBit",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_63_comment},
  { "invertInPlace",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_64_comment},
  { "hasBitsInCommon",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_65_comment},
  { "clear",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_clear_66_comment},
  { "output",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_67_comment},
  { "outputBinary",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_binary_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_binary_68_comment},
  { "outputHex",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_hex_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_output_hex_69_comment},
  { "write",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_write_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_write_70_comment},
  { "eq",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_71_comment},
  { "ne",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_72_comment},
  { "lessThan",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_73_comment},
  { "compareTo",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_compare_to_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_compare_to_74_comment},
  { "__and__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75_comment},
  { "__or__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76_comment},
  { "__xor__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77_comment},
  { "__invert__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78_comment},
  { "__lshift__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79_comment},
  { "__rshift__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80_comment},
  { "__iand__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81_comment},
  { "__ior__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_82_comment},
  { "__ixor__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83_comment},
  { "__ilshift__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84_comment},
  { "__irshift__",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85_comment},
  { "getClassType",(PyCFunction ) &Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_86_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_lshift = __ilshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84__ilshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_lshift = __lshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79__lshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_rshift = __rshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80__rshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_xor = __ixor__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83__ixor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_xor = __xor__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77__xor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_rshift = __irshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85__irshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     DoubleBitMask_BitMask_unsigned_int_32
//////////////////
static PyObject *  Dtool_Repr_DoubleBitMask_BitMask_unsigned_int_32(PyObject * self)
{
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DoubleBitMask_BitMask_unsigned_int_32
//////////////////
static PyObject *  Dtool_Str_DoubleBitMask_BitMask_unsigned_int_32(PyObject * self)
{
    DoubleBitMask< BitMask< unsigned int, 32 > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DoubleBitMask_BitMask_unsigned_int_32(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_inplace_lshift = __ilshift__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_lshift = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_84__ilshift__;
        // tp_as_number->nb_invert = __invert__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_78__invert__;
        // tp_as_number->nb_and = __and__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_and = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_75__and__;
        // tp_as_number->nb_or = __or__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_or = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_76__or__;
        // tp_as_number->nb_lshift = __lshift__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_lshift = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_79__lshift__;
        // tp_as_number->nb_rshift = __rshift__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_rshift = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_80__rshift__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_81__iand__;
        // tp_as_number->nb_inplace_xor = __ixor__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_xor = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_83__ixor__;
        // tp_as_number->nb_xor = __xor__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_xor = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_77__xor__;
        // tp_as_number->nb_inplace_rshift = __irshift__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_rshift = &Dtool_DoubleBitMask_BitMask_unsigned_int_32_operator_85__irshift__;
        // __repr__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_repr = & Dtool_Repr_DoubleBitMask_BitMask_unsigned_int_32;
        // __str__
        Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_str = & Dtool_Str_DoubleBitMask_BitMask_unsigned_int_32;
        if(PyType_Ready(&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DoubleBitMask_BitMask_unsigned_int_32)");
             printf(" Error In PyType_ReadyDoubleBitMask_BitMask_unsigned_int_32");
             return;
        }
        Py_INCREF(&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"DoubleBitMaskNative",&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject());
        //  Static Method allOn
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"allOn",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[1],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method allOff
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"allOff",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[2],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method lowerOn
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"lowerOn",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[3],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method bit
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"bit",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[4],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method range
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"range",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[5],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method hasMaxNumBits
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"hasMaxNumBits",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[6],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getMaxNumBits
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getMaxNumBits",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[7],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getNumBits
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getNumBits",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[8],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DoubleBitMask_BitMask_unsigned_int_32[51],&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DoubleBitMask_BitMask_unsigned_int_32,DoubleBitMask< BitMask< unsigned int, 32 > >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject());
        PyModule_AddObject(module, "DoubleBitMaskNative",(PyObject *)&Dtool_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 | QuadBitMaskNative
//********************************************************************
PyMethodDef Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[]= {
  { "assign",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_89_comment},
  { "allOn",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_on_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_on_90_comment},
  { "allOff",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_off_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_all_off_91_comment},
  { "lowerOn",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_lower_on_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_lower_on_92_comment},
  { "bit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_bit_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_bit_93_comment},
  { "range",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_range_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_range_94_comment},
  { "hasMaxNumBits",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_max_num_bits_96_comment},
  { "getMaxNumBits",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_max_num_bits_97_comment},
  { "getNumBits",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_bits_98_comment},
  { "getBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_bit_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_bit_99_comment},
  { "setBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_100_comment},
  { "clearBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_bit_101_comment},
  { "setBitTo",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_bit_to_102_comment},
  { "isZero",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_zero_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_zero_103_comment},
  { "isAllOn",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_is_all_on_104_comment},
  { "extract",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_extract_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_extract_105_comment},
  { "store",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_store_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_store_106_comment},
  { "hasAnyOf",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_any_of_107_comment},
  { "hasAllOf",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_all_of_108_comment},
  { "setRange",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_109_comment},
  { "clearRange",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_range_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_range_110_comment},
  { "setRangeTo",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_set_range_to_111_comment},
  { "getNumOnBits",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_on_bits_112_comment},
  { "getNumOffBits",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_num_off_bits_113_comment},
  { "getLowestOnBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_on_bit_114_comment},
  { "getLowestOffBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_lowest_off_bit_115_comment},
  { "getHighestOnBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_on_bit_116_comment},
  { "getHighestOffBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_highest_off_bit_117_comment},
  { "getNextHigherDifferentBit",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_next_higher_different_bit_118_comment},
  { "invertInPlace",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_invert_in_place_119_comment},
  { "hasBitsInCommon",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_has_bits_in_common_120_comment},
  { "clear",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_clear_121_comment},
  { "output",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_122_comment},
  { "outputBinary",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_binary_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_binary_123_comment},
  { "outputHex",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_hex_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_output_hex_124_comment},
  { "write",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_write_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_write_125_comment},
  { "eq",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_126_comment},
  { "ne",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_127_comment},
  { "lessThan",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_128_comment},
  { "compareTo",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_compare_to_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_compare_to_129_comment},
  { "__and__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130_comment},
  { "__or__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131_comment},
  { "__xor__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132_comment},
  { "__invert__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133_comment},
  { "__lshift__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134_comment},
  { "__rshift__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135_comment},
  { "__iand__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136_comment},
  { "__ior__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_137_comment},
  { "__ixor__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138_comment},
  { "__ilshift__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139_comment},
  { "__irshift__",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140_comment},
  { "getClassType",(PyCFunction ) &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_get_class_type_141_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_rshift = __rshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135__rshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_rshift = __irshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140__irshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_lshift = __lshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134__lshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_xor = __ixor__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138__ixor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_lshift = __ilshift__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139__ilshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32 ...tp_as_number->nb_xor = __xor__
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132__xor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32
//////////////////
static PyObject *  Dtool_Repr_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(PyObject * self)
{
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32
//////////////////
static PyObject *  Dtool_Str_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(PyObject * self)
{
    DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_and = __and__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_and = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_130__and__;
        // tp_as_number->nb_or = __or__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_or = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_131__or__;
        // tp_as_number->nb_rshift = __rshift__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_rshift = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_135__rshift__;
        // tp_as_number->nb_inplace_rshift = __irshift__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_rshift = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_140__irshift__;
        // tp_as_number->nb_lshift = __lshift__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_lshift = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_134__lshift__;
        // tp_as_number->nb_invert = __invert__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_133__invert__;
        // tp_as_number->nb_inplace_xor = __ixor__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_xor = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_138__ixor__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_136__iand__;
        // tp_as_number->nb_inplace_lshift = __ilshift__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_lshift = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_139__ilshift__;
        // tp_as_number->nb_xor = __xor__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_xor = &Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32_operator_132__xor__;
        // __repr__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_repr = & Dtool_Repr_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32;
        // __str__
        Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_str = & Dtool_Str_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32;
        if(PyType_Ready(&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32)");
             printf(" Error In PyType_ReadyDoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32");
             return;
        }
        Py_INCREF(&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"QuadBitMaskNative",&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject());
        //  Static Method allOn
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"allOn",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[1],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method allOff
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"allOff",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[2],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method lowerOn
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"lowerOn",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[3],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method bit
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"bit",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[4],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method range
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"range",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[5],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method hasMaxNumBits
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"hasMaxNumBits",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[6],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getMaxNumBits
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getMaxNumBits",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[7],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getNumBits
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getNumBits",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[8],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32[51],&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32,DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject());
        PyModule_AddObject(module, "QuadBitMaskNative",(PyObject *)&Dtool_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_double | PTADouble
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_double[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_double_empty_array_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_empty_array_144_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_double_size_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_size_145_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_double_push_back_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_push_back_146_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_double_pop_back_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_pop_back_147_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_double_get_element_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_get_element_148_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_double_set_element_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_set_element_149_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_double_getitem_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_getitem_150_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_double_setitem_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_setitem_151_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_double_get_data_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_get_data_152_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_double_set_data_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_set_data_153_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_double_get_subdata_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_get_subdata_154_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_double_set_subdata_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_set_subdata_155_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_double_get_ref_count_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_get_ref_count_156_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_double_get_node_ref_count_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_double_get_node_ref_count_157_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_double ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_double_size_145size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_double_size_145(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_double ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_double_getitem_150Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_double_getitem_150(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_double ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_double_setitem_151Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_double_setitem_151(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

void   Dtool_PyModuleClassInit_PointerToArray_double(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_double._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_double.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_double.As_PyTypeObject());
        Dtool_PointerToArray_double.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_double.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_double.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_double.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_double_size_145size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_double.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_double_getitem_150Getitem;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_double.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_double_setitem_151Setitem;
        if(PyType_Ready(&Dtool_PointerToArray_double.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_double)");
             printf(" Error In PyType_ReadyPointerToArray_double");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_double.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_double.As_PyTypeObject().tp_dict,"PTADouble",&Dtool_PointerToArray_double.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_double.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_double[0],&Dtool_PointerToArray_double.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_double,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_double.As_PyTypeObject());
        PyModule_AddObject(module, "PTADouble",(PyObject *)&Dtool_PointerToArray_double.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_unsigned_short_int | PTAUshort
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_unsigned_short_int[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_empty_array_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_empty_array_161_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_size_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_size_162_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_push_back_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_push_back_163_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_pop_back_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_pop_back_164_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_get_element_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_get_element_165_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_set_element_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_set_element_166_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_getitem_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_getitem_167_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_setitem_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_setitem_168_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_get_data_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_get_data_169_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_set_data_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_set_data_170_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_get_subdata_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_get_subdata_171_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_set_subdata_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_set_subdata_172_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_get_ref_count_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_get_ref_count_173_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_unsigned_short_int_get_node_ref_count_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_short_int_get_node_ref_count_174_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_unsigned_short_int ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_unsigned_short_int_size_162size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_unsigned_short_int_size_162(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_unsigned_short_int ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_unsigned_short_int_setitem_168Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_unsigned_short_int_setitem_168(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_unsigned_short_int ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_unsigned_short_int_getitem_167Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_unsigned_short_int_getitem_167(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_PointerToArray_unsigned_short_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_unsigned_short_int._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_unsigned_short_int.As_PyTypeObject());
        Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_unsigned_short_int_size_162size;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_unsigned_short_int_setitem_168Setitem;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_unsigned_short_int_getitem_167Getitem;
        if(PyType_Ready(&Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_unsigned_short_int)");
             printf(" Error In PyType_ReadyPointerToArray_unsigned_short_int");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict,"PTAUshort",&Dtool_PointerToArray_unsigned_short_int.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_unsigned_short_int[0],&Dtool_PointerToArray_unsigned_short_int.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_unsigned_short_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject());
        PyModule_AddObject(module, "PTAUshort",(PyObject *)&Dtool_PointerToArray_unsigned_short_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. basic_string_char | CString
//********************************************************************
PyMethodDef Dtool_Methods_basic_string_char[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_basic_string_char(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_basic_string_char.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_basic_string_char.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_basic_string_char.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_basic_string_char.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_basic_string_char.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(basic_string_char)");
             printf(" Error In PyType_Readybasic_string_char");
             return;
        }
        Py_INCREF(&Dtool_basic_string_char.As_PyTypeObject());
        PyDict_SetItemString(Dtool_basic_string_char.As_PyTypeObject().tp_dict,"CString",&Dtool_basic_string_char.As_PyObject());
        RegisterRuntimeClass(&Dtool_basic_string_char,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_basic_string_char.As_PyTypeObject());
        PyModule_AddObject(module, "CString",(PyObject *)&Dtool_basic_string_char.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimInterface | AnimInterface
//********************************************************************
PyMethodDef Dtool_Methods_AnimInterface[]= {
  { "play",(PyCFunction ) &Dtool_AnimInterface_play_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_play_179_comment},
  { "loop",(PyCFunction ) &Dtool_AnimInterface_loop_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_loop_180_comment},
  { "pingpong",(PyCFunction ) &Dtool_AnimInterface_pingpong_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_pingpong_181_comment},
  { "stop",(PyCFunction ) &Dtool_AnimInterface_stop_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_stop_182_comment},
  { "pose",(PyCFunction ) &Dtool_AnimInterface_pose_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_pose_183_comment},
  { "setPlayRate",(PyCFunction ) &Dtool_AnimInterface_set_play_rate_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_set_play_rate_184_comment},
  { "getPlayRate",(PyCFunction ) &Dtool_AnimInterface_get_play_rate_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_play_rate_185_comment},
  { "getFrameRate",(PyCFunction ) &Dtool_AnimInterface_get_frame_rate_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_frame_rate_186_comment},
  { "getNumFrames",(PyCFunction ) &Dtool_AnimInterface_get_num_frames_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_num_frames_187_comment},
  { "getFrame",(PyCFunction ) &Dtool_AnimInterface_get_frame_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_frame_188_comment},
  { "getNextFrame",(PyCFunction ) &Dtool_AnimInterface_get_next_frame_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_next_frame_189_comment},
  { "getFrac",(PyCFunction ) &Dtool_AnimInterface_get_frac_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_frac_190_comment},
  { "getFullFrame",(PyCFunction ) &Dtool_AnimInterface_get_full_frame_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_full_frame_191_comment},
  { "getFullFframe",(PyCFunction ) &Dtool_AnimInterface_get_full_fframe_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_full_fframe_192_comment},
  { "isPlaying",(PyCFunction ) &Dtool_AnimInterface_is_playing_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_is_playing_193_comment},
  { "output",(PyCFunction ) &Dtool_AnimInterface_output_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_output_194_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimInterface_get_class_type_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimInterface_get_class_type_195_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AnimInterface
//////////////////
static PyObject *  Dtool_Repr_AnimInterface(PyObject * self)
{
    AnimInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimInterface,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AnimInterface(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimInterface.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimInterface\n"
          "// Description : This is the fundamental interface for things that\n"
          "//               have a play/loop/stop type interface for frame-based\n"
          "//               animation, such as animated characters.  This is the\n"
          "//               base class for AnimControl and other, similar\n"
          "//               classes.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_AnimInterface.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_AnimInterface.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimInterface.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimInterface.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AnimInterface.As_PyTypeObject().tp_repr = & Dtool_Repr_AnimInterface;
        // __str__ Repr Proxy
        Dtool_AnimInterface.As_PyTypeObject().tp_str = & Dtool_Repr_AnimInterface;
        if(PyType_Ready(&Dtool_AnimInterface.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimInterface)");
             printf(" Error In PyType_ReadyAnimInterface");
             return;
        }
        Py_INCREF(&Dtool_AnimInterface.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimInterface.As_PyTypeObject().tp_dict,"AnimInterface",&Dtool_AnimInterface.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimInterface.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimInterface[16],&Dtool_AnimInterface.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimInterface,AnimInterface::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimInterface.As_PyTypeObject());
        PyModule_AddObject(module, "AnimInterface",(PyObject *)&Dtool_AnimInterface.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. UpdateSeq | UpdateSeq
//********************************************************************
PyMethodDef Dtool_Methods_UpdateSeq[]= {
  { "initial",(PyCFunction ) &Dtool_UpdateSeq_initial_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_initial_198_comment},
  { "old",(PyCFunction ) &Dtool_UpdateSeq_old_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_old_199_comment},
  { "fresh",(PyCFunction ) &Dtool_UpdateSeq_fresh_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_fresh_200_comment},
  { "assign",(PyCFunction ) &Dtool_UpdateSeq_operator_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_201_comment},
  { "clear",(PyCFunction ) &Dtool_UpdateSeq_clear_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_clear_202_comment},
  { "isInitial",(PyCFunction ) &Dtool_UpdateSeq_is_initial_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_is_initial_203_comment},
  { "isOld",(PyCFunction ) &Dtool_UpdateSeq_is_old_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_is_old_204_comment},
  { "isFresh",(PyCFunction ) &Dtool_UpdateSeq_is_fresh_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_is_fresh_205_comment},
  { "isSpecial",(PyCFunction ) &Dtool_UpdateSeq_is_special_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_is_special_206_comment},
  { "eq",(PyCFunction ) &Dtool_UpdateSeq_operator_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_207_comment},
  { "ne",(PyCFunction ) &Dtool_UpdateSeq_operator_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_208_comment},
  { "lessThan",(PyCFunction ) &Dtool_UpdateSeq_operator_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_209_comment},
  { "lessThanOrEqual",(PyCFunction ) &Dtool_UpdateSeq_operator_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_210_comment},
  { "greaterThan",(PyCFunction ) &Dtool_UpdateSeq_operator_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_211_comment},
  { "greaterThanOrEqual",(PyCFunction ) &Dtool_UpdateSeq_operator_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_212_comment},
  { "increment",(PyCFunction ) &Dtool_UpdateSeq_operator_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_213_comment},
  { "increment",(PyCFunction ) &Dtool_UpdateSeq_operator_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_operator_214_comment},
  { "output",(PyCFunction ) &Dtool_UpdateSeq_output_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UpdateSeq_output_215_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     UpdateSeq
//////////////////
static PyObject *  Dtool_Repr_UpdateSeq(PyObject * self)
{
    UpdateSeq * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UpdateSeq,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_UpdateSeq(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_UpdateSeq.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : UpdateSeq\n"
          "// Description : This is a sequence number that increments\n"
          "//               monotonically.  It can be used to track cache\n"
          "//               updates, or serve as a kind of timestamp for any\n"
          "//               changing properties.\n"
          "//\n"
          "//               A special class is used instead of simply an int, so\n"
          "//               we can elegantly handle such things as wraparound and\n"
          "//               special cases.  There are two special cases.\n"
          "//               Firstly, a sequence number is 'initial' when it is\n"
          "//               first created.  This sequence is older than any other\n"
          "//               sequence number.  Secondly, a sequence number may be\n"
          "//               explicitly set to 'old'.  This is older than any\n"
          "//               other sequence number except 'initial'.  Finally, we\n"
          "//               have the explicit number 'fresh', which is newer\n"
          "//               than any other sequence number.  All other sequences\n"
          "//               are numeric and are monotonically increasing.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_UpdateSeq.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_UpdateSeq.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_UpdateSeq.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_UpdateSeq.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_UpdateSeq.As_PyTypeObject().tp_repr = & Dtool_Repr_UpdateSeq;
        // __str__ Repr Proxy
        Dtool_UpdateSeq.As_PyTypeObject().tp_str = & Dtool_Repr_UpdateSeq;
        if(PyType_Ready(&Dtool_UpdateSeq.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(UpdateSeq)");
             printf(" Error In PyType_ReadyUpdateSeq");
             return;
        }
        Py_INCREF(&Dtool_UpdateSeq.As_PyTypeObject());
        PyDict_SetItemString(Dtool_UpdateSeq.As_PyTypeObject().tp_dict,"UpdateSeq",&Dtool_UpdateSeq.As_PyObject());
        //  Static Method initial
        PyDict_SetItemString(Dtool_UpdateSeq.As_PyTypeObject().tp_dict,"initial",PyCFunction_New(&Dtool_Methods_UpdateSeq[0],&Dtool_UpdateSeq.As_PyObject()));
        //  Static Method old
        PyDict_SetItemString(Dtool_UpdateSeq.As_PyTypeObject().tp_dict,"old",PyCFunction_New(&Dtool_Methods_UpdateSeq[1],&Dtool_UpdateSeq.As_PyObject()));
        //  Static Method fresh
        PyDict_SetItemString(Dtool_UpdateSeq.As_PyTypeObject().tp_dict,"fresh",PyCFunction_New(&Dtool_Methods_UpdateSeq[2],&Dtool_UpdateSeq.As_PyObject()));
        RegisterRuntimeClass(&Dtool_UpdateSeq,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_UpdateSeq.As_PyTypeObject());
        PyModule_AddObject(module, "UpdateSeq",(PyObject *)&Dtool_UpdateSeq.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypedWritable | TypedWritable
//********************************************************************
PyMethodDef Dtool_Methods_TypedWritable[]= {
  { "markBamModified",(PyCFunction ) &Dtool_TypedWritable_mark_bam_modified_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_mark_bam_modified_219_comment},
  { "getBamModified",(PyCFunction ) &Dtool_TypedWritable_get_bam_modified_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_get_bam_modified_220_comment},
  { "__reduce__",(PyCFunction ) &Dtool_TypedWritable_reduce_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_reduce_221_comment},
  { "__reduce_persist__",(PyCFunction ) &Dtool_TypedWritable_reduce_persist_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_reduce_persist_222_comment},
  { "encodeToBamStream",(PyCFunction ) &Dtool_TypedWritable_encode_to_bam_stream_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_encode_to_bam_stream_223_comment},
  { "getClassType",(PyCFunction ) &Dtool_TypedWritable_get_class_type_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_get_class_type_225_comment},
  { "downcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritable_downcast_to_TypedWritableReferenceCount_230_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TypedWritable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypedWritable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypedWritable\n"
          "// Description : Base class for objects that can be written to and\n"
          "//               read from Bam files.\n"
          "//               \n"
          "//               See also TypedObject for detailed instructions.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_TypedWritable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_TypedWritable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypedWritable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypedWritable.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TypedWritable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypedWritable)");
             printf(" Error In PyType_ReadyTypedWritable");
             return;
        }
        Py_INCREF(&Dtool_TypedWritable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypedWritable.As_PyTypeObject().tp_dict,"TypedWritable",&Dtool_TypedWritable.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TypedWritable.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TypedWritable[5],&Dtool_TypedWritable.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypedWritable,TypedWritable::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypedWritable.As_PyTypeObject());
        PyModule_AddObject(module, "TypedWritable",(PyObject *)&Dtool_TypedWritable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypedWritableReferenceCount | TypedWritableReferenceCount
//********************************************************************
PyMethodDef Dtool_Methods_TypedWritableReferenceCount[]= {
  { "decodeFromBamStream",(PyCFunction ) &Dtool_TypedWritableReferenceCount_decode_from_bam_stream_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritableReferenceCount_decode_from_bam_stream_234_comment},
  { "getClassType",(PyCFunction ) &Dtool_TypedWritableReferenceCount_get_class_type_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritableReferenceCount_get_class_type_235_comment},
  { "upcastToTypedWritable",(PyCFunction ) &Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_229_comment},
  { "upcastToReferenceCount",(PyCFunction ) &Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_232_comment},
  { "downcastToBamCacheRecord",(PyCFunction ) &Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedWritableReferenceCount_downcast_to_BamCacheRecord_239_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TypedWritableReferenceCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypedWritableReferenceCount\n"
          "// Description : A base class for things which need to inherit from\n"
          "//               both TypedWritable and from ReferenceCount.  It's\n"
          "//               convenient to define this intermediate base class\n"
          "//               instead of multiply inheriting from the two classes\n"
          "//               each time they are needed, so that we can sensibly\n"
          "//               pass around pointers to things which are both\n"
          "//               TypedWritables and ReferenceCounters.\n"
          "//               \n"
          "//               See also TypedObject for detailed instructions.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritable._Dtool_ClassInit(NULL);
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritable.As_PyTypeObject(),&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TypedWritableReferenceCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypedWritableReferenceCount)");
             printf(" Error In PyType_ReadyTypedWritableReferenceCount");
             return;
        }
        Py_INCREF(&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_dict,"TypedWritableReferenceCount",&Dtool_TypedWritableReferenceCount.As_PyObject());
        //  Static Method decodeFromBamStream
        PyDict_SetItemString(Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_dict,"decodeFromBamStream",PyCFunction_New(&Dtool_Methods_TypedWritableReferenceCount[0],&Dtool_TypedWritableReferenceCount.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TypedWritableReferenceCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TypedWritableReferenceCount[1],&Dtool_TypedWritableReferenceCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypedWritableReferenceCount,TypedWritableReferenceCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        PyModule_AddObject(module, "TypedWritableReferenceCount",(PyObject *)&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BamCacheRecord | BamCacheRecord
//********************************************************************
PyMethodDef Dtool_Methods_BamCacheRecord[]= {
  { "makeCopy",(PyCFunction ) &Dtool_BamCacheRecord_make_copy_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_make_copy_244_comment},
  { "eq",(PyCFunction ) &Dtool_BamCacheRecord_operator_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_operator_245_comment},
  { "getSourcePathname",(PyCFunction ) &Dtool_BamCacheRecord_get_source_pathname_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_source_pathname_246_comment},
  { "getCacheFilename",(PyCFunction ) &Dtool_BamCacheRecord_get_cache_filename_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_cache_filename_247_comment},
  { "getRecordedTime",(PyCFunction ) &Dtool_BamCacheRecord_get_recorded_time_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_recorded_time_248_comment},
  { "getNumDependentFiles",(PyCFunction ) &Dtool_BamCacheRecord_get_num_dependent_files_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_num_dependent_files_249_comment},
  { "getDependentPathname",(PyCFunction ) &Dtool_BamCacheRecord_get_dependent_pathname_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_dependent_pathname_250_comment},
  { "dependentsUnchanged",(PyCFunction ) &Dtool_BamCacheRecord_dependents_unchanged_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_dependents_unchanged_251_comment},
  { "clearDependentFiles",(PyCFunction ) &Dtool_BamCacheRecord_clear_dependent_files_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_clear_dependent_files_252_comment},
  { "addDependentFile",(PyCFunction ) &Dtool_BamCacheRecord_add_dependent_file_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_add_dependent_file_253_comment},
  { "hasData",(PyCFunction ) &Dtool_BamCacheRecord_has_data_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_has_data_254_comment},
  { "clearData",(PyCFunction ) &Dtool_BamCacheRecord_clear_data_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_clear_data_255_comment},
  { "getData",(PyCFunction ) &Dtool_BamCacheRecord_get_data_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_data_256_comment},
  { "setData",(PyCFunction ) &Dtool_BamCacheRecord_set_data_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_set_data_258_comment},
  { "output",(PyCFunction ) &Dtool_BamCacheRecord_output_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_output_259_comment},
  { "write",(PyCFunction ) &Dtool_BamCacheRecord_write_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_write_260_comment},
  { "getClassType",(PyCFunction ) &Dtool_BamCacheRecord_get_class_type_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_get_class_type_261_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_238_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BamCacheRecord
//////////////////
static PyObject *  Dtool_Repr_BamCacheRecord(PyObject * self)
{
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BamCacheRecord
//////////////////
static PyObject *  Dtool_Str_BamCacheRecord(PyObject * self)
{
    BamCacheRecord * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BamCacheRecord,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BamCacheRecord(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BamCacheRecord.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BamCacheRecord\n"
          "// Description : An instance of this class is written to the front of\n"
          "//               a Bam or Txo file to make the file a cached instance\n"
          "//               of some other loadable resource.  This record\n"
          "//               contains information needed to test the validity of\n"
          "//               the cache.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BamCacheRecord.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_BamCacheRecord.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BamCacheRecord.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BamCacheRecord.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BamCacheRecord.As_PyTypeObject().tp_repr = & Dtool_Repr_BamCacheRecord;
        // __str__
        Dtool_BamCacheRecord.As_PyTypeObject().tp_str = & Dtool_Str_BamCacheRecord;
        if(PyType_Ready(&Dtool_BamCacheRecord.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BamCacheRecord)");
             printf(" Error In PyType_ReadyBamCacheRecord");
             return;
        }
        Py_INCREF(&Dtool_BamCacheRecord.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BamCacheRecord.As_PyTypeObject().tp_dict,"BamCacheRecord",&Dtool_BamCacheRecord.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BamCacheRecord.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BamCacheRecord[16],&Dtool_BamCacheRecord.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BamCacheRecord,BamCacheRecord::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BamCacheRecord.As_PyTypeObject());
        PyModule_AddObject(module, "BamCacheRecord",(PyObject *)&Dtool_BamCacheRecord.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BamCache | BamCache
//********************************************************************
PyMethodDef Dtool_Methods_BamCache[]= {
  { "setActive",(PyCFunction ) &Dtool_BamCache_set_active_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_active_265_comment},
  { "getActive",(PyCFunction ) &Dtool_BamCache_get_active_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_active_266_comment},
  { "setCacheModels",(PyCFunction ) &Dtool_BamCache_set_cache_models_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_cache_models_267_comment},
  { "getCacheModels",(PyCFunction ) &Dtool_BamCache_get_cache_models_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_cache_models_268_comment},
  { "setCacheTextures",(PyCFunction ) &Dtool_BamCache_set_cache_textures_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_cache_textures_269_comment},
  { "getCacheTextures",(PyCFunction ) &Dtool_BamCache_get_cache_textures_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_cache_textures_270_comment},
  { "setCacheCompressedTextures",(PyCFunction ) &Dtool_BamCache_set_cache_compressed_textures_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_cache_compressed_textures_271_comment},
  { "getCacheCompressedTextures",(PyCFunction ) &Dtool_BamCache_get_cache_compressed_textures_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_cache_compressed_textures_272_comment},
  { "setRoot",(PyCFunction ) &Dtool_BamCache_set_root_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_root_273_comment},
  { "getRoot",(PyCFunction ) &Dtool_BamCache_get_root_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_root_274_comment},
  { "setFlushTime",(PyCFunction ) &Dtool_BamCache_set_flush_time_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_flush_time_275_comment},
  { "getFlushTime",(PyCFunction ) &Dtool_BamCache_get_flush_time_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_flush_time_276_comment},
  { "setCacheMaxKbytes",(PyCFunction ) &Dtool_BamCache_set_cache_max_kbytes_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_cache_max_kbytes_277_comment},
  { "getCacheMaxKbytes",(PyCFunction ) &Dtool_BamCache_get_cache_max_kbytes_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_cache_max_kbytes_278_comment},
  { "setReadOnly",(PyCFunction ) &Dtool_BamCache_set_read_only_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_set_read_only_279_comment},
  { "getReadOnly",(PyCFunction ) &Dtool_BamCache_get_read_only_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_read_only_280_comment},
  { "lookup",(PyCFunction ) &Dtool_BamCache_lookup_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_lookup_281_comment},
  { "store",(PyCFunction ) &Dtool_BamCache_store_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_store_282_comment},
  { "considerFlushIndex",(PyCFunction ) &Dtool_BamCache_consider_flush_index_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_consider_flush_index_283_comment},
  { "flushIndex",(PyCFunction ) &Dtool_BamCache_flush_index_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_flush_index_284_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_BamCache_get_global_ptr_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamCache_get_global_ptr_285_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BamCache(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BamCache.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BamCache\n"
          "// Description : This class maintains a cache of Bam and/or Txo\n"
          "//               objects generated from model files and texture images\n"
          "//               (as well as possibly other kinds of loadable objects\n"
          "//               that can be stored in bam file format).\n"
          "//\n"
          "//               This class also maintains a persistent index that\n"
          "//               lists all of the cached objects (see BamCacheIndex).\n"
          "//               We go through some considerable effort to make sure\n"
          "//               this index gets saved correctly to disk, even in the\n"
          "//               presence of multiple different processes writing to\n"
          "//               the same index, and without relying too heavily on\n"
          "//               low-level os-provided file locks (which work poorly\n"
          "//               with C++ iostreams).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_BamCache.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_BamCache.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BamCache.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BamCache.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BamCache.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BamCache)");
             printf(" Error In PyType_ReadyBamCache");
             return;
        }
        Py_INCREF(&Dtool_BamCache.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BamCache.As_PyTypeObject().tp_dict,"BamCache",&Dtool_BamCache.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_BamCache.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_BamCache[20],&Dtool_BamCache.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BamCache,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BamCache.As_PyTypeObject());
        PyModule_AddObject(module, "BamCache",(PyObject *)&Dtool_BamCache.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BamEnums | BamEnums
//********************************************************************
PyMethodDef Dtool_Methods_BamEnums[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BamEnums(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BamEnums.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BamEnums\n"
          "// Description : This class exists just to provide scoping for the\n"
          "//               enums shared by BamReader and BamWriter.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_BamEnums.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_BamEnums.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BamEnums.As_PyTypeObject().tp_dict);
        // Enum  BamEnums::BamEndian;
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BEBigendian",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BELittleendian",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BENative",PyInt_FromLong(1));
        // Enum  BamEnums::BamObjectCode;
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BOCPush",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BOCPop",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BOCAdjunct",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BOCRemove",PyInt_FromLong(3));
        // Enum  BamEnums::BamTextureMode;
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BTMUnchanged",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BTMFullpath",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BTMRelative",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BTMBasename",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BTMRawdata",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_BamEnums.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BamEnums)");
             printf(" Error In PyType_ReadyBamEnums");
             return;
        }
        Py_INCREF(&Dtool_BamEnums.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BamEnums.As_PyTypeObject().tp_dict,"BamEnums",&Dtool_BamEnums.As_PyObject());
        RegisterRuntimeClass(&Dtool_BamEnums,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BamEnums.As_PyTypeObject());
        PyModule_AddObject(module, "BamEnums",(PyObject *)&Dtool_BamEnums.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LoaderOptions | LoaderOptions
//********************************************************************
PyMethodDef Dtool_Methods_LoaderOptions[]= {
  { "assign",(PyCFunction ) &Dtool_LoaderOptions_operator_295, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LoaderOptions_operator_295_comment},
  { "setFlags",(PyCFunction ) &Dtool_LoaderOptions_set_flags_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LoaderOptions_set_flags_296_comment},
  { "getFlags",(PyCFunction ) &Dtool_LoaderOptions_get_flags_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LoaderOptions_get_flags_297_comment},
  { "setTextureFlags",(PyCFunction ) &Dtool_LoaderOptions_set_texture_flags_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LoaderOptions_set_texture_flags_298_comment},
  { "getTextureFlags",(PyCFunction ) &Dtool_LoaderOptions_get_texture_flags_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LoaderOptions_get_texture_flags_299_comment},
  { "output",(PyCFunction ) &Dtool_LoaderOptions_output_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LoaderOptions_output_300_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     LoaderOptions
//////////////////
static PyObject *  Dtool_Repr_LoaderOptions(PyObject * self)
{
    LoaderOptions * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LoaderOptions,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_LoaderOptions(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LoaderOptions.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LoaderOptions\n"
          "// Description : Specifies parameters that may be passed to the\n"
          "//               loader.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_LoaderOptions.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_LoaderOptions.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LoaderOptions.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_LoaderOptions.As_PyTypeObject().tp_repr = & Dtool_Repr_LoaderOptions;
        // __str__ Repr Proxy
        Dtool_LoaderOptions.As_PyTypeObject().tp_str = & Dtool_Repr_LoaderOptions;
        // Enum  LoaderOptions::LoaderFlags;
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFSearch",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFReportErrors",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFConvertSkeleton",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFConvertChannels",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFConvertAnim",PyInt_FromLong(12));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFNoDiskCache",PyInt_FromLong(16));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFNoRamCache",PyInt_FromLong(32));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFNoCache",PyInt_FromLong(48));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFCacheOnly",PyInt_FromLong(64));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LFAllowInstance",PyInt_FromLong(128));
        // Enum  LoaderOptions::TextureFlags;
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"TFPreload",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"TFPreloadSimple",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"TFAllow1d",PyInt_FromLong(16));
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"TFGenerateMipmaps",PyInt_FromLong(32));
        if(PyType_Ready(&Dtool_LoaderOptions.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LoaderOptions)");
             printf(" Error In PyType_ReadyLoaderOptions");
             return;
        }
        Py_INCREF(&Dtool_LoaderOptions.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LoaderOptions.As_PyTypeObject().tp_dict,"LoaderOptions",&Dtool_LoaderOptions.As_PyObject());
        RegisterRuntimeClass(&Dtool_LoaderOptions,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LoaderOptions.As_PyTypeObject());
        PyModule_AddObject(module, "LoaderOptions",(PyObject *)&Dtool_LoaderOptions.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BamReader | BamReader
//********************************************************************
PyMethodDef Dtool_Methods_BamReader[]= {
  { "setSource",(PyCFunction ) &Dtool_BamReader_set_source_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_set_source_305_comment},
  { "init",(PyCFunction ) &Dtool_BamReader_init_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_init_306_comment},
  { "getFilename",(PyCFunction ) &Dtool_BamReader_get_filename_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_filename_309_comment},
  { "getLoaderOptions",(PyCFunction ) &Dtool_BamReader_get_loader_options_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_loader_options_310_comment},
  { "setLoaderOptions",(PyCFunction ) &Dtool_BamReader_set_loader_options_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_set_loader_options_311_comment},
  { "readObject",(PyCFunction ) &Dtool_BamReader_read_object_312, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_read_object_312_comment},
  { "isEof",(PyCFunction ) &Dtool_BamReader_is_eof_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_is_eof_313_comment},
  { "resolve",(PyCFunction ) &Dtool_BamReader_resolve_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_resolve_314_comment},
  { "changePointer",(PyCFunction ) &Dtool_BamReader_change_pointer_315, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_change_pointer_315_comment},
  { "getFileMajorVer",(PyCFunction ) &Dtool_BamReader_get_file_major_ver_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_file_major_ver_316_comment},
  { "getFileMinorVer",(PyCFunction ) &Dtool_BamReader_get_file_minor_ver_317, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_file_minor_ver_317_comment},
  { "getFileEndian",(PyCFunction ) &Dtool_BamReader_get_file_endian_318, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_file_endian_318_comment},
  { "getCurrentMajorVer",(PyCFunction ) &Dtool_BamReader_get_current_major_ver_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_current_major_ver_319_comment},
  { "getCurrentMinorVer",(PyCFunction ) &Dtool_BamReader_get_current_minor_ver_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamReader_get_current_minor_ver_320_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BamReader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BamReader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BamReader\n"
          "// Description : This is the fundamental interface for extracting\n"
          "//               binary objects from a Bam file, as generated by a\n"
          "//               BamWriter.\n"
          "//\n"
          "//               A Bam file can be thought of as a linear collection\n"
          "//               of objects.  Each object is an instance of a class\n"
          "//               that inherits, directly or indirectly, from\n"
          "//               TypedWritable.  The objects may include pointers to\n"
          "//               other objects within the Bam file; the BamReader\n"
          "//               automatically manages these (with help from code\n"
          "//               within each class) and restores the pointers\n"
          "//               correctly.\n"
          "//\n"
          "//               This is the abstract interface and does not\n"
          "//               specifically deal with disk files, but rather with a\n"
          "//               DatagramGenerator of some kind, which is simply a\n"
          "//               linear source of Datagrams.  It is probably from a\n"
          "//               disk file, but it might conceivably be streamed\n"
          "//               directly from a network or some such nonsense.\n"
          "//\n"
          "//               Bam files are most often used to store scene graphs\n"
          "//               or subgraphs, and by convention they are given\n"
          "//               filenames ending in the extension \".bam\" when they\n"
          "//               are used for this purpose.  However, a Bam file may\n"
          "//               store any arbitrary list of TypedWritable objects;\n"
          "//               in this more general usage, they are given filenames\n"
          "//               ending in \".boo\" to differentiate them from the more\n"
          "//               common scene graph files.\n"
          "//\n"
          "//               See also BamFile, which defines a higher-level\n"
          "//               interface to read and write Bam files on disk.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BamEnums._Dtool_ClassInit(NULL);
        Dtool_BamReader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BamEnums.As_PyTypeObject());
        Dtool_BamReader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BamReader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BamReader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BamReader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BamReader)");
             printf(" Error In PyType_ReadyBamReader");
             return;
        }
        Py_INCREF(&Dtool_BamReader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BamReader.As_PyTypeObject().tp_dict,"BamReader",&Dtool_BamReader.As_PyObject());
        RegisterRuntimeClass(&Dtool_BamReader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BamReader.As_PyTypeObject());
        PyModule_AddObject(module, "BamReader",(PyObject *)&Dtool_BamReader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BamWriter | BamWriter
//********************************************************************
PyMethodDef Dtool_Methods_BamWriter[]= {
  { "setTarget",(PyCFunction ) &Dtool_BamWriter_set_target_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_set_target_324_comment},
  { "init",(PyCFunction ) &Dtool_BamWriter_init_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_init_325_comment},
  { "getFilename",(PyCFunction ) &Dtool_BamWriter_get_filename_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_get_filename_326_comment},
  { "writeObject",(PyCFunction ) &Dtool_BamWriter_write_object_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_write_object_327_comment},
  { "hasObject",(PyCFunction ) &Dtool_BamWriter_has_object_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_has_object_328_comment},
  { "flush",(PyCFunction ) &Dtool_BamWriter_flush_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_flush_329_comment},
  { "getFileEndian",(PyCFunction ) &Dtool_BamWriter_get_file_endian_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_get_file_endian_330_comment},
  { "getFileTextureMode",(PyCFunction ) &Dtool_BamWriter_get_file_texture_mode_331, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_get_file_texture_mode_331_comment},
  { "setFileTextureMode",(PyCFunction ) &Dtool_BamWriter_set_file_texture_mode_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BamWriter_set_file_texture_mode_332_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BamWriter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BamWriter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BamWriter\n"
          "// Description : This is the fundamental interface for writing binary\n"
          "//               objects to a Bam file, to be extracted later by a\n"
          "//               BamReader.\n"
          "//\n"
          "//               A Bam file can be thought of as a linear collection\n"
          "//               of objects.  Each object is an instance of a class\n"
          "//               that inherits, directly or indirectly, from\n"
          "//               TypedWritable.  The objects may include pointers to\n"
          "//               other objects; the BamWriter automatically manages\n"
          "//               these (with help from code within each class) and\n"
          "//               writes all referenced objects to the file in such a\n"
          "//               way that the pointers may be correctly restored\n"
          "//               later.\n"
          "//\n"
          "//               This is the abstract interface and does not\n"
          "//               specifically deal with disk files, but rather with a\n"
          "//               DatagramSink of some kind, which simply accepts a\n"
          "//               linear stream of Datagrams.  It is probably written\n"
          "//               to a disk file, but it might conceivably be streamed\n"
          "//               directly to a network or some such nonsense.\n"
          "//\n"
          "//               Bam files are most often used to store scene graphs\n"
          "//               or subgraphs, and by convention they are given\n"
          "//               filenames ending in the extension \".bam\" when they\n"
          "//               are used for this purpose.  However, a Bam file may\n"
          "//               store any arbitrary list of TypedWritable objects;\n"
          "//               in this more general usage, they are given filenames\n"
          "//               ending in \".boo\" to differentiate them from the more\n"
          "//               common scene graph files.\n"
          "//\n"
          "//               See also BamFile, which defines a higher-level\n"
          "//               interface to read and write Bam files on disk.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BamEnums._Dtool_ClassInit(NULL);
        Dtool_BamWriter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BamEnums.As_PyTypeObject());
        Dtool_BamWriter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BamWriter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BamWriter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BamWriter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BamWriter)");
             printf(" Error In PyType_ReadyBamWriter");
             return;
        }
        Py_INCREF(&Dtool_BamWriter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BamWriter.As_PyTypeObject().tp_dict,"BamWriter",&Dtool_BamWriter.As_PyObject());
        RegisterRuntimeClass(&Dtool_BamWriter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BamWriter.As_PyTypeObject());
        PyModule_AddObject(module, "BamWriter",(PyObject *)&Dtool_BamWriter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BitMask_unsigned_int_32 | BitMask32
//********************************************************************
PyMethodDef Dtool_Methods_BitMask_unsigned_int_32[]= {
  { "assign",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_335_comment},
  { "allOn",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_all_on_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_all_on_336_comment},
  { "allOff",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_all_off_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_all_off_337_comment},
  { "lowerOn",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_lower_on_338, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_lower_on_338_comment},
  { "bit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_bit_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_bit_339_comment},
  { "range",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_range_340, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_range_340_comment},
  { "hasMaxNumBits",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_has_max_num_bits_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_has_max_num_bits_342_comment},
  { "getMaxNumBits",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_max_num_bits_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_max_num_bits_343_comment},
  { "getNumBits",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_num_bits_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_num_bits_344_comment},
  { "getBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_bit_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_bit_345_comment},
  { "setBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_set_bit_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_set_bit_346_comment},
  { "clearBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_clear_bit_347, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_clear_bit_347_comment},
  { "setBitTo",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_set_bit_to_348, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_set_bit_to_348_comment},
  { "isZero",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_is_zero_349, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_is_zero_349_comment},
  { "isAllOn",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_is_all_on_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_is_all_on_350_comment},
  { "extract",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_extract_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_extract_351_comment},
  { "store",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_store_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_store_352_comment},
  { "hasAnyOf",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_has_any_of_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_has_any_of_353_comment},
  { "hasAllOf",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_has_all_of_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_has_all_of_354_comment},
  { "setRange",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_set_range_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_set_range_355_comment},
  { "clearRange",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_clear_range_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_clear_range_356_comment},
  { "setRangeTo",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_set_range_to_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_set_range_to_357_comment},
  { "getWord",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_word_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_word_358_comment},
  { "setWord",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_set_word_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_set_word_359_comment},
  { "getNumOnBits",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_num_on_bits_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_num_on_bits_360_comment},
  { "getNumOffBits",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_num_off_bits_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_num_off_bits_361_comment},
  { "getLowestOnBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_lowest_on_bit_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_lowest_on_bit_362_comment},
  { "getLowestOffBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_lowest_off_bit_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_lowest_off_bit_363_comment},
  { "getHighestOnBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_highest_on_bit_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_highest_on_bit_364_comment},
  { "getHighestOffBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_highest_off_bit_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_highest_off_bit_365_comment},
  { "getNextHigherDifferentBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_next_higher_different_bit_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_next_higher_different_bit_366_comment},
  { "invertInPlace",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_invert_in_place_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_invert_in_place_367_comment},
  { "hasBitsInCommon",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_has_bits_in_common_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_has_bits_in_common_368_comment},
  { "clear",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_clear_369, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_clear_369_comment},
  { "output",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_output_370, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_output_370_comment},
  { "outputBinary",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_output_binary_371, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_output_binary_371_comment},
  { "outputHex",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_output_hex_372, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_output_hex_372_comment},
  { "write",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_write_373, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_write_373_comment},
  { "eq",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_374, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_374_comment},
  { "ne",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_375, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_375_comment},
  { "lessThan",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_376, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_376_comment},
  { "compareTo",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_compare_to_377, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_compare_to_377_comment},
  { "__and__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_378, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_378_comment},
  { "__or__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_379, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_379_comment},
  { "__xor__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_380, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_380_comment},
  { "__invert__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_381, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_381_comment},
  { "__lshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_382, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_382_comment},
  { "__rshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_383, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_383_comment},
  { "__iand__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_384, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_384_comment},
  { "__ior__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_385, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_385_comment},
  { "__ixor__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_386, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_386_comment},
  { "__ilshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_387, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_387_comment},
  { "__irshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_operator_388, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_operator_388_comment},
  { "floodDownInPlace",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_flood_down_in_place_389, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_flood_down_in_place_389_comment},
  { "floodUpInPlace",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_flood_up_in_place_390, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_flood_up_in_place_390_comment},
  { "floodBitsDown",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_flood_bits_down_391, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_flood_bits_down_391_comment},
  { "floodBitsUp",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_flood_bits_up_392, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_flood_bits_up_392_comment},
  { "keepNextHighestBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_keep_next_highest_bit_393, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_keep_next_highest_bit_393_comment},
  { "keepNextLowestBit",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_keep_next_lowest_bit_394, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_keep_next_lowest_bit_394_comment},
  { "getKey",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_key_395, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_key_395_comment},
  { "getClassType",(PyCFunction ) &Dtool_BitMask_unsigned_int_32_get_class_type_396, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int_32_get_class_type_396_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_378__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_378(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_379__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_379(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_rshift = __rshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_383__rshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_383(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_lshift = __ilshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_387__ilshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_387(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_xor = __xor__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_380__xor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_380(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_384__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_384(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_xor = __ixor__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_386__ixor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_386(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_inplace_rshift = __irshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_388__irshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_388(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_BitMask_unsigned_int_32_operator_381__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_381(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int_32 ...tp_as_number->nb_lshift = __lshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int_32_operator_382__lshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int_32_operator_382(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A LocalHash(getKey) Function for this type
//     BitMask_unsigned_int_32
//////////////////
static long  DTool_HashKey_BitMask_unsigned_int_32(PyObject * self)
{
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return -1;
    };
    return local_this->get_key();
}

//////////////////
//  A __repr__ Function
//     BitMask_unsigned_int_32
//////////////////
static PyObject *  Dtool_Repr_BitMask_unsigned_int_32(PyObject * self)
{
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BitMask_unsigned_int_32
//////////////////
static PyObject *  Dtool_Str_BitMask_unsigned_int_32(PyObject * self)
{
    BitMask< unsigned int, 32 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int_32,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BitMask_unsigned_int_32(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_and = __and__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_and = &Dtool_BitMask_unsigned_int_32_operator_378__and__;
        // tp_as_number->nb_or = __or__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_or = &Dtool_BitMask_unsigned_int_32_operator_379__or__;
        // tp_as_number->nb_rshift = __rshift__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_rshift = &Dtool_BitMask_unsigned_int_32_operator_383__rshift__;
        // tp_as_number->nb_inplace_lshift = __ilshift__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_lshift = &Dtool_BitMask_unsigned_int_32_operator_387__ilshift__;
        // tp_as_number->nb_xor = __xor__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_xor = &Dtool_BitMask_unsigned_int_32_operator_380__xor__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_BitMask_unsigned_int_32_operator_384__iand__;
        // tp_as_number->nb_inplace_xor = __ixor__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_xor = &Dtool_BitMask_unsigned_int_32_operator_386__ixor__;
        // tp_as_number->nb_inplace_rshift = __irshift__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_inplace_rshift = &Dtool_BitMask_unsigned_int_32_operator_388__irshift__;
        // tp_as_number->nb_invert = __invert__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_BitMask_unsigned_int_32_operator_381__invert__;
        // tp_as_number->nb_lshift = __lshift__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_as_number->nb_lshift = &Dtool_BitMask_unsigned_int_32_operator_382__lshift__;
        // __hash__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_hash = &DTool_HashKey_BitMask_unsigned_int_32;
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_compare = &DTOOL_PyObject_Compare;
        // __repr__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_repr = & Dtool_Repr_BitMask_unsigned_int_32;
        // __str__
        Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_str = & Dtool_Str_BitMask_unsigned_int_32;
        if(PyType_Ready(&Dtool_BitMask_unsigned_int_32.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BitMask_unsigned_int_32)");
             printf(" Error In PyType_ReadyBitMask_unsigned_int_32");
             return;
        }
        Py_INCREF(&Dtool_BitMask_unsigned_int_32.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"BitMask32",&Dtool_BitMask_unsigned_int_32.As_PyObject());
        //  Static Method allOn
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"allOn",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[1],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method allOff
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"allOff",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[2],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method lowerOn
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"lowerOn",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[3],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method bit
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"bit",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[4],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method range
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"range",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[5],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method hasMaxNumBits
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"hasMaxNumBits",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[6],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getMaxNumBits
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getMaxNumBits",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[7],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getNumBits
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getNumBits",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[8],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BitMask_unsigned_int_32.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int_32[60],&Dtool_BitMask_unsigned_int_32.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BitMask_unsigned_int_32,BitMask< unsigned int, 32 >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BitMask_unsigned_int_32.As_PyTypeObject());
        PyModule_AddObject(module, "BitMask32",(PyObject *)&Dtool_BitMask_unsigned_int_32.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BitMask_unsigned_int64_64 | BitMask64
//********************************************************************
PyMethodDef Dtool_Methods_BitMask_unsigned_int64_64[]= {
  { "assign",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_399, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_399_comment},
  { "allOn",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_all_on_400, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_all_on_400_comment},
  { "allOff",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_all_off_401, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_all_off_401_comment},
  { "lowerOn",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_lower_on_402, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_lower_on_402_comment},
  { "bit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_bit_403, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_bit_403_comment},
  { "range",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_range_404, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_range_404_comment},
  { "hasMaxNumBits",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_has_max_num_bits_406, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_has_max_num_bits_406_comment},
  { "getMaxNumBits",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_max_num_bits_407, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_max_num_bits_407_comment},
  { "getNumBits",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_num_bits_408, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_num_bits_408_comment},
  { "getBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_bit_409, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_bit_409_comment},
  { "setBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_set_bit_410, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_set_bit_410_comment},
  { "clearBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_clear_bit_411, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_clear_bit_411_comment},
  { "setBitTo",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_set_bit_to_412, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_set_bit_to_412_comment},
  { "isZero",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_is_zero_413, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_is_zero_413_comment},
  { "isAllOn",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_is_all_on_414, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_is_all_on_414_comment},
  { "extract",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_extract_415, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_extract_415_comment},
  { "store",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_store_416, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_store_416_comment},
  { "hasAnyOf",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_has_any_of_417, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_has_any_of_417_comment},
  { "hasAllOf",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_has_all_of_418, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_has_all_of_418_comment},
  { "setRange",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_set_range_419, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_set_range_419_comment},
  { "clearRange",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_clear_range_420, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_clear_range_420_comment},
  { "setRangeTo",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_set_range_to_421, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_set_range_to_421_comment},
  { "getWord",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_word_422, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_word_422_comment},
  { "setWord",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_set_word_423, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_set_word_423_comment},
  { "getNumOnBits",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_num_on_bits_424, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_num_on_bits_424_comment},
  { "getNumOffBits",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_num_off_bits_425, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_num_off_bits_425_comment},
  { "getLowestOnBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_lowest_on_bit_426, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_lowest_on_bit_426_comment},
  { "getLowestOffBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_lowest_off_bit_427, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_lowest_off_bit_427_comment},
  { "getHighestOnBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_highest_on_bit_428, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_highest_on_bit_428_comment},
  { "getHighestOffBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_highest_off_bit_429, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_highest_off_bit_429_comment},
  { "getNextHigherDifferentBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_next_higher_different_bit_430, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_next_higher_different_bit_430_comment},
  { "invertInPlace",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_invert_in_place_431, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_invert_in_place_431_comment},
  { "hasBitsInCommon",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_has_bits_in_common_432, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_has_bits_in_common_432_comment},
  { "clear",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_clear_433, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_clear_433_comment},
  { "output",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_output_434, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_output_434_comment},
  { "outputBinary",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_output_binary_435, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_output_binary_435_comment},
  { "outputHex",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_output_hex_436, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_output_hex_436_comment},
  { "write",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_write_437, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_write_437_comment},
  { "eq",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_438, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_438_comment},
  { "ne",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_439, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_439_comment},
  { "lessThan",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_440, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_440_comment},
  { "compareTo",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_compare_to_441, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_compare_to_441_comment},
  { "__and__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_442, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_442_comment},
  { "__or__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_443, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_443_comment},
  { "__xor__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_444, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_444_comment},
  { "__invert__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_445, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_445_comment},
  { "__lshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_446, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_446_comment},
  { "__rshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_447, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_447_comment},
  { "__iand__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_448, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_448_comment},
  { "__ior__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_449, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_449_comment},
  { "__ixor__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_450, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_450_comment},
  { "__ilshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_451, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_451_comment},
  { "__irshift__",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_operator_452, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_operator_452_comment},
  { "floodDownInPlace",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_flood_down_in_place_453, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_flood_down_in_place_453_comment},
  { "floodUpInPlace",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_flood_up_in_place_454, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_flood_up_in_place_454_comment},
  { "floodBitsDown",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_flood_bits_down_455, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_flood_bits_down_455_comment},
  { "floodBitsUp",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_flood_bits_up_456, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_flood_bits_up_456_comment},
  { "keepNextHighestBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_keep_next_highest_bit_457, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_keep_next_highest_bit_457_comment},
  { "keepNextLowestBit",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_keep_next_lowest_bit_458, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_keep_next_lowest_bit_458_comment},
  { "getKey",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_key_459, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_key_459_comment},
  { "getClassType",(PyCFunction ) &Dtool_BitMask_unsigned_int64_64_get_class_type_460, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitMask_unsigned_int64_64_get_class_type_460_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_xor = __xor__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_444__xor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_444(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_rshift = __rshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_447__rshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_447(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_lshift = __lshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_446__lshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_446(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_443__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_443(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_448__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_448(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_BitMask_unsigned_int64_64_operator_445__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_445(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_442__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_442(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_inplace_rshift = __irshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_452__irshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_452(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_inplace_lshift = __ilshift__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_451__ilshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_451(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitMask_unsigned_int64_64 ...tp_as_number->nb_inplace_xor = __ixor__
//////////////////
static PyObject *Dtool_BitMask_unsigned_int64_64_operator_450__ixor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitMask_unsigned_int64_64_operator_450(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A LocalHash(getKey) Function for this type
//     BitMask_unsigned_int64_64
//////////////////
static long  DTool_HashKey_BitMask_unsigned_int64_64(PyObject * self)
{
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return -1;
    };
    return local_this->get_key();
}

//////////////////
//  A __repr__ Function
//     BitMask_unsigned_int64_64
//////////////////
static PyObject *  Dtool_Repr_BitMask_unsigned_int64_64(PyObject * self)
{
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BitMask_unsigned_int64_64
//////////////////
static PyObject *  Dtool_Str_BitMask_unsigned_int64_64(PyObject * self)
{
    BitMask< unsigned __int64, 64 > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitMask_unsigned_int64_64,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BitMask_unsigned_int64_64(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_xor = __xor__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_xor = &Dtool_BitMask_unsigned_int64_64_operator_444__xor__;
        // tp_as_number->nb_rshift = __rshift__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_rshift = &Dtool_BitMask_unsigned_int64_64_operator_447__rshift__;
        // tp_as_number->nb_lshift = __lshift__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_lshift = &Dtool_BitMask_unsigned_int64_64_operator_446__lshift__;
        // tp_as_number->nb_or = __or__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_or = &Dtool_BitMask_unsigned_int64_64_operator_443__or__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_BitMask_unsigned_int64_64_operator_448__iand__;
        // tp_as_number->nb_invert = __invert__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_BitMask_unsigned_int64_64_operator_445__invert__;
        // tp_as_number->nb_and = __and__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_and = &Dtool_BitMask_unsigned_int64_64_operator_442__and__;
        // tp_as_number->nb_inplace_rshift = __irshift__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_inplace_rshift = &Dtool_BitMask_unsigned_int64_64_operator_452__irshift__;
        // tp_as_number->nb_inplace_lshift = __ilshift__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_inplace_lshift = &Dtool_BitMask_unsigned_int64_64_operator_451__ilshift__;
        // tp_as_number->nb_inplace_xor = __ixor__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_as_number->nb_inplace_xor = &Dtool_BitMask_unsigned_int64_64_operator_450__ixor__;
        // __hash__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_hash = &DTool_HashKey_BitMask_unsigned_int64_64;
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_compare = &DTOOL_PyObject_Compare;
        // __repr__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_repr = & Dtool_Repr_BitMask_unsigned_int64_64;
        // __str__
        Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_str = & Dtool_Str_BitMask_unsigned_int64_64;
        if(PyType_Ready(&Dtool_BitMask_unsigned_int64_64.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BitMask_unsigned_int64_64)");
             printf(" Error In PyType_ReadyBitMask_unsigned_int64_64");
             return;
        }
        Py_INCREF(&Dtool_BitMask_unsigned_int64_64.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"BitMask64",&Dtool_BitMask_unsigned_int64_64.As_PyObject());
        //  Static Method allOn
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"allOn",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[1],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method allOff
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"allOff",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[2],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method lowerOn
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"lowerOn",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[3],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method bit
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"bit",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[4],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method range
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"range",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[5],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method hasMaxNumBits
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"hasMaxNumBits",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[6],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method getMaxNumBits
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"getMaxNumBits",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[7],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method getNumBits
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"getNumBits",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[8],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BitMask_unsigned_int64_64.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BitMask_unsigned_int64_64[60],&Dtool_BitMask_unsigned_int64_64.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BitMask_unsigned_int64_64,BitMask< unsigned __int64, 64 >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BitMask_unsigned_int64_64.As_PyTypeObject());
        PyModule_AddObject(module, "BitMask64",(PyObject *)&Dtool_BitMask_unsigned_int64_64.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BitArray | BitArray
//********************************************************************
PyMethodDef Dtool_Methods_BitArray[]= {
  { "assign",(PyCFunction ) &Dtool_BitArray_operator_463, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_463_comment},
  { "allOn",(PyCFunction ) &Dtool_BitArray_all_on_464, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_all_on_464_comment},
  { "allOff",(PyCFunction ) &Dtool_BitArray_all_off_465, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_all_off_465_comment},
  { "lowerOn",(PyCFunction ) &Dtool_BitArray_lower_on_466, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_lower_on_466_comment},
  { "bit",(PyCFunction ) &Dtool_BitArray_bit_467, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_bit_467_comment},
  { "range",(PyCFunction ) &Dtool_BitArray_range_468, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_range_468_comment},
  { "hasMaxNumBits",(PyCFunction ) &Dtool_BitArray_has_max_num_bits_470, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_has_max_num_bits_470_comment},
  { "getMaxNumBits",(PyCFunction ) &Dtool_BitArray_get_max_num_bits_471, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_max_num_bits_471_comment},
  { "getNumBitsPerWord",(PyCFunction ) &Dtool_BitArray_get_num_bits_per_word_472, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_num_bits_per_word_472_comment},
  { "getNumBits",(PyCFunction ) &Dtool_BitArray_get_num_bits_473, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_num_bits_473_comment},
  { "getBit",(PyCFunction ) &Dtool_BitArray_get_bit_474, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_bit_474_comment},
  { "setBit",(PyCFunction ) &Dtool_BitArray_set_bit_475, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_set_bit_475_comment},
  { "clearBit",(PyCFunction ) &Dtool_BitArray_clear_bit_476, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_clear_bit_476_comment},
  { "setBitTo",(PyCFunction ) &Dtool_BitArray_set_bit_to_477, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_set_bit_to_477_comment},
  { "getHighestBits",(PyCFunction ) &Dtool_BitArray_get_highest_bits_478, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_highest_bits_478_comment},
  { "isZero",(PyCFunction ) &Dtool_BitArray_is_zero_479, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_is_zero_479_comment},
  { "isAllOn",(PyCFunction ) &Dtool_BitArray_is_all_on_480, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_is_all_on_480_comment},
  { "extract",(PyCFunction ) &Dtool_BitArray_extract_481, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_extract_481_comment},
  { "store",(PyCFunction ) &Dtool_BitArray_store_482, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_store_482_comment},
  { "hasAnyOf",(PyCFunction ) &Dtool_BitArray_has_any_of_483, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_has_any_of_483_comment},
  { "hasAllOf",(PyCFunction ) &Dtool_BitArray_has_all_of_484, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_has_all_of_484_comment},
  { "setRange",(PyCFunction ) &Dtool_BitArray_set_range_485, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_set_range_485_comment},
  { "clearRange",(PyCFunction ) &Dtool_BitArray_clear_range_486, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_clear_range_486_comment},
  { "setRangeTo",(PyCFunction ) &Dtool_BitArray_set_range_to_487, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_set_range_to_487_comment},
  { "getNumOnBits",(PyCFunction ) &Dtool_BitArray_get_num_on_bits_488, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_num_on_bits_488_comment},
  { "getNumOffBits",(PyCFunction ) &Dtool_BitArray_get_num_off_bits_489, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_num_off_bits_489_comment},
  { "getLowestOnBit",(PyCFunction ) &Dtool_BitArray_get_lowest_on_bit_490, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_lowest_on_bit_490_comment},
  { "getLowestOffBit",(PyCFunction ) &Dtool_BitArray_get_lowest_off_bit_491, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_lowest_off_bit_491_comment},
  { "getHighestOnBit",(PyCFunction ) &Dtool_BitArray_get_highest_on_bit_492, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_highest_on_bit_492_comment},
  { "getHighestOffBit",(PyCFunction ) &Dtool_BitArray_get_highest_off_bit_493, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_highest_off_bit_493_comment},
  { "getNextHigherDifferentBit",(PyCFunction ) &Dtool_BitArray_get_next_higher_different_bit_494, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_next_higher_different_bit_494_comment},
  { "getNumWords",(PyCFunction ) &Dtool_BitArray_get_num_words_495, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_num_words_495_comment},
  { "getWord",(PyCFunction ) &Dtool_BitArray_get_word_496, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_word_496_comment},
  { "setWord",(PyCFunction ) &Dtool_BitArray_set_word_497, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_set_word_497_comment},
  { "invertInPlace",(PyCFunction ) &Dtool_BitArray_invert_in_place_498, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_invert_in_place_498_comment},
  { "hasBitsInCommon",(PyCFunction ) &Dtool_BitArray_has_bits_in_common_499, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_has_bits_in_common_499_comment},
  { "clear",(PyCFunction ) &Dtool_BitArray_clear_500, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_clear_500_comment},
  { "output",(PyCFunction ) &Dtool_BitArray_output_501, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_output_501_comment},
  { "outputBinary",(PyCFunction ) &Dtool_BitArray_output_binary_502, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_output_binary_502_comment},
  { "outputHex",(PyCFunction ) &Dtool_BitArray_output_hex_503, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_output_hex_503_comment},
  { "write",(PyCFunction ) &Dtool_BitArray_write_504, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_write_504_comment},
  { "eq",(PyCFunction ) &Dtool_BitArray_operator_505, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_505_comment},
  { "ne",(PyCFunction ) &Dtool_BitArray_operator_506, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_506_comment},
  { "lessThan",(PyCFunction ) &Dtool_BitArray_operator_507, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_507_comment},
  { "compareTo",(PyCFunction ) &Dtool_BitArray_compare_to_508, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_compare_to_508_comment},
  { "__and__",(PyCFunction ) &Dtool_BitArray_operator_509, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_509_comment},
  { "__or__",(PyCFunction ) &Dtool_BitArray_operator_510, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_510_comment},
  { "__xor__",(PyCFunction ) &Dtool_BitArray_operator_511, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_511_comment},
  { "__invert__",(PyCFunction ) &Dtool_BitArray_operator_512, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_512_comment},
  { "__lshift__",(PyCFunction ) &Dtool_BitArray_operator_513, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_513_comment},
  { "__rshift__",(PyCFunction ) &Dtool_BitArray_operator_514, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_514_comment},
  { "__iand__",(PyCFunction ) &Dtool_BitArray_operator_515, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_515_comment},
  { "__ior__",(PyCFunction ) &Dtool_BitArray_operator_516, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_516_comment},
  { "__ixor__",(PyCFunction ) &Dtool_BitArray_operator_517, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_517_comment},
  { "__ilshift__",(PyCFunction ) &Dtool_BitArray_operator_518, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_518_comment},
  { "__irshift__",(PyCFunction ) &Dtool_BitArray_operator_519, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_operator_519_comment},
  { "getClassType",(PyCFunction ) &Dtool_BitArray_get_class_type_520, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BitArray_get_class_type_520_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_BitArray_operator_509__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_509(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_BitArray_operator_512__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_BitArray_operator_512(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_BitArray_operator_515__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_515(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_BitArray_operator_510__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_510(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_xor = __xor__
//////////////////
static PyObject *Dtool_BitArray_operator_511__xor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_511(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_lshift = __lshift__
//////////////////
static PyObject *Dtool_BitArray_operator_513__lshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_513(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_rshift = __rshift__
//////////////////
static PyObject *Dtool_BitArray_operator_514__rshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_514(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_inplace_rshift = __irshift__
//////////////////
static PyObject *Dtool_BitArray_operator_519__irshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_519(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_inplace_xor = __ixor__
//////////////////
static PyObject *Dtool_BitArray_operator_517__ixor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_517(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     BitArray ...tp_as_number->nb_inplace_lshift = __ilshift__
//////////////////
static PyObject *Dtool_BitArray_operator_518__ilshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_BitArray_operator_518(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     BitArray
//////////////////
static PyObject *  Dtool_Repr_BitArray(PyObject * self)
{
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BitArray
//////////////////
static PyObject *  Dtool_Str_BitArray(PyObject * self)
{
    BitArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BitArray,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BitArray(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BitArray.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BitArray\n"
          "// Description : A dynamic array with an unlimited number of bits.\n"
          "//\n"
          "//               This is similar to a BitMask, except it appears to\n"
          "//               contain an infinite number of bits.  You can use it\n"
          "//               very much as you would use a BitMask.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_BitArray.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_BitArray.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BitArray.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_and = __and__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_and = &Dtool_BitArray_operator_509__and__;
        // tp_as_number->nb_invert = __invert__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_BitArray_operator_512__invert__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_BitArray_operator_515__iand__;
        // tp_as_number->nb_or = __or__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_or = &Dtool_BitArray_operator_510__or__;
        // tp_as_number->nb_xor = __xor__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_xor = &Dtool_BitArray_operator_511__xor__;
        // tp_as_number->nb_lshift = __lshift__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_lshift = &Dtool_BitArray_operator_513__lshift__;
        // tp_as_number->nb_rshift = __rshift__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_rshift = &Dtool_BitArray_operator_514__rshift__;
        // tp_as_number->nb_inplace_rshift = __irshift__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_inplace_rshift = &Dtool_BitArray_operator_519__irshift__;
        // tp_as_number->nb_inplace_xor = __ixor__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_inplace_xor = &Dtool_BitArray_operator_517__ixor__;
        // tp_as_number->nb_inplace_lshift = __ilshift__
        Dtool_BitArray.As_PyTypeObject().tp_as_number->nb_inplace_lshift = &Dtool_BitArray_operator_518__ilshift__;
        // __repr__
        Dtool_BitArray.As_PyTypeObject().tp_repr = & Dtool_Repr_BitArray;
        // __str__
        Dtool_BitArray.As_PyTypeObject().tp_str = & Dtool_Str_BitArray;
        if(PyType_Ready(&Dtool_BitArray.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BitArray)");
             printf(" Error In PyType_ReadyBitArray");
             return;
        }
        Py_INCREF(&Dtool_BitArray.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"BitArray",&Dtool_BitArray.As_PyObject());
        //  Static Method allOn
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"allOn",PyCFunction_New(&Dtool_Methods_BitArray[1],&Dtool_BitArray.As_PyObject()));
        //  Static Method allOff
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"allOff",PyCFunction_New(&Dtool_Methods_BitArray[2],&Dtool_BitArray.As_PyObject()));
        //  Static Method lowerOn
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"lowerOn",PyCFunction_New(&Dtool_Methods_BitArray[3],&Dtool_BitArray.As_PyObject()));
        //  Static Method bit
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"bit",PyCFunction_New(&Dtool_Methods_BitArray[4],&Dtool_BitArray.As_PyObject()));
        //  Static Method range
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"range",PyCFunction_New(&Dtool_Methods_BitArray[5],&Dtool_BitArray.As_PyObject()));
        //  Static Method hasMaxNumBits
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"hasMaxNumBits",PyCFunction_New(&Dtool_Methods_BitArray[6],&Dtool_BitArray.As_PyObject()));
        //  Static Method getMaxNumBits
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"getMaxNumBits",PyCFunction_New(&Dtool_Methods_BitArray[7],&Dtool_BitArray.As_PyObject()));
        //  Static Method getNumBitsPerWord
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"getNumBitsPerWord",PyCFunction_New(&Dtool_Methods_BitArray[8],&Dtool_BitArray.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BitArray.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BitArray[56],&Dtool_BitArray.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BitArray,BitArray::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BitArray.As_PyTypeObject());
        PyModule_AddObject(module, "BitArray",(PyObject *)&Dtool_BitArray.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ButtonHandle | ButtonHandle
//********************************************************************
PyMethodDef Dtool_Methods_ButtonHandle[]= {
  { "getName",(PyCFunction ) &Dtool_ButtonHandle_get_name_523, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_get_name_523_comment},
  { "hasAsciiEquivalent",(PyCFunction ) &Dtool_ButtonHandle_has_ascii_equivalent_524, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_has_ascii_equivalent_524_comment},
  { "getAsciiEquivalent",(PyCFunction ) &Dtool_ButtonHandle_get_ascii_equivalent_525, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_get_ascii_equivalent_525_comment},
  { "getAlias",(PyCFunction ) &Dtool_ButtonHandle_get_alias_526, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_get_alias_526_comment},
  { "matches",(PyCFunction ) &Dtool_ButtonHandle_matches_527, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_matches_527_comment},
  { "getIndex",(PyCFunction ) &Dtool_ButtonHandle_get_index_528, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_get_index_528_comment},
  { "output",(PyCFunction ) &Dtool_ButtonHandle_output_529, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_output_529_comment},
  { "none",(PyCFunction ) &Dtool_ButtonHandle_none_530, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_none_530_comment},
  { "getClassType",(PyCFunction ) &Dtool_ButtonHandle_get_class_type_531, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonHandle_get_class_type_531_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ButtonHandle
//////////////////
static PyObject *  Dtool_Repr_ButtonHandle(PyObject * self)
{
    ButtonHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonHandle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ButtonHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ButtonHandle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ButtonHandle\n"
          "// Description : A ButtonHandle represents a single button from any\n"
          "//               device, including keyboard buttons and mouse buttons\n"
          "//               (but see KeyboardButton and MouseButton).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ButtonHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ButtonHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ButtonHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ButtonHandle.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ButtonHandle.As_PyTypeObject().tp_repr = & Dtool_Repr_ButtonHandle;
        // __str__ Repr Proxy
        Dtool_ButtonHandle.As_PyTypeObject().tp_str = & Dtool_Repr_ButtonHandle;
        if(PyType_Ready(&Dtool_ButtonHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ButtonHandle)");
             printf(" Error In PyType_ReadyButtonHandle");
             return;
        }
        Py_INCREF(&Dtool_ButtonHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ButtonHandle.As_PyTypeObject().tp_dict,"ButtonHandle",&Dtool_ButtonHandle.As_PyObject());
        //  Static Method none
        PyDict_SetItemString(Dtool_ButtonHandle.As_PyTypeObject().tp_dict,"none",PyCFunction_New(&Dtool_Methods_ButtonHandle[7],&Dtool_ButtonHandle.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ButtonHandle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ButtonHandle[8],&Dtool_ButtonHandle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ButtonHandle,ButtonHandle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ButtonHandle.As_PyTypeObject());
        PyModule_AddObject(module, "ButtonHandle",(PyObject *)&Dtool_ButtonHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ButtonRegistry | ButtonRegistry
//********************************************************************
PyMethodDef Dtool_Methods_ButtonRegistry[]= {
  { "getButton",(PyCFunction ) &Dtool_ButtonRegistry_get_button_534, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonRegistry_get_button_534_comment},
  { "findAsciiButton",(PyCFunction ) &Dtool_ButtonRegistry_find_ascii_button_535, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonRegistry_find_ascii_button_535_comment},
  { "write",(PyCFunction ) &Dtool_ButtonRegistry_write_536, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonRegistry_write_536_comment},
  { "ptr",(PyCFunction ) &Dtool_ButtonRegistry_ptr_537, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonRegistry_ptr_537_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     ButtonRegistry
//////////////////
static PyObject *  Dtool_Str_ButtonRegistry(PyObject * self)
{
    ButtonRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonRegistry,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ButtonRegistry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ButtonRegistry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ButtonRegistry\n"
          "// Description : The ButtonRegistry class maintains all the assigned\n"
          "//               ButtonHandles in a given system.  There should be only\n"
          "//               one ButtonRegistry class during the lifetime of the\n"
          "//               application.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ButtonRegistry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ButtonRegistry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ButtonRegistry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ButtonRegistry.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_ButtonRegistry.As_PyTypeObject().tp_str = & Dtool_Str_ButtonRegistry;
        if(PyType_Ready(&Dtool_ButtonRegistry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ButtonRegistry)");
             printf(" Error In PyType_ReadyButtonRegistry");
             return;
        }
        Py_INCREF(&Dtool_ButtonRegistry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ButtonRegistry.As_PyTypeObject().tp_dict,"ButtonRegistry",&Dtool_ButtonRegistry.As_PyObject());
        //  Static Method ptr
        PyDict_SetItemString(Dtool_ButtonRegistry.As_PyTypeObject().tp_dict,"ptr",PyCFunction_New(&Dtool_Methods_ButtonRegistry[3],&Dtool_ButtonRegistry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ButtonRegistry,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ButtonRegistry.As_PyTypeObject());
        PyModule_AddObject(module, "ButtonRegistry",(PyObject *)&Dtool_ButtonRegistry.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CallbackObject | CallbackObject
//********************************************************************
PyMethodDef Dtool_Methods_CallbackObject[]= {
  { "output",(PyCFunction ) &Dtool_CallbackObject_output_541, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackObject_output_541_comment},
  { "getClassType",(PyCFunction ) &Dtool_CallbackObject_get_class_type_542, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackObject_get_class_type_542_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CallbackObject
//////////////////
static PyObject *  Dtool_Repr_CallbackObject(PyObject * self)
{
    CallbackObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackObject,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CallbackObject(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CallbackObject.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CallbackObject\n"
          "// Description : This is a generic object that can be assigned to a\n"
          "//               callback at various points in the rendering process.\n"
          "//               This is actually a base class for a handful of\n"
          "//               specialized callback object types.  You can also\n"
          "//               subclass it yourself to make your own callback\n"
          "//               handler.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CallbackObject.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CallbackObject.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CallbackObject.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CallbackObject.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CallbackObject.As_PyTypeObject().tp_repr = & Dtool_Repr_CallbackObject;
        // __str__ Repr Proxy
        Dtool_CallbackObject.As_PyTypeObject().tp_str = & Dtool_Repr_CallbackObject;
        if(PyType_Ready(&Dtool_CallbackObject.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CallbackObject)");
             printf(" Error In PyType_ReadyCallbackObject");
             return;
        }
        Py_INCREF(&Dtool_CallbackObject.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CallbackObject.As_PyTypeObject().tp_dict,"CallbackObject",&Dtool_CallbackObject.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CallbackObject.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CallbackObject[1],&Dtool_CallbackObject.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CallbackObject,CallbackObject::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CallbackObject.As_PyTypeObject());
        PyModule_AddObject(module, "CallbackObject",(PyObject *)&Dtool_CallbackObject.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CachedTypedWritableReferenceCount | CachedTypedWritableReferenceCount
//********************************************************************
PyMethodDef Dtool_Methods_CachedTypedWritableReferenceCount[]= {
  { "getCacheRefCount",(PyCFunction ) &Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_545, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_545_comment},
  { "cacheRef",(PyCFunction ) &Dtool_CachedTypedWritableReferenceCount_cache_ref_546, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CachedTypedWritableReferenceCount_cache_ref_546_comment},
  { "cacheUnref",(PyCFunction ) &Dtool_CachedTypedWritableReferenceCount_cache_unref_547, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CachedTypedWritableReferenceCount_cache_unref_547_comment},
  { "testRefCountIntegrity",(PyCFunction ) &Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_548, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_548_comment},
  { "getClassType",(PyCFunction ) &Dtool_CachedTypedWritableReferenceCount_get_class_type_549, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CachedTypedWritableReferenceCount_get_class_type_549_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CachedTypedWritableReferenceCount\n"
          "// Description : This is a special extension to ReferenceCount that\n"
          "//               includes dual reference counts: the standard\n"
          "//               reference count number, which includes all references\n"
          "//               to the object, and a separate number (the cache\n"
          "//               reference count) that counts the number of references\n"
          "//               to the object just within its cache alone.  When\n"
          "//               get_ref_count() == get_cache_ref_count(), the object\n"
          "//               is not referenced outside the cache.\n"
          "//\n"
          "//               The cache refs must be explicitly maintained; there\n"
          "//               is no PointerTo<> class to maintain the cache\n"
          "//               reference counts automatically.  The cache reference\n"
          "//               count is automatically included in the overall\n"
          "//               reference count: calling cache_ref() and\n"
          "//               cache_unref() automatically calls ref() and unref().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CachedTypedWritableReferenceCount)");
             printf(" Error In PyType_ReadyCachedTypedWritableReferenceCount");
             return;
        }
        Py_INCREF(&Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_dict,"CachedTypedWritableReferenceCount",&Dtool_CachedTypedWritableReferenceCount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CachedTypedWritableReferenceCount[4],&Dtool_CachedTypedWritableReferenceCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CachedTypedWritableReferenceCount,CachedTypedWritableReferenceCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject());
        PyModule_AddObject(module, "CachedTypedWritableReferenceCount",(PyObject *)&Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CallbackData | CallbackData
//********************************************************************
PyMethodDef Dtool_Methods_CallbackData[]= {
  { "output",(PyCFunction ) &Dtool_CallbackData_output_551, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackData_output_551_comment},
  { "upcall",(PyCFunction ) &Dtool_CallbackData_upcall_552, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackData_upcall_552_comment},
  { "getClassType",(PyCFunction ) &Dtool_CallbackData_get_class_type_553, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackData_get_class_type_553_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CallbackData
//////////////////
static PyObject *  Dtool_Repr_CallbackData(PyObject * self)
{
    CallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackData,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CallbackData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CallbackData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CallbackData\n"
          "// Description : This is a generic data block that is passed along to\n"
          "//               a CallbackObject when a callback is made.  It\n"
          "//               contains data specific to the particular callback\n"
          "//               type in question.\n"
          "//\n"
          "//               This is actually an abstract base class and contains\n"
          "//               no data.  Specializations of this class will contain\n"
          "//               the actual data relevant to each callback type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_CallbackData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_CallbackData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CallbackData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CallbackData.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CallbackData.As_PyTypeObject().tp_repr = & Dtool_Repr_CallbackData;
        // __str__ Repr Proxy
        Dtool_CallbackData.As_PyTypeObject().tp_str = & Dtool_Repr_CallbackData;
        if(PyType_Ready(&Dtool_CallbackData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CallbackData)");
             printf(" Error In PyType_ReadyCallbackData");
             return;
        }
        Py_INCREF(&Dtool_CallbackData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CallbackData.As_PyTypeObject().tp_dict,"CallbackData",&Dtool_CallbackData.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CallbackData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CallbackData[2],&Dtool_CallbackData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CallbackData,CallbackData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CallbackData.As_PyTypeObject());
        PyModule_AddObject(module, "CallbackData",(PyObject *)&Dtool_CallbackData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TimeVal | TimeVal
//********************************************************************
PyMethodDef Dtool_Methods_TimeVal[]= {
  { "getSec",(PyCFunction ) &Dtool_TimeVal_get_sec_557, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TimeVal_get_sec_557_comment},
  { "getUsec",(PyCFunction ) &Dtool_TimeVal_get_usec_558, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TimeVal_get_usec_558_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TimeVal(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TimeVal.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TimeVal.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TimeVal.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TimeVal.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TimeVal.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TimeVal)");
             printf(" Error In PyType_ReadyTimeVal");
             return;
        }
        Py_INCREF(&Dtool_TimeVal.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TimeVal.As_PyTypeObject().tp_dict,"TimeVal",&Dtool_TimeVal.As_PyObject());
        RegisterRuntimeClass(&Dtool_TimeVal,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TimeVal.As_PyTypeObject());
        PyModule_AddObject(module, "TimeVal",(PyObject *)&Dtool_TimeVal.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ClockObject | ClockObject
//********************************************************************
PyMethodDef Dtool_Methods_ClockObject[]= {
  { "setMode",(PyCFunction ) &Dtool_ClockObject_set_mode_564, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_mode_564_comment},
  { "getMode",(PyCFunction ) &Dtool_ClockObject_get_mode_565, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_mode_565_comment},
  { "getFrameTime",(PyCFunction ) &Dtool_ClockObject_get_frame_time_566, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_frame_time_566_comment},
  { "getRealTime",(PyCFunction ) &Dtool_ClockObject_get_real_time_567, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_real_time_567_comment},
  { "getLongTime",(PyCFunction ) &Dtool_ClockObject_get_long_time_568, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_long_time_568_comment},
  { "reset",(PyCFunction ) &Dtool_ClockObject_reset_569, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_reset_569_comment},
  { "setRealTime",(PyCFunction ) &Dtool_ClockObject_set_real_time_570, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_real_time_570_comment},
  { "setFrameTime",(PyCFunction ) &Dtool_ClockObject_set_frame_time_571, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_frame_time_571_comment},
  { "setFrameCount",(PyCFunction ) &Dtool_ClockObject_set_frame_count_572, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_frame_count_572_comment},
  { "getFrameCount",(PyCFunction ) &Dtool_ClockObject_get_frame_count_573, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_frame_count_573_comment},
  { "getNetFrameRate",(PyCFunction ) &Dtool_ClockObject_get_net_frame_rate_574, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_net_frame_rate_574_comment},
  { "getDt",(PyCFunction ) &Dtool_ClockObject_get_dt_575, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_dt_575_comment},
  { "setDt",(PyCFunction ) &Dtool_ClockObject_set_dt_576, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_dt_576_comment},
  { "setFrameRate",(PyCFunction ) &Dtool_ClockObject_set_frame_rate_577, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_frame_rate_577_comment},
  { "getMaxDt",(PyCFunction ) &Dtool_ClockObject_get_max_dt_578, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_max_dt_578_comment},
  { "setMaxDt",(PyCFunction ) &Dtool_ClockObject_set_max_dt_579, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_max_dt_579_comment},
  { "getDegradeFactor",(PyCFunction ) &Dtool_ClockObject_get_degrade_factor_580, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_degrade_factor_580_comment},
  { "setDegradeFactor",(PyCFunction ) &Dtool_ClockObject_set_degrade_factor_581, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_degrade_factor_581_comment},
  { "setAverageFrameRateInterval",(PyCFunction ) &Dtool_ClockObject_set_average_frame_rate_interval_582, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_set_average_frame_rate_interval_582_comment},
  { "getAverageFrameRateInterval",(PyCFunction ) &Dtool_ClockObject_get_average_frame_rate_interval_583, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_average_frame_rate_interval_583_comment},
  { "getAverageFrameRate",(PyCFunction ) &Dtool_ClockObject_get_average_frame_rate_584, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_average_frame_rate_584_comment},
  { "getMaxFrameDuration",(PyCFunction ) &Dtool_ClockObject_get_max_frame_duration_585, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_max_frame_duration_585_comment},
  { "calcFrameRateDeviation",(PyCFunction ) &Dtool_ClockObject_calc_frame_rate_deviation_586, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_calc_frame_rate_deviation_586_comment},
  { "tick",(PyCFunction ) &Dtool_ClockObject_tick_587, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_tick_587_comment},
  { "syncFrameTime",(PyCFunction ) &Dtool_ClockObject_sync_frame_time_588, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_sync_frame_time_588_comment},
  { "checkErrors",(PyCFunction ) &Dtool_ClockObject_check_errors_589, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_check_errors_589_comment},
  { "getGlobalClock",(PyCFunction ) &Dtool_ClockObject_get_global_clock_590, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_global_clock_590_comment},
  { "getClassType",(PyCFunction ) &Dtool_ClockObject_get_class_type_591, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClockObject_get_class_type_591_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ClockObject(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ClockObject.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ClockObject\n"
          "// Description : A ClockObject keeps track of elapsed real time and\n"
          "//               discrete time.  In normal mode, get_frame_time()\n"
          "//               returns the time as of the last time tick() was\n"
          "//               called.  This is the \"discrete\" time, and is usually\n"
          "//               used to get the time as of, for instance, the\n"
          "//               beginning of the current frame.\n"
          "//\n"
          "//               In other modes, as set by set_mode() or the\n"
          "//               clock-mode config variable, get_frame_time() may\n"
          "//               return other values to simulate different timing\n"
          "//               effects, for instance to perform non-real-time\n"
          "//               animation.  See set_mode().\n"
          "//\n"
          "//               In all modes, get_real_time() always returns the\n"
          "//               elapsed real time in seconds since the ClockObject\n"
          "//               was constructed, or since it was last reset.\n"
          "//\n"
          "//               You can create your own ClockObject whenever you want\n"
          "//               to have your own local timer.  There is also a\n"
          "//               default, global ClockObject intended to represent\n"
          "//               global time for the application; this is normally set\n"
          "//               up to tick every frame so that its get_frame_time()\n"
          "//               will return the time for the current frame.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ClockObject.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_ClockObject.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ClockObject.As_PyTypeObject().tp_dict);
        // Enum  ClockObject::Mode;
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MNormal",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MNonRealTime",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MForced",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MDegrade",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MSlave",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MLimited",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MInteger",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"MIntegerLimited",PyInt_FromLong(7));
        if(PyType_Ready(&Dtool_ClockObject.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ClockObject)");
             printf(" Error In PyType_ReadyClockObject");
             return;
        }
        Py_INCREF(&Dtool_ClockObject.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"ClockObject",&Dtool_ClockObject.As_PyObject());
        //  Static Method getGlobalClock
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"getGlobalClock",PyCFunction_New(&Dtool_Methods_ClockObject[26],&Dtool_ClockObject.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ClockObject.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ClockObject[27],&Dtool_ClockObject.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ClockObject,ClockObject::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ClockObject.As_PyTypeObject());
        PyModule_AddObject(module, "ClockObject",(PyObject *)&Dtool_ClockObject.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CopyOnWriteObject | CopyOnWriteObject
//********************************************************************
PyMethodDef Dtool_Methods_CopyOnWriteObject[]= {
  { "cacheRef",(PyCFunction ) &Dtool_CopyOnWriteObject_cache_ref_595, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CopyOnWriteObject_cache_ref_595_comment},
  { "getClassType",(PyCFunction ) &Dtool_CopyOnWriteObject_get_class_type_596, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CopyOnWriteObject_get_class_type_596_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CopyOnWriteObject(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CopyOnWriteObject.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CopyOnWriteObject\n"
          "// Description : This base class provides basic reference counting,\n"
          "//               but also can be used with a CopyOnWritePointer to\n"
          "//               provide get_read_pointer() and get_write_pointer().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CachedTypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CopyOnWriteObject.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject());
        Dtool_CopyOnWriteObject.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CopyOnWriteObject.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CopyOnWriteObject.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CopyOnWriteObject.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CopyOnWriteObject)");
             printf(" Error In PyType_ReadyCopyOnWriteObject");
             return;
        }
        Py_INCREF(&Dtool_CopyOnWriteObject.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CopyOnWriteObject.As_PyTypeObject().tp_dict,"CopyOnWriteObject",&Dtool_CopyOnWriteObject.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CopyOnWriteObject.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CopyOnWriteObject[1],&Dtool_CopyOnWriteObject.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CopyOnWriteObject,CopyOnWriteObject::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CopyOnWriteObject.As_PyTypeObject());
        PyModule_AddObject(module, "CopyOnWriteObject",(PyObject *)&Dtool_CopyOnWriteObject.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. KeyboardButton | KeyboardButton
//********************************************************************
PyMethodDef Dtool_Methods_KeyboardButton[]= {
  { "asciiKey",(PyCFunction ) &Dtool_KeyboardButton_ascii_key_599, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_ascii_key_599_comment},
  { "space",(PyCFunction ) &Dtool_KeyboardButton_space_600, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_space_600_comment},
  { "backspace",(PyCFunction ) &Dtool_KeyboardButton_backspace_601, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_backspace_601_comment},
  { "tab",(PyCFunction ) &Dtool_KeyboardButton_tab_602, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_tab_602_comment},
  { "enter",(PyCFunction ) &Dtool_KeyboardButton_enter_603, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_enter_603_comment},
  { "escape",(PyCFunction ) &Dtool_KeyboardButton_escape_604, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_escape_604_comment},
  { "f1",(PyCFunction ) &Dtool_KeyboardButton_f1_605, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f1_605_comment},
  { "f2",(PyCFunction ) &Dtool_KeyboardButton_f2_606, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f2_606_comment},
  { "f3",(PyCFunction ) &Dtool_KeyboardButton_f3_607, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f3_607_comment},
  { "f4",(PyCFunction ) &Dtool_KeyboardButton_f4_608, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f4_608_comment},
  { "f5",(PyCFunction ) &Dtool_KeyboardButton_f5_609, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f5_609_comment},
  { "f6",(PyCFunction ) &Dtool_KeyboardButton_f6_610, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f6_610_comment},
  { "f7",(PyCFunction ) &Dtool_KeyboardButton_f7_611, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f7_611_comment},
  { "f8",(PyCFunction ) &Dtool_KeyboardButton_f8_612, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f8_612_comment},
  { "f9",(PyCFunction ) &Dtool_KeyboardButton_f9_613, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f9_613_comment},
  { "f10",(PyCFunction ) &Dtool_KeyboardButton_f10_614, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f10_614_comment},
  { "f11",(PyCFunction ) &Dtool_KeyboardButton_f11_615, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f11_615_comment},
  { "f12",(PyCFunction ) &Dtool_KeyboardButton_f12_616, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f12_616_comment},
  { "f13",(PyCFunction ) &Dtool_KeyboardButton_f13_617, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f13_617_comment},
  { "f14",(PyCFunction ) &Dtool_KeyboardButton_f14_618, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f14_618_comment},
  { "f15",(PyCFunction ) &Dtool_KeyboardButton_f15_619, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f15_619_comment},
  { "f16",(PyCFunction ) &Dtool_KeyboardButton_f16_620, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_f16_620_comment},
  { "left",(PyCFunction ) &Dtool_KeyboardButton_left_621, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_left_621_comment},
  { "right",(PyCFunction ) &Dtool_KeyboardButton_right_622, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_right_622_comment},
  { "up",(PyCFunction ) &Dtool_KeyboardButton_up_623, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_up_623_comment},
  { "down",(PyCFunction ) &Dtool_KeyboardButton_down_624, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_down_624_comment},
  { "pageUp",(PyCFunction ) &Dtool_KeyboardButton_page_up_625, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_page_up_625_comment},
  { "pageDown",(PyCFunction ) &Dtool_KeyboardButton_page_down_626, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_page_down_626_comment},
  { "home",(PyCFunction ) &Dtool_KeyboardButton_home_627, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_home_627_comment},
  { "end",(PyCFunction ) &Dtool_KeyboardButton_end_628, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_end_628_comment},
  { "insert",(PyCFunction ) &Dtool_KeyboardButton_insert_629, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_insert_629_comment},
  { "_del",(PyCFunction ) &Dtool_KeyboardButton_del_630, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_del_630_comment},
  { "help",(PyCFunction ) &Dtool_KeyboardButton_help_631, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_help_631_comment},
  { "shift",(PyCFunction ) &Dtool_KeyboardButton_shift_632, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_shift_632_comment},
  { "control",(PyCFunction ) &Dtool_KeyboardButton_control_633, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_control_633_comment},
  { "alt",(PyCFunction ) &Dtool_KeyboardButton_alt_634, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_alt_634_comment},
  { "meta",(PyCFunction ) &Dtool_KeyboardButton_meta_635, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_meta_635_comment},
  { "capsLock",(PyCFunction ) &Dtool_KeyboardButton_caps_lock_636, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_caps_lock_636_comment},
  { "shiftLock",(PyCFunction ) &Dtool_KeyboardButton_shift_lock_637, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_shift_lock_637_comment},
  { "numLock",(PyCFunction ) &Dtool_KeyboardButton_num_lock_638, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_num_lock_638_comment},
  { "scrollLock",(PyCFunction ) &Dtool_KeyboardButton_scroll_lock_639, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_scroll_lock_639_comment},
  { "printScreen",(PyCFunction ) &Dtool_KeyboardButton_print_screen_640, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_print_screen_640_comment},
  { "pause",(PyCFunction ) &Dtool_KeyboardButton_pause_641, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_pause_641_comment},
  { "lshift",(PyCFunction ) &Dtool_KeyboardButton_lshift_642, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_lshift_642_comment},
  { "rshift",(PyCFunction ) &Dtool_KeyboardButton_rshift_643, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_rshift_643_comment},
  { "lcontrol",(PyCFunction ) &Dtool_KeyboardButton_lcontrol_644, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_lcontrol_644_comment},
  { "rcontrol",(PyCFunction ) &Dtool_KeyboardButton_rcontrol_645, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_rcontrol_645_comment},
  { "lalt",(PyCFunction ) &Dtool_KeyboardButton_lalt_646, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_lalt_646_comment},
  { "ralt",(PyCFunction ) &Dtool_KeyboardButton_ralt_647, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_KeyboardButton_ralt_647_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_KeyboardButton(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_KeyboardButton.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : KeyboardButton\n"
          "// Description : This class is just used as a convenient namespace for\n"
          "//               grouping all of these handy functions that return\n"
          "//               buttons which map to standard keyboard keys.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_KeyboardButton.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_KeyboardButton.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_KeyboardButton.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_KeyboardButton.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(KeyboardButton)");
             printf(" Error In PyType_ReadyKeyboardButton");
             return;
        }
        Py_INCREF(&Dtool_KeyboardButton.As_PyTypeObject());
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"KeyboardButton",&Dtool_KeyboardButton.As_PyObject());
        //  Static Method asciiKey
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"asciiKey",PyCFunction_New(&Dtool_Methods_KeyboardButton[0],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method space
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"space",PyCFunction_New(&Dtool_Methods_KeyboardButton[1],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method backspace
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"backspace",PyCFunction_New(&Dtool_Methods_KeyboardButton[2],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method tab
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"tab",PyCFunction_New(&Dtool_Methods_KeyboardButton[3],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method enter
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"enter",PyCFunction_New(&Dtool_Methods_KeyboardButton[4],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method escape
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"escape",PyCFunction_New(&Dtool_Methods_KeyboardButton[5],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f1
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f1",PyCFunction_New(&Dtool_Methods_KeyboardButton[6],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f2
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f2",PyCFunction_New(&Dtool_Methods_KeyboardButton[7],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f3
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f3",PyCFunction_New(&Dtool_Methods_KeyboardButton[8],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f4
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f4",PyCFunction_New(&Dtool_Methods_KeyboardButton[9],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f5
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f5",PyCFunction_New(&Dtool_Methods_KeyboardButton[10],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f6
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f6",PyCFunction_New(&Dtool_Methods_KeyboardButton[11],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f7
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f7",PyCFunction_New(&Dtool_Methods_KeyboardButton[12],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f8
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f8",PyCFunction_New(&Dtool_Methods_KeyboardButton[13],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f9
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f9",PyCFunction_New(&Dtool_Methods_KeyboardButton[14],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f10
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f10",PyCFunction_New(&Dtool_Methods_KeyboardButton[15],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f11
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f11",PyCFunction_New(&Dtool_Methods_KeyboardButton[16],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f12
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f12",PyCFunction_New(&Dtool_Methods_KeyboardButton[17],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f13
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f13",PyCFunction_New(&Dtool_Methods_KeyboardButton[18],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f14
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f14",PyCFunction_New(&Dtool_Methods_KeyboardButton[19],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f15
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f15",PyCFunction_New(&Dtool_Methods_KeyboardButton[20],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method f16
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"f16",PyCFunction_New(&Dtool_Methods_KeyboardButton[21],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method left
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"left",PyCFunction_New(&Dtool_Methods_KeyboardButton[22],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method right
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"right",PyCFunction_New(&Dtool_Methods_KeyboardButton[23],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method up
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"up",PyCFunction_New(&Dtool_Methods_KeyboardButton[24],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method down
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"down",PyCFunction_New(&Dtool_Methods_KeyboardButton[25],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method pageUp
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"pageUp",PyCFunction_New(&Dtool_Methods_KeyboardButton[26],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method pageDown
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"pageDown",PyCFunction_New(&Dtool_Methods_KeyboardButton[27],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method home
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"home",PyCFunction_New(&Dtool_Methods_KeyboardButton[28],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method end
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"end",PyCFunction_New(&Dtool_Methods_KeyboardButton[29],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method insert
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"insert",PyCFunction_New(&Dtool_Methods_KeyboardButton[30],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method _del
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"_del",PyCFunction_New(&Dtool_Methods_KeyboardButton[31],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method help
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"help",PyCFunction_New(&Dtool_Methods_KeyboardButton[32],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method shift
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"shift",PyCFunction_New(&Dtool_Methods_KeyboardButton[33],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method control
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"control",PyCFunction_New(&Dtool_Methods_KeyboardButton[34],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method alt
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"alt",PyCFunction_New(&Dtool_Methods_KeyboardButton[35],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method meta
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"meta",PyCFunction_New(&Dtool_Methods_KeyboardButton[36],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method capsLock
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"capsLock",PyCFunction_New(&Dtool_Methods_KeyboardButton[37],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method shiftLock
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"shiftLock",PyCFunction_New(&Dtool_Methods_KeyboardButton[38],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method numLock
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"numLock",PyCFunction_New(&Dtool_Methods_KeyboardButton[39],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method scrollLock
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"scrollLock",PyCFunction_New(&Dtool_Methods_KeyboardButton[40],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method printScreen
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"printScreen",PyCFunction_New(&Dtool_Methods_KeyboardButton[41],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method pause
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"pause",PyCFunction_New(&Dtool_Methods_KeyboardButton[42],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method lshift
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"lshift",PyCFunction_New(&Dtool_Methods_KeyboardButton[43],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method rshift
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"rshift",PyCFunction_New(&Dtool_Methods_KeyboardButton[44],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method lcontrol
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"lcontrol",PyCFunction_New(&Dtool_Methods_KeyboardButton[45],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method rcontrol
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"rcontrol",PyCFunction_New(&Dtool_Methods_KeyboardButton[46],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method lalt
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"lalt",PyCFunction_New(&Dtool_Methods_KeyboardButton[47],&Dtool_KeyboardButton.As_PyObject()));
        //  Static Method ralt
        PyDict_SetItemString(Dtool_KeyboardButton.As_PyTypeObject().tp_dict,"ralt",PyCFunction_New(&Dtool_Methods_KeyboardButton[48],&Dtool_KeyboardButton.As_PyObject()));
        RegisterRuntimeClass(&Dtool_KeyboardButton,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_KeyboardButton.As_PyTypeObject());
        PyModule_AddObject(module, "KeyboardButton",(PyObject *)&Dtool_KeyboardButton.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LineStream | LineStream
//********************************************************************
PyMethodDef Dtool_Methods_LineStream[]= {
  { "isTextAvailable",(PyCFunction ) &Dtool_LineStream_is_text_available_652, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineStream_is_text_available_652_comment},
  { "getLine",(PyCFunction ) &Dtool_LineStream_get_line_653, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineStream_get_line_653_comment},
  { "hasNewline",(PyCFunction ) &Dtool_LineStream_has_newline_654, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineStream_has_newline_654_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LineStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LineStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LineStream\n"
          "// Description : This is a special ostream that writes to a memory\n"
          "//               buffer, like ostrstream.  However, its contents can\n"
          "//               be continuously extracted as a sequence of lines of\n"
          "//               text.\n"
          "//\n"
          "//               Unlike ostrstream, which can only be extracted from\n"
          "//               once (and then the buffer freezes and it can no\n"
          "//               longer be written to), the LineStream is not\n"
          "//               otherwise affected when a line of text is extracted.\n"
          "//               More text can still be written to it and continuously\n"
          "//               extracted.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_LineStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ostream.As_PyTypeObject());
        Dtool_LineStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LineStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LineStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LineStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LineStream)");
             printf(" Error In PyType_ReadyLineStream");
             return;
        }
        Py_INCREF(&Dtool_LineStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LineStream.As_PyTypeObject().tp_dict,"LineStream",&Dtool_LineStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_LineStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LineStream.As_PyTypeObject());
        PyModule_AddObject(module, "LineStream",(PyObject *)&Dtool_LineStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ModifierButtons | ModifierButtons
//********************************************************************
PyMethodDef Dtool_Methods_ModifierButtons[]= {
  { "assign",(PyCFunction ) &Dtool_ModifierButtons_operator_663, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_663_comment},
  { "eq",(PyCFunction ) &Dtool_ModifierButtons_operator_664, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_664_comment},
  { "ne",(PyCFunction ) &Dtool_ModifierButtons_operator_665, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_665_comment},
  { "lessThan",(PyCFunction ) &Dtool_ModifierButtons_operator_666, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_666_comment},
  { "__and__",(PyCFunction ) &Dtool_ModifierButtons_operator_667, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_667_comment},
  { "__or__",(PyCFunction ) &Dtool_ModifierButtons_operator_668, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_668_comment},
  { "__iand__",(PyCFunction ) &Dtool_ModifierButtons_operator_669, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_669_comment},
  { "__ior__",(PyCFunction ) &Dtool_ModifierButtons_operator_670, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_operator_670_comment},
  { "setButtonList",(PyCFunction ) &Dtool_ModifierButtons_set_button_list_671, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_set_button_list_671_comment},
  { "matches",(PyCFunction ) &Dtool_ModifierButtons_matches_672, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_matches_672_comment},
  { "addButton",(PyCFunction ) &Dtool_ModifierButtons_add_button_673, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_add_button_673_comment},
  { "hasButton",(PyCFunction ) &Dtool_ModifierButtons_has_button_674, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_has_button_674_comment},
  { "removeButton",(PyCFunction ) &Dtool_ModifierButtons_remove_button_675, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_remove_button_675_comment},
  { "getNumButtons",(PyCFunction ) &Dtool_ModifierButtons_get_num_buttons_676, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_get_num_buttons_676_comment},
  { "getButton",(PyCFunction ) &Dtool_ModifierButtons_get_button_677, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_get_button_677_comment},
  { "buttonDown",(PyCFunction ) &Dtool_ModifierButtons_button_down_678, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_button_down_678_comment},
  { "buttonUp",(PyCFunction ) &Dtool_ModifierButtons_button_up_679, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_button_up_679_comment},
  { "allButtonsUp",(PyCFunction ) &Dtool_ModifierButtons_all_buttons_up_680, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_all_buttons_up_680_comment},
  { "isDown",(PyCFunction ) &Dtool_ModifierButtons_is_down_681, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_is_down_681_comment},
  { "isAnyDown",(PyCFunction ) &Dtool_ModifierButtons_is_any_down_682, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_is_any_down_682_comment},
  { "getPrefix",(PyCFunction ) &Dtool_ModifierButtons_get_prefix_683, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_get_prefix_683_comment},
  { "output",(PyCFunction ) &Dtool_ModifierButtons_output_684, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_output_684_comment},
  { "write",(PyCFunction ) &Dtool_ModifierButtons_write_685, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ModifierButtons_write_685_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getButtons",(PyCFunction) &MakeSeq_ModifierButtons_get_buttons, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ModifierButtons ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_ModifierButtons_operator_667__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_ModifierButtons_operator_667(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ModifierButtons ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_ModifierButtons_operator_668__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_ModifierButtons_operator_668(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ModifierButtons ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_ModifierButtons_operator_669__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_ModifierButtons_operator_669(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     ModifierButtons
//////////////////
static PyObject *  Dtool_Repr_ModifierButtons(PyObject * self)
{
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ModifierButtons
//////////////////
static PyObject *  Dtool_Str_ModifierButtons(PyObject * self)
{
    ModifierButtons * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ModifierButtons,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ModifierButtons(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ModifierButtons.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ModifierButtons\n"
          "// Description : This class monitors the state of a number of\n"
          "//               individual buttons and tracks whether each button is\n"
          "//               known to be down or up.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ModifierButtons.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ModifierButtons.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ModifierButtons.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ModifierButtons.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_and = __and__
        Dtool_ModifierButtons.As_PyTypeObject().tp_as_number->nb_and = &Dtool_ModifierButtons_operator_667__and__;
        // tp_as_number->nb_or = __or__
        Dtool_ModifierButtons.As_PyTypeObject().tp_as_number->nb_or = &Dtool_ModifierButtons_operator_668__or__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_ModifierButtons.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_ModifierButtons_operator_669__iand__;
        // __repr__
        Dtool_ModifierButtons.As_PyTypeObject().tp_repr = & Dtool_Repr_ModifierButtons;
        // __str__
        Dtool_ModifierButtons.As_PyTypeObject().tp_str = & Dtool_Str_ModifierButtons;
        if(PyType_Ready(&Dtool_ModifierButtons.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ModifierButtons)");
             printf(" Error In PyType_ReadyModifierButtons");
             return;
        }
        Py_INCREF(&Dtool_ModifierButtons.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ModifierButtons.As_PyTypeObject().tp_dict,"ModifierButtons",&Dtool_ModifierButtons.As_PyObject());
        RegisterRuntimeClass(&Dtool_ModifierButtons,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ModifierButtons.As_PyTypeObject());
        PyModule_AddObject(module, "ModifierButtons",(PyObject *)&Dtool_ModifierButtons.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseButton | MouseButton
//********************************************************************
PyMethodDef Dtool_Methods_MouseButton[]= {
  { "button",(PyCFunction ) &Dtool_MouseButton_button_687, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_button_687_comment},
  { "one",(PyCFunction ) &Dtool_MouseButton_one_688, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_one_688_comment},
  { "two",(PyCFunction ) &Dtool_MouseButton_two_689, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_two_689_comment},
  { "three",(PyCFunction ) &Dtool_MouseButton_three_690, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_three_690_comment},
  { "four",(PyCFunction ) &Dtool_MouseButton_four_691, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_four_691_comment},
  { "five",(PyCFunction ) &Dtool_MouseButton_five_692, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_five_692_comment},
  { "wheelUp",(PyCFunction ) &Dtool_MouseButton_wheel_up_693, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_wheel_up_693_comment},
  { "wheelDown",(PyCFunction ) &Dtool_MouseButton_wheel_down_694, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_wheel_down_694_comment},
  { "wheelLeft",(PyCFunction ) &Dtool_MouseButton_wheel_left_695, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_wheel_left_695_comment},
  { "wheelRight",(PyCFunction ) &Dtool_MouseButton_wheel_right_696, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_wheel_right_696_comment},
  { "isMouseButton",(PyCFunction ) &Dtool_MouseButton_is_mouse_button_697, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseButton_is_mouse_button_697_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MouseButton(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseButton.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseButton\n"
          "// Description : This class is just used as a convenient namespace for\n"
          "//               grouping all of these handy functions that return\n"
          "//               buttons which map to standard mouse buttons.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_MouseButton.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_MouseButton.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseButton.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MouseButton.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseButton)");
             printf(" Error In PyType_ReadyMouseButton");
             return;
        }
        Py_INCREF(&Dtool_MouseButton.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"MouseButton",&Dtool_MouseButton.As_PyObject());
        //  Static Method button
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"button",PyCFunction_New(&Dtool_Methods_MouseButton[0],&Dtool_MouseButton.As_PyObject()));
        //  Static Method one
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"one",PyCFunction_New(&Dtool_Methods_MouseButton[1],&Dtool_MouseButton.As_PyObject()));
        //  Static Method two
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"two",PyCFunction_New(&Dtool_Methods_MouseButton[2],&Dtool_MouseButton.As_PyObject()));
        //  Static Method three
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"three",PyCFunction_New(&Dtool_Methods_MouseButton[3],&Dtool_MouseButton.As_PyObject()));
        //  Static Method four
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"four",PyCFunction_New(&Dtool_Methods_MouseButton[4],&Dtool_MouseButton.As_PyObject()));
        //  Static Method five
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"five",PyCFunction_New(&Dtool_Methods_MouseButton[5],&Dtool_MouseButton.As_PyObject()));
        //  Static Method wheelUp
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"wheelUp",PyCFunction_New(&Dtool_Methods_MouseButton[6],&Dtool_MouseButton.As_PyObject()));
        //  Static Method wheelDown
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"wheelDown",PyCFunction_New(&Dtool_Methods_MouseButton[7],&Dtool_MouseButton.As_PyObject()));
        //  Static Method wheelLeft
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"wheelLeft",PyCFunction_New(&Dtool_Methods_MouseButton[8],&Dtool_MouseButton.As_PyObject()));
        //  Static Method wheelRight
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"wheelRight",PyCFunction_New(&Dtool_Methods_MouseButton[9],&Dtool_MouseButton.As_PyObject()));
        //  Static Method isMouseButton
        PyDict_SetItemString(Dtool_MouseButton.As_PyTypeObject().tp_dict,"isMouseButton",PyCFunction_New(&Dtool_Methods_MouseButton[10],&Dtool_MouseButton.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseButton,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseButton.As_PyTypeObject());
        PyModule_AddObject(module, "MouseButton",(PyObject *)&Dtool_MouseButton.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseData | MouseData
//********************************************************************
PyMethodDef Dtool_Methods_MouseData[]= {
  { "assign",(PyCFunction ) &Dtool_MouseData_operator_701, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseData_operator_701_comment},
  { "getX",(PyCFunction ) &Dtool_MouseData_get_x_702, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseData_get_x_702_comment},
  { "getY",(PyCFunction ) &Dtool_MouseData_get_y_703, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseData_get_y_703_comment},
  { "getInWindow",(PyCFunction ) &Dtool_MouseData_get_in_window_704, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseData_get_in_window_704_comment},
  { "output",(PyCFunction ) &Dtool_MouseData_output_705, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseData_output_705_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     MouseData
//////////////////
static PyObject *  Dtool_Repr_MouseData(PyObject * self)
{
    MouseData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseData,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_MouseData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseData\n"
          "// Description : Holds the data that might be generated by a 2-d\n"
          "//               pointer input device, such as the mouse in the\n"
          "//               GraphicsWindow.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_MouseData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_MouseData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseData.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_MouseData.As_PyTypeObject().tp_repr = & Dtool_Repr_MouseData;
        // __str__ Repr Proxy
        Dtool_MouseData.As_PyTypeObject().tp_str = & Dtool_Repr_MouseData;
        if(PyType_Ready(&Dtool_MouseData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseData)");
             printf(" Error In PyType_ReadyMouseData");
             return;
        }
        Py_INCREF(&Dtool_MouseData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseData.As_PyTypeObject().tp_dict,"MouseData",&Dtool_MouseData.As_PyObject());
        RegisterRuntimeClass(&Dtool_MouseData,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseData.As_PyTypeObject());
        PyModule_AddObject(module, "MouseData",(PyObject *)&Dtool_MouseData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NodeCachedReferenceCount | NodeCachedReferenceCount
//********************************************************************
PyMethodDef Dtool_Methods_NodeCachedReferenceCount[]= {
  { "getNodeRefCount",(PyCFunction ) &Dtool_NodeCachedReferenceCount_get_node_ref_count_708, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCachedReferenceCount_get_node_ref_count_708_comment},
  { "nodeRef",(PyCFunction ) &Dtool_NodeCachedReferenceCount_node_ref_709, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCachedReferenceCount_node_ref_709_comment},
  { "nodeUnref",(PyCFunction ) &Dtool_NodeCachedReferenceCount_node_unref_710, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCachedReferenceCount_node_unref_710_comment},
  { "testRefCountIntegrity",(PyCFunction ) &Dtool_NodeCachedReferenceCount_test_ref_count_integrity_711, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCachedReferenceCount_test_ref_count_integrity_711_comment},
  { "getReferencedBits",(PyCFunction ) &Dtool_NodeCachedReferenceCount_get_referenced_bits_713, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCachedReferenceCount_get_referenced_bits_713_comment},
  { "getClassType",(PyCFunction ) &Dtool_NodeCachedReferenceCount_get_class_type_714, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCachedReferenceCount_get_class_type_714_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NodeCachedReferenceCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NodeCachedReferenceCount\n"
          "// Description : This class further specializes\n"
          "//               CachedTypedWritableReferenceCount to also add a\n"
          "//               node_ref_count, for the purposes of counting the\n"
          "//               number of times the object is referenced by a \"node\",\n"
          "//               presumably a PandaNode.\n"
          "//\n"
          "//               This essentially combines the functionality of\n"
          "//               NodeReferenceCount and\n"
          "//               CachedTypedWritableReferenceCount, so that a\n"
          "//               derivative of this object actually has three\n"
          "//               counters: the standard reference count, the \"cache\"\n"
          "//               reference count, and the \"node\" reference count.\n"
          "//               Rather than multiply inheriting from the two\n"
          "//               reference count classes, we inherit only from\n"
          "//               CachedTypedWritableReferenceCount and simply\n"
          "//               duplicate the functionality of NodeReferenceCount, to\n"
          "//               avoid all of the problems associated with multiple\n"
          "//               inheritance.\n"
          "//\n"
          "//               The intended design is to use this as a base class\n"
          "//               for RenderState and TransformState, both of which are\n"
          "//               held by PandaNodes, and also have caches which are\n"
          "//               independently maintained.  By keeping track of how\n"
          "//               many nodes hold a pointer to a particular object, we\n"
          "//               can classify each object into node-referenced,\n"
          "//               cache-referenced, or other, which is primarily useful\n"
          "//               for PStats reporting.\n"
          "//\n"
          "//               As with CachedTypedWritableReferenceCount's\n"
          "//               cache_ref() and cache_unref(), the new methods\n"
          "//               node_ref() and node_unref() automatically increment\n"
          "//               and decrement the primary reference count as well.\n"
          "//               In this case, however, there does exist a\n"
          "//               NodePointerTo<> class to maintain the node_ref\n"
          "//               counters automatically.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CachedTypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CachedTypedWritableReferenceCount.As_PyTypeObject());
        Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict);
        // Enum  NodeCachedReferenceCount::Referenced;
        PyDict_SetItemString(Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict,"RNode",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict,"RCache",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_NodeCachedReferenceCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NodeCachedReferenceCount)");
             printf(" Error In PyType_ReadyNodeCachedReferenceCount");
             return;
        }
        Py_INCREF(&Dtool_NodeCachedReferenceCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict,"NodeCachedReferenceCount",&Dtool_NodeCachedReferenceCount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NodeCachedReferenceCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NodeCachedReferenceCount[5],&Dtool_NodeCachedReferenceCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NodeCachedReferenceCount,NodeCachedReferenceCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NodeCachedReferenceCount.As_PyTypeObject());
        PyModule_AddObject(module, "NodeCachedReferenceCount",(PyObject *)&Dtool_NodeCachedReferenceCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SparseArray | SparseArray
//********************************************************************
PyMethodDef Dtool_Methods_SparseArray[]= {
  { "assign",(PyCFunction ) &Dtool_SparseArray_operator_717, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_717_comment},
  { "allOn",(PyCFunction ) &Dtool_SparseArray_all_on_718, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_all_on_718_comment},
  { "allOff",(PyCFunction ) &Dtool_SparseArray_all_off_719, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_all_off_719_comment},
  { "lowerOn",(PyCFunction ) &Dtool_SparseArray_lower_on_720, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_lower_on_720_comment},
  { "bit",(PyCFunction ) &Dtool_SparseArray_bit_721, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_bit_721_comment},
  { "range",(PyCFunction ) &Dtool_SparseArray_range_722, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_range_722_comment},
  { "hasMaxNumBits",(PyCFunction ) &Dtool_SparseArray_has_max_num_bits_724, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_has_max_num_bits_724_comment},
  { "getMaxNumBits",(PyCFunction ) &Dtool_SparseArray_get_max_num_bits_725, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_max_num_bits_725_comment},
  { "getNumBits",(PyCFunction ) &Dtool_SparseArray_get_num_bits_726, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_num_bits_726_comment},
  { "getBit",(PyCFunction ) &Dtool_SparseArray_get_bit_727, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_bit_727_comment},
  { "setBit",(PyCFunction ) &Dtool_SparseArray_set_bit_728, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_set_bit_728_comment},
  { "clearBit",(PyCFunction ) &Dtool_SparseArray_clear_bit_729, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_clear_bit_729_comment},
  { "setBitTo",(PyCFunction ) &Dtool_SparseArray_set_bit_to_730, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_set_bit_to_730_comment},
  { "getHighestBits",(PyCFunction ) &Dtool_SparseArray_get_highest_bits_731, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_highest_bits_731_comment},
  { "isZero",(PyCFunction ) &Dtool_SparseArray_is_zero_732, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_is_zero_732_comment},
  { "isAllOn",(PyCFunction ) &Dtool_SparseArray_is_all_on_733, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_is_all_on_733_comment},
  { "hasAnyOf",(PyCFunction ) &Dtool_SparseArray_has_any_of_734, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_has_any_of_734_comment},
  { "hasAllOf",(PyCFunction ) &Dtool_SparseArray_has_all_of_735, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_has_all_of_735_comment},
  { "setRange",(PyCFunction ) &Dtool_SparseArray_set_range_736, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_set_range_736_comment},
  { "clearRange",(PyCFunction ) &Dtool_SparseArray_clear_range_737, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_clear_range_737_comment},
  { "setRangeTo",(PyCFunction ) &Dtool_SparseArray_set_range_to_738, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_set_range_to_738_comment},
  { "getNumOnBits",(PyCFunction ) &Dtool_SparseArray_get_num_on_bits_739, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_num_on_bits_739_comment},
  { "getNumOffBits",(PyCFunction ) &Dtool_SparseArray_get_num_off_bits_740, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_num_off_bits_740_comment},
  { "getLowestOnBit",(PyCFunction ) &Dtool_SparseArray_get_lowest_on_bit_741, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_lowest_on_bit_741_comment},
  { "getLowestOffBit",(PyCFunction ) &Dtool_SparseArray_get_lowest_off_bit_742, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_lowest_off_bit_742_comment},
  { "getHighestOnBit",(PyCFunction ) &Dtool_SparseArray_get_highest_on_bit_743, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_highest_on_bit_743_comment},
  { "getHighestOffBit",(PyCFunction ) &Dtool_SparseArray_get_highest_off_bit_744, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_highest_off_bit_744_comment},
  { "getNextHigherDifferentBit",(PyCFunction ) &Dtool_SparseArray_get_next_higher_different_bit_745, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_next_higher_different_bit_745_comment},
  { "invertInPlace",(PyCFunction ) &Dtool_SparseArray_invert_in_place_746, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_invert_in_place_746_comment},
  { "hasBitsInCommon",(PyCFunction ) &Dtool_SparseArray_has_bits_in_common_747, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_has_bits_in_common_747_comment},
  { "clear",(PyCFunction ) &Dtool_SparseArray_clear_748, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_clear_748_comment},
  { "output",(PyCFunction ) &Dtool_SparseArray_output_749, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_output_749_comment},
  { "eq",(PyCFunction ) &Dtool_SparseArray_operator_750, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_750_comment},
  { "ne",(PyCFunction ) &Dtool_SparseArray_operator_751, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_751_comment},
  { "lessThan",(PyCFunction ) &Dtool_SparseArray_operator_752, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_752_comment},
  { "compareTo",(PyCFunction ) &Dtool_SparseArray_compare_to_753, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_compare_to_753_comment},
  { "__and__",(PyCFunction ) &Dtool_SparseArray_operator_754, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_754_comment},
  { "__or__",(PyCFunction ) &Dtool_SparseArray_operator_755, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_755_comment},
  { "__xor__",(PyCFunction ) &Dtool_SparseArray_operator_756, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_756_comment},
  { "__invert__",(PyCFunction ) &Dtool_SparseArray_operator_757, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_757_comment},
  { "__lshift__",(PyCFunction ) &Dtool_SparseArray_operator_758, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_758_comment},
  { "__rshift__",(PyCFunction ) &Dtool_SparseArray_operator_759, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_759_comment},
  { "__iand__",(PyCFunction ) &Dtool_SparseArray_operator_760, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_760_comment},
  { "__ior__",(PyCFunction ) &Dtool_SparseArray_operator_761, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_761_comment},
  { "__ixor__",(PyCFunction ) &Dtool_SparseArray_operator_762, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_762_comment},
  { "__ilshift__",(PyCFunction ) &Dtool_SparseArray_operator_763, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_763_comment},
  { "__irshift__",(PyCFunction ) &Dtool_SparseArray_operator_764, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_operator_764_comment},
  { "isInverse",(PyCFunction ) &Dtool_SparseArray_is_inverse_765, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_is_inverse_765_comment},
  { "getNumSubranges",(PyCFunction ) &Dtool_SparseArray_get_num_subranges_766, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_num_subranges_766_comment},
  { "getSubrangeBegin",(PyCFunction ) &Dtool_SparseArray_get_subrange_begin_767, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_subrange_begin_767_comment},
  { "getSubrangeEnd",(PyCFunction ) &Dtool_SparseArray_get_subrange_end_768, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_subrange_end_768_comment},
  { "getClassType",(PyCFunction ) &Dtool_SparseArray_get_class_type_769, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparseArray_get_class_type_769_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_and = __and__
//////////////////
static PyObject *Dtool_SparseArray_operator_754__and__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_754(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_lshift = __lshift__
//////////////////
static PyObject *Dtool_SparseArray_operator_758__lshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_758(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_or = __or__
//////////////////
static PyObject *Dtool_SparseArray_operator_755__or__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_755(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_rshift = __rshift__
//////////////////
static PyObject *Dtool_SparseArray_operator_759__rshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_759(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_inplace_and = __iand__
//////////////////
static PyObject *Dtool_SparseArray_operator_760__iand__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_760(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_xor = __xor__
//////////////////
static PyObject *Dtool_SparseArray_operator_756__xor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_756(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_SparseArray_operator_757__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_SparseArray_operator_757(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_inplace_xor = __ixor__
//////////////////
static PyObject *Dtool_SparseArray_operator_762__ixor__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_762(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_inplace_lshift = __ilshift__
//////////////////
static PyObject *Dtool_SparseArray_operator_763__ilshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_763(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     SparseArray ...tp_as_number->nb_inplace_rshift = __irshift__
//////////////////
static PyObject *Dtool_SparseArray_operator_764__irshift__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_SparseArray_operator_764(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     SparseArray
//////////////////
static PyObject *  Dtool_Repr_SparseArray(PyObject * self)
{
    SparseArray * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparseArray,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_SparseArray(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SparseArray.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SparseArray\n"
          "// Description : This class records a set of integers, where each\n"
          "//               integer is either present or not present in the set.\n"
          "//\n"
          "//               It is similar in principle and in interface to a\n"
          "//               BitArray (which can be thought of as a set of\n"
          "//               integers, one integer corresponding to each different\n"
          "//               bit position), but the SparseArray is implemented as\n"
          "//               a list of min/max subrange lists, rather than as a\n"
          "//               bitmask.  \n"
          "//\n"
          "//               This makes it particularly efficient for storing sets\n"
          "//               which consist of large sections of consecutively\n"
          "//               included or consecutively excluded elements, with\n"
          "//               arbitrarily large integers, but particularly\n"
          "//               inefficient for doing boolean operations such as & or\n"
          "//               |.\n"
          "//\n"
          "//               Also, unlike BitArray, the SparseArray can store\n"
          "//               negative integers.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SparseArray.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SparseArray.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SparseArray.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_and = __and__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_and = &Dtool_SparseArray_operator_754__and__;
        // tp_as_number->nb_lshift = __lshift__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_lshift = &Dtool_SparseArray_operator_758__lshift__;
        // tp_as_number->nb_or = __or__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_or = &Dtool_SparseArray_operator_755__or__;
        // tp_as_number->nb_rshift = __rshift__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_rshift = &Dtool_SparseArray_operator_759__rshift__;
        // tp_as_number->nb_inplace_and = __iand__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_inplace_and = &Dtool_SparseArray_operator_760__iand__;
        // tp_as_number->nb_xor = __xor__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_xor = &Dtool_SparseArray_operator_756__xor__;
        // tp_as_number->nb_invert = __invert__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_SparseArray_operator_757__invert__;
        // tp_as_number->nb_inplace_xor = __ixor__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_inplace_xor = &Dtool_SparseArray_operator_762__ixor__;
        // tp_as_number->nb_inplace_lshift = __ilshift__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_inplace_lshift = &Dtool_SparseArray_operator_763__ilshift__;
        // tp_as_number->nb_inplace_rshift = __irshift__
        Dtool_SparseArray.As_PyTypeObject().tp_as_number->nb_inplace_rshift = &Dtool_SparseArray_operator_764__irshift__;
        // __repr__
        Dtool_SparseArray.As_PyTypeObject().tp_repr = & Dtool_Repr_SparseArray;
        // __str__ Repr Proxy
        Dtool_SparseArray.As_PyTypeObject().tp_str = & Dtool_Repr_SparseArray;
        if(PyType_Ready(&Dtool_SparseArray.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SparseArray)");
             printf(" Error In PyType_ReadySparseArray");
             return;
        }
        Py_INCREF(&Dtool_SparseArray.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"SparseArray",&Dtool_SparseArray.As_PyObject());
        //  Static Method allOn
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"allOn",PyCFunction_New(&Dtool_Methods_SparseArray[1],&Dtool_SparseArray.As_PyObject()));
        //  Static Method allOff
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"allOff",PyCFunction_New(&Dtool_Methods_SparseArray[2],&Dtool_SparseArray.As_PyObject()));
        //  Static Method lowerOn
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"lowerOn",PyCFunction_New(&Dtool_Methods_SparseArray[3],&Dtool_SparseArray.As_PyObject()));
        //  Static Method bit
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"bit",PyCFunction_New(&Dtool_Methods_SparseArray[4],&Dtool_SparseArray.As_PyObject()));
        //  Static Method range
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"range",PyCFunction_New(&Dtool_Methods_SparseArray[5],&Dtool_SparseArray.As_PyObject()));
        //  Static Method hasMaxNumBits
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"hasMaxNumBits",PyCFunction_New(&Dtool_Methods_SparseArray[6],&Dtool_SparseArray.As_PyObject()));
        //  Static Method getMaxNumBits
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"getMaxNumBits",PyCFunction_New(&Dtool_Methods_SparseArray[7],&Dtool_SparseArray.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SparseArray.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SparseArray[51],&Dtool_SparseArray.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SparseArray,SparseArray::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SparseArray.As_PyTypeObject());
        PyModule_AddObject(module, "SparseArray",(PyObject *)&Dtool_SparseArray.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PythonCallbackObject | PythonCallbackObject
//********************************************************************
PyMethodDef Dtool_Methods_PythonCallbackObject[]= {
  { "setFunction",(PyCFunction ) &Dtool_PythonCallbackObject_set_function_775, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonCallbackObject_set_function_775_comment},
  { "getFunction",(PyCFunction ) &Dtool_PythonCallbackObject_get_function_776, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonCallbackObject_get_function_776_comment},
  { "getClassType",(PyCFunction ) &Dtool_PythonCallbackObject_get_class_type_777, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonCallbackObject_get_class_type_777_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PythonCallbackObject(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PythonCallbackObject.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PythonCallbackObject\n"
          "// Description : This is a specialization on CallbackObject to allow\n"
          "//               a callback to directly call an arbitarary Python\n"
          "//               function.  Powerful!  But use with caution.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CallbackObject._Dtool_ClassInit(NULL);
        Dtool_PythonCallbackObject.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CallbackObject.As_PyTypeObject());
        Dtool_PythonCallbackObject.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PythonCallbackObject.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PythonCallbackObject.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PythonCallbackObject.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PythonCallbackObject)");
             printf(" Error In PyType_ReadyPythonCallbackObject");
             return;
        }
        Py_INCREF(&Dtool_PythonCallbackObject.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PythonCallbackObject.As_PyTypeObject().tp_dict,"PythonCallbackObject",&Dtool_PythonCallbackObject.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PythonCallbackObject.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PythonCallbackObject[2],&Dtool_PythonCallbackObject.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PythonCallbackObject,PythonCallbackObject::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PythonCallbackObject.As_PyTypeObject());
        PyModule_AddObject(module, "PythonCallbackObject",(PyObject *)&Dtool_PythonCallbackObject.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WritableConfigurable | WritableConfigurable
//********************************************************************
PyMethodDef Dtool_Methods_WritableConfigurable[]= {
  { "getClassType",(PyCFunction ) &Dtool_WritableConfigurable_get_class_type_779, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WritableConfigurable_get_class_type_779_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_WritableConfigurable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WritableConfigurable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "// Defines\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WritableConfigurable\n"
          "// Description : Defined as a fix to allow creating Configurable and\n"
          "//               Writable objects.  Otherwise the compiler gets\n"
          "//               confused since both TypedWritable and Configurable\n"
          "//               inherit from TypedObject.\n"
          "//\n"
          "//               An object that has data or parameters that are set\n"
          "//               less frequently (at least occasionally) than every\n"
          "//               frame.  We can cache the configuration info by\n"
          "//               by using the \"dirty\" flag.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritable._Dtool_ClassInit(NULL);
        Dtool_WritableConfigurable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritable.As_PyTypeObject());
        Dtool_WritableConfigurable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WritableConfigurable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WritableConfigurable.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_WritableConfigurable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WritableConfigurable)");
             printf(" Error In PyType_ReadyWritableConfigurable");
             return;
        }
        Py_INCREF(&Dtool_WritableConfigurable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WritableConfigurable.As_PyTypeObject().tp_dict,"WritableConfigurable",&Dtool_WritableConfigurable.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_WritableConfigurable.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_WritableConfigurable[0],&Dtool_WritableConfigurable.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WritableConfigurable,WritableConfigurable::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WritableConfigurable.As_PyTypeObject());
        PyModule_AddObject(module, "WritableConfigurable",(PyObject *)&Dtool_WritableConfigurable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. UniqueIdAllocator | UniqueIdAllocator
//********************************************************************
PyMethodDef Dtool_Methods_UniqueIdAllocator[]= {
  { "allocate",(PyCFunction ) &Dtool_UniqueIdAllocator_allocate_784, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UniqueIdAllocator_allocate_784_comment},
  { "initialReserveId",(PyCFunction ) &Dtool_UniqueIdAllocator_initial_reserve_id_785, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UniqueIdAllocator_initial_reserve_id_785_comment},
  { "free",(PyCFunction ) &Dtool_UniqueIdAllocator_free_786, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UniqueIdAllocator_free_786_comment},
  { "fractionUsed",(PyCFunction ) &Dtool_UniqueIdAllocator_fraction_used_787, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UniqueIdAllocator_fraction_used_787_comment},
  { "output",(PyCFunction ) &Dtool_UniqueIdAllocator_output_788, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UniqueIdAllocator_output_788_comment},
  { "write",(PyCFunction ) &Dtool_UniqueIdAllocator_write_789, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UniqueIdAllocator_write_789_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     UniqueIdAllocator
//////////////////
static PyObject *  Dtool_Repr_UniqueIdAllocator(PyObject * self)
{
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     UniqueIdAllocator
//////////////////
static PyObject *  Dtool_Str_UniqueIdAllocator(PyObject * self)
{
    UniqueIdAllocator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UniqueIdAllocator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_UniqueIdAllocator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_UniqueIdAllocator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : UniqueIdAllocator\n"
          "// Description : Manage a set of ID values from min to max inclusive.\n"
          "//               The ID numbers that are freed will be allocated\n"
          "//               (reused) in the same order.  I.e. the oldest ID numbers\n"
          "//               will be allocated.\n"
          "//\n"
          "//               This implementation will use 4 bytes per id number,\n"
          "//               plus a few bytes of management data.  e.g. 10,000\n"
          "//               ID numbers will use 40KB.\n"
          "//\n"
          "//               Also be advised that ID -1 and -2 are used internally by\n"
          "//               the allocator.  If allocate returns IndexEnd (-1) then\n"
          "//               the allocator is out of free ID numbers.\n"
          "//\n"
          "//               There are other implementations that can better leverage\n"
          "//               runs of used or unused IDs or use bit arrays for the\n"
          "//               IDs.  But, it takes extra work to track the age of\n"
          "//               freed IDs, which is required for what we wanted.  If\n"
          "//               you would like to kick around other implementation\n"
          "//               ideas, please contact Schuyler.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_UniqueIdAllocator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_UniqueIdAllocator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_UniqueIdAllocator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_UniqueIdAllocator.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_UniqueIdAllocator.As_PyTypeObject().tp_repr = & Dtool_Repr_UniqueIdAllocator;
        // __str__
        Dtool_UniqueIdAllocator.As_PyTypeObject().tp_str = & Dtool_Str_UniqueIdAllocator;
        if(PyType_Ready(&Dtool_UniqueIdAllocator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(UniqueIdAllocator)");
             printf(" Error In PyType_ReadyUniqueIdAllocator");
             return;
        }
        Py_INCREF(&Dtool_UniqueIdAllocator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_UniqueIdAllocator.As_PyTypeObject().tp_dict,"UniqueIdAllocator",&Dtool_UniqueIdAllocator.As_PyObject());
        RegisterRuntimeClass(&Dtool_UniqueIdAllocator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_UniqueIdAllocator.As_PyTypeObject());
        PyModule_AddObject(module, "UniqueIdAllocator",(PyObject *)&Dtool_UniqueIdAllocator.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< double >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_double(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< double >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_double(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< double > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< unsigned short int >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_short_int(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< unsigned short int >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_short_int(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< unsigned short int > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_short_int(module);
//********************************************************************
//*** Module Init Updcall ..DoubleBitMask< BitMask< unsigned int, 32 > >
//********************************************************************
   Dtool_PyModuleClassInit_DoubleBitMask_BitMask_unsigned_int_32(module);
//********************************************************************
//*** Module Init Updcall ..DoubleBitMask< DoubleBitMask< BitMask< unsigned int, 32 > > >
//********************************************************************
   Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMask_BitMask_unsigned_int_32(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< double >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_double(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< unsigned short int >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_unsigned_short_int(module);
//********************************************************************
//*** Module Init Updcall ..basic_string< char >
//********************************************************************
   Dtool_PyModuleClassInit_basic_string_char(module);
//********************************************************************
//*** Module Init Updcall ..AnimInterface
//********************************************************************
   Dtool_PyModuleClassInit_AnimInterface(module);
//********************************************************************
//*** Module Init Updcall ..UpdateSeq
//********************************************************************
   Dtool_PyModuleClassInit_UpdateSeq(module);
//********************************************************************
//*** Module Init Updcall ..TypedWritable
//********************************************************************
   Dtool_PyModuleClassInit_TypedWritable(module);
//********************************************************************
//*** Module Init Updcall ..TypedWritableReferenceCount
//********************************************************************
   Dtool_PyModuleClassInit_TypedWritableReferenceCount(module);
//********************************************************************
//*** Module Init Updcall ..BamCacheRecord
//********************************************************************
   Dtool_PyModuleClassInit_BamCacheRecord(module);
//********************************************************************
//*** Module Init Updcall ..BamCache
//********************************************************************
   Dtool_PyModuleClassInit_BamCache(module);
//********************************************************************
//*** Module Init Updcall ..BamEnums
//********************************************************************
   Dtool_PyModuleClassInit_BamEnums(module);
//********************************************************************
//*** Module Init Updcall ..LoaderOptions
//********************************************************************
   Dtool_PyModuleClassInit_LoaderOptions(module);
//********************************************************************
//*** Module Init Updcall ..BamReader
//********************************************************************
   Dtool_PyModuleClassInit_BamReader(module);
//********************************************************************
//*** Module Init Updcall ..BamWriter
//********************************************************************
   Dtool_PyModuleClassInit_BamWriter(module);
//********************************************************************
//*** Module Init Updcall ..BitMask< unsigned int, 32 >
//********************************************************************
   Dtool_PyModuleClassInit_BitMask_unsigned_int_32(module);
//********************************************************************
//*** Module Init Updcall ..BitMask< unsigned __int64, 64 >
//********************************************************************
   Dtool_PyModuleClassInit_BitMask_unsigned_int64_64(module);
//********************************************************************
//*** Module Init Updcall ..BitArray
//********************************************************************
   Dtool_PyModuleClassInit_BitArray(module);
//********************************************************************
//*** Module Init Updcall ..ButtonHandle
//********************************************************************
   Dtool_PyModuleClassInit_ButtonHandle(module);
//********************************************************************
//*** Module Init Updcall ..ButtonRegistry
//********************************************************************
   Dtool_PyModuleClassInit_ButtonRegistry(module);
//********************************************************************
//*** Module Init Updcall ..CallbackObject
//********************************************************************
   Dtool_PyModuleClassInit_CallbackObject(module);
//********************************************************************
//*** Module Init Updcall ..CachedTypedWritableReferenceCount
//********************************************************************
   Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(module);
//********************************************************************
//*** Module Init Updcall ..CallbackData
//********************************************************************
   Dtool_PyModuleClassInit_CallbackData(module);
//********************************************************************
//*** Module Init Updcall ..TimeVal
//********************************************************************
   Dtool_PyModuleClassInit_TimeVal(module);
//********************************************************************
//*** Module Init Updcall ..ClockObject
//********************************************************************
   Dtool_PyModuleClassInit_ClockObject(module);
//********************************************************************
//*** Module Init Updcall ..CopyOnWriteObject
//********************************************************************
   Dtool_PyModuleClassInit_CopyOnWriteObject(module);
//********************************************************************
//*** Module Init Updcall ..KeyboardButton
//********************************************************************
   Dtool_PyModuleClassInit_KeyboardButton(module);
//********************************************************************
//*** Module Init Updcall ..LineStream
//********************************************************************
   Dtool_PyModuleClassInit_LineStream(module);
//********************************************************************
//*** Module Init Updcall ..ModifierButtons
//********************************************************************
   Dtool_PyModuleClassInit_ModifierButtons(module);
//********************************************************************
//*** Module Init Updcall ..MouseButton
//********************************************************************
   Dtool_PyModuleClassInit_MouseButton(module);
//********************************************************************
//*** Module Init Updcall ..MouseData
//********************************************************************
   Dtool_PyModuleClassInit_MouseData(module);
//********************************************************************
//*** Module Init Updcall ..NodeCachedReferenceCount
//********************************************************************
   Dtool_PyModuleClassInit_NodeCachedReferenceCount(module);
//********************************************************************
//*** Module Init Updcall ..SparseArray
//********************************************************************
   Dtool_PyModuleClassInit_SparseArray(module);
//********************************************************************
//*** Module Init Updcall ..PythonCallbackObject
//********************************************************************
   Dtool_PyModuleClassInit_PythonCallbackObject(module);
//********************************************************************
//*** Module Init Updcall ..WritableConfigurable
//********************************************************************
   Dtool_PyModuleClassInit_WritableConfigurable(module);
//********************************************************************
//*** Module Init Updcall ..UniqueIdAllocator
//********************************************************************
   Dtool_PyModuleClassInit_UniqueIdAllocator(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "pyDecodeTypedWritableFromBamStream", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_py_decode_TypedWritable_from_bam_stream_226_comment},
  { "pyDecodeTypedWritableFromBamStreamPersist", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_persist_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_py_decode_TypedWritable_from_bam_stream_persist_227_comment},
  { "getModelPath", (PyCFunction) &Dtool_get_model_path_592, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_model_path_592_comment},
  { "getPluginPath", (PyCFunction) &Dtool_get_plugin_path_593, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_plugin_path_593_comment},
  { "loadPrcFile", (PyCFunction) &Dtool_load_prc_file_656, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_load_prc_file_656_comment},
  { "loadPrcFileData", (PyCFunction) &Dtool_load_prc_file_data_657, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_load_prc_file_data_657_comment},
  { "unloadPrcFile", (PyCFunction) &Dtool_unload_prc_file_658, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_unload_prc_file_658_comment},
  { "hashPrcVariables", (PyCFunction) &Dtool_hash_prc_variables_659, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_hash_prc_variables_659_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libputil_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212821,  /* file_identifier */
  "libputil",  /* library_name */
  "flbo",  /* library_hash_name */
  "panda",  /* module_name */
  "libputil.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1695  /* next_index */
};

Configure(_in_configure_libputil);
ConfigureFn(_in_configure_libputil) {
  interrogate_request_module(&_in_module_def);
}

