/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/dgraph -Ipanda/src/dgraph -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdgraph_igate.cxx -od built_Rocket/pandac/input/libdgraph.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/dgraph -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libdgraph config_dgraph.h dataGraphTraverser.h dataNode.h dataNodeTransmit.h dgraph_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdgraph
#include "py_panda.h"  

#include "config_dgraph.h"
#include "dataGraphTraverser.h"
#include "dataNode.h"
#include "dataNodeTransmit.h"
#include "notifyCategoryProxy.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. DataGraphTraverser
//********************************************************************
typedef  DataGraphTraverser  DataGraphTraverser_localtype;
Define_Module_Class(panda,DataGraphTraverser,DataGraphTraverser_localtype,DataGraphTraverser);
//********************************************************************
//*** prototypes for .. DataNode
//********************************************************************
typedef  DataNode  DataNode_localtype;
Define_Module_ClassRef(panda,DataNode,DataNode_localtype,DataNode);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Thread;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. DataGraphTraverser 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Thread *DataGraphTraverser::get_current_thread(void) const
 *******************************************************************/
static PyObject *Dtool_DataGraphTraverser_get_current_thread_4(PyObject *self, PyObject *args,PyObject *kwds) {
    DataGraphTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DataGraphTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Thread *DataGraphTraverser::get_current_thread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentThread", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentThread"));
        if(!PyErr_Occurred())
        {
            Thread *return_value = ((const DataGraphTraverser*)local_this)->get_current_thread();
            if (return_value != (Thread *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Thread,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentThread(const DataGraphTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataGraphTraverser_get_current_thread_4_comment =
    "C++ Interface:\n"
    "getCurrentThread(const DataGraphTraverser this)\n"
    "\n"
    "// Filename: dataGraphTraverser.I\n"
    "// Created by:  drose (11Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DataGraphTraverser::get_current_thread\n"
    "//       Access: Public\n"
    "//  Description: Returns the currently-executing thread object, as\n"
    "//               passed to the DataGraphTraverser constructor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DataGraphTraverser_get_current_thread_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DataGraphTraverser::traverse(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_DataGraphTraverser_traverse_5(PyObject *self, PyObject *args,PyObject *kwds) {
    DataGraphTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DataGraphTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DataGraphTraverser::traverse(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:traverse", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:traverse", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DataGraphTraverser.traverse", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->traverse(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DataGraphTraverser.traverse() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "traverse(non-const DataGraphTraverser this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataGraphTraverser_traverse_5_comment =
    "C++ Interface:\n"
    "traverse(non-const DataGraphTraverser this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DataGraphTraverser::traverse\n"
    "//       Access: Public\n"
    "//  Description: Starts the traversal of the data graph at the\n"
    "//               indicated root node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DataGraphTraverser_traverse_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DataGraphTraverser::collect_leftovers(void)
 *******************************************************************/
static PyObject *Dtool_DataGraphTraverser_collect_leftovers_7(PyObject *self, PyObject *args,PyObject *kwds) {
    DataGraphTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DataGraphTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DataGraphTraverser::collect_leftovers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":collectLeftovers", key_word_list));
        else
            (PyArg_Parse(args, ":collectLeftovers"));
        if(!PyErr_Occurred())
        {
            (local_this)->collect_leftovers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DataGraphTraverser.collectLeftovers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "collectLeftovers(non-const DataGraphTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataGraphTraverser_collect_leftovers_7_comment =
    "C++ Interface:\n"
    "collectLeftovers(non-const DataGraphTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DataGraphTraverser::collect_leftovers\n"
    "//       Access: Public\n"
    "//  Description: Pick up any nodes that didn't get completely\n"
    "//               traversed.  These must be nodes that have multiple\n"
    "//               parents, with at least one parent completely outside\n"
    "//               of the data graph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DataGraphTraverser_collect_leftovers_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DataGraphTraverser::DataGraphTraverser(Thread *current_thread)
 * DataGraphTraverser::DataGraphTraverser(Thread *current_thread = ((get_current_thread())))
 *******************************************************************/
int  Dtool_Init_DataGraphTraverser(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DataGraphTraverser::DataGraphTraverser(Thread *current_thread = ((get_current_thread())))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DataGraphTraverser", key_word_list))
            {
                DataGraphTraverser *return_value = new DataGraphTraverser();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DataGraphTraverser,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-DataGraphTraverser::DataGraphTraverser(Thread *current_thread)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DataGraphTraverser", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DataGraphTraverser", &param0));
                if(!PyErr_Occurred())
                {
                    Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Thread, 0, "DataGraphTraverser.DataGraphTraverser", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        DataGraphTraverser *return_value = new DataGraphTraverser(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DataGraphTraverser,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DataGraphTraverser() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DataGraphTraverser()\n"
          "DataGraphTraverser(non-const Thread current_thread)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DataGraphTraverser(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DataGraphTraverser)
    {
        printf("DataGraphTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DataGraphTraverser * local_this = (DataGraphTraverser *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DataGraphTraverser)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DataGraphTraverser(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DataGraphTraverser)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DataNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DataNode::write_inputs(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DataNode_write_inputs_11(PyObject *self, PyObject *args,PyObject *kwds) {
    DataNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DataNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DataNode::write_inputs(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeInputs", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeInputs", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DataNode.writeInputs", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DataNode*)local_this)->write_inputs(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeInputs(const DataNode this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataNode_write_inputs_11_comment =
    "C++ Interface:\n"
    "writeInputs(const DataNode this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DataNode::write_inputs\n"
    "//       Access: Published\n"
    "//  Description: Writes to the indicated ostream a list of all the\n"
    "//               inputs this DataNode might expect to receive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DataNode_write_inputs_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DataNode::write_outputs(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DataNode_write_outputs_12(PyObject *self, PyObject *args,PyObject *kwds) {
    DataNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DataNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DataNode::write_outputs(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeOutputs", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeOutputs", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DataNode.writeOutputs", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DataNode*)local_this)->write_outputs(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeOutputs(const DataNode this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataNode_write_outputs_12_comment =
    "C++ Interface:\n"
    "writeOutputs(const DataNode this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DataNode::write_outputs\n"
    "//       Access: Published\n"
    "//  Description: Writes to the indicated ostream a list of all the\n"
    "//               outputs this DataNode might generate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DataNode_write_outputs_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DataNode::write_connections(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DataNode_write_connections_13(PyObject *self, PyObject *args,PyObject *kwds) {
    DataNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DataNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DataNode::write_connections(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeConnections", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeConnections", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DataNode.writeConnections", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DataNode*)local_this)->write_connections(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeConnections(const DataNode this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataNode_write_connections_13_comment =
    "C++ Interface:\n"
    "writeConnections(const DataNode this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DataNode::write_connections\n"
    "//       Access: Published\n"
    "//  Description: Writes to the indicated ostream a list of all the\n"
    "//               connections currently showing between this DataNode\n"
    "//               and its parent(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DataNode_write_connections_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DataNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DataNode_get_class_type_14(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DataNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DataNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DataNode_get_class_type_14_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DataNode_get_class_type_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DataNode::DataNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_DataNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline DataNode::DataNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DataNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DataNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DataNode *return_value = new DataNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DataNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DataNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DataNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DataNode)
    {
        printf("DataNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DataNode * local_this = (DataNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DataNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DataNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DataNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DataNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (DataNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DataNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (DataNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. DataGraphTraverser | DataGraphTraverser
//********************************************************************
PyMethodDef Dtool_Methods_DataGraphTraverser[]= {
  { "getCurrentThread",(PyCFunction ) &Dtool_DataGraphTraverser_get_current_thread_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataGraphTraverser_get_current_thread_4_comment},
  { "traverse",(PyCFunction ) &Dtool_DataGraphTraverser_traverse_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataGraphTraverser_traverse_5_comment},
  { "collectLeftovers",(PyCFunction ) &Dtool_DataGraphTraverser_collect_leftovers_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataGraphTraverser_collect_leftovers_7_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DataGraphTraverser(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DataGraphTraverser.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DataGraphTraverser\n"
          "// Description : This object supervises the traversal of the data\n"
          "//               graph and the moving of data from one DataNode to its\n"
          "//               children.  The data graph is used to manage data from\n"
          "//               input devices, etc.  See the overview of the data\n"
          "//               graph in dataNode.h.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DataGraphTraverser.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DataGraphTraverser.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DataGraphTraverser.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DataGraphTraverser.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DataGraphTraverser.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DataGraphTraverser)");
             printf(" Error In PyType_ReadyDataGraphTraverser");
             return;
        }
        Py_INCREF(&Dtool_DataGraphTraverser.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DataGraphTraverser.As_PyTypeObject().tp_dict,"DataGraphTraverser",&Dtool_DataGraphTraverser.As_PyObject());
        RegisterRuntimeClass(&Dtool_DataGraphTraverser,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DataGraphTraverser.As_PyTypeObject());
        PyModule_AddObject(module, "DataGraphTraverser",(PyObject *)&Dtool_DataGraphTraverser.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DataNode | DataNode
//********************************************************************
PyMethodDef Dtool_Methods_DataNode[]= {
  { "writeInputs",(PyCFunction ) &Dtool_DataNode_write_inputs_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataNode_write_inputs_11_comment},
  { "writeOutputs",(PyCFunction ) &Dtool_DataNode_write_outputs_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataNode_write_outputs_12_comment},
  { "writeConnections",(PyCFunction ) &Dtool_DataNode_write_connections_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataNode_write_connections_13_comment},
  { "getClassType",(PyCFunction ) &Dtool_DataNode_get_class_type_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DataNode_get_class_type_14_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DataNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DataNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DataNode\n"
          "// Description : The fundamental type of node for the data graph.  The\n"
          "//               DataNode class is itself primarily intended as an\n"
          "//               abstract class; it defines no inputs and no outputs.\n"
          "//               Most kinds of data nodes will derive from this to\n"
          "//               specify the inputs and outputs in the constructor.\n"
          "//\n"
          "//               DataNode does not attempt to cycle its data with a\n"
          "//               PipelineCycler.  The data graph is intended to be\n"
          "//               used only within a single thread.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_DataNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_DataNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DataNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DataNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DataNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DataNode)");
             printf(" Error In PyType_ReadyDataNode");
             return;
        }
        Py_INCREF(&Dtool_DataNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DataNode.As_PyTypeObject().tp_dict,"DataNode",&Dtool_DataNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DataNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DataNode[3],&Dtool_DataNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DataNode,DataNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DataNode.As_PyTypeObject());
        PyModule_AddObject(module, "DataNode",(PyObject *)&Dtool_DataNode.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..DataGraphTraverser
//********************************************************************
   Dtool_PyModuleClassInit_DataGraphTraverser(module);
//********************************************************************
//*** Module Init Updcall ..DataNode
//********************************************************************
   Dtool_PyModuleClassInit_DataNode(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdgraph_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212868,  /* file_identifier */
  "libdgraph",  /* library_name */
  "SLSe",  /* library_hash_name */
  "panda",  /* module_name */
  "libdgraph.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  45  /* next_index */
};

Configure(_in_configure_libdgraph);
ConfigureFn(_in_configure_libdgraph) {
  interrogate_request_module(&_in_module_def);
}

