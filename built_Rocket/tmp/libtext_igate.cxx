/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/text -Ipanda/src/text -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libtext_igate.cxx -od built_Rocket/pandac/input/libtext.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/text -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/zlib/include -Sthirdparty/win-libs-vc9/freetype/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libtext config_text.h default_font.h dynamicTextFont.h dynamicTextGlyph.h dynamicTextPage.h fontPool.h geomTextGlyph.h staticTextFont.h textAssembler.h textFont.h textGlyph.h textGraphic.h textNode.h textProperties.h textPropertiesManager.h text_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libtext
#include "py_panda.h"  

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "config_text.h"
#include "default_font.h"
#include "dynamicTextFont.h"
#include "dynamicTextGlyph.h"
#include "dynamicTextPage.h"
#include "filename.h"
#include "fontPool.h"
#include "freetypeFont.h"
#include <ft2build.h>
#include "geom.h"
#include "geomNode.h"
#include "geomTextGlyph.h"
#include "geomVertexRewriter.h"
#include "lightMutex.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "staticTextFont.h"
#include "textAssembler.h"
#include "textEncoder.h"
#include "textFont.h"
#include "textGlyph.h"
#include "textGraphic.h"
#include "textNode.h"
#include "textProperties.h"
#include "textPropertiesManager.h"
#include "texture.h"
#include "unicodeLatinMap.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. TextFont
//********************************************************************
typedef  TextFont  TextFont_localtype;
Define_Module_ClassRef(panda,TextFont,TextFont_localtype,TextFont);
//********************************************************************
//*** prototypes for .. DynamicTextPage
//********************************************************************
typedef  DynamicTextPage  DynamicTextPage_localtype;
Define_Module_ClassRef(panda,DynamicTextPage,DynamicTextPage_localtype,DynamicTextPage);
//********************************************************************
//*** prototypes for .. DynamicTextFont
//********************************************************************
typedef  DynamicTextFont  DynamicTextFont_localtype;
Define_Module_ClassRef(panda,DynamicTextFont,DynamicTextFont_localtype,DynamicTextFont);
//********************************************************************
//*** prototypes for .. FontPool
//********************************************************************
typedef  FontPool  FontPool_localtype;
Define_Module_Class(panda,FontPool,FontPool_localtype,FontPool);
//********************************************************************
//*** prototypes for .. GeomTextGlyph
//********************************************************************
typedef  GeomTextGlyph  GeomTextGlyph_localtype;
Define_Module_ClassRef(panda,GeomTextGlyph,GeomTextGlyph_localtype,GeomTextGlyph);
//********************************************************************
//*** prototypes for .. StaticTextFont
//********************************************************************
typedef  StaticTextFont  StaticTextFont_localtype;
Define_Module_ClassRef(panda,StaticTextFont,StaticTextFont_localtype,StaticTextFont);
//********************************************************************
//*** prototypes for .. TextProperties
//********************************************************************
typedef  TextProperties  TextProperties_localtype;
Define_Module_Class(panda,TextProperties,TextProperties_localtype,TextProperties);
//********************************************************************
//*** prototypes for .. TextGraphic
//********************************************************************
typedef  TextGraphic  TextGraphic_localtype;
Define_Module_Class(panda,TextGraphic,TextGraphic_localtype,TextGraphic);
//********************************************************************
//*** prototypes for .. TextPropertiesManager
//********************************************************************
typedef  TextPropertiesManager  TextPropertiesManager_localtype;
Define_Module_Class_Private(panda,TextPropertiesManager,TextPropertiesManager_localtype,TextPropertiesManager);
//********************************************************************
//*** prototypes for .. TextAssembler
//********************************************************************
typedef  TextAssembler  TextAssembler_localtype;
Define_Module_Class(panda,TextAssembler,TextAssembler_localtype,TextAssembler);
//********************************************************************
//*** prototypes for .. TextNode
//********************************************************************
typedef  TextNode  TextNode_localtype;
Define_Module_ClassRef(panda,TextNode,TextNode_localtype,TextNode);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CopyOnWriteObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_FreetypeFont;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Geom;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GeomEnums;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextEncoder;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. TextFont 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0
 *******************************************************************/
static PyObject *Dtool_TextFont_make_copy_11(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            PointerTo< TextFont > return_value = ((const TextFont*)local_this)->make_copy();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_TextFont,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_make_copy_11_comment =
    "C++ Interface:\n"
    "makeCopy(const TextFont this)\n"
    "\n"
    "";
#else
static const char * Dtool_TextFont_make_copy_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextFont::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_TextFont_is_valid_12(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextFont::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextFont*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_is_valid_12_comment =
    "C++ Interface:\n"
    "isValid(const TextFont this)\n"
    "\n"
    "// Filename: textFont.I\n"
    "// Created by:  drose (08Feb02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the font is valid and ready to use,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_is_valid_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextFont::get_line_height(void) const
 *******************************************************************/
static PyObject *Dtool_TextFont_get_line_height_14(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextFont::get_line_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLineHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getLineHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextFont*)local_this)->get_line_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLineHeight(const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_get_line_height_14_comment =
    "C++ Interface:\n"
    "getLineHeight(const TextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::get_line_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of units high each line of text\n"
    "//               is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_get_line_height_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextFont::set_line_height(float line_height)
 *******************************************************************/
static PyObject *Dtool_TextFont_set_line_height_15(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextFont::set_line_height(float line_height)
        double param1;
        static char * key_word_list[] = {(char *)"line_height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLineHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLineHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_line_height((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextFont.setLineHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLineHeight(non-const TextFont this, float line_height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_set_line_height_15_comment =
    "C++ Interface:\n"
    "setLineHeight(non-const TextFont this, float line_height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::set_line_height\n"
    "//       Access: Published\n"
    "//  Description: Changes the number of units high each line of text\n"
    "//               is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_set_line_height_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextFont::get_space_advance(void) const
 *******************************************************************/
static PyObject *Dtool_TextFont_get_space_advance_16(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextFont::get_space_advance(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpaceAdvance", key_word_list));
        else
            (PyArg_Parse(args, ":getSpaceAdvance"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextFont*)local_this)->get_space_advance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpaceAdvance(const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_get_space_advance_16_comment =
    "C++ Interface:\n"
    "getSpaceAdvance(const TextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::get_space_advance\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of units wide a space is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_get_space_advance_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextFont::set_space_advance(float space_advance)
 *******************************************************************/
static PyObject *Dtool_TextFont_set_space_advance_17(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextFont::set_space_advance(float space_advance)
        double param1;
        static char * key_word_list[] = {(char *)"space_advance", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSpaceAdvance", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSpaceAdvance", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_space_advance((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextFont.setSpaceAdvance() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpaceAdvance(non-const TextFont this, float space_advance)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_set_space_advance_17_comment =
    "C++ Interface:\n"
    "setSpaceAdvance(non-const TextFont this, float space_advance)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::set_space_advance\n"
    "//       Access: Published\n"
    "//  Description: Changes the number of units wide a space is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_set_space_advance_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void TextFont::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_TextFont_write_18(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void TextFont::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextFont.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const TextFont*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const TextFont this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_write_18_comment =
    "C++ Interface:\n"
    "write(const TextFont this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::write\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_write_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TextFont::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TextFont_get_class_type_19(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TextFont::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TextFont::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_get_class_type_19_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TextFont_get_class_type_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextFont::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_TextFont_operator_typecast_bool_13(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextFont::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const TextFont*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_operator_typecast_bool_13_comment =
    "C++ Interface:\n"
    "__nonzero__(const TextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextFont::operator bool\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the font is valid and ready to use,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextFont_operator_typecast_bool_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_TextFont_upcast_to_TypedReferenceCount_3(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextFont.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_upcast_to_TypedReferenceCount_3_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const TextFont this)\n"
    "\n"
    "upcast from TextFont to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_TextFont_upcast_to_TypedReferenceCount_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *TextFont::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_TextFont_upcast_to_Namable_6(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *TextFont::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextFont.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_upcast_to_Namable_6_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const TextFont this)\n"
    "\n"
    "upcast from TextFont to Namable\n"
    "";
#else
static const char * Dtool_TextFont_upcast_to_Namable_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DynamicTextFont *TextFont::downcast_to_DynamicTextFont(void)
 *******************************************************************/
static PyObject *Dtool_TextFont_downcast_to_DynamicTextFont_27(PyObject *self, PyObject *args,PyObject *kwds) {
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DynamicTextFont *TextFont::downcast_to_DynamicTextFont(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDynamicTextFont", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDynamicTextFont"));
        if(!PyErr_Occurred())
        {
            DynamicTextFont *return_value = (DynamicTextFont *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DynamicTextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextFont.downcastToDynamicTextFont() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDynamicTextFont(non-const TextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextFont_downcast_to_DynamicTextFont_27_comment =
    "C++ Interface:\n"
    "downcastToDynamicTextFont(non-const TextFont this)\n"
    "\n"
    "downcast from TextFont to DynamicTextFont\n"
    "";
#else
static const char * Dtool_TextFont_downcast_to_DynamicTextFont_27_comment = NULL;
#endif

int  Dtool_Init_TextFont(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TextFont)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TextFont(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextFont)
    {
        printf("TextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextFont * local_this = (TextFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextFont)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextFont(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextFont)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (TextFont*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (TextFont*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TextFont*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (TextFont*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DynamicTextPage 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool DynamicTextPage::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextPage_is_empty_22(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DynamicTextPage::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DynamicTextPage*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const DynamicTextPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextPage_is_empty_22_comment =
    "C++ Interface:\n"
    "isEmpty(const DynamicTextPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextPage::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the page has no glyphs, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextPage_is_empty_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DynamicTextPage::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DynamicTextPage_get_class_type_23(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DynamicTextPage::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DynamicTextPage::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextPage_get_class_type_23_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DynamicTextPage_get_class_type_23_comment = NULL;
#endif

int  Dtool_Init_DynamicTextPage(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DynamicTextPage)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DynamicTextPage(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DynamicTextPage)
    {
        printf("DynamicTextPage ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DynamicTextPage * local_this = (DynamicTextPage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DynamicTextPage)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Texture *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Texture *) local_this;
    if(requested_type == &Dtool_Texture)
        return ( Texture *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Texture *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Texture *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Texture *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DynamicTextPage(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DynamicTextPage)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DynamicTextPage*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DynamicTextPage*)other_this;
    }
    if(from_type == &Dtool_Texture)
    {
          Texture* other_this = (Texture*)from_this;
          return (DynamicTextPage*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DynamicTextPage*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (DynamicTextPage*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (DynamicTextPage*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DynamicTextFont 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_make_copy_33(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            PointerTo< TextFont > return_value = ((const DynamicTextFont*)local_this)->make_copy();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_TextFont,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_make_copy_33_comment =
    "C++ Interface:\n"
    "makeCopy(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::make_copy\n"
    "//       Access: Published\n"
    "//  Description: Returns a new copy of the same font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_make_copy_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &DynamicTextFont::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_name_34(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &DynamicTextFont::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DynamicTextFont*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_name_34_comment =
    "C++ Interface:\n"
    "getName(const DynamicTextFont this)\n"
    "\n"
    "// Filename: dynamicTextFont.I\n"
    "// Created by:  drose (08Feb02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_name\n"
    "//       Access: Published\n"
    "//  Description: Disambiguates the get_name() method between that\n"
    "//               inherited from TextFont and that inherited from\n"
    "//               FreetypeFont.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_name_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DynamicTextFont::set_point_size(float point_size)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_point_size_35(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool DynamicTextFont::set_point_size(float point_size)
        double param1;
        static char * key_word_list[] = {(char *)"point_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPointSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPointSize", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_point_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setPointSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPointSize(non-const DynamicTextFont this, float point_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_point_size_35_comment =
    "C++ Interface:\n"
    "setPointSize(non-const DynamicTextFont this, float point_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_point_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the point size of the font.  This controls the\n"
    "//               apparent size of the font onscreen.  By convention, a\n"
    "//               10 point font is about 1 screen unit high.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_point_size_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_point_size(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_point_size_36(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_point_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPointSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_point_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointSize(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_point_size_36_comment =
    "C++ Interface:\n"
    "getPointSize(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_point_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the point size of the font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_point_size_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DynamicTextFont::set_pixels_per_unit(float pixels_per_unit)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_pixels_per_unit_37(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool DynamicTextFont::set_pixels_per_unit(float pixels_per_unit)
        double param1;
        static char * key_word_list[] = {(char *)"pixels_per_unit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPixelsPerUnit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPixelsPerUnit", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_pixels_per_unit((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setPixelsPerUnit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPixelsPerUnit(non-const DynamicTextFont this, float pixels_per_unit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_pixels_per_unit_37_comment =
    "C++ Interface:\n"
    "setPixelsPerUnit(non-const DynamicTextFont this, float pixels_per_unit)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_pixels_per_unit\n"
    "//       Access: Published\n"
    "//  Description: Set the resolution of the texture map, and hence the\n"
    "//               clarity of the resulting font.  This sets the number\n"
    "//               of pixels in the texture map that are used for each\n"
    "//               onscreen unit.\n"
    "//\n"
    "//               Setting this number larger results in an easier to\n"
    "//               read font, but at the cost of more texture memory.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_pixels_per_unit_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_pixels_per_unit(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_pixels_per_unit_38(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_pixels_per_unit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPixelsPerUnit", key_word_list));
        else
            (PyArg_Parse(args, ":getPixelsPerUnit"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_pixels_per_unit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixelsPerUnit(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_pixels_per_unit_38_comment =
    "C++ Interface:\n"
    "getPixelsPerUnit(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_pixels_per_unit\n"
    "//       Access: Published\n"
    "//  Description: Returns the resolution of the texture map.  See\n"
    "//               set_pixels_per_unit().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_pixels_per_unit_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DynamicTextFont::set_scale_factor(float scale_factor)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_scale_factor_39(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool DynamicTextFont::set_scale_factor(float scale_factor)
        double param1;
        static char * key_word_list[] = {(char *)"scale_factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setScaleFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setScaleFactor", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_scale_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setScaleFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScaleFactor(non-const DynamicTextFont this, float scale_factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_scale_factor_39_comment =
    "C++ Interface:\n"
    "setScaleFactor(non-const DynamicTextFont this, float scale_factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_scale_factor\n"
    "//       Access: Published\n"
    "//  Description: Sets the factor by which the font is rendered larger\n"
    "//               by the FreeType library before being filtered down to\n"
    "//               its actual size in the texture as specified by\n"
    "//               set_pixels_per_unit().  This may be set to a number\n"
    "//               larger than 1.0 to improve the font's antialiasing\n"
    "//               (since FreeType doesn't really do a swell job of\n"
    "//               antialiasing by itself).  There is some performance\n"
    "//               implication for setting this different than 1.0, but\n"
    "//               it is probably small.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_scale_factor_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_scale_factor(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_scale_factor_40(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_scale_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScaleFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getScaleFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_scale_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScaleFactor(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_scale_factor_40_comment =
    "C++ Interface:\n"
    "getScaleFactor(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_scale_factor\n"
    "//       Access: Published\n"
    "//  Description: Returns the antialiasing scale factor.  See\n"
    "//               set_scale_factor().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_scale_factor_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_native_antialias(bool native_antialias)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_native_antialias_41(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_native_antialias(bool native_antialias)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"native_antialias", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNativeAntialias", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setNativeAntialias", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_native_antialias((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setNativeAntialias() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNativeAntialias(non-const DynamicTextFont this, bool native_antialias)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_native_antialias_41_comment =
    "C++ Interface:\n"
    "setNativeAntialias(non-const DynamicTextFont this, bool native_antialias)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_native_antialias\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the Freetype library's built-in\n"
    "//               antialias mode is enabled.  There are two unrelated\n"
    "//               ways to achieve antialiasing: with Freetype's native\n"
    "//               antialias mode, and with the use of a scale_factor\n"
    "//               greater than one.  By default, both modes are\n"
    "//               enabled.\n"
    "//\n"
    "//               At low resolutions, some fonts may do better with one\n"
    "//               mode or the other.  In general, Freetype's native\n"
    "//               antialiasing will produce less blurry results, but\n"
    "//               may introduce more artifacts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_native_antialias_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DynamicTextFont::get_native_antialias(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_native_antialias_42(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DynamicTextFont::get_native_antialias(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNativeAntialias", key_word_list));
        else
            (PyArg_Parse(args, ":getNativeAntialias"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DynamicTextFont*)local_this)->get_native_antialias();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNativeAntialias(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_native_antialias_42_comment =
    "C++ Interface:\n"
    "getNativeAntialias(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_native_antialias\n"
    "//       Access: Published\n"
    "//  Description: Returns whether Freetype's built-in antialias mode is\n"
    "//               enabled.  See set_native_antialias().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_native_antialias_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DynamicTextFont::get_font_pixel_size(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_font_pixel_size_43(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DynamicTextFont::get_font_pixel_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFontPixelSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFontPixelSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DynamicTextFont*)local_this)->get_font_pixel_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFontPixelSize(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_font_pixel_size_43_comment =
    "C++ Interface:\n"
    "getFontPixelSize(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_font_pixel_size\n"
    "//       Access: Published\n"
    "//  Description: This is used to report whether the requested pixel\n"
    "//               size is being only approximated by a fixed-pixel-size\n"
    "//               font.  This returns 0 in the normal case, in which a\n"
    "//               scalable font is used, or the fixed-pixel-size font\n"
    "//               has exactly the requested pixel size.\n"
    "//\n"
    "//               If this returns non-zero, it is the pixel size of the\n"
    "//               font that we are using to approximate our desired\n"
    "//               size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_font_pixel_size_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_line_height(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_line_height_44(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_line_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLineHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getLineHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_line_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLineHeight(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_line_height_44_comment =
    "C++ Interface:\n"
    "getLineHeight(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_line_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of units high each line of text\n"
    "//               is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_line_height_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_space_advance(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_space_advance_45(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_space_advance(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpaceAdvance", key_word_list));
        else
            (PyArg_Parse(args, ":getSpaceAdvance"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_space_advance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpaceAdvance(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_space_advance_45_comment =
    "C++ Interface:\n"
    "getSpaceAdvance(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_space_advance\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of units wide a space is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_space_advance_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_texture_margin(int texture_margin)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_texture_margin_46(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_texture_margin(int texture_margin)
        int param1;
        static char * key_word_list[] = {(char *)"texture_margin", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTextureMargin", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTextureMargin", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_texture_margin((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setTextureMargin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextureMargin(non-const DynamicTextFont this, int texture_margin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_texture_margin_46_comment =
    "C++ Interface:\n"
    "setTextureMargin(non-const DynamicTextFont this, int texture_margin)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_texture_margin\n"
    "//       Access: Published\n"
    "//  Description: Sets the number of pixels of padding that is added\n"
    "//               around the border of each glyph before adding it to\n"
    "//               the texture map.  This reduces the bleed in from\n"
    "//               neighboring glyphs in the texture map.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_texture_margin_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DynamicTextFont::get_texture_margin(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_texture_margin_47(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DynamicTextFont::get_texture_margin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureMargin", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureMargin"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DynamicTextFont*)local_this)->get_texture_margin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureMargin(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_texture_margin_47_comment =
    "C++ Interface:\n"
    "getTextureMargin(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_texture_margin\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pixels of padding that is added\n"
    "//               around the border of each glyph in the texture map.\n"
    "//               See set_texture_margin().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_texture_margin_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_poly_margin(float poly_margin)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_poly_margin_48(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_poly_margin(float poly_margin)
        double param1;
        static char * key_word_list[] = {(char *)"poly_margin", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPolyMargin", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPolyMargin", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_poly_margin((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setPolyMargin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPolyMargin(non-const DynamicTextFont this, float poly_margin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_poly_margin_48_comment =
    "C++ Interface:\n"
    "setPolyMargin(non-const DynamicTextFont this, float poly_margin)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_poly_margin\n"
    "//       Access: Published\n"
    "//  Description: Sets the number of pixels of padding that is included\n"
    "//               around each glyph in the generated polygons.  This\n"
    "//               helps prevent the edges of the glyphs from being cut\n"
    "//               off at small minifications.  It is not related to the\n"
    "//               amount of extra pixels reserved in the texture map\n"
    "//               (but it should be set somewhat smaller than this\n"
    "//               number, which is controlled by set_texture_margin(),\n"
    "//               to prevent bleed-in from neighboring letters in the\n"
    "//               texture).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_poly_margin_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_poly_margin(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_poly_margin_49(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_poly_margin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPolyMargin", key_word_list));
        else
            (PyArg_Parse(args, ":getPolyMargin"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_poly_margin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPolyMargin(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_poly_margin_49_comment =
    "C++ Interface:\n"
    "getPolyMargin(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_poly_margin\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pixels of padding that is\n"
    "//               included around each glyph in the generated polygons.\n"
    "//               See set_poly_margin().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_poly_margin_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_page_size(int x_size, int y_size)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_page_size_50(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_page_size(int x_size, int y_size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setPageSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_page_size((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setPageSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPageSize(non-const DynamicTextFont this, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_page_size_50_comment =
    "C++ Interface:\n"
    "setPageSize(non-const DynamicTextFont this, int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_page_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the x, y size of the textures that are created\n"
    "//               for the DynamicTextFont.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_page_size_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DynamicTextFont::get_page_x_size(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_page_x_size_51(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DynamicTextFont::get_page_x_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageXSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPageXSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DynamicTextFont*)local_this)->get_page_x_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageXSize(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_page_x_size_51_comment =
    "C++ Interface:\n"
    "getPageXSize(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_page_x_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the x size of the textures that are created\n"
    "//               for the DynamicTextFont.  See set_page_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_page_x_size_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DynamicTextFont::get_page_y_size(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_page_y_size_52(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DynamicTextFont::get_page_y_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageYSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPageYSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DynamicTextFont*)local_this)->get_page_y_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageYSize(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_page_y_size_52_comment =
    "C++ Interface:\n"
    "getPageYSize(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_page_y_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the y size of the textures that are created\n"
    "//               for the DynamicTextFont.  See set_page_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_page_y_size_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_minfilter(Texture::FilterType filter)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_minfilter_53(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_minfilter(Texture::FilterType filter)
        int param1;
        static char * key_word_list[] = {(char *)"filter", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMinfilter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMinfilter", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_minfilter((Texture::FilterType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setMinfilter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinfilter(non-const DynamicTextFont this, int filter)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_minfilter_53_comment =
    "C++ Interface:\n"
    "setMinfilter(non-const DynamicTextFont this, int filter)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_minfilter\n"
    "//       Access: Published\n"
    "//  Description: Sets the filter type used when minimizing the\n"
    "//               textures created for this font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_minfilter_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture::FilterType DynamicTextFont::get_minfilter(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_minfilter_54(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Texture::FilterType DynamicTextFont::get_minfilter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinfilter", key_word_list));
        else
            (PyArg_Parse(args, ":getMinfilter"));
        if(!PyErr_Occurred())
        {
            Texture::FilterType return_value = ((const DynamicTextFont*)local_this)->get_minfilter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinfilter(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_minfilter_54_comment =
    "C++ Interface:\n"
    "getMinfilter(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_minfilter\n"
    "//       Access: Published\n"
    "//  Description: Returns the filter type used when minimizing the\n"
    "//               textures created for this font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_minfilter_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_magfilter(Texture::FilterType filter)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_magfilter_55(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_magfilter(Texture::FilterType filter)
        int param1;
        static char * key_word_list[] = {(char *)"filter", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMagfilter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMagfilter", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_magfilter((Texture::FilterType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setMagfilter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMagfilter(non-const DynamicTextFont this, int filter)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_magfilter_55_comment =
    "C++ Interface:\n"
    "setMagfilter(non-const DynamicTextFont this, int filter)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_magfilter\n"
    "//       Access: Published\n"
    "//  Description: Sets the filter type used when enlarging the\n"
    "//               textures created for this font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_magfilter_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture::FilterType DynamicTextFont::get_magfilter(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_magfilter_56(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Texture::FilterType DynamicTextFont::get_magfilter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMagfilter", key_word_list));
        else
            (PyArg_Parse(args, ":getMagfilter"));
        if(!PyErr_Occurred())
        {
            Texture::FilterType return_value = ((const DynamicTextFont*)local_this)->get_magfilter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMagfilter(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_magfilter_56_comment =
    "C++ Interface:\n"
    "getMagfilter(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_magfilter\n"
    "//       Access: Published\n"
    "//  Description: Returns the filter type used when enlarging the\n"
    "//               textures created for this font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_magfilter_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_anisotropic_degree_57(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree)
        int param1;
        static char * key_word_list[] = {(char *)"anisotropic_degree", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAnisotropicDegree", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAnisotropicDegree", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_anisotropic_degree((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setAnisotropicDegree() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnisotropicDegree(non-const DynamicTextFont this, int anisotropic_degree)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_anisotropic_degree_57_comment =
    "C++ Interface:\n"
    "setAnisotropicDegree(non-const DynamicTextFont this, int anisotropic_degree)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_anisotropic_degree\n"
    "//       Access: Published\n"
    "//  Description: Enables or disables anisotropic filtering on the\n"
    "//               textures created for this font.  The default value is\n"
    "//               specified by the text-anisotropic-degree variable.\n"
    "//               See Texture::set_anisotropic_degree().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_anisotropic_degree_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DynamicTextFont::get_anisotropic_degree(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_anisotropic_degree_58(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DynamicTextFont::get_anisotropic_degree(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnisotropicDegree", key_word_list));
        else
            (PyArg_Parse(args, ":getAnisotropicDegree"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DynamicTextFont*)local_this)->get_anisotropic_degree();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnisotropicDegree(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_anisotropic_degree_58_comment =
    "C++ Interface:\n"
    "getAnisotropicDegree(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_anisotropic_degree\n"
    "//       Access: Published\n"
    "//  Description: Returns the current anisotropic degree for textures\n"
    "//               created for this font.  See set_anisotropic_degree().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_anisotropic_degree_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_render_mode_59(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode)
        int param1;
        static char * key_word_list[] = {(char *)"render_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRenderMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRenderMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_render_mode((TextFont::RenderMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setRenderMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRenderMode(non-const DynamicTextFont this, int render_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_render_mode_59_comment =
    "C++ Interface:\n"
    "setRenderMode(non-const DynamicTextFont this, int render_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_render_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies the way the glyphs on this particular font\n"
    "//               are generated.  The default is RM_texture, which is\n"
    "//               the only mode supported for bitmap fonts. Other modes\n"
    "//               are possible for most modern fonts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_render_mode_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_render_mode_60(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRenderMode", key_word_list));
        else
            (PyArg_Parse(args, ":getRenderMode"));
        if(!PyErr_Occurred())
        {
            TextFont::RenderMode return_value = ((const DynamicTextFont*)local_this)->get_render_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderMode(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_render_mode_60_comment =
    "C++ Interface:\n"
    "getRenderMode(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_render_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the way the glyphs on this particular font\n"
    "//               are generated.  See set_render_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_render_mode_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_winding_order(TextFont::WindingOrder winding_order)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_winding_order_61(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DynamicTextFont::set_winding_order(TextFont::WindingOrder winding_order)
        int param1;
        static char * key_word_list[] = {(char *)"winding_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setWindingOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setWindingOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_winding_order((TextFont::WindingOrder)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.setWindingOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWindingOrder(non-const DynamicTextFont this, int winding_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_winding_order_61_comment =
    "C++ Interface:\n"
    "setWindingOrder(non-const DynamicTextFont this, int winding_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_winding_order\n"
    "//       Access: Published\n"
    "//  Description: Specifies an explicitly winding order on this\n"
    "//               particular font.  This is only necessary if the\n"
    "//               render_mode is RM_polygon or RM_solid, and only if\n"
    "//               FreeType appears to guess wrong on this font.\n"
    "//               Normally, you should leave this at WO_default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_winding_order_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextFont::WindingOrder DynamicTextFont::get_winding_order(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_winding_order_62(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextFont::WindingOrder DynamicTextFont::get_winding_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindingOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getWindingOrder"));
        if(!PyErr_Occurred())
        {
            TextFont::WindingOrder return_value = ((const DynamicTextFont*)local_this)->get_winding_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindingOrder(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_winding_order_62_comment =
    "C++ Interface:\n"
    "getWindingOrder(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_winding_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the winding order set via set_winding_order().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_winding_order_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_fg(LVecBase4f const &fg)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_fg_63(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DynamicTextFont::set_fg(LVecBase4f const &fg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"fg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFg", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFg", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DynamicTextFont.setFg", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_fg(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DynamicTextFont.setFg() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFg(non-const DynamicTextFont this, const VBase4 fg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_fg_63_comment =
    "C++ Interface:\n"
    "setFg(non-const DynamicTextFont this, const VBase4 fg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_fg\n"
    "//       Access: Published\n"
    "//  Description: Changes the color of the foreground pixels of the\n"
    "//               font as they are rendered into the font texture.  The\n"
    "//               default is (1, 1, 1, 1), or opaque white, which\n"
    "//               allows text created with the font to be colored\n"
    "//               individually.  Normally, you would not change this\n"
    "//               unless you really need a particular color effect to\n"
    "//               appear in the font itself.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_fg_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &DynamicTextFont::get_fg(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_fg_64(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &DynamicTextFont::get_fg(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFg", key_word_list));
        else
            (PyArg_Parse(args, ":getFg"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const DynamicTextFont*)local_this)->get_fg());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFg(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_fg_64_comment =
    "C++ Interface:\n"
    "getFg(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_fg\n"
    "//       Access: Published\n"
    "//  Description: Returns the color of the foreground pixels of the\n"
    "//               font as they are rendered into the font texture.\n"
    "//               See set_fg().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_fg_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_bg(LVecBase4f const &bg)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_bg_65(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DynamicTextFont::set_bg(LVecBase4f const &bg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBg", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setBg", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DynamicTextFont.setBg", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_bg(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DynamicTextFont.setBg() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBg(non-const DynamicTextFont this, const VBase4 bg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_bg_65_comment =
    "C++ Interface:\n"
    "setBg(non-const DynamicTextFont this, const VBase4 bg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_bg\n"
    "//       Access: Published\n"
    "//  Description: Changes the color of the background pixels of the\n"
    "//               font as they are rendered into the font texture.  The\n"
    "//               default is (1, 1, 1, 0), or transparent white, which\n"
    "//               allows text created with the font to be colored\n"
    "//               individually.  (Note that it should not generally be\n"
    "//               (0, 0, 0, 0), which would tend to bleed into the\n"
    "//               foreground color, unless you have also specified a\n"
    "//               outline color of (0, 0, 0, 1)) .\n"
    "//\n"
    "//               Normally, you would not change this unless you really\n"
    "//               need a particular color effect to appear in the font\n"
    "//               itself.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_bg_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &DynamicTextFont::get_bg(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_bg_66(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &DynamicTextFont::get_bg(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBg", key_word_list));
        else
            (PyArg_Parse(args, ":getBg"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const DynamicTextFont*)local_this)->get_bg());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBg(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_bg_66_comment =
    "C++ Interface:\n"
    "getBg(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_bg\n"
    "//       Access: Published\n"
    "//  Description: Returns the color of the background pixels of the\n"
    "//               font as they are rendered into the font texture.\n"
    "//               See set_bg().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_bg_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DynamicTextFont::set_outline(LVecBase4f const &outline_color, float outline_width, float outline_feather)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_set_outline_67(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DynamicTextFont::set_outline(LVecBase4f const &outline_color, float outline_width, float outline_feather)
            PyObject *param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"outline_color", (char *)"outline_width", (char *)"outline_feather", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:setOutline", key_word_list, &param1, &param2, &param3))
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DynamicTextFont.setOutline", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_outline(*param1_this, (float)param2, (float)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DynamicTextFont.setOutline() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOutline(non-const DynamicTextFont this, const VBase4 outline_color, float outline_width, float outline_feather)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_set_outline_67_comment =
    "C++ Interface:\n"
    "setOutline(non-const DynamicTextFont this, const VBase4 outline_color, float outline_width, float outline_feather)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::set_outline\n"
    "//       Access: Published\n"
    "//  Description: Sets up the font to have an outline around each font\n"
    "//               letter.  This is achieved via a Gaussian post-process\n"
    "//               as each letter is generated; there is some runtime\n"
    "//               cost for this effect, but it is minimal as each\n"
    "//               letter is normally generated only once and then\n"
    "//               cached.\n"
    "//\n"
    "//               The color is the desired color of the outline, width\n"
    "//               is the number of points beyond the letter that the\n"
    "//               outline extends (a typical font is 10 points high),\n"
    "//               and feather is a number in the range 0.0 .. 1.0 that\n"
    "//               controls the softness of the outline.  Set the width\n"
    "//               to 0.0 to disable the outline.\n"
    "//\n"
    "//               This should only be called before any characters have\n"
    "//               been requested out of the font, or immediately after\n"
    "//               calling clear().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_set_outline_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &DynamicTextFont::get_outline_color(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_outline_color_68(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &DynamicTextFont::get_outline_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOutlineColor", key_word_list));
        else
            (PyArg_Parse(args, ":getOutlineColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const DynamicTextFont*)local_this)->get_outline_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOutlineColor(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_outline_color_68_comment =
    "C++ Interface:\n"
    "getOutlineColor(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_outline_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the color of the outline pixels of the\n"
    "//               font as they are rendered into the font texture.\n"
    "//               See set_outline().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_outline_color_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_outline_width(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_outline_width_69(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_outline_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOutlineWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getOutlineWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_outline_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOutlineWidth(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_outline_width_69_comment =
    "C++ Interface:\n"
    "getOutlineWidth(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_outline_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of the outline pixels of the\n"
    "//               font, as the number of points beyond each letter.\n"
    "//               See set_outline().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_outline_width_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DynamicTextFont::get_outline_feather(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_outline_feather_70(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DynamicTextFont::get_outline_feather(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOutlineFeather", key_word_list));
        else
            (PyArg_Parse(args, ":getOutlineFeather"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DynamicTextFont*)local_this)->get_outline_feather();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOutlineFeather(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_outline_feather_70_comment =
    "C++ Interface:\n"
    "getOutlineFeather(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_outline_feather\n"
    "//       Access: Published\n"
    "//  Description: Returns the softness of the outline pixels of the\n"
    "//               font, as a value in the range 0.0 to 1.0.\n"
    "//               See set_outline().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_outline_feather_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture::Format DynamicTextFont::get_tex_format(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_tex_format_71(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Texture::Format DynamicTextFont::get_tex_format(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexFormat", key_word_list));
        else
            (PyArg_Parse(args, ":getTexFormat"));
        if(!PyErr_Occurred())
        {
            Texture::Format return_value = ((const DynamicTextFont*)local_this)->get_tex_format();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTexFormat(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_tex_format_71_comment =
    "C++ Interface:\n"
    "getTexFormat(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_tex_format\n"
    "//       Access: Published\n"
    "//  Description: Returns the texture format used to render the\n"
    "//               individual pages.  This is set automatically\n"
    "//               according to the colors selected.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_tex_format_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DynamicTextFont::get_num_pages(void) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_num_pages_72(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DynamicTextFont::get_num_pages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPages", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPages"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DynamicTextFont*)local_this)->get_num_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPages(const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_num_pages_72_comment =
    "C++ Interface:\n"
    "getNumPages(const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_num_pages\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pages associated with the font.\n"
    "//               Initially, the font has zero pages; when the first\n"
    "//               piece of text is rendered with the font, it will add\n"
    "//               additional pages as needed.  Each page is a Texture\n"
    "//               object that contains the images for each of the\n"
    "//               glyphs currently in use somewhere.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_num_pages_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DynamicTextPage *DynamicTextFont::get_page(int n) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_page_73(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DynamicTextPage *DynamicTextFont::get_page(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPage", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPage", &param1));
        if(!PyErr_Occurred())
        {
            DynamicTextPage *return_value = ((const DynamicTextFont*)local_this)->get_page((int)param1);
            if (return_value != (DynamicTextPage *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DynamicTextPage,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPage(const DynamicTextFont this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_page_73_comment =
    "C++ Interface:\n"
    "getPage(const DynamicTextFont this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::get_page\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth page associated with the font.\n"
    "//               Initially, the font has zero pages; when the first\n"
    "//               piece of text is rendered with the font, it will add\n"
    "//               additional pages as needed.  Each page is a Texture\n"
    "//               object that contains the images for each of the\n"
    "//               glyphs currently in use somewhere.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_page_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DynamicTextFont::garbage_collect(void)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_garbage_collect_74(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DynamicTextFont::garbage_collect(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":garbageCollect", key_word_list));
        else
            (PyArg_Parse(args, ":garbageCollect"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->garbage_collect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.garbageCollect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "garbageCollect(non-const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_garbage_collect_74_comment =
    "C++ Interface:\n"
    "garbageCollect(non-const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::garbage_collect\n"
    "//       Access: Published\n"
    "//  Description: Removes all of the glyphs from the font that are no\n"
    "//               longer being used by any Geoms.  Returns the number\n"
    "//               of glyphs removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_garbage_collect_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DynamicTextFont::clear(void)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_clear_75(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DynamicTextFont::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_clear_75_comment =
    "C++ Interface:\n"
    "clear(non-const DynamicTextFont this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::clear\n"
    "//       Access: Published\n"
    "//  Description: Drops all the glyphs out of the cache and frees any\n"
    "//               association with any previously-generated pages.\n"
    "//\n"
    "//               Calling this frequently can result in wasted texture\n"
    "//               memory, as any previously rendered text will still\n"
    "//               keep a pointer to the old, previously-generated\n"
    "//               pages.  As long as the previously rendered text\n"
    "//               remains around, the old pages will also remain\n"
    "//               around.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_clear_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DynamicTextFont::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_write_76(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void DynamicTextFont::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DynamicTextFont.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DynamicTextFont*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const DynamicTextFont this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_write_76_comment =
    "C++ Interface:\n"
    "write(const DynamicTextFont this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DynamicTextFont::write\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DynamicTextFont_write_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DynamicTextFont::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DynamicTextFont::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DynamicTextFont::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DynamicTextFont_get_class_type_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextFont *DynamicTextFont::upcast_to_TextFont(void)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_upcast_to_TextFont_26(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextFont *DynamicTextFont::upcast_to_TextFont(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTextFont", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTextFont"));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = (TextFont *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.upcastToTextFont() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTextFont(non-const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_upcast_to_TextFont_26_comment =
    "C++ Interface:\n"
    "upcastToTextFont(non-const DynamicTextFont this)\n"
    "\n"
    "upcast from DynamicTextFont to TextFont\n"
    "";
#else
static const char * Dtool_DynamicTextFont_upcast_to_TextFont_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void)
 *******************************************************************/
static PyObject *Dtool_DynamicTextFont_upcast_to_FreetypeFont_29(PyObject *self, PyObject *args,PyObject *kwds) {
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToFreetypeFont", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToFreetypeFont"));
        if(!PyErr_Occurred())
        {
            FreetypeFont *return_value = (FreetypeFont *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_FreetypeFont,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DynamicTextFont.upcastToFreetypeFont() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToFreetypeFont(non-const DynamicTextFont this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DynamicTextFont_upcast_to_FreetypeFont_29_comment =
    "C++ Interface:\n"
    "upcastToFreetypeFont(non-const DynamicTextFont this)\n"
    "\n"
    "upcast from DynamicTextFont to FreetypeFont\n"
    "";
#else
static const char * Dtool_DynamicTextFont_upcast_to_FreetypeFont_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
 * DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
 * DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index = (0))
 * DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
 *******************************************************************/
int  Dtool_Init_DynamicTextFont(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DynamicTextFont", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DynamicTextFont", &param0));
                if(!PyErr_Occurred())
                {
                    DynamicTextFont *param0_this = (DynamicTextFont *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DynamicTextFont, 0, "DynamicTextFont.DynamicTextFont", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DynamicTextFont,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index = (0))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"font_filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DynamicTextFont", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DynamicTextFont", &param0));
                if(!PyErr_Occurred())
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DynamicTextFont.DynamicTextFont", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        DynamicTextFont *return_value = new DynamicTextFont(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DynamicTextFont,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index)
                PyObject *param0;
                int param1;
                static char * key_word_list[] = {(char *)"font_filename", (char *)"face_index", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:DynamicTextFont", key_word_list, &param0, &param1))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DynamicTextFont.DynamicTextFont", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        DynamicTextFont *return_value = new DynamicTextFont(*param0_this, (int)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DynamicTextFont,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index)
            char *param0;
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"font_data", (char *)"data_length", (char *)"face_index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "sii:DynamicTextFont", key_word_list, &param0, &param1, &param2))
            {
                DynamicTextFont *return_value = new DynamicTextFont((char const *)param0, (int)param1, (int)param2);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DynamicTextFont,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DynamicTextFont() takes 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DynamicTextFont(const DynamicTextFont copy)\n"
          "DynamicTextFont(const Filename font_filename)\n"
          "DynamicTextFont(const Filename font_filename, int face_index)\n"
          "DynamicTextFont(string font_data, int data_length, int face_index)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_DynamicTextFont_get_pages(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPages", "getPage");
}
inline void  * Dtool_UpcastInterface_DynamicTextFont(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DynamicTextFont)
    {
        printf("DynamicTextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DynamicTextFont * local_this = (DynamicTextFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DynamicTextFont)
        return local_this;
    if(requested_type == &Dtool_FreetypeFont)
        return ( FreetypeFont *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( TextFont *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( TextFont *) local_this;
    if(requested_type == &Dtool_TextFont)
        return ( TextFont *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( TextFont *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( TextFont *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DynamicTextFont(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DynamicTextFont)
        return from_this;
    if(from_type == &Dtool_FreetypeFont)
    {
          FreetypeFont* other_this = (FreetypeFont*)from_this;
          return (DynamicTextFont*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DynamicTextFont*)other_this;
    }
    if(from_type == &Dtool_TextFont)
    {
          TextFont* other_this = (TextFont*)from_this;
          return (DynamicTextFont*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DynamicTextFont*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DynamicTextFont*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FontPool 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline bool FontPool::has_font(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_FontPool_has_font_79(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool FontPool::has_font(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasFont", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:hasFont", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            bool return_value = FontPool::has_font(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFont(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_has_font_79_comment =
    "C++ Interface:\n"
    "hasFont(string filename)\n"
    "\n"
    "// These functions take string parameters instead of Filenames\n"
    "// because the parameters may not be entirely an actual filename:\n"
    "// they may be a filename followed by a face index.\n"
    "\n"
    "// Filename: fontPool.I\n"
    "// Created by:  drose (31Jan03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::has_font\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns true if the font has ever been loaded,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_has_font_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool FontPool::verify_font(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_FontPool_verify_font_80(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool FontPool::verify_font(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:verifyFont", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:verifyFont", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            bool return_value = FontPool::verify_font(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "verifyFont(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_verify_font_80_comment =
    "C++ Interface:\n"
    "verifyFont(string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::verify_font\n"
    "//       Access: Public, Static\n"
    "//  Description: Loads the given filename up into a font, if it has\n"
    "//               not already been loaded, and returns true to indicate\n"
    "//               success, or false to indicate failure.  If this\n"
    "//               returns true, it is guaranteed that a subsequent call\n"
    "//               to load_font() with the same font name will\n"
    "//               return a valid Font pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_verify_font_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline TextFont *FontPool::load_font(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_FontPool_load_font_81(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline TextFont *FontPool::load_font(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:loadFont", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:loadFont", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = FontPool::load_font(basic_string<char>(param0_str, param0_len));
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadFont(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_load_font_81_comment =
    "C++ Interface:\n"
    "loadFont(string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::load_font\n"
    "//       Access: Public, Static\n"
    "//  Description: Loads the given filename up into a font, if it has\n"
    "//               not already been loaded, and returns the new font.\n"
    "//               If a font with the same filename was previously\n"
    "//               loaded, returns that one instead.  If the font\n"
    "//               file cannot be found, returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_load_font_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void FontPool::add_font(basic_string< char > const &filename, TextFont *font)
 *******************************************************************/
static PyObject *Dtool_FontPool_add_font_82(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void FontPool::add_font(basic_string< char > const &filename, TextFont *font)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", (char *)"font", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addFont", key_word_list, &param0_str, &param0_len, &param1))
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "FontPool.addFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    FontPool::add_font(basic_string<char>(param0_str, param0_len), param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFont(string filename, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_add_font_82_comment =
    "C++ Interface:\n"
    "addFont(string filename, non-const TextFont font)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::add_font\n"
    "//       Access: Public, Static\n"
    "//  Description: Adds the indicated already-loaded font to the\n"
    "//               pool.  The font will always replace any\n"
    "//               previously-loaded font in the pool that had the\n"
    "//               same filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_add_font_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void FontPool::release_font(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_FontPool_release_font_83(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void FontPool::release_font(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:releaseFont", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:releaseFont", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            FontPool::release_font(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseFont(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_release_font_83_comment =
    "C++ Interface:\n"
    "releaseFont(string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::release_font\n"
    "//       Access: Public, Static\n"
    "//  Description: Removes the indicated font from the pool,\n"
    "//               indicating it will never be loaded again; the font\n"
    "//               may then be freed.  If this function is never called,\n"
    "//               a reference count will be maintained on every font\n"
    "//               every loaded, and fonts will never be freed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_release_font_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void FontPool::release_all_fonts(void)
 *******************************************************************/
static PyObject *Dtool_FontPool_release_all_fonts_84(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void FontPool::release_all_fonts(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":releaseAllFonts", key_word_list))
        {
            FontPool::release_all_fonts();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseAllFonts()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_release_all_fonts_84_comment =
    "C++ Interface:\n"
    "releaseAllFonts()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::release_all_fonts\n"
    "//       Access: Public, Static\n"
    "//  Description: Releases all fonts in the pool and restores the\n"
    "//               pool to the empty state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_release_all_fonts_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int FontPool::garbage_collect(void)
 *******************************************************************/
static PyObject *Dtool_FontPool_garbage_collect_85(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int FontPool::garbage_collect(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":garbageCollect", key_word_list))
        {
            int return_value = FontPool::garbage_collect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "garbageCollect()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_garbage_collect_85_comment =
    "C++ Interface:\n"
    "garbageCollect()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::garbage_collect\n"
    "//       Access: Public, Static\n"
    "//  Description: Releases only those fonts in the pool that have a\n"
    "//               reference count of exactly 1; i.e. only those\n"
    "//               fonts that are not being used outside of the pool.\n"
    "//               Returns the number of fonts released.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_garbage_collect_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void FontPool::list_contents(ostream &out)
 *******************************************************************/
static PyObject *Dtool_FontPool_list_contents_86(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void FontPool::list_contents(ostream &out)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:listContents", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:listContents", &param0));
            if(!PyErr_Occurred())
            {
                ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "FontPool.listContents", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    FontPool::list_contents(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "listContents(non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_list_contents_86_comment =
    "C++ Interface:\n"
    "listContents(non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::list_contents\n"
    "//       Access: Public, Static\n"
    "//  Description: Lists the contents of the font pool to the\n"
    "//               indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_list_contents_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void FontPool::write(ostream &out)
 *******************************************************************/
static PyObject *Dtool_FontPool_write_87(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void FontPool::write(ostream &out)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:write", &param0));
            if(!PyErr_Occurred())
            {
                ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "FontPool.write", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    FontPool::write(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FontPool_write_87_comment =
    "C++ Interface:\n"
    "write(non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FontPool::write\n"
    "//       Access: Published, Static\n"
    "//  Description: Lists the contents of the font pool to the\n"
    "//               indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FontPool_write_87_comment = NULL;
#endif

int  Dtool_Init_FontPool(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (FontPool)");
       return -1;
}
inline void  * Dtool_UpcastInterface_FontPool(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FontPool)
    {
        printf("FontPool ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FontPool * local_this = (FontPool *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FontPool)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FontPool(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FontPool)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GeomTextGlyph 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GeomTextGlyph::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GeomTextGlyph_get_class_type_91(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GeomTextGlyph::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GeomTextGlyph::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomTextGlyph_get_class_type_91_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GeomTextGlyph_get_class_type_91_comment = NULL;
#endif

int  Dtool_Init_GeomTextGlyph(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GeomTextGlyph)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GeomTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GeomTextGlyph)
    {
        printf("GeomTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GeomTextGlyph * local_this = (GeomTextGlyph *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GeomTextGlyph)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( Geom *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( Geom *) local_this;
    if(requested_type == &Dtool_Geom)
        return ( Geom *) local_this;
    if(requested_type == &Dtool_GeomEnums)
        return ( GeomEnums *)( Geom *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( Geom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( Geom *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( Geom *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( Geom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GeomTextGlyph(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GeomTextGlyph)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_Geom)
    {
          Geom* other_this = (Geom*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_GeomEnums)
    {
          GeomEnums* other_this = (GeomEnums*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GeomTextGlyph*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StaticTextFont 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle StaticTextFont::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_StaticTextFont_get_class_type_94(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle StaticTextFont::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = StaticTextFont::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StaticTextFont_get_class_type_94_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_StaticTextFont_get_class_type_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * StaticTextFont::StaticTextFont(PandaNode *font_def)
 *******************************************************************/
int  Dtool_Init_StaticTextFont(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-StaticTextFont::StaticTextFont(PandaNode *font_def)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"font_def", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:StaticTextFont", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:StaticTextFont", &param0));
            if(!PyErr_Occurred())
            {
                PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "StaticTextFont.StaticTextFont", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    StaticTextFont *return_value = new StaticTextFont(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_StaticTextFont,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "StaticTextFont(non-const PandaNode font_def)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StaticTextFont(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StaticTextFont)
    {
        printf("StaticTextFont ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StaticTextFont * local_this = (StaticTextFont *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StaticTextFont)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( TextFont *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( TextFont *) local_this;
    if(requested_type == &Dtool_TextFont)
        return ( TextFont *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( TextFont *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( TextFont *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StaticTextFont(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StaticTextFont)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (StaticTextFont*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (StaticTextFont*)other_this;
    }
    if(from_type == &Dtool_TextFont)
    {
          TextFont* other_this = (TextFont*)from_this;
          return (StaticTextFont*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (StaticTextFont*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (StaticTextFont*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TextProperties 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TextProperties::operator =(TextProperties const &copy)
 *******************************************************************/
static PyObject *Dtool_TextProperties_operator_99(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TextProperties::operator =(TextProperties const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextProperties.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TextProperties *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextProperties.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TextProperties this, const TextProperties copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_operator_99_comment =
    "C++ Interface:\n"
    "assign(non-const TextProperties this, const TextProperties copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_operator_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextProperties::operator ==(TextProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_operator_100(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool TextProperties::operator ==(TextProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextProperties.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TextProperties*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const TextProperties this, const TextProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_operator_100_comment =
    "C++ Interface:\n"
    "eq(const TextProperties this, const TextProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_operator_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::operator !=(TextProperties const &other) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_operator_101(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TextProperties::operator !=(TextProperties const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextProperties.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TextProperties*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const TextProperties this, const TextProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_operator_101_comment =
    "C++ Interface:\n"
    "ne(const TextProperties this, const TextProperties other)\n"
    "\n"
    "// Filename: textProperties.I\n"
    "// Created by:  drose (06Apr04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_operator_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextProperties::clear(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_102(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TextProperties::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_102_comment =
    "C++ Interface:\n"
    "clear(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear\n"
    "//       Access: Published\n"
    "//  Description: Unsets all properties that have been specified so\n"
    "//               far, and resets the TextProperties structure to its\n"
    "//               initial empty state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::is_any_specified(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_is_any_specified_103(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::is_any_specified(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAnySpecified", key_word_list));
        else
            (PyArg_Parse(args, ":isAnySpecified"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->is_any_specified();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAnySpecified(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_is_any_specified_103_comment =
    "C++ Interface:\n"
    "isAnySpecified(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::is_any_specified\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any properties have been specified,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_is_any_specified_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void TextProperties::set_default_font(TextFont *)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_default_font_104(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void TextProperties::set_default_font(TextFont *)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDefaultFont", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setDefaultFont", &param0));
            if(!PyErr_Occurred())
            {
                TextFont *param0_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextFont, 0, "TextProperties.setDefaultFont", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    TextProperties::set_default_font(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefaultFont(non-const TextFont)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_default_font_104_comment =
    "C++ Interface:\n"
    "setDefaultFont(non-const TextFont)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_default_font\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies the default font to be used for any\n"
    "//               TextNode whose font is uninitialized or NULL.  See\n"
    "//               set_font().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_default_font_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline TextFont *TextProperties::get_default_font(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_default_font_105(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline TextFont *TextProperties::get_default_font(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultFont", key_word_list))
        {
            TextFont *return_value = TextProperties::get_default_font();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultFont()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_default_font_105_comment =
    "C++ Interface:\n"
    "getDefaultFont()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_default_font\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies the default font to be used for any\n"
    "//               TextNode whose font is uninitialized or NULL.  See\n"
    "//               set_font().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_default_font_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_font(TextFont *font)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_font_106(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextProperties::set_font(TextFont *font)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"font", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFont", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFont", &param1));
            if(!PyErr_Occurred())
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "TextProperties.setFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_font(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextProperties.setFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFont(non-const TextProperties this, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_font_106_comment =
    "C++ Interface:\n"
    "setFont(non-const TextProperties this, non-const TextFont font)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_font\n"
    "//       Access: Published\n"
    "//  Description: Sets the font that will be used when making text.  If\n"
    "//               this is set to NULL, the default font will be used,\n"
    "//               which can be set via set_default_font().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_font_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_font(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_font_107(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_font(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFont", key_word_list));
        else
            (PyArg_Parse(args, ":clearFont"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_font();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearFont() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFont(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_font_107_comment =
    "C++ Interface:\n"
    "clearFont(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_font\n"
    "//       Access: Published\n"
    "//  Description: Restores the default font to the text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_font_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_font(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_font_108(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_font(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasFont", key_word_list));
        else
            (PyArg_Parse(args, ":hasFont"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_font();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFont(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_font_108_comment =
    "C++ Interface:\n"
    "hasFont(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_font\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_font_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextFont *TextProperties::get_font(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_font_109(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextFont *TextProperties::get_font(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFont", key_word_list));
        else
            (PyArg_Parse(args, ":getFont"));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = ((const TextProperties*)local_this)->get_font();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFont(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_font_109_comment =
    "C++ Interface:\n"
    "getFont(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_font\n"
    "//       Access: Published\n"
    "//  Description: Returns the font currently in use, if any.  If no\n"
    "//               font is in use, this returns the default font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_font_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_small_caps(bool small_caps)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_small_caps_110(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_small_caps(bool small_caps)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"small_caps", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSmallCaps", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSmallCaps", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_small_caps((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setSmallCaps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSmallCaps(non-const TextProperties this, bool small_caps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_small_caps_110_comment =
    "C++ Interface:\n"
    "setSmallCaps(non-const TextProperties this, bool small_caps)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_small_caps\n"
    "//       Access: Published\n"
    "//  Description: Sets the small_caps flag.  When this is set,\n"
    "//               lowercase letters are generated as scaled-down\n"
    "//               versions of their uppercase equivalents.  This is\n"
    "//               particularly useful to set for fonts that do not have\n"
    "//               lowercase letters.\n"
    "//\n"
    "//               It is also a good idea to set this for a (dynamic)\n"
    "//               font that has already implemented lowercase letters\n"
    "//               as scaled-down versions of their uppercase\n"
    "//               equivalents, since without this flag the texture\n"
    "//               memory may needlessly duplicate equivalent glyphs for\n"
    "//               upper and lowercase letters.  Setting this flag\n"
    "//               causes the texture memory to share the mixed-case\n"
    "//               letters.\n"
    "//\n"
    "//               The amount by which the lowercase letters are scaled\n"
    "//               is specified by set_small_caps_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_small_caps_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_small_caps(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_small_caps_111(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_small_caps(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSmallCaps", key_word_list));
        else
            (PyArg_Parse(args, ":clearSmallCaps"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_small_caps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearSmallCaps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSmallCaps(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_small_caps_111_comment =
    "C++ Interface:\n"
    "clearSmallCaps(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_small_caps\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_small_caps_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_small_caps(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_small_caps_112(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_small_caps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSmallCaps", key_word_list));
        else
            (PyArg_Parse(args, ":hasSmallCaps"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_small_caps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSmallCaps(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_small_caps_112_comment =
    "C++ Interface:\n"
    "hasSmallCaps(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_small_caps\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_small_caps_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::get_small_caps(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_small_caps_113(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::get_small_caps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmallCaps", key_word_list));
        else
            (PyArg_Parse(args, ":getSmallCaps"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->get_small_caps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmallCaps(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_small_caps_113_comment =
    "C++ Interface:\n"
    "getSmallCaps(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_small_caps\n"
    "//       Access: Published\n"
    "//  Description: Returns the small_caps flag.  See set_small_caps().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_small_caps_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_small_caps_scale(float small_caps_scale)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_small_caps_scale_114(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_small_caps_scale(float small_caps_scale)
        double param1;
        static char * key_word_list[] = {(char *)"small_caps_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSmallCapsScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSmallCapsScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_small_caps_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setSmallCapsScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSmallCapsScale(non-const TextProperties this, float small_caps_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_small_caps_scale_114_comment =
    "C++ Interface:\n"
    "setSmallCapsScale(non-const TextProperties this, float small_caps_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_small_caps_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets the scale factor applied to lowercase letters\n"
    "//               from their uppercase equivalents, when the small_caps\n"
    "//               flag is in effect.  See set_small_caps().  Normally,\n"
    "//               this will be a number less than one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_small_caps_scale_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_small_caps_scale(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_small_caps_scale_115(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_small_caps_scale(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSmallCapsScale", key_word_list));
        else
            (PyArg_Parse(args, ":clearSmallCapsScale"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_small_caps_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearSmallCapsScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSmallCapsScale(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_small_caps_scale_115_comment =
    "C++ Interface:\n"
    "clearSmallCapsScale(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_small_caps_scale\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_small_caps_scale_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_small_caps_scale(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_small_caps_scale_116(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_small_caps_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSmallCapsScale", key_word_list));
        else
            (PyArg_Parse(args, ":hasSmallCapsScale"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_small_caps_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSmallCapsScale(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_small_caps_scale_116_comment =
    "C++ Interface:\n"
    "hasSmallCapsScale(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_small_caps_scale\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_small_caps_scale_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_small_caps_scale(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_small_caps_scale_117(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_small_caps_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmallCapsScale", key_word_list));
        else
            (PyArg_Parse(args, ":getSmallCapsScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_small_caps_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmallCapsScale(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_small_caps_scale_117_comment =
    "C++ Interface:\n"
    "getSmallCapsScale(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_small_caps_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the scale factor applied to lowercase letters\n"
    "//               from their uppercase equivalents, when the small_caps\n"
    "//               flag is in effect.  See set_small_caps() and\n"
    "//               set_small_caps_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_small_caps_scale_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_slant(float slant)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_slant_118(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_slant(float slant)
        double param1;
        static char * key_word_list[] = {(char *)"slant", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSlant", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSlant", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_slant((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setSlant() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSlant(non-const TextProperties this, float slant)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_slant_118_comment =
    "C++ Interface:\n"
    "setSlant(non-const TextProperties this, float slant)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_slant\n"
    "//       Access: Published\n"
    "//  Description: Specifies the factor by which the text slants to the\n"
    "//               right.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_slant_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_slant(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_slant_119(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_slant(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSlant", key_word_list));
        else
            (PyArg_Parse(args, ":clearSlant"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_slant();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearSlant() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSlant(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_slant_119_comment =
    "C++ Interface:\n"
    "clearSlant(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_slant\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_slant_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_slant(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_slant_120(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_slant(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSlant", key_word_list));
        else
            (PyArg_Parse(args, ":hasSlant"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_slant();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSlant(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_slant_120_comment =
    "C++ Interface:\n"
    "hasSlant(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_slant\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_slant_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_slant(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_slant_121(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_slant(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSlant", key_word_list));
        else
            (PyArg_Parse(args, ":getSlant"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_slant();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSlant(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_slant_121_comment =
    "C++ Interface:\n"
    "getSlant(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_slant\n"
    "//       Access: Published\n"
    "//  Description: Returns the factor by which the text is specified to\n"
    "//               slant to the right.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_slant_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_underscore(bool underscore)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_underscore_122(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_underscore(bool underscore)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"underscore", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUnderscore", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUnderscore", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_underscore((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setUnderscore() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUnderscore(non-const TextProperties this, bool underscore)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_underscore_122_comment =
    "C++ Interface:\n"
    "setUnderscore(non-const TextProperties this, bool underscore)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_underscore\n"
    "//       Access: Published\n"
    "//  Description: Sets the underscore flag.  When this is set,\n"
    "//               the text is underscored with a one-pixel line the\n"
    "//               same color as the text foreground, drawn at the\n"
    "//               baseline.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_underscore_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_underscore(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_underscore_123(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_underscore(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearUnderscore", key_word_list));
        else
            (PyArg_Parse(args, ":clearUnderscore"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_underscore();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearUnderscore() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearUnderscore(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_underscore_123_comment =
    "C++ Interface:\n"
    "clearUnderscore(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_underscore\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_underscore_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_underscore(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_underscore_124(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_underscore(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasUnderscore", key_word_list));
        else
            (PyArg_Parse(args, ":hasUnderscore"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_underscore();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasUnderscore(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_underscore_124_comment =
    "C++ Interface:\n"
    "hasUnderscore(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_underscore\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_underscore_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::get_underscore(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_underscore_125(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::get_underscore(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUnderscore", key_word_list));
        else
            (PyArg_Parse(args, ":getUnderscore"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->get_underscore();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUnderscore(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_underscore_125_comment =
    "C++ Interface:\n"
    "getUnderscore(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_underscore\n"
    "//       Access: Published\n"
    "//  Description: Returns the underscore flag.  See set_underscore().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_underscore_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_underscore_height(float underscore_height)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_underscore_height_126(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_underscore_height(float underscore_height)
        double param1;
        static char * key_word_list[] = {(char *)"underscore_height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setUnderscoreHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setUnderscoreHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_underscore_height((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setUnderscoreHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUnderscoreHeight(non-const TextProperties this, float underscore_height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_underscore_height_126_comment =
    "C++ Interface:\n"
    "setUnderscoreHeight(non-const TextProperties this, float underscore_height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_underscore_height\n"
    "//       Access: Published\n"
    "//  Description: Specifies the vertical height of the underscore,\n"
    "//               relative to the text baseline.  This only has meaning\n"
    "//               if the underscore mode is enabled with\n"
    "//               set_underscore().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_underscore_height_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_underscore_height(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_underscore_height_127(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_underscore_height(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearUnderscoreHeight", key_word_list));
        else
            (PyArg_Parse(args, ":clearUnderscoreHeight"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_underscore_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearUnderscoreHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearUnderscoreHeight(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_underscore_height_127_comment =
    "C++ Interface:\n"
    "clearUnderscoreHeight(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_underscore_height\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_underscore_height_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_underscore_height(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_underscore_height_128(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_underscore_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasUnderscoreHeight", key_word_list));
        else
            (PyArg_Parse(args, ":hasUnderscoreHeight"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_underscore_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasUnderscoreHeight(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_underscore_height_128_comment =
    "C++ Interface:\n"
    "hasUnderscoreHeight(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_underscore_height\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_underscore_height_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_underscore_height(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_underscore_height_129(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_underscore_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUnderscoreHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getUnderscoreHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_underscore_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUnderscoreHeight(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_underscore_height_129_comment =
    "C++ Interface:\n"
    "getUnderscoreHeight(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_underscore_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the vertical height of the underscore; see\n"
    "//               set_underscore_height().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_underscore_height_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_align(TextProperties::Alignment align_type)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_align_130(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_align(TextProperties::Alignment align_type)
        int param1;
        static char * key_word_list[] = {(char *)"align_type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAlign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAlign", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_align((TextProperties::Alignment)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setAlign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlign(non-const TextProperties this, int align_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_align_130_comment =
    "C++ Interface:\n"
    "setAlign(non-const TextProperties this, int align_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_align\n"
    "//       Access: Published\n"
    "//  Description: Specifies the alignment of the text within its\n"
    "//               margins.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_align_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_align(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_align_131(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_align(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAlign", key_word_list));
        else
            (PyArg_Parse(args, ":clearAlign"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_align();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearAlign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAlign(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_align_131_comment =
    "C++ Interface:\n"
    "clearAlign(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_align\n"
    "//       Access: Published\n"
    "//  Description: Restores the default alignment of the text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_align_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_align(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_align_132(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_align(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAlign", key_word_list));
        else
            (PyArg_Parse(args, ":hasAlign"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_align();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAlign(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_align_132_comment =
    "C++ Interface:\n"
    "hasAlign(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_align\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_align_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextProperties::Alignment TextProperties::get_align(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_align_133(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextProperties::Alignment TextProperties::get_align(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlign", key_word_list));
        else
            (PyArg_Parse(args, ":getAlign"));
        if(!PyErr_Occurred())
        {
            TextProperties::Alignment return_value = ((const TextProperties*)local_this)->get_align();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlign(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_align_133_comment =
    "C++ Interface:\n"
    "getAlign(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_align\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_align_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_indent(float indent)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_indent_134(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_indent(float indent)
        double param1;
        static char * key_word_list[] = {(char *)"indent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setIndent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setIndent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_indent((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setIndent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIndent(non-const TextProperties this, float indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_indent_134_comment =
    "C++ Interface:\n"
    "setIndent(non-const TextProperties this, float indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_indent\n"
    "//       Access: Published\n"
    "//  Description: Specifies the amount of extra space that is inserted\n"
    "//               before the first character of each line.  This can be\n"
    "//               thought of as a left margin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_indent_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_indent(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_indent_135(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_indent(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearIndent", key_word_list));
        else
            (PyArg_Parse(args, ":clearIndent"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_indent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearIndent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearIndent(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_indent_135_comment =
    "C++ Interface:\n"
    "clearIndent(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_indent\n"
    "//       Access: Published\n"
    "//  Description: Removes the indent setting from the text.  Text\n"
    "//               will be as wide as it is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_indent_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_indent(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_indent_136(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_indent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasIndent", key_word_list));
        else
            (PyArg_Parse(args, ":hasIndent"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_indent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasIndent(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_indent_136_comment =
    "C++ Interface:\n"
    "hasIndent(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_indent\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_indent_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_indent(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_indent_137(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_indent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndent", key_word_list));
        else
            (PyArg_Parse(args, ":getIndent"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_indent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndent(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_indent_137_comment =
    "C++ Interface:\n"
    "getIndent(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_indent\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_indent_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_wordwrap(float wordwrap)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_wordwrap_138(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_wordwrap(float wordwrap)
        double param1;
        static char * key_word_list[] = {(char *)"wordwrap", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWordwrap", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWordwrap", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_wordwrap((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setWordwrap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWordwrap(non-const TextProperties this, float wordwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_wordwrap_138_comment =
    "C++ Interface:\n"
    "setWordwrap(non-const TextProperties this, float wordwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Sets the text up to automatically wordwrap when it\n"
    "//               exceeds the indicated width.  This can be thought of\n"
    "//               as a right margin or margin width.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_wordwrap_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_wordwrap(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_wordwrap_139(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_wordwrap(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearWordwrap", key_word_list));
        else
            (PyArg_Parse(args, ":clearWordwrap"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearWordwrap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearWordwrap(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_wordwrap_139_comment =
    "C++ Interface:\n"
    "clearWordwrap(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Removes the wordwrap setting from the text.  Text\n"
    "//               will be as wide as it is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_wordwrap_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_wordwrap(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_wordwrap_140(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_wordwrap(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasWordwrap", key_word_list));
        else
            (PyArg_Parse(args, ":hasWordwrap"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasWordwrap(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_wordwrap_140_comment =
    "C++ Interface:\n"
    "hasWordwrap(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_wordwrap\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_wordwrap_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_wordwrap(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_wordwrap_141(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_wordwrap(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWordwrap", key_word_list));
        else
            (PyArg_Parse(args, ":getWordwrap"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWordwrap(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_wordwrap_141_comment =
    "C++ Interface:\n"
    "getWordwrap(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_wordwrap\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_wordwrap_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_preserve_trailing_whitespace_142(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"preserve_trailing_whitespace", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPreserveTrailingWhitespace", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPreserveTrailingWhitespace", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_preserve_trailing_whitespace((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setPreserveTrailingWhitespace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPreserveTrailingWhitespace(non-const TextProperties this, bool preserve_trailing_whitespace)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_preserve_trailing_whitespace_142_comment =
    "C++ Interface:\n"
    "setPreserveTrailingWhitespace(non-const TextProperties this, bool preserve_trailing_whitespace)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_preserve_trailing_whitespace\n"
    "//       Access: Published\n"
    "//  Description: Sets the preserve_trailing_whitespace flag.  When\n"
    "//               this is set, trailing whitespace at the end of the\n"
    "//               line is not stripped when the text is wordwrapped (it\n"
    "//               is stripped by default).  Since the trailing\n"
    "//               whitespace is invisible, this is important primarily\n"
    "//               for determining the proper width of a frame or card\n"
    "//               behind the text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_preserve_trailing_whitespace_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_preserve_trailing_whitespace(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_preserve_trailing_whitespace_143(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_preserve_trailing_whitespace(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearPreserveTrailingWhitespace", key_word_list));
        else
            (PyArg_Parse(args, ":clearPreserveTrailingWhitespace"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_preserve_trailing_whitespace();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearPreserveTrailingWhitespace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPreserveTrailingWhitespace(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_preserve_trailing_whitespace_143_comment =
    "C++ Interface:\n"
    "clearPreserveTrailingWhitespace(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_preserve_trailing_whitespace\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_preserve_trailing_whitespace_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_preserve_trailing_whitespace(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_preserve_trailing_whitespace_144(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_preserve_trailing_whitespace(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasPreserveTrailingWhitespace", key_word_list));
        else
            (PyArg_Parse(args, ":hasPreserveTrailingWhitespace"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_preserve_trailing_whitespace();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasPreserveTrailingWhitespace(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_preserve_trailing_whitespace_144_comment =
    "C++ Interface:\n"
    "hasPreserveTrailingWhitespace(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_preserve_trailing_whitespace\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_preserve_trailing_whitespace_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::get_preserve_trailing_whitespace(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_preserve_trailing_whitespace_145(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::get_preserve_trailing_whitespace(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPreserveTrailingWhitespace", key_word_list));
        else
            (PyArg_Parse(args, ":getPreserveTrailingWhitespace"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->get_preserve_trailing_whitespace();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPreserveTrailingWhitespace(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_preserve_trailing_whitespace_145_comment =
    "C++ Interface:\n"
    "getPreserveTrailingWhitespace(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_preserve_trailing_whitespace\n"
    "//       Access: Published\n"
    "//  Description: Returns the preserve_trailing_whitespace flag.  See\n"
    "//               set_preserve_trailing_whitespace().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_preserve_trailing_whitespace_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_text_color(LVecBase4f const &text_color)
 * inline void TextProperties::set_text_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_text_color_146(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextProperties::set_text_color(LVecBase4f const &text_color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"text_color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTextColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setTextColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextProperties.setTextColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_text_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextProperties.setTextColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextProperties::set_text_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setTextColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_text_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextProperties.setTextColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setTextColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setTextColor(non-const TextProperties this, const VBase4 text_color)\n"
          "setTextColor(non-const TextProperties this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_text_color_146_comment =
    "C++ Interface:\n"
    "setTextColor(non-const TextProperties this, const VBase4 text_color)\n"
    "setTextColor(non-const TextProperties this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_text_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_text_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_text_color_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_text_color(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_text_color_147(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_text_color(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTextColor", key_word_list));
        else
            (PyArg_Parse(args, ":clearTextColor"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_text_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearTextColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTextColor(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_text_color_147_comment =
    "C++ Interface:\n"
    "clearTextColor(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_text_color\n"
    "//       Access: Published\n"
    "//  Description: Removes the text color specification; the text will\n"
    "//               be colored whatever it was in the source font file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_text_color_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_text_color(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_text_color_148(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_text_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTextColor", key_word_list));
        else
            (PyArg_Parse(args, ":hasTextColor"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_text_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTextColor(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_text_color_148_comment =
    "C++ Interface:\n"
    "hasTextColor(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_text_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_text_color_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextProperties::get_text_color(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_text_color_149(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextProperties::get_text_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextColor", key_word_list));
        else
            (PyArg_Parse(args, ":getTextColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextProperties*)local_this)->get_text_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextColor(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_text_color_149_comment =
    "C++ Interface:\n"
    "getTextColor(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_text_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_text_color_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_shadow_color(LVecBase4f const &shadow_color)
 * inline void TextProperties::set_shadow_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_shadow_color_150(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextProperties::set_shadow_color(LVecBase4f const &shadow_color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"shadow_color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setShadowColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setShadowColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextProperties.setShadowColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_shadow_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextProperties.setShadowColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextProperties::set_shadow_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setShadowColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_shadow_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextProperties.setShadowColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setShadowColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setShadowColor(non-const TextProperties this, const VBase4 shadow_color)\n"
          "setShadowColor(non-const TextProperties this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_shadow_color_150_comment =
    "C++ Interface:\n"
    "setShadowColor(non-const TextProperties this, const VBase4 shadow_color)\n"
    "setShadowColor(non-const TextProperties this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_shadow_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_shadow_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_shadow_color_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_shadow_color(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_shadow_color_151(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_shadow_color(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearShadowColor", key_word_list));
        else
            (PyArg_Parse(args, ":clearShadowColor"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_shadow_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearShadowColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearShadowColor(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_shadow_color_151_comment =
    "C++ Interface:\n"
    "clearShadowColor(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_shadow_color\n"
    "//       Access: Published\n"
    "//  Description: Removes the shadow color specification.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_shadow_color_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_shadow_color(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_shadow_color_152(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_shadow_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasShadowColor", key_word_list));
        else
            (PyArg_Parse(args, ":hasShadowColor"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_shadow_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasShadowColor(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_shadow_color_152_comment =
    "C++ Interface:\n"
    "hasShadowColor(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_shadow_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_shadow_color_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextProperties::get_shadow_color(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_shadow_color_153(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextProperties::get_shadow_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShadowColor", key_word_list));
        else
            (PyArg_Parse(args, ":getShadowColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextProperties*)local_this)->get_shadow_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShadowColor(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_shadow_color_153_comment =
    "C++ Interface:\n"
    "getShadowColor(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_shadow_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_shadow_color_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_shadow(LVecBase2f const &shadow_offset)
 * inline void TextProperties::set_shadow(float xoffset, float yoffset)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_shadow_154(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextProperties::set_shadow(LVecBase2f const &shadow_offset)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"shadow_offset", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setShadow", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setShadow", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "TextProperties.setShadow", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_shadow(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextProperties.setShadow() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextProperties::set_shadow(float xoffset, float yoffset)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"xoffset", (char *)"yoffset", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setShadow", key_word_list, &param1, &param2))
            {
                (local_this)->set_shadow((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextProperties.setShadow() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setShadow() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setShadow(non-const TextProperties this, const VBase2 shadow_offset)\n"
          "setShadow(non-const TextProperties this, float xoffset, float yoffset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_shadow_154_comment =
    "C++ Interface:\n"
    "setShadow(non-const TextProperties this, const VBase2 shadow_offset)\n"
    "setShadow(non-const TextProperties this, float xoffset, float yoffset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the text should be drawn with a\n"
    "//               shadow, by creating a second copy of the text and\n"
    "//               offsetting it slightly behind the first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the text should be drawn with a\n"
    "//               shadow, by creating a second copy of the text and\n"
    "//               offsetting it slightly behind the first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_shadow_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_shadow(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_shadow_155(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_shadow(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearShadow", key_word_list));
        else
            (PyArg_Parse(args, ":clearShadow"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_shadow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearShadow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearShadow(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_shadow_155_comment =
    "C++ Interface:\n"
    "clearShadow(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a shadow will not be drawn behind the\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_shadow_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_shadow(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_shadow_156(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_shadow(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasShadow", key_word_list));
        else
            (PyArg_Parse(args, ":hasShadow"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_shadow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasShadow(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_shadow_156_comment =
    "C++ Interface:\n"
    "hasShadow(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_shadow\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_shadow_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f TextProperties::get_shadow(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_shadow_157(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector2f TextProperties::get_shadow(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShadow", key_word_list));
        else
            (PyArg_Parse(args, ":getShadow"));
        if(!PyErr_Occurred())
        {
            LVector2f result = ((const TextProperties*)local_this)->get_shadow();
            LVector2f *return_value = new LVector2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShadow(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_shadow_157_comment =
    "C++ Interface:\n"
    "getShadow(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_shadow\n"
    "//       Access: Published\n"
    "//  Description: Returns the offset of the shadow as set by\n"
    "//               set_shadow().  It is an error to call this if\n"
    "//               has_shadow() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_shadow_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_bin(basic_string< char > const &bin)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_bin_158(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_bin(basic_string< char > const &bin)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"bin", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setBin", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setBin", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bin(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setBin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBin(non-const TextProperties this, string bin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_bin_158_comment =
    "C++ Interface:\n"
    "setBin(non-const TextProperties this, string bin)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_bin\n"
    "//       Access: Published\n"
    "//  Description: Names the CullBin that the text geometry should be\n"
    "//               assigned to.  If this is set, then a CullBinAttrib\n"
    "//               will be created to explicitly place each component in\n"
    "//               the named bin.\n"
    "//\n"
    "//               The draw_order value will also be passed to each\n"
    "//               CullBinAttrib as appropriate; this is particularly\n"
    "//               useful if this names a CullBinFixed, e.g. \"fixed\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_bin_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_bin(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_bin_159(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_bin(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearBin", key_word_list));
        else
            (PyArg_Parse(args, ":clearBin"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearBin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBin(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_bin_159_comment =
    "C++ Interface:\n"
    "clearBin(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_bin\n"
    "//       Access: Published\n"
    "//  Description: Removes the effect of a previous call to\n"
    "//               set_bin().  Text will be drawn in whatever bin\n"
    "//               it would like to be drawn in, with no explicit\n"
    "//               ordering.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_bin_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_bin(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_bin_160(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_bin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasBin", key_word_list));
        else
            (PyArg_Parse(args, ":hasBin"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_bin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBin(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_bin_160_comment =
    "C++ Interface:\n"
    "hasBin(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_bin\n"
    "//       Access: Published\n"
    "//  Description: Returns true if an explicit drawing bin has been\n"
    "//               set via set_bin(), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_bin_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &TextProperties::get_bin(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_bin_161(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &TextProperties::get_bin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBin", key_word_list));
        else
            (PyArg_Parse(args, ":getBin"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const TextProperties*)local_this)->get_bin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBin(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_bin_161_comment =
    "C++ Interface:\n"
    "getBin(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_bin\n"
    "//       Access: Published\n"
    "//  Description: Returns the drawing bin set with set_bin(), or empty\n"
    "//               string if no bin has been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_bin_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextProperties::set_draw_order(int draw_order)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_draw_order_162(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int TextProperties::set_draw_order(int draw_order)
        int param1;
        static char * key_word_list[] = {(char *)"draw_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setDrawOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setDrawOrder", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->set_draw_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setDrawOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDrawOrder(non-const TextProperties this, int draw_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_draw_order_162_comment =
    "C++ Interface:\n"
    "setDrawOrder(non-const TextProperties this, int draw_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_draw_order\n"
    "//       Access: Published\n"
    "//  Description: Sets the drawing order of text created by the\n"
    "//               TextNode.  This is actually the draw order of the\n"
    "//               card and frame.  The shadow is drawn at\n"
    "//               _draw_order+1, and the text at _draw_order+2.\n"
    "//\n"
    "//               This affects the sorting order assigned to the nodes\n"
    "//               as they are created, and also is passed to whatever\n"
    "//               bin may be assigned via set_bin().\n"
    "//\n"
    "//               The return value is the first unused draw_order\n"
    "//               number, e.g. _draw_order + 3.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_draw_order_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_draw_order(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_draw_order_163(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_draw_order(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDrawOrder", key_word_list));
        else
            (PyArg_Parse(args, ":clearDrawOrder"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_draw_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearDrawOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDrawOrder(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_draw_order_163_comment =
    "C++ Interface:\n"
    "clearDrawOrder(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_draw_order\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_draw_order_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_draw_order(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_draw_order_164(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_draw_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasDrawOrder", key_word_list));
        else
            (PyArg_Parse(args, ":hasDrawOrder"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_draw_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDrawOrder(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_draw_order_164_comment =
    "C++ Interface:\n"
    "hasDrawOrder(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_draw_order\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_draw_order_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextProperties::get_draw_order(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_draw_order_165(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextProperties::get_draw_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDrawOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getDrawOrder"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextProperties*)local_this)->get_draw_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDrawOrder(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_draw_order_165_comment =
    "C++ Interface:\n"
    "getDrawOrder(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_draw_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the drawing order set with set_draw_order().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_draw_order_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_tab_width(float tab_width)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_tab_width_166(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_tab_width(float tab_width)
        double param1;
        static char * key_word_list[] = {(char *)"tab_width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTabWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTabWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tab_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setTabWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTabWidth(non-const TextProperties this, float tab_width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_tab_width_166_comment =
    "C++ Interface:\n"
    "setTabWidth(non-const TextProperties this, float tab_width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_tab_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the width of each tab stop, in screen units.  A\n"
    "//               tab character embedded in the text will advance the\n"
    "//               horizontal position to the next tab stop.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_tab_width_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_tab_width(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_tab_width_167(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_tab_width(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTabWidth", key_word_list));
        else
            (PyArg_Parse(args, ":clearTabWidth"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_tab_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearTabWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTabWidth(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_tab_width_167_comment =
    "C++ Interface:\n"
    "clearTabWidth(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_tab_width\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_tab_width_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_tab_width(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_tab_width_168(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_tab_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTabWidth", key_word_list));
        else
            (PyArg_Parse(args, ":hasTabWidth"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_tab_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTabWidth(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_tab_width_168_comment =
    "C++ Interface:\n"
    "hasTabWidth(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_tab_width\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_tab_width_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_tab_width(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_tab_width_169(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_tab_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTabWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getTabWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_tab_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTabWidth(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_tab_width_169_comment =
    "C++ Interface:\n"
    "getTabWidth(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_tab_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width set via set_tab_width().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_tab_width_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_glyph_scale(float glyph_scale)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_glyph_scale_170(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_glyph_scale(float glyph_scale)
        double param1;
        static char * key_word_list[] = {(char *)"glyph_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGlyphScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setGlyphScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_glyph_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setGlyphScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGlyphScale(non-const TextProperties this, float glyph_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_glyph_scale_170_comment =
    "C++ Interface:\n"
    "setGlyphScale(non-const TextProperties this, float glyph_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_glyph_scale\n"
    "//       Access: Published\n"
    "//  Description: Specifies the factor by which to scale each letter of\n"
    "//               the text as it is placed, in addition to any scales\n"
    "//               inherited from the node or from set_text_scale().\n"
    "//               This can be used (possibly in conjunction with\n"
    "//               set_glyph_shift()) to implement superscripting or\n"
    "//               subscripting.\n"
    "//\n"
    "//               The glyph scale is cumulative when applied to nested\n"
    "//               TextProperties.  It is intended primarily for\n"
    "//               implementing superscripts, not for scaling the text\n"
    "//               in general.  See also set_text_scale(), which is\n"
    "//               intended primarily for scaling the text in general,\n"
    "//               and is not cumulative.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_glyph_scale_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_glyph_scale(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_glyph_scale_171(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_glyph_scale(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearGlyphScale", key_word_list));
        else
            (PyArg_Parse(args, ":clearGlyphScale"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_glyph_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearGlyphScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearGlyphScale(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_glyph_scale_171_comment =
    "C++ Interface:\n"
    "clearGlyphScale(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_glyph_scale\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_glyph_scale_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_glyph_scale(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_glyph_scale_172(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_glyph_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasGlyphScale", key_word_list));
        else
            (PyArg_Parse(args, ":hasGlyphScale"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_glyph_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasGlyphScale(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_glyph_scale_172_comment =
    "C++ Interface:\n"
    "hasGlyphScale(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_glyph_scale\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_glyph_scale_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_glyph_scale(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_glyph_scale_173(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_glyph_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlyphScale", key_word_list));
        else
            (PyArg_Parse(args, ":getGlyphScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_glyph_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlyphScale(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_glyph_scale_173_comment =
    "C++ Interface:\n"
    "getGlyphScale(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_glyph_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the scale factor of each letter as specified\n"
    "//               by set_glyph_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_glyph_scale_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_glyph_shift(float glyph_shift)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_glyph_shift_174(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_glyph_shift(float glyph_shift)
        double param1;
        static char * key_word_list[] = {(char *)"glyph_shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGlyphShift", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setGlyphShift", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_glyph_shift((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setGlyphShift() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGlyphShift(non-const TextProperties this, float glyph_shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_glyph_shift_174_comment =
    "C++ Interface:\n"
    "setGlyphShift(non-const TextProperties this, float glyph_shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_glyph_shift\n"
    "//       Access: Published\n"
    "//  Description: Specifies a vertical amount to shift each letter of\n"
    "//               the text as it is placed.  This can be used (possibly\n"
    "//               in conjunction with set_glyph_scale()) to implement\n"
    "//               superscripting or subscripting.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_glyph_shift_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_glyph_shift(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_glyph_shift_175(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_glyph_shift(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearGlyphShift", key_word_list));
        else
            (PyArg_Parse(args, ":clearGlyphShift"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_glyph_shift();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearGlyphShift() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearGlyphShift(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_glyph_shift_175_comment =
    "C++ Interface:\n"
    "clearGlyphShift(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_glyph_shift\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_glyph_shift_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_glyph_shift(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_glyph_shift_176(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_glyph_shift(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasGlyphShift", key_word_list));
        else
            (PyArg_Parse(args, ":hasGlyphShift"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_glyph_shift();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasGlyphShift(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_glyph_shift_176_comment =
    "C++ Interface:\n"
    "hasGlyphShift(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_glyph_shift\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_glyph_shift_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_glyph_shift(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_glyph_shift_177(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_glyph_shift(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlyphShift", key_word_list));
        else
            (PyArg_Parse(args, ":getGlyphShift"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_glyph_shift();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlyphShift(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_glyph_shift_177_comment =
    "C++ Interface:\n"
    "getGlyphShift(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_glyph_shift\n"
    "//       Access: Published\n"
    "//  Description: Returns the vertical shift of each letter as\n"
    "//               specified by set_glyph_shift().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_glyph_shift_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::set_text_scale(float text_scale)
 *******************************************************************/
static PyObject *Dtool_TextProperties_set_text_scale_178(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::set_text_scale(float text_scale)
        double param1;
        static char * key_word_list[] = {(char *)"text_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTextScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTextScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_text_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.setTextScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextScale(non-const TextProperties this, float text_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_set_text_scale_178_comment =
    "C++ Interface:\n"
    "setTextScale(non-const TextProperties this, float text_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::set_text_scale\n"
    "//       Access: Published\n"
    "//  Description: Specifies the factor by which to scale the text, in\n"
    "//               addition to any scalings imposed by the node, as well\n"
    "//               as in addition to the glyph scale.\n"
    "//\n"
    "//               The text scale is not cumulative when applied to\n"
    "//               nested TextProperties.  See also set_glyph_scale(),\n"
    "//               which is cumulative.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_set_text_scale_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextProperties::clear_text_scale(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_clear_text_scale_179(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextProperties::clear_text_scale(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTextScale", key_word_list));
        else
            (PyArg_Parse(args, ":clearTextScale"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_text_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.clearTextScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTextScale(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_clear_text_scale_179_comment =
    "C++ Interface:\n"
    "clearTextScale(non-const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::clear_text_scale\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_clear_text_scale_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextProperties::has_text_scale(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_has_text_scale_180(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextProperties::has_text_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTextScale", key_word_list));
        else
            (PyArg_Parse(args, ":hasTextScale"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextProperties*)local_this)->has_text_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTextScale(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_has_text_scale_180_comment =
    "C++ Interface:\n"
    "hasTextScale(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::has_text_scale\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_has_text_scale_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextProperties::get_text_scale(void) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_text_scale_181(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextProperties::get_text_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextScale", key_word_list));
        else
            (PyArg_Parse(args, ":getTextScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextProperties*)local_this)->get_text_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextScale(const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_text_scale_181_comment =
    "C++ Interface:\n"
    "getTextScale(const TextProperties this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::get_text_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the scale factor of the text as specified\n"
    "//               by set_text_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_get_text_scale_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextProperties::add_properties(TextProperties const &other)
 *******************************************************************/
static PyObject *Dtool_TextProperties_add_properties_182(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TextProperties::add_properties(TextProperties const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addProperties", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addProperties", &param1));
            if(!PyErr_Occurred())
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextProperties.addProperties", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_properties(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextProperties.addProperties() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addProperties(non-const TextProperties this, const TextProperties other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_add_properties_182_comment =
    "C++ Interface:\n"
    "addProperties(non-const TextProperties this, const TextProperties other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::add_properties\n"
    "//       Access: Published\n"
    "//  Description: Sets any properties that are explicitly specified in\n"
    "//               other on this object.  Leaves other properties\n"
    "//               unchanged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_add_properties_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextProperties::write(ostream &out, int indent_level) const
 * void TextProperties::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_TextProperties_write_183(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void TextProperties::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextProperties.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const TextProperties*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void TextProperties::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextProperties.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const TextProperties*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const TextProperties this, non-const Ostream out)\n"
          "write(const TextProperties this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_write_183_comment =
    "C++ Interface:\n"
    "write(const TextProperties this, non-const Ostream out)\n"
    "write(const TextProperties this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextProperties::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextProperties_write_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TextProperties::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_get_class_type_184(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TextProperties::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TextProperties::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_get_class_type_184_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TextProperties_get_class_type_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextNode *TextProperties::downcast_to_TextNode(void)
 *******************************************************************/
static PyObject *Dtool_TextProperties_downcast_to_TextNode_254(PyObject *self, PyObject *args,PyObject *kwds) {
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextNode *TextProperties::downcast_to_TextNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToTextNode", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToTextNode"));
        if(!PyErr_Occurred())
        {
            TextNode *return_value = (TextNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextProperties.downcastToTextNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToTextNode(non-const TextProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextProperties_downcast_to_TextNode_254_comment =
    "C++ Interface:\n"
    "downcastToTextNode(non-const TextProperties this)\n"
    "\n"
    "downcast from TextProperties to TextNode\n"
    "";
#else
static const char * Dtool_TextProperties_downcast_to_TextNode_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextProperties::TextProperties(void)
 * TextProperties::TextProperties(TextProperties const &copy)
 *******************************************************************/
int  Dtool_Init_TextProperties(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TextProperties::TextProperties(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TextProperties", key_word_list))
            {
                TextProperties *return_value = new TextProperties();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TextProperties,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-TextProperties::TextProperties(TextProperties const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TextProperties", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TextProperties", &param0));
                if(!PyErr_Occurred())
                {
                    TextProperties *param0_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextProperties, 0, "TextProperties.TextProperties", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TextProperties *return_value = new TextProperties(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TextProperties,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TextProperties() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TextProperties()\n"
          "TextProperties(const TextProperties copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TextProperties(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextProperties)
    {
        printf("TextProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextProperties * local_this = (TextProperties *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextProperties)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextProperties(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextProperties)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TextGraphic 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline NodePath TextGraphic::get_model(void) const
 *******************************************************************/
static PyObject *Dtool_TextGraphic_get_model_188(PyObject *self, PyObject *args,PyObject *kwds) {
    TextGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath TextGraphic::get_model(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModel", key_word_list));
        else
            (PyArg_Parse(args, ":getModel"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const TextGraphic*)local_this)->get_model();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModel(const TextGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextGraphic_get_model_188_comment =
    "C++ Interface:\n"
    "getModel(const TextGraphic this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::get_model\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath associated with the graphic,\n"
    "//               that renders the desired image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextGraphic_get_model_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextGraphic::set_model(NodePath const &model)
 *******************************************************************/
static PyObject *Dtool_TextGraphic_set_model_189(PyObject *self, PyObject *args,PyObject *kwds) {
    TextGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextGraphic::set_model(NodePath const &model)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"model", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setModel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setModel", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "TextGraphic.setModel", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_model(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextGraphic.setModel() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setModel(non-const TextGraphic this, const NodePath model)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextGraphic_set_model_189_comment =
    "C++ Interface:\n"
    "setModel(non-const TextGraphic this, const NodePath model)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::set_model\n"
    "//       Access: Published\n"
    "//  Description: Changes the NodePath associated with the graphic.\n"
    "//               This NodePath should contain geometry that will\n"
    "//               render the desired graphic image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextGraphic_set_model_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextGraphic::get_frame(void) const
 *******************************************************************/
static PyObject *Dtool_TextGraphic_get_frame_190(PyObject *self, PyObject *args,PyObject *kwds) {
    TextGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextGraphic::get_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getFrame"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextGraphic*)local_this)->get_frame();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrame(const TextGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextGraphic_get_frame_190_comment =
    "C++ Interface:\n"
    "getFrame(const TextGraphic this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::get_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the frame specified for the graphic.  This is\n"
    "//               the amount of space that will be reserved for the\n"
    "//               graphic when it is embedded in a text paragraph, in\n"
    "//               the form (left, right, bottom, top).\n"
    "//\n"
    "//               The actual graphic, as rendered by the NodePath\n"
    "//               specified via set_model(), should more or less fit\n"
    "//               within this rectangle.  It is not required to fit\n"
    "//               completely within it, but if it does not, it may\n"
    "//               visually overlap with nearby text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextGraphic_get_frame_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextGraphic::set_frame(LVecBase4f const &frame)
 * inline void TextGraphic::set_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_TextGraphic_set_frame_191(PyObject *self, PyObject *args,PyObject *kwds) {
    TextGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextGraphic::set_frame(LVecBase4f const &frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextGraphic.setFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextGraphic.setFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextGraphic::set_frame(float left, float right, float bottom, float top)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrame", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_frame((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextGraphic.setFrame() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrame(non-const TextGraphic this, const VBase4 frame)\n"
          "setFrame(non-const TextGraphic this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextGraphic_set_frame_191_comment =
    "C++ Interface:\n"
    "setFrame(non-const TextGraphic this, const VBase4 frame)\n"
    "setFrame(non-const TextGraphic this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::set_frame\n"
    "//       Access: Published\n"
    "//  Description: Specifies the (left, right, bottom, top) bounding\n"
    "//               frame for the graphic.  See get_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::set_frame\n"
    "//       Access: Published\n"
    "//  Description: Specifies the (left, right, bottom, top) bounding\n"
    "//               frame for the graphic.  See get_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextGraphic_set_frame_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextGraphic::get_instance_flag(void) const
 *******************************************************************/
static PyObject *Dtool_TextGraphic_get_instance_flag_192(PyObject *self, PyObject *args,PyObject *kwds) {
    TextGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextGraphic::get_instance_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInstanceFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getInstanceFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextGraphic*)local_this)->get_instance_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInstanceFlag(const TextGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextGraphic_get_instance_flag_192_comment =
    "C++ Interface:\n"
    "getInstanceFlag(const TextGraphic this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::get_instance_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns the instance_flag.  See set_instance_flag().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextGraphic_get_instance_flag_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextGraphic::set_instance_flag(bool instance_flag)
 *******************************************************************/
static PyObject *Dtool_TextGraphic_set_instance_flag_193(PyObject *self, PyObject *args,PyObject *kwds) {
    TextGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextGraphic::set_instance_flag(bool instance_flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"instance_flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInstanceFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setInstanceFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_instance_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextGraphic.setInstanceFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInstanceFlag(non-const TextGraphic this, bool instance_flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextGraphic_set_instance_flag_193_comment =
    "C++ Interface:\n"
    "setInstanceFlag(non-const TextGraphic this, bool instance_flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextGraphic::set_instance_flag\n"
    "//       Access: Published\n"
    "//  Description: Sets the instance_flag.  When this is true, the\n"
    "//               graphic is directly instanced to the scene graph\n"
    "//               whenever it appears; when it is false, the graphic is\n"
    "//               copied.  The default is false, which is best for most\n"
    "//               applications.  You might need to set it true for\n"
    "//               special kinds of \"graphics\" like interactive\n"
    "//               elements, for instance a PGEntry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextGraphic_set_instance_flag_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextGraphic::TextGraphic(void)
 * inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4f const &frame)
 * inline TextGraphic::TextGraphic(NodePath const &model, float left, float right, float bottom, float top)
 *******************************************************************/
int  Dtool_Init_TextGraphic(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline TextGraphic::TextGraphic(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TextGraphic", key_word_list))
            {
                TextGraphic *return_value = new TextGraphic();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TextGraphic,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4f const &frame)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"model", (char *)"frame", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:TextGraphic", key_word_list, &param0, &param1))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "TextGraphic.TextGraphic", 1, coerced_ptr, report_errors);
LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextGraphic.TextGraphic", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        TextGraphic *return_value = new TextGraphic(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TextGraphic,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline TextGraphic::TextGraphic(NodePath const &model, float left, float right, float bottom, float top)
                PyObject *param0;
                double param1;
                double param2;
                double param3;
                double param4;
                static char * key_word_list[] = {(char *)"model", (char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odddd:TextGraphic", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "TextGraphic.TextGraphic", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        TextGraphic *return_value = new TextGraphic(*param0_this, (float)param1, (float)param2, (float)param3, (float)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TextGraphic,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TextGraphic() takes 0, 2, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TextGraphic()\n"
          "TextGraphic(const NodePath model, const VBase4 frame)\n"
          "TextGraphic(const NodePath model, float left, float right, float bottom, float top)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TextGraphic(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextGraphic)
    {
        printf("TextGraphic ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextGraphic * local_this = (TextGraphic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextGraphic)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextGraphic(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextGraphic)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TextPropertiesManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TextPropertiesManager::set_properties(basic_string< char > const &name, TextProperties const &properties)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_set_properties_196(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TextPropertiesManager::set_properties(basic_string< char > const &name, TextProperties const &properties)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"properties", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setProperties", key_word_list, &param1_str, &param1_len, &param2))
            {
                TextProperties *param2_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextProperties, 2, "TextPropertiesManager.setProperties", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_properties(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextPropertiesManager.setProperties() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setProperties(non-const TextPropertiesManager this, string name, const TextProperties properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_set_properties_196_comment =
    "C++ Interface:\n"
    "setProperties(non-const TextPropertiesManager this, string name, const TextProperties properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::set_properties\n"
    "//       Access: Published\n"
    "//  Description: Defines the TextProperties associated with the\n"
    "//               indicated name.  When the name is subsequently\n"
    "//               encountered in text embedded between \\1 characters in\n"
    "//               a TextNode string, the following text will be\n"
    "//               rendered with these properties.\n"
    "//\n"
    "//               If there was already a TextProperties structure\n"
    "//               associated with this name, it is quietly replaced\n"
    "//               with the new definition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_set_properties_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextProperties TextPropertiesManager::get_properties(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_get_properties_197(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextProperties TextPropertiesManager::get_properties(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getProperties", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getProperties", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            TextProperties result = (local_this)->get_properties(basic_string<char>(param1_str, param1_len));
            TextProperties *return_value = new TextProperties(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextPropertiesManager.getProperties() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProperties(non-const TextPropertiesManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_get_properties_197_comment =
    "C++ Interface:\n"
    "getProperties(non-const TextPropertiesManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::get_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextProperties associated with the\n"
    "//               indicated name.  If there was not previously a\n"
    "//               TextProperties associated with this name, a warning\n"
    "//               is printed and then a default TextProperties\n"
    "//               structure is associated with the name, and returned.\n"
    "//\n"
    "//               Call has_properties() instead to check whether a\n"
    "//               particular name has been defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_get_properties_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextPropertiesManager::has_properties(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_has_properties_198(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TextPropertiesManager::has_properties(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasProperties", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hasProperties", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextPropertiesManager*)local_this)->has_properties(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasProperties(const TextPropertiesManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_has_properties_198_comment =
    "C++ Interface:\n"
    "hasProperties(const TextPropertiesManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::has_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a TextProperties structure has been\n"
    "//               associated with the indicated name, false otherwise.\n"
    "//               Normally this means set_properties() has been called\n"
    "//               with this name, but because get_properties() will\n"
    "//               implicitly create a default TextProperties structure,\n"
    "//               it may also mean simply that get_properties() has\n"
    "//               been called with the indicated name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_has_properties_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextPropertiesManager::clear_properties(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_clear_properties_199(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TextPropertiesManager::clear_properties(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clearProperties", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clearProperties", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_properties(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextPropertiesManager.clearProperties() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearProperties(non-const TextPropertiesManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_clear_properties_199_comment =
    "C++ Interface:\n"
    "clearProperties(non-const TextPropertiesManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::clear_properties\n"
    "//       Access: Published\n"
    "//  Description: Removes the named TextProperties structure from the\n"
    "//               manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_clear_properties_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextPropertiesManager::set_graphic(basic_string< char > const &name, NodePath const &model)
 * void TextPropertiesManager::set_graphic(basic_string< char > const &name, TextGraphic const &graphic)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_set_graphic_200(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void TextPropertiesManager::set_graphic(basic_string< char > const &name, NodePath const &model)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"model", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setGraphic", key_word_list, &param1_str, &param1_len, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "TextPropertiesManager.setGraphic", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_graphic(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void TextPropertiesManager::set_graphic(basic_string< char > const &name, TextGraphic const &graphic)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"graphic", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setGraphic", key_word_list, &param1_str, &param1_len, &param2))
            {
                TextGraphic *param2_this = (TextGraphic *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextGraphic, 2, "TextPropertiesManager.setGraphic", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_graphic(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGraphic(non-const TextPropertiesManager this, string name, const NodePath model)\n"
          "setGraphic(non-const TextPropertiesManager this, string name, const TextGraphic graphic)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_set_graphic_200_comment =
    "C++ Interface:\n"
    "setGraphic(non-const TextPropertiesManager this, string name, const NodePath model)\n"
    "setGraphic(non-const TextPropertiesManager this, string name, const TextGraphic graphic)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::set_graphic\n"
    "//       Access: Published\n"
    "//  Description: Defines the TextGraphic associated with the\n"
    "//               indicated name.  When the name is subsequently\n"
    "//               encountered in text embedded between \\5 characters in\n"
    "//               a TextNode string, the specified graphic will be\n"
    "//               embedded in the text at that point.\n"
    "//\n"
    "//               If there was already a TextGraphic structure\n"
    "//               associated with this name, it is quietly replaced\n"
    "//               with the new definition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::set_graphic\n"
    "//       Access: Published\n"
    "//  Description: This flavor of set_graphic implicitly creates a frame\n"
    "//               for the model using the model's actual computed\n"
    "//               bounding volume, as derived from\n"
    "//               NodePath::calc_tight_bounds().  Create a TextGraphic\n"
    "//               object first if you want to have explicit control of\n"
    "//               the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_set_graphic_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextGraphic TextPropertiesManager::get_graphic(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_get_graphic_201(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextGraphic TextPropertiesManager::get_graphic(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getGraphic", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getGraphic", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            TextGraphic result = (local_this)->get_graphic(basic_string<char>(param1_str, param1_len));
            TextGraphic *return_value = new TextGraphic(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextGraphic,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextPropertiesManager.getGraphic() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGraphic(non-const TextPropertiesManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_get_graphic_201_comment =
    "C++ Interface:\n"
    "getGraphic(non-const TextPropertiesManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::get_graphic\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextGraphic associated with the\n"
    "//               indicated name.  If there was not previously a\n"
    "//               TextGraphic associated with this name, a warning\n"
    "//               is printed and then a default TextGraphic\n"
    "//               structure is associated with the name, and returned.\n"
    "//\n"
    "//               Call has_graphic() instead to check whether a\n"
    "//               particular name has been defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_get_graphic_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextPropertiesManager::has_graphic(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_has_graphic_202(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TextPropertiesManager::has_graphic(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasGraphic", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hasGraphic", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextPropertiesManager*)local_this)->has_graphic(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasGraphic(const TextPropertiesManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_has_graphic_202_comment =
    "C++ Interface:\n"
    "hasGraphic(const TextPropertiesManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::has_graphic\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a TextGraphic structure has been\n"
    "//               associated with the indicated name, false otherwise.\n"
    "//               Normally this means set_graphic() has been called\n"
    "//               with this name, but because get_graphic() will\n"
    "//               implicitly create a default TextGraphic structure,\n"
    "//               it may also mean simply that get_graphic() has\n"
    "//               been called with the indicated name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_has_graphic_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextPropertiesManager::clear_graphic(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_clear_graphic_203(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TextPropertiesManager::clear_graphic(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clearGraphic", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clearGraphic", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_graphic(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextPropertiesManager.clearGraphic() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearGraphic(non-const TextPropertiesManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_clear_graphic_203_comment =
    "C++ Interface:\n"
    "clearGraphic(non-const TextPropertiesManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::clear_graphic\n"
    "//       Access: Published\n"
    "//  Description: Removes the named TextGraphic structure from the\n"
    "//               manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_clear_graphic_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextPropertiesManager::write(ostream &out, int indent_level) const
 * void TextPropertiesManager::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_write_204(PyObject *self, PyObject *args,PyObject *kwds) {
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void TextPropertiesManager::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextPropertiesManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const TextPropertiesManager*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void TextPropertiesManager::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextPropertiesManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const TextPropertiesManager*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const TextPropertiesManager this, non-const Ostream out)\n"
          "write(const TextPropertiesManager this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_write_204_comment =
    "C++ Interface:\n"
    "write(const TextPropertiesManager this, non-const Ostream out)\n"
    "write(const TextPropertiesManager this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_write_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_TextPropertiesManager_get_global_ptr_205(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            TextPropertiesManager *return_value = TextPropertiesManager::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextPropertiesManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextPropertiesManager_get_global_ptr_205_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextPropertiesManager::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the pointer to the global TextPropertiesManager\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextPropertiesManager_get_global_ptr_205_comment = NULL;
#endif

int  Dtool_Init_TextPropertiesManager(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TextPropertiesManager)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TextPropertiesManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextPropertiesManager)
    {
        printf("TextPropertiesManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextPropertiesManager * local_this = (TextPropertiesManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextPropertiesManager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextPropertiesManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextPropertiesManager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TextAssembler 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TextAssembler::operator =(TextAssembler const &copy)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_operator_208(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TextAssembler::operator =(TextAssembler const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TextAssembler *param1_this = (TextAssembler *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextAssembler, 1, "TextAssembler.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TextAssembler *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TextAssembler,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextAssembler.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TextAssembler this, const TextAssembler copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_operator_208_comment =
    "C++ Interface:\n"
    "assign(non-const TextAssembler this, const TextAssembler copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_operator_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextAssembler::clear(void)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_clear_210(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TextAssembler::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_clear_210_comment =
    "C++ Interface:\n"
    "clear(non-const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::clear\n"
    "//       Access: Published\n"
    "//  Description: Reinitializes the contents of the TextAssembler.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_clear_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_usage_hint_211(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint)
        int param1;
        static char * key_word_list[] = {(char *)"usage_hint", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setUsageHint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setUsageHint", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_usage_hint((GeomEnums::UsageHint)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.setUsageHint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUsageHint(non-const TextAssembler this, int usage_hint)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_usage_hint_211_comment =
    "C++ Interface:\n"
    "setUsageHint(non-const TextAssembler this, int usage_hint)\n"
    "\n"
    "// Filename: textAssembler.I\n"
    "// Created by:  drose (06Apr04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_usage_hint\n"
    "//       Access: Published\n"
    "//  Description: Specifies the UsageHint that will be applied to\n"
    "//               generated geometry.  The default is UH_static, which\n"
    "//               is probably the right setting, but if you know the\n"
    "//               TextNode's geometry will have a short lifespan, it\n"
    "//               may be better to set it to UH_stream.  See\n"
    "//               geomEnums.h.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_usage_hint_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_usage_hint_212(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUsageHint", key_word_list));
        else
            (PyArg_Parse(args, ":getUsageHint"));
        if(!PyErr_Occurred())
        {
            GeomEnums::UsageHint return_value = ((const TextAssembler*)local_this)->get_usage_hint();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUsageHint(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_usage_hint_212_comment =
    "C++ Interface:\n"
    "getUsageHint(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_usage_hint\n"
    "//       Access: Published\n"
    "//  Description: Returns the UsageHint that will be applied to\n"
    "//               generated geometry.  See set_usage_hint().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_usage_hint_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextAssembler::set_max_rows(int max_rows)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_max_rows_213(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextAssembler::set_max_rows(int max_rows)
        int param1;
        static char * key_word_list[] = {(char *)"max_rows", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxRows", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxRows", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_rows((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.setMaxRows() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxRows(non-const TextAssembler this, int max_rows)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_max_rows_213_comment =
    "C++ Interface:\n"
    "setMaxRows(non-const TextAssembler this, int max_rows)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_max_rows\n"
    "//       Access: Published\n"
    "//  Description: If max_rows is greater than zero, no more than\n"
    "//               max_rows will be accepted.  Text beyond that will be\n"
    "//               truncated.\n"
    "//\n"
    "//               Setting this will not truncate text immediately.  You\n"
    "//               must follow this up with a call to set_wtext() to\n"
    "//               truncate the existing text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_max_rows_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextAssembler::get_max_rows(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_max_rows_214(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextAssembler::get_max_rows(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxRows", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxRows"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextAssembler*)local_this)->get_max_rows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxRows(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_max_rows_214_comment =
    "C++ Interface:\n"
    "getMaxRows(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_max_rows\n"
    "//       Access: Published\n"
    "//  Description: If max_rows is greater than zero, no more than\n"
    "//               max_rows will be accepted.  Text beyond that will be\n"
    "//               truncated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_max_rows_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_dynamic_merge_215(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextAssembler::set_dynamic_merge(bool dynamic_merge)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"dynamic_merge", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDynamicMerge", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setDynamicMerge", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_dynamic_merge((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.setDynamicMerge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDynamicMerge(non-const TextAssembler this, bool dynamic_merge)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_dynamic_merge_215_comment =
    "C++ Interface:\n"
    "setDynamicMerge(non-const TextAssembler this, bool dynamic_merge)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_dynamic_merge\n"
    "//       Access: Published\n"
    "//  Description: Sets the dynamic_merge flag.  See\n"
    "//               TextNode::set_flatten_flags().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_dynamic_merge_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextAssembler::get_dynamic_merge(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_dynamic_merge_216(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextAssembler::get_dynamic_merge(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDynamicMerge", key_word_list));
        else
            (PyArg_Parse(args, ":getDynamicMerge"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextAssembler*)local_this)->get_dynamic_merge();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDynamicMerge(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_dynamic_merge_216_comment =
    "C++ Interface:\n"
    "getDynamicMerge(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_dynamic_merge\n"
    "//       Access: Published\n"
    "//  Description: Returns the dynamic_merge flag.  See\n"
    "//               TextNode::set_flatten_flags().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_dynamic_merge_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextAssembler::set_multiline_mode(bool flag)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_multiline_mode_217(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextAssembler::set_multiline_mode(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMultilineMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setMultilineMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_multiline_mode((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.setMultilineMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMultilineMode(non-const TextAssembler this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_multiline_mode_217_comment =
    "C++ Interface:\n"
    "setMultilineMode(non-const TextAssembler this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_multiline_mode\n"
    "//       Access: Published\n"
    "//  Description: Sets the multiline mode flag. Set the multiline\n"
    "//               mode to allow text to wrap. It defaults to true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_multiline_mode_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextAssembler::get_multiline_mode(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_multiline_mode_218(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextAssembler::get_multiline_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMultilineMode", key_word_list));
        else
            (PyArg_Parse(args, ":getMultilineMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextAssembler*)local_this)->get_multiline_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMultilineMode(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_multiline_mode_218_comment =
    "C++ Interface:\n"
    "getMultilineMode(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_multiline_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the multline_mode flag.  See\n"
    "//               TextNode::set_multiline_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_multiline_mode_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextAssembler::set_properties(TextProperties const &properties)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_properties_219(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextAssembler::set_properties(TextProperties const &properties)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"properties", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setProperties", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setProperties", &param1));
            if(!PyErr_Occurred())
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextAssembler.setProperties", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_properties(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextAssembler.setProperties() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setProperties(non-const TextAssembler this, const TextProperties properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_properties_219_comment =
    "C++ Interface:\n"
    "setProperties(non-const TextAssembler this, const TextProperties properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_properties\n"
    "//       Access: Published\n"
    "//  Description: Specifies the default TextProperties that are applied\n"
    "//               to the text in the absence of any nested property\n"
    "//               change sequences.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_properties_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextProperties const &TextAssembler::get_properties(void) const
 * inline TextProperties const &TextAssembler::get_properties(int n) const
 * inline TextProperties const &TextAssembler::get_properties(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_properties_220(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline TextProperties const &TextAssembler::get_properties(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getProperties", key_word_list));
            else
                (PyArg_Parse(args, ":getProperties"));
            if(!PyErr_Occurred())
            {
                TextProperties const *return_value = &(((const TextAssembler*)local_this)->get_properties());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,false, true);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline TextProperties const &TextAssembler::get_properties(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getProperties", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getProperties", &param1));
            if(!PyErr_Occurred())
            {
                TextProperties const *return_value = &(((const TextAssembler*)local_this)->get_properties((int)param1));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,false, true);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline TextProperties const &TextAssembler::get_properties(int r, int c) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getProperties", key_word_list, &param1, &param2))
            {
                TextProperties const *return_value = &(((const TextAssembler*)local_this)->get_properties((int)param1, (int)param2));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,false, true);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getProperties() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getProperties(const TextAssembler this)\n"
          "getProperties(const TextAssembler this, int n)\n"
          "getProperties(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_properties_220_comment =
    "C++ Interface:\n"
    "getProperties(const TextAssembler this)\n"
    "getProperties(const TextAssembler this, int n)\n"
    "getProperties(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the default TextProperties that are applied\n"
    "//               to the text in the absence of any nested property\n"
    "//               change sequences.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextProperties in effect for the object\n"
    "//               at the indicated position in the pre-wordwrapped\n"
    "//               string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextProperties in effect for the object\n"
    "//               at the indicated position in the indicated row.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_properties_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextAssembler::set_wtext(basic_string< wchar_t > const &wtext)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_wtext_221(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool TextAssembler::set_wtext(basic_string< wchar_t > const &wtext)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"wtext", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:setWtext", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:setWtext", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            bool return_value = (local_this)->set_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.setWtext() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWtext(non-const TextAssembler this, string wtext)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_wtext_221_comment =
    "C++ Interface:\n"
    "setWtext(non-const TextAssembler this, string wtext)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_wtext\n"
    "//       Access: Published\n"
    "//  Description: Accepts a new text string and associated properties\n"
    "//               structure, and precomputes the wordwrapping layout\n"
    "//               appropriately.  After this call,\n"
    "//               get_wordwrapped_wtext() and get_num_rows() can be\n"
    "//               called.\n"
    "//\n"
    "//               The return value is true if all the text is accepted,\n"
    "//               or false if some was truncated (see set_max_rows()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_wtext_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextAssembler::set_wsubstr(basic_string< wchar_t > const &wtext, int start, int count)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_set_wsubstr_222(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool TextAssembler::set_wsubstr(basic_string< wchar_t > const &wtext, int start, int count)
        PyUnicodeObject *param1
;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"wtext", (char *)"start", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Uii:setWsubstr", key_word_list, &param1, &param2, &param3))
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            bool return_value = (local_this)->set_wsubstr(basic_string<wchar_t>((wchar_t *)param1_str, param1_len), (int)param2, (int)param3);
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.setWsubstr() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWsubstr(non-const TextAssembler this, string wtext, int start, int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_set_wsubstr_222_comment =
    "C++ Interface:\n"
    "setWsubstr(non-const TextAssembler this, string wtext, int start, int count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::set_wsubstr\n"
    "//       Access: Published\n"
    "//  Description: Replaces the 'count' characters from 'start' of the\n"
    "//               current text with the indicated replacement text.  If\n"
    "//               the replacement text does not have count characters,\n"
    "//               the length of the string will be changed accordingly.\n"
    "//\n"
    "//               The substring may include nested formatting\n"
    "//               characters, but they must be self-contained and\n"
    "//               self-closed.  The formatting characters are not\n"
    "//               literally saved in the internal string; they are\n"
    "//               parsed at the time of the set_wsubstr() call.\n"
    "//\n"
    "//               The return value is true if all the text is accepted,\n"
    "//               or false if some was truncated (see set_max_rows()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_set_wsubstr_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< wchar_t > TextAssembler::get_plain_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_plain_wtext_223(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< wchar_t > TextAssembler::get_plain_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlainWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getPlainWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const TextAssembler*)local_this)->get_plain_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlainWtext(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_plain_wtext_223_comment =
    "C++ Interface:\n"
    "getPlainWtext(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_plain_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns a wstring that represents the contents of the\n"
    "//               text, without any embedded properties characters.  If\n"
    "//               there is an embedded graphic object, a zero value is\n"
    "//               inserted in that position.\n"
    "//\n"
    "//               This string has the same length as\n"
    "//               get_num_characters(), and the characters in this\n"
    "//               string correspond one-to-one with the characters\n"
    "//               returned by get_character(n).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_plain_wtext_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< wchar_t > TextAssembler::get_wordwrapped_plain_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_wordwrapped_plain_wtext_224(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< wchar_t > TextAssembler::get_wordwrapped_plain_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWordwrappedPlainWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getWordwrappedPlainWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const TextAssembler*)local_this)->get_wordwrapped_plain_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWordwrappedPlainWtext(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_wordwrapped_plain_wtext_224_comment =
    "C++ Interface:\n"
    "getWordwrappedPlainWtext(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_wordwrapped_plain_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns a wstring that represents the contents of the\n"
    "//               text, with newlines inserted according to the\n"
    "//               wordwrapping.  The string will contain no embedded\n"
    "//               properties characters.  If there is an embedded\n"
    "//               graphic object, a zero value is inserted in that\n"
    "//               position.\n"
    "//\n"
    "//               This string has the same number of newline characters\n"
    "//               as get_num_rows(), and the characters in this string\n"
    "//               correspond one-to-one with the characters returned by\n"
    "//               get_character(r, c).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_wordwrapped_plain_wtext_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< wchar_t > TextAssembler::get_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_wtext_225(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< wchar_t > TextAssembler::get_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const TextAssembler*)local_this)->get_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWtext(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_wtext_225_comment =
    "C++ Interface:\n"
    "getWtext(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns a wstring that represents the contents of the\n"
    "//               text.\n"
    "//\n"
    "//               The string will contain embedded properties\n"
    "//               characters, which may not exactly match the embedded\n"
    "//               properties characters of the original string, but it\n"
    "//               will encode the same way.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_wtext_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< wchar_t > TextAssembler::get_wordwrapped_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_wordwrapped_wtext_226(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< wchar_t > TextAssembler::get_wordwrapped_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWordwrappedWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getWordwrappedWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const TextAssembler*)local_this)->get_wordwrapped_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWordwrappedWtext(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_wordwrapped_wtext_226_comment =
    "C++ Interface:\n"
    "getWordwrappedWtext(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_wordwrapped_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns a wstring that represents the contents of the\n"
    "//               text, with newlines inserted according to the\n"
    "//               wordwrapping.\n"
    "//\n"
    "//               The string will contain embedded properties\n"
    "//               characters, which may not exactly match the embedded\n"
    "//               properties characters of the original string, but it\n"
    "//               will encode the same way.\n"
    "//\n"
    "//               Embedded properties characters will be closed before\n"
    "//               every newline, then reopened (if necessary) on the\n"
    "//               subsequent character following the newline.  This\n"
    "//               means it will be safe to divide the text up at the\n"
    "//               newline characters and treat each line as an\n"
    "//               independent piece.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_wordwrapped_wtext_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextAssembler::calc_r(int n) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_calc_r_228(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextAssembler::calc_r(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:calcR", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:calcR", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextAssembler*)local_this)->calc_r((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcR(const TextAssembler this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_calc_r_228_comment =
    "C++ Interface:\n"
    "calcR(const TextAssembler this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::calc_r\n"
    "//       Access: Published\n"
    "//  Description: Computes the row index of the nth character or\n"
    "//               graphic object in the text and returns it.\n"
    "//\n"
    "//               If the nth character is not a normal printable\n"
    "//               character with a position in the wordwrapped string,\n"
    "//               returns -1 (for instance, a soft-hyphen character, or\n"
    "//               a newline character, may not have a corresponding\n"
    "//               position).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_calc_r_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextAssembler::calc_c(int n) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_calc_c_229(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextAssembler::calc_c(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:calcC", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:calcC", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextAssembler*)local_this)->calc_c((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcC(const TextAssembler this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_calc_c_229_comment =
    "C++ Interface:\n"
    "calcC(const TextAssembler this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::calc_c\n"
    "//       Access: Published\n"
    "//  Description: Computes the column index of the nth character or\n"
    "//               graphic object in the text and returns it.\n"
    "//\n"
    "//               If the nth character is not a normal printable\n"
    "//               character with a position in the wordwrapped string,\n"
    "//               returns -1 (for instance, a soft-hyphen character, or\n"
    "//               a newline character, may not have a corresponding\n"
    "//               position).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_calc_c_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TextAssembler::calc_index(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_calc_index_230(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TextAssembler::calc_index(int r, int c) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:calcIndex", key_word_list, &param1, &param2))
        {
            int return_value = ((const TextAssembler*)local_this)->calc_index((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcIndex(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_calc_index_230_comment =
    "C++ Interface:\n"
    "calcIndex(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::calc_index\n"
    "//       Access: Published\n"
    "//  Description: Computes the character index of the character at the\n"
    "//               rth row and cth column position.  This is the inverse\n"
    "//               of calc_r_c().\n"
    "//\n"
    "//               It is legal for c to exceed the index number of the\n"
    "//               last column by 1, and it is legal for r to exceed the\n"
    "//               index number of the last row by 1, if c is 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_calc_index_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextAssembler::get_num_characters(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_num_characters_231(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextAssembler::get_num_characters(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCharacters", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCharacters"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextAssembler*)local_this)->get_num_characters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCharacters(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_num_characters_231_comment =
    "C++ Interface:\n"
    "getNumCharacters(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_num_characters\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of characters of text, before\n"
    "//               wordwrapping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_num_characters_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline wchar_t TextAssembler::get_character(int n) const
 * inline wchar_t TextAssembler::get_character(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_character_232(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline wchar_t TextAssembler::get_character(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCharacter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getCharacter", &param1));
            if(!PyErr_Occurred())
            {
                wchar_t return_value = ((const TextAssembler*)local_this)->get_character((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline wchar_t TextAssembler::get_character(int r, int c) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getCharacter", key_word_list, &param1, &param2))
            {
                wchar_t return_value = ((const TextAssembler*)local_this)->get_character((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCharacter() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCharacter(const TextAssembler this, int n)\n"
          "getCharacter(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_character_232_comment =
    "C++ Interface:\n"
    "getCharacter(const TextAssembler this, int n)\n"
    "getCharacter(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_character\n"
    "//       Access: Published\n"
    "//  Description: Returns the character at the indicated position in\n"
    "//               the pre-wordwrapped string.  If the object at this\n"
    "//               position is a graphic object instead of a character,\n"
    "//               returns 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_character\n"
    "//       Access: Published\n"
    "//  Description: Returns the character at the indicated position in\n"
    "//               the indicated row.  If the object at this position is\n"
    "//               a graphic object instead of a character, returns 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_character_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextGraphic const *TextAssembler::get_graphic(int n) const
 * inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_graphic_233(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline TextGraphic const *TextAssembler::get_graphic(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getGraphic", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getGraphic", &param1));
            if(!PyErr_Occurred())
            {
                TextGraphic const *return_value = ((const TextAssembler*)local_this)->get_graphic((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TextGraphic,false, true);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getGraphic", key_word_list, &param1, &param2))
            {
                TextGraphic const *return_value = ((const TextAssembler*)local_this)->get_graphic((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TextGraphic,false, true);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getGraphic() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getGraphic(const TextAssembler this, int n)\n"
          "getGraphic(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_graphic_233_comment =
    "C++ Interface:\n"
    "getGraphic(const TextAssembler this, int n)\n"
    "getGraphic(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_graphic\n"
    "//       Access: Published\n"
    "//  Description: Returns the graphic object at the indicated position\n"
    "//               in the pre-wordwrapped string.  If the object at this\n"
    "//               position is a character instead of a graphic object,\n"
    "//               returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_graphic\n"
    "//       Access: Published\n"
    "//  Description: Returns the graphic object at the indicated position\n"
    "//               in the indicated row.  If the object at this position\n"
    "//               is a character instead of a graphic object, returns\n"
    "//               NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_graphic_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextAssembler::get_width(int n) const
 * inline float TextAssembler::get_width(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_width_234(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline float TextAssembler::get_width(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWidth", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getWidth", &param1));
            if(!PyErr_Occurred())
            {
                float return_value = ((const TextAssembler*)local_this)->get_width((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline float TextAssembler::get_width(int r, int c) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getWidth", key_word_list, &param1, &param2))
            {
                float return_value = ((const TextAssembler*)local_this)->get_width((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getWidth() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getWidth(const TextAssembler this, int n)\n"
          "getWidth(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_width_234_comment =
    "C++ Interface:\n"
    "getWidth(const TextAssembler this, int n)\n"
    "getWidth(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of the character or object at the\n"
    "//               indicated position in the pre-wordwrapped string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of the character or object at the\n"
    "//               indicated position in the indicated row.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_width_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextAssembler::get_num_rows(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_num_rows_235(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextAssembler::get_num_rows(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumRows", key_word_list));
        else
            (PyArg_Parse(args, ":getNumRows"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextAssembler*)local_this)->get_num_rows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumRows(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_num_rows_235_comment =
    "C++ Interface:\n"
    "getNumRows(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_num_rows\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of rows of text after it has all\n"
    "//               been wordwrapped and assembled.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_num_rows_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextAssembler::get_num_cols(int r) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_num_cols_236(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextAssembler::get_num_cols(int r) const
        int param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNumCols", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNumCols", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextAssembler*)local_this)->get_num_cols((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCols(const TextAssembler this, int r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_num_cols_236_comment =
    "C++ Interface:\n"
    "getNumCols(const TextAssembler this, int r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_num_cols\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of characters and/or graphic\n"
    "//               objects in the nth row.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_num_cols_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float TextAssembler::get_xpos(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_xpos_237(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float TextAssembler::get_xpos(int r, int c) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getXpos", key_word_list, &param1, &param2))
        {
            float return_value = ((const TextAssembler*)local_this)->get_xpos((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXpos(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_xpos_237_comment =
    "C++ Interface:\n"
    "getXpos(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_xpos\n"
    "//       Access: Published\n"
    "//  Description: Returns the x position of the origin of the character\n"
    "//               or graphic object at the indicated position in the\n"
    "//               indicated row.\n"
    "//\n"
    "//               It is legal for c to exceed the index number of the\n"
    "//               last column by 1, and it is legal for r to exceed the\n"
    "//               index number of the last row by 1, if c is 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_xpos_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextAssembler::get_ypos(int r, int c) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_ypos_238(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextAssembler::get_ypos(int r, int c) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"r", (char *)"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getYpos", key_word_list, &param1, &param2))
        {
            float return_value = ((const TextAssembler*)local_this)->get_ypos((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYpos(const TextAssembler this, int r, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_ypos_238_comment =
    "C++ Interface:\n"
    "getYpos(const TextAssembler this, int r, int c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_ypos\n"
    "//       Access: Published\n"
    "//  Description: Returns the y position of the origin of all of the\n"
    "//               characters or graphic objects in the indicated row.\n"
    "//\n"
    "//               It is legal for r to exceed the index number of the\n"
    "//               last row by 1.  The value of c is presently ignored.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_ypos_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > TextAssembler::assemble_text(void)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_assemble_text_239(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< PandaNode > TextAssembler::assemble_text(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":assembleText", key_word_list));
        else
            (PyArg_Parse(args, ":assembleText"));
        if(!PyErr_Occurred())
        {
            PointerTo< PandaNode > return_value = (local_this)->assemble_text();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextAssembler.assembleText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assembleText(non-const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_assemble_text_239_comment =
    "C++ Interface:\n"
    "assembleText(non-const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::assemble_text\n"
    "//       Access: Published\n"
    "//  Description: Actually assembles all of the text into a GeomNode,\n"
    "//               and returns the node (or possibly a parent of the\n"
    "//               node, to keep the shadow separate).  Once this has\n"
    "//               been called, you may query the extents of the text\n"
    "//               via get_ul(), get_lr().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_assemble_text_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &TextAssembler::get_ul(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_ul_240(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector2f const &TextAssembler::get_ul(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUl", key_word_list));
        else
            (PyArg_Parse(args, ":getUl"));
        if(!PyErr_Occurred())
        {
            LVector2f const *return_value = &(((const TextAssembler*)local_this)->get_ul());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUl(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_ul_240_comment =
    "C++ Interface:\n"
    "getUl(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_ul\n"
    "//       Access: Published\n"
    "//  Description: Returns the upper-left corner of the assembled text,\n"
    "//               in 2-d text coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_ul_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &TextAssembler::get_lr(void) const
 *******************************************************************/
static PyObject *Dtool_TextAssembler_get_lr_241(PyObject *self, PyObject *args,PyObject *kwds) {
    TextAssembler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextAssembler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector2f const &TextAssembler::get_lr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLr", key_word_list));
        else
            (PyArg_Parse(args, ":getLr"));
        if(!PyErr_Occurred())
        {
            LVector2f const *return_value = &(((const TextAssembler*)local_this)->get_lr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLr(const TextAssembler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_get_lr_241_comment =
    "C++ Interface:\n"
    "getLr(const TextAssembler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::get_lr\n"
    "//       Access: Published\n"
    "//  Description: Returns the lower-right corner of the assembled text,\n"
    "//               in 2-d text coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_get_lr_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static float TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
 * static float TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_calc_width_242(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 static float TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"graphic", (char *)"properties", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:calcWidth", key_word_list, &param0, &param1))
            {
                TextGraphic *param0_this = (TextGraphic *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextGraphic, 0, "TextAssembler.calcWidth", 1, coerced_ptr, report_errors);
TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextAssembler.calcWidth", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    float return_value = TextAssembler::calc_width(param0_this, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 static float TextAssembler::calc_width(wchar_t character, TextProperties const &properties)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"character", (char *)"properties", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:calcWidth", key_word_list, &param0, &param1))
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextAssembler.calcWidth", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    float return_value = TextAssembler::calc_width((wchar_t)param0, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcWidth(const TextGraphic graphic, const TextProperties properties)\n"
          "calcWidth(int character, const TextProperties properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_calc_width_242_comment =
    "C++ Interface:\n"
    "calcWidth(const TextGraphic graphic, const TextProperties properties)\n"
    "calcWidth(int character, const TextProperties properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::calc_width\n"
    "//       Access: Private, Static\n"
    "//  Description: Returns the width of a single character, according to\n"
    "//               its associated font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::calc_width\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the width of a single character, according to\n"
    "//               its associated font.  This also correctly calculates\n"
    "//               the width of cheesy ligatures and accented\n"
    "//               characters, which may not exist in the font as such.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::calc_width\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the width of a single TextGraphic image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_calc_width_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_has_exact_character_243(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"character", (char *)"properties", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:hasExactCharacter", key_word_list, &param0, &param1))
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextAssembler.hasExactCharacter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = TextAssembler::has_exact_character((wchar_t)param0, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasExactCharacter(int character, const TextProperties properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_has_exact_character_243_comment =
    "C++ Interface:\n"
    "hasExactCharacter(int character, const TextProperties properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::has_exact_character\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the named character exists in the\n"
    "//               font exactly as named, false otherwise.  Note that\n"
    "//               because Panda can assemble glyphs together\n"
    "//               automatically using cheesy accent marks, this is not\n"
    "//               a reliable indicator of whether a suitable glyph can\n"
    "//               be rendered for the character.  For that, use\n"
    "//               has_character() instead.\n"
    "//\n"
    "//               This returns true for whitespace and Unicode\n"
    "//               whitespace characters (if they exist in the font),\n"
    "//               but returns false for characters that would render\n"
    "//               with the \"invalid glyph\".  It also returns false for\n"
    "//               characters that would be synthesized within Panda,\n"
    "//               but see has_character().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_has_exact_character_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_has_character_244(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"character", (char *)"properties", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:hasCharacter", key_word_list, &param0, &param1))
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextAssembler.hasCharacter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = TextAssembler::has_character((wchar_t)param0, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCharacter(int character, const TextProperties properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_has_character_244_comment =
    "C++ Interface:\n"
    "hasCharacter(int character, const TextProperties properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::has_character\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the named character exists in the\n"
    "//               font or can be synthesized by Panda, false otherwise.\n"
    "//               (Panda can synthesize some accented characters by\n"
    "//               combining similar-looking glyphs from the font.)\n"
    "//\n"
    "//               This returns true for whitespace and Unicode\n"
    "//               whitespace characters (if they exist in the font),\n"
    "//               but returns false for characters that would render\n"
    "//               with the \"invalid glyph\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_has_character_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties)
 *******************************************************************/
static PyObject *Dtool_TextAssembler_is_whitespace_245(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"character", (char *)"properties", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:isWhitespace", key_word_list, &param0, &param1))
            {
                TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextAssembler.isWhitespace", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = TextAssembler::is_whitespace((wchar_t)param0, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWhitespace(int character, const TextProperties properties)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextAssembler_is_whitespace_245_comment =
    "C++ Interface:\n"
    "isWhitespace(int character, const TextProperties properties)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextAssembler::is_whitespace\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character represents\n"
    "//               whitespace in the font, or false if anything visible\n"
    "//               will be rendered for it.\n"
    "//\n"
    "//               This returns true for whitespace and Unicode\n"
    "//               whitespace characters (if they exist in the font),\n"
    "//               and returns false for any other characters, including\n"
    "//               characters that do not exist in the font (these would\n"
    "//               be rendered with the \"invalid glyph\", which is\n"
    "//               visible).\n"
    "//\n"
    "//               Note that this function can be reliably used to\n"
    "//               identify Unicode whitespace characters only if the\n"
    "//               font has all of the whitespace characters defined.\n"
    "//               It will return false for any character not in the\n"
    "//               font, even if it is an official Unicode whitespace\n"
    "//               character.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextAssembler_is_whitespace_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextAssembler::TextAssembler(TextAssembler const &copy)
 * TextAssembler::TextAssembler(TextEncoder *encoder)
 *******************************************************************/
int  Dtool_Init_TextAssembler(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 TextAssembler::TextAssembler(TextAssembler const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:TextAssembler", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:TextAssembler", &param0));
            if(!PyErr_Occurred())
            {
                TextAssembler *param0_this = (TextAssembler *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextAssembler, 0, "TextAssembler.TextAssembler", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    TextAssembler *return_value = new TextAssembler(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TextAssembler,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TextAssembler::TextAssembler(TextEncoder *encoder)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"encoder", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:TextAssembler", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:TextAssembler", &param0));
            if(!PyErr_Occurred())
            {
                TextEncoder *param0_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextEncoder, 0, "TextAssembler.TextAssembler", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    TextAssembler *return_value = new TextAssembler(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TextAssembler,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TextAssembler(const TextAssembler copy)\n"
          "TextAssembler(non-const TextEncoder encoder)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TextAssembler(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextAssembler)
    {
        printf("TextAssembler ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextAssembler * local_this = (TextAssembler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextAssembler)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextAssembler(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextAssembler)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TextNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_line_height(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_line_height_258(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_line_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLineHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getLineHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_line_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLineHeight(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_line_height_258_comment =
    "C++ Interface:\n"
    "getLineHeight(const TextNode this)\n"
    "\n"
    "// Filename: textNode.I\n"
    "// Created by:  drose (13Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_line_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of units high each line of text\n"
    "//               is.  This is based on the font.  Note that it is\n"
    "//               possible for the text to include nested font change\n"
    "//               commands, in which case the value of this method is\n"
    "//               questionable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_line_height_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_max_rows(int max_rows)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_max_rows_259(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_max_rows(int max_rows)
        int param1;
        static char * key_word_list[] = {(char *)"max_rows", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxRows", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxRows", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_rows((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setMaxRows() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxRows(non-const TextNode this, int max_rows)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_max_rows_259_comment =
    "C++ Interface:\n"
    "setMaxRows(non-const TextNode this, int max_rows)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_max_rows\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum number of rows that may be formatted\n"
    "//               by the TextNode.  If more text than this is\n"
    "//               attempted, it will be truncated and has_overflow()\n"
    "//               will return true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_max_rows_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_max_rows(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_max_rows_260(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_max_rows(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearMaxRows", key_word_list));
        else
            (PyArg_Parse(args, ":clearMaxRows"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_max_rows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearMaxRows() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearMaxRows(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_max_rows_260_comment =
    "C++ Interface:\n"
    "clearMaxRows(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_max_rows\n"
    "//       Access: Published\n"
    "//  Description: Resets the TextNode's default behavior of not\n"
    "//               limiting the number of rows of text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_max_rows_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::has_max_rows(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_max_rows_261(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::has_max_rows(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMaxRows", key_word_list));
        else
            (PyArg_Parse(args, ":hasMaxRows"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_max_rows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMaxRows(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_max_rows_261_comment =
    "C++ Interface:\n"
    "hasMaxRows(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_max_rows\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a limit on the height of the TextNode\n"
    "//               has been set via set_max_rows(), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_max_rows_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextNode::get_max_rows(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_max_rows_262(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextNode::get_max_rows(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxRows", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxRows"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextNode*)local_this)->get_max_rows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxRows(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_max_rows_262_comment =
    "C++ Interface:\n"
    "getMaxRows(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_max_rows\n"
    "//       Access: Published\n"
    "//  Description: Returns the limit on the height of the TextNode\n"
    "//               specified by set_max_rows().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_max_rows_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::has_overflow(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_overflow_263(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::has_overflow(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasOverflow", key_word_list));
        else
            (PyArg_Parse(args, ":hasOverflow"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_overflow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasOverflow(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_overflow_263_comment =
    "C++ Interface:\n"
    "hasOverflow(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_overflow\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the last text set on the text node\n"
    "//               exceeded the max_rows constraint, or false if it all\n"
    "//               fit.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_overflow_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_frame_color(LVecBase4f const &frame_color)
 * inline void TextNode::set_frame_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_frame_color_264(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextNode::set_frame_color(LVecBase4f const &frame_color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frame_color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrameColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFrameColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextNode.setFrameColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_frame_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextNode.setFrameColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_frame_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrameColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_frame_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setFrameColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrameColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrameColor(non-const TextNode this, const VBase4 frame_color)\n"
          "setFrameColor(non-const TextNode this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_frame_color_264_comment =
    "C++ Interface:\n"
    "setFrameColor(non-const TextNode this, const VBase4 frame_color)\n"
    "setFrameColor(non-const TextNode this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_frame_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_frame_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_frame_color_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_frame_color(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_frame_color_265(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_frame_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameColor", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_frame_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameColor(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_frame_color_265_comment =
    "C++ Interface:\n"
    "getFrameColor(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_frame_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_frame_color_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_card_border(float size, float uv_portion)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_card_border_266(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_card_border(float size, float uv_portion)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"size", (char *)"uv_portion", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setCardBorder", key_word_list, &param1, &param2))
        {
            (local_this)->set_card_border((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setCardBorder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCardBorder(non-const TextNode this, float size, float uv_portion)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_card_border_266_comment =
    "C++ Interface:\n"
    "setCardBorder(non-const TextNode this, float size, float uv_portion)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_border\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_card_border_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_card_border(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_card_border_267(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_card_border(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCardBorder", key_word_list));
        else
            (PyArg_Parse(args, ":clearCardBorder"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_card_border();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearCardBorder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCardBorder(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_card_border_267_comment =
    "C++ Interface:\n"
    "clearCardBorder(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_card_border\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_card_border_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_card_border_size(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_border_size_268(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_card_border_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardBorderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCardBorderSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_card_border_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardBorderSize(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_border_size_268_comment =
    "C++ Interface:\n"
    "getCardBorderSize(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_border_size\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_border_size_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_card_border_uv_portion(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_border_uv_portion_269(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_card_border_uv_portion(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardBorderUvPortion", key_word_list));
        else
            (PyArg_Parse(args, ":getCardBorderUvPortion"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_card_border_uv_portion();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardBorderUvPortion(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_border_uv_portion_269_comment =
    "C++ Interface:\n"
    "getCardBorderUvPortion(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_border_uv_portion\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_border_uv_portion_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::has_card_border(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_card_border_270(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::has_card_border(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCardBorder", key_word_list));
        else
            (PyArg_Parse(args, ":hasCardBorder"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_card_border();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCardBorder(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_card_border_270_comment =
    "C++ Interface:\n"
    "hasCardBorder(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_card_border\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_card_border_270_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_card_color(LVecBase4f const &card_color)
 * inline void TextNode::set_card_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_card_color_271(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextNode::set_card_color(LVecBase4f const &card_color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"card_color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCardColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setCardColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextNode.setCardColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_card_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextNode.setCardColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_card_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setCardColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_card_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setCardColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCardColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCardColor(non-const TextNode this, const VBase4 card_color)\n"
          "setCardColor(non-const TextNode this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_card_color_271_comment =
    "C++ Interface:\n"
    "setCardColor(non-const TextNode this, const VBase4 card_color)\n"
    "setCardColor(non-const TextNode this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_card_color_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_card_color(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_color_272(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_card_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardColor", key_word_list));
        else
            (PyArg_Parse(args, ":getCardColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_card_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardColor(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_color_272_comment =
    "C++ Interface:\n"
    "getCardColor(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_color_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_card_texture(Texture *card_texture)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_card_texture_273(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_card_texture(Texture *card_texture)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"card_texture", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCardTexture", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCardTexture", &param1));
            if(!PyErr_Occurred())
            {
                Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "TextNode.setCardTexture", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_card_texture(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setCardTexture() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCardTexture(non-const TextNode this, non-const Texture card_texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_card_texture_273_comment =
    "C++ Interface:\n"
    "setCardTexture(non-const TextNode this, non-const Texture card_texture)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_texture\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_card_texture_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_card_texture(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_card_texture_274(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_card_texture(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCardTexture", key_word_list));
        else
            (PyArg_Parse(args, ":clearCardTexture"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_card_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearCardTexture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCardTexture(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_card_texture_274_comment =
    "C++ Interface:\n"
    "clearCardTexture(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_card_texture\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_card_texture_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::has_card_texture(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_card_texture_275(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::has_card_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCardTexture", key_word_list));
        else
            (PyArg_Parse(args, ":hasCardTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_card_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCardTexture(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_card_texture_275_comment =
    "C++ Interface:\n"
    "hasCardTexture(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_card_texture\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_card_texture_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *TextNode::get_card_texture(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_texture_276(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Texture *TextNode::get_card_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getCardTexture"));
        if(!PyErr_Occurred())
        {
            Texture *return_value = ((const TextNode*)local_this)->get_card_texture();
            if (return_value != (Texture *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardTexture(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_texture_276_comment =
    "C++ Interface:\n"
    "getCardTexture(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_texture\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_texture_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_frame_as_margin(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_frame_as_margin_277(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_frame_as_margin(float left, float right, float bottom, float top)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrameAsMargin", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_frame_as_margin((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setFrameAsMargin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameAsMargin(non-const TextNode this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_frame_as_margin_277_comment =
    "C++ Interface:\n"
    "setFrameAsMargin(non-const TextNode this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_frame_as_margin\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a border will be drawn around the text\n"
    "//               when it is next created.  The parameters are the\n"
    "//               amount of additional padding to insert between the\n"
    "//               frame and the text in each dimension, and all should\n"
    "//               generally be positive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_frame_as_margin_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_frame_actual(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_frame_actual_278(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_frame_actual(float left, float right, float bottom, float top)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrameActual", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_frame_actual((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setFrameActual() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameActual(non-const TextNode this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_frame_actual_278_comment =
    "C++ Interface:\n"
    "setFrameActual(non-const TextNode this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_frame_actual\n"
    "//       Access: Published\n"
    "//  Description: Similar to set_frame_as_margin, except the frame is\n"
    "//               specified in actual coordinate units (relative to\n"
    "//               the text's origin), irrespective of the size of the\n"
    "//               text.  The left and bottom coordinates should\n"
    "//               generally be negative, while the right and top\n"
    "//               coordinates should generally be positive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_frame_actual_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_frame(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_frame_279(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFrame", key_word_list));
        else
            (PyArg_Parse(args, ":clearFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFrame(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_frame_279_comment =
    "C++ Interface:\n"
    "clearFrame(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_frame\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a border will not be drawn around the\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_frame_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::has_frame(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_frame_280(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::has_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasFrame", key_word_list));
        else
            (PyArg_Parse(args, ":hasFrame"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFrame(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_frame_280_comment =
    "C++ Interface:\n"
    "hasFrame(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_frame\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_frame_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::is_frame_as_margin(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_is_frame_as_margin_281(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::is_frame_as_margin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isFrameAsMargin", key_word_list));
        else
            (PyArg_Parse(args, ":isFrameAsMargin"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->is_frame_as_margin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFrameAsMargin(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_is_frame_as_margin_281_comment =
    "C++ Interface:\n"
    "isFrameAsMargin(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::is_frame_as_margin\n"
    "//       Access: Published\n"
    "//  Description: If this is true, the frame was set via a call to\n"
    "//               set_frame_as_margin(), and the dimension of the frame\n"
    "//               as returned by get_frame_as_set() represent a margin\n"
    "//               all around the text.  If false, then the frame was\n"
    "//               set via a call to set_frame_actual(), and the\n"
    "//               dimensions of the frame as returned by\n"
    "//               get_frame_as_set() are relative to the text's origin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_is_frame_as_margin_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_frame_as_set(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_frame_as_set_282(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_frame_as_set(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameAsSet", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameAsSet"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_frame_as_set();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameAsSet(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_frame_as_set_282_comment =
    "C++ Interface:\n"
    "getFrameAsSet(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_frame_as_set\n"
    "//       Access: Published\n"
    "//  Description: Returns the dimensions of the frame as set by\n"
    "//               set_frame_as_margin() or set_frame_actual().  Use\n"
    "//               is_frame_actual() to determine how to interpret the\n"
    "//               values returned by this function.  It is an error to\n"
    "//               call this if has_frame() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_frame_as_set_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_frame_actual(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_frame_actual_283(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_frame_actual(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameActual", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameActual"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_frame_actual();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameActual(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_frame_actual_283_comment =
    "C++ Interface:\n"
    "getFrameActual(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_frame_actual\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual dimensions of the frame around the\n"
    "//               text.  If the frame was set via set_frame_as_margin(),\n"
    "//               the result returned by this function reflects the\n"
    "//               size of the current text; if the frame was set via\n"
    "//               set_frame_actual(), this returns the values\n"
    "//               actually set.\n"
    "//\n"
    "//               If the text has no frame at all, this returns the\n"
    "//               dimensions of the text itself, as if the frame were\n"
    "//               set with a margin of 0, 0, 0, 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_frame_actual_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_frame_line_width(float line_width)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_frame_line_width_284(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_frame_line_width(float line_width)
        double param1;
        static char * key_word_list[] = {(char *)"line_width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFrameLineWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFrameLineWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_line_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setFrameLineWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameLineWidth(non-const TextNode this, float line_width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_frame_line_width_284_comment =
    "C++ Interface:\n"
    "setFrameLineWidth(non-const TextNode this, float line_width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_frame_line_width\n"
    "//       Access: Published\n"
    "//  Description: Specifies the thickness of the lines that will be\n"
    "//               used to draw the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_frame_line_width_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_frame_line_width(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_frame_line_width_285(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_frame_line_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameLineWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameLineWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_frame_line_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameLineWidth(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_frame_line_width_285_comment =
    "C++ Interface:\n"
    "getFrameLineWidth(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_frame_line_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the thickness of the lines that will be\n"
    "//               used to draw the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_frame_line_width_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_frame_corners(bool corners)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_frame_corners_286(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_frame_corners(bool corners)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"corners", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrameCorners", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFrameCorners", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_corners((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setFrameCorners() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameCorners(non-const TextNode this, bool corners)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_frame_corners_286_comment =
    "C++ Interface:\n"
    "setFrameCorners(non-const TextNode this, bool corners)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_frame_corners\n"
    "//       Access: Published\n"
    "//  Description: Enables or disables the drawing of corners for the\n"
    "//               frame.  These are extra points drawn at each of the\n"
    "//               four corners, to soften the ugly edges generated when\n"
    "//               the line width is greater than one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_frame_corners_286_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::get_frame_corners(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_frame_corners_287(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::get_frame_corners(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameCorners", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameCorners"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->get_frame_corners();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameCorners(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_frame_corners_287_comment =
    "C++ Interface:\n"
    "getFrameCorners(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_frame_corners\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_frame_corners_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_card_as_margin(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_card_as_margin_288(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_card_as_margin(float left, float right, float bottom, float top)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setCardAsMargin", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_card_as_margin((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setCardAsMargin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCardAsMargin(non-const TextNode this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_card_as_margin_288_comment =
    "C++ Interface:\n"
    "setCardAsMargin(non-const TextNode this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_as_margin\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a (possibly opaque or semitransparent)\n"
    "//               card will be held behind the text when it is next\n"
    "//               created.  Like set_frame_as_margin, the parameters are\n"
    "//               the amount of additional padding to insert around the\n"
    "//               text in each dimension, and all should generally be\n"
    "//               positive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_card_as_margin_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_card_actual(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_card_actual_289(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_card_actual(float left, float right, float bottom, float top)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setCardActual", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_card_actual((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setCardActual() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCardActual(non-const TextNode this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_card_actual_289_comment =
    "C++ Interface:\n"
    "setCardActual(non-const TextNode this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_actual\n"
    "//       Access: Published\n"
    "//  Description: Similar to set_card_as_margin, except the card is\n"
    "//               specified in actual coordinate units (relative to\n"
    "//               the text's origin), irrespective of the size of the\n"
    "//               text.  The left and bottom coordinates should\n"
    "//               generally be negative, while the right and top\n"
    "//               coordinates should generally be positive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_card_actual_289_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_card_decal(bool card_decal)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_card_decal_290(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_card_decal(bool card_decal)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"card_decal", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCardDecal", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCardDecal", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_card_decal((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setCardDecal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCardDecal(non-const TextNode this, bool card_decal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_card_decal_290_comment =
    "C++ Interface:\n"
    "setCardDecal(non-const TextNode this, bool card_decal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_card_decal\n"
    "//       Access: Published\n"
    "//  Description: Sets the card_decal flag.  When this is true, the\n"
    "//               text is decalled onto the card, which is necessary if\n"
    "//               the TextNode is to be rendered in the 3-d world\n"
    "//               without putting it in a bin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_card_decal_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_card(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_card_291(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_card(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCard", key_word_list));
        else
            (PyArg_Parse(args, ":clearCard"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_card();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearCard() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCard(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_card_291_comment =
    "C++ Interface:\n"
    "clearCard(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_card\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a card will not be drawn behind the\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_card_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::has_card(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_card_292(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::has_card(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCard", key_word_list));
        else
            (PyArg_Parse(args, ":hasCard"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_card();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCard(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_card_292_comment =
    "C++ Interface:\n"
    "hasCard(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_card\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_card_292_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::get_card_decal(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_decal_293(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::get_card_decal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardDecal", key_word_list));
        else
            (PyArg_Parse(args, ":getCardDecal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->get_card_decal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardDecal(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_decal_293_comment =
    "C++ Interface:\n"
    "getCardDecal(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_decal\n"
    "//       Access: Published\n"
    "//  Description: Returns the card_decal flag.  See set_card_decal().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_decal_293_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextNode::is_card_as_margin(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_is_card_as_margin_294(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextNode::is_card_as_margin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isCardAsMargin", key_word_list));
        else
            (PyArg_Parse(args, ":isCardAsMargin"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->is_card_as_margin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isCardAsMargin(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_is_card_as_margin_294_comment =
    "C++ Interface:\n"
    "isCardAsMargin(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::is_card_as_margin\n"
    "//       Access: Published\n"
    "//  Description: If this is true, the card was set via a call to\n"
    "//               set_card_as_margin(), and the dimension of the card\n"
    "//               as returned by get_card_as_set() represent a margin\n"
    "//               all around the text.  If false, then the card was\n"
    "//               set via a call to set_card_actual(), and the\n"
    "//               dimensions of the card as returned by\n"
    "//               get_card_as_set() are relative to the text's origin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_is_card_as_margin_294_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_card_as_set(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_as_set_295(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_card_as_set(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardAsSet", key_word_list));
        else
            (PyArg_Parse(args, ":getCardAsSet"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_card_as_set();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardAsSet(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_as_set_295_comment =
    "C++ Interface:\n"
    "getCardAsSet(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_as_set\n"
    "//       Access: Published\n"
    "//  Description: Returns the dimensions of the card as set by\n"
    "//               set_card_as_margin() or set_card_actual().  Use\n"
    "//               is_card_actual() to determine how to interpret the\n"
    "//               values returned by this function.  It is an error to\n"
    "//               call this if has_card() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_as_set_295_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_card_actual(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_actual_296(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_card_actual(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardActual", key_word_list));
        else
            (PyArg_Parse(args, ":getCardActual"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_card_actual();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardActual(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_actual_296_comment =
    "C++ Interface:\n"
    "getCardActual(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_actual\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual dimensions of the card around the\n"
    "//               text.  If the card was set via set_card_as_margin(),\n"
    "//               the result returned by this function reflects the\n"
    "//               size of the current text; if the card was set via\n"
    "//               set_card_actual(), this returns the values\n"
    "//               actually set.\n"
    "//\n"
    "//               If the text has no card at all, this returns the\n"
    "//               dimensions of the text itself, as if the card were\n"
    "//               set with a margin of 0, 0, 0, 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_actual_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f TextNode::get_card_transformed(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_card_transformed_297(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f TextNode::get_card_transformed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardTransformed", key_word_list));
        else
            (PyArg_Parse(args, ":getCardTransformed"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const TextNode*)local_this)->get_card_transformed();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardTransformed(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_card_transformed_297_comment =
    "C++ Interface:\n"
    "getCardTransformed(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_card_transformed\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual card dimensions, transformed by\n"
    "//               the matrix set by set_transform().  This returns the\n"
    "//               card dimensions in actual coordinates as seen by the\n"
    "//               rest of the world.  Also see get_upper_left_3d() and\n"
    "//               get_lower_right_3d().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_card_transformed_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_transform(LMatrix4f const &transform)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_transform_298(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_transform(LMatrix4f const &transform)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"transform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTransform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "TextNode.setTransform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_transform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTransform(non-const TextNode this, const Mat4 transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_transform_298_comment =
    "C++ Interface:\n"
    "setTransform(non-const TextNode this, const Mat4 transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_transform\n"
    "//       Access: Published\n"
    "//  Description: Sets an additional transform that is applied to the\n"
    "//               entire text paragraph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_transform_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f TextNode::get_transform(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_transform_299(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f TextNode::get_transform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTransform", key_word_list));
        else
            (PyArg_Parse(args, ":getTransform"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const TextNode*)local_this)->get_transform();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTransform(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_transform_299_comment =
    "C++ Interface:\n"
    "getTransform(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_transform\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_transform_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_coordinate_system(CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_coordinate_system_300(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_coordinate_system(CoordinateSystem cs)
        int param1;
        static char * key_word_list[] = {(char *)"cs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoordinateSystem(non-const TextNode this, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_coordinate_system_300_comment =
    "C++ Interface:\n"
    "setCoordinateSystem(non-const TextNode this, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Specifies the coordinate system in which the text\n"
    "//               will be generated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_coordinate_system_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CoordinateSystem TextNode::get_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_coordinate_system_301(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CoordinateSystem TextNode::get_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const TextNode*)local_this)->get_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoordinateSystem(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_coordinate_system_301_comment =
    "C++ Interface:\n"
    "getCoordinateSystem(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_coordinate_system_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_usage_hint_302(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint)
        int param1;
        static char * key_word_list[] = {(char *)"usage_hint", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setUsageHint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setUsageHint", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_usage_hint((GeomEnums::UsageHint)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setUsageHint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUsageHint(non-const TextNode this, int usage_hint)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_usage_hint_302_comment =
    "C++ Interface:\n"
    "setUsageHint(non-const TextNode this, int usage_hint)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_usage_hint\n"
    "//       Access: Published\n"
    "//  Description: Specifies the UsageHint that will be applied to\n"
    "//               generated geometry.  The default is UH_static, which\n"
    "//               is probably the right setting, but if you know the\n"
    "//               TextNode's geometry will have a short lifespan, it\n"
    "//               may be better to set it to UH_stream.  See\n"
    "//               geomEnums.h.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_usage_hint_302_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_usage_hint_303(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUsageHint", key_word_list));
        else
            (PyArg_Parse(args, ":getUsageHint"));
        if(!PyErr_Occurred())
        {
            GeomEnums::UsageHint return_value = ((const TextNode*)local_this)->get_usage_hint();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUsageHint(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_usage_hint_303_comment =
    "C++ Interface:\n"
    "getUsageHint(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_usage_hint\n"
    "//       Access: Published\n"
    "//  Description: Returns the UsageHint that will be applied to\n"
    "//               generated geometry.  See set_usage_hint().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_usage_hint_303_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_flatten_flags(int flatten_flags)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_flatten_flags_304(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_flatten_flags(int flatten_flags)
        int param1;
        static char * key_word_list[] = {(char *)"flatten_flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFlattenFlags", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFlattenFlags", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_flatten_flags((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setFlattenFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFlattenFlags(non-const TextNode this, int flatten_flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_flatten_flags_304_comment =
    "C++ Interface:\n"
    "setFlattenFlags(non-const TextNode this, int flatten_flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_flatten_flags\n"
    "//       Access: Published\n"
    "//  Description: Sets the flatten flags.  This should be a union of\n"
    "//               the TextNode::FlattenFlags options.  This controls\n"
    "//               the degree of flattening performed on the TextNode's\n"
    "//               internal geometry (i.e. the scene graph returned by\n"
    "//               generate()) each time the text is changed.  In\n"
    "//               general, more flattening means a more optimal result,\n"
    "//               but it will take more time to generate.\n"
    "//\n"
    "//               The choice may be any of these three:\n"
    "//\n"
    "//               FF_none - No flatten operation is called.  The\n"
    "//               letters are left as independent Geoms.\n"
    "//\n"
    "//               FF_light - A flatten_light() operation is called.\n"
    "//               The attributes are applied to the vertices, but no\n"
    "//               nodes are removed.\n"
    "//\n"
    "//               FF_medium - A flatten_medium() operation is called.\n"
    "//               The attributes are applied to the vertices, and a few\n"
    "//               trivial nodes are removed.\n"
    "//\n"
    "//               FF_strong - A flatten_strong() operation is called.\n"
    "//               The attributes are applied to the vertices, and the\n"
    "//               resulting nodes are aggressively combined into as few\n"
    "//               nodes as possible.\n"
    "//\n"
    "//               In addition to the above choices, you may optionally\n"
    "//               include the following flag:\n"
    "//\n"
    "//               FF_dynamic_merge - Copy the geoms into a single\n"
    "//               GeomVertexData as we go, instead of relying on the\n"
    "//               flatten operation at the end.  This pre-flattens the\n"
    "//               text considerably, and may obviate the need for\n"
    "//               flatten altogether; it also tends to improve\n"
    "//               performance considerably even if you do call flatten.\n"
    "//               However, it is not as fast as not calling flatten at\n"
    "//               all.\n"
    "//\n"
    "//               The default is taken from the text-flatten and\n"
    "//               text-dynamic-merge config variables.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_flatten_flags_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextNode::get_flatten_flags(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_flatten_flags_305(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextNode::get_flatten_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFlattenFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getFlattenFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextNode*)local_this)->get_flatten_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFlattenFlags(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_flatten_flags_305_comment =
    "C++ Interface:\n"
    "getFlattenFlags(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_flatten_flags\n"
    "//       Access: Published\n"
    "//  Description: Returns the flatten flags.  See set_flatten_flags().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_flatten_flags_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_font(TextFont *font)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_font_306(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_font(TextFont *font)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"font", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFont", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFont", &param1));
            if(!PyErr_Occurred())
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "TextNode.setFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_font(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFont(non-const TextNode this, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_font_306_comment =
    "C++ Interface:\n"
    "setFont(non-const TextNode this, non-const TextFont font)\n"
    "\n"
    "// These methods are inherited from TextProperties, but we override\n"
    "// here so we can flag the TextNode as dirty when they have been\n"
    "// changed.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_font\n"
    "//       Access: Published\n"
    "//  Description: Sets the font that will be used when making text.  If\n"
    "//               this is set to NULL, the default font will be used,\n"
    "//               which can be set via set_default_font().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_font_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_font(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_font_307(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_font(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFont", key_word_list));
        else
            (PyArg_Parse(args, ":clearFont"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_font();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearFont() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFont(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_font_307_comment =
    "C++ Interface:\n"
    "clearFont(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_font\n"
    "//       Access: Published\n"
    "//  Description: Resets the font to the default font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_font_307_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_small_caps(bool small_caps)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_small_caps_308(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_small_caps(bool small_caps)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"small_caps", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSmallCaps", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSmallCaps", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_small_caps((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setSmallCaps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSmallCaps(non-const TextNode this, bool small_caps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_small_caps_308_comment =
    "C++ Interface:\n"
    "setSmallCaps(non-const TextNode this, bool small_caps)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_small_caps\n"
    "//       Access: Published\n"
    "//  Description: Sets the small_caps flag.  When this is set,\n"
    "//               lowercase letters are generated as scaled-down\n"
    "//               versions of their uppercase equivalents.  This is\n"
    "//               particularly useful to set for fonts that do not have\n"
    "//               lowercase letters.\n"
    "//\n"
    "//               It is also a good idea to set this for a (dynamic)\n"
    "//               font that has already implemented lowercase letters\n"
    "//               as scaled-down versions of their uppercase\n"
    "//               equivalents, since without this flag the texture\n"
    "//               memory may needlessly duplicate equivalent glyphs for\n"
    "//               upper and lowercase letters.  Setting this flag\n"
    "//               causes the texture memory to share the mixed-case\n"
    "//               letters.\n"
    "//\n"
    "//               The amount by which the lowercase letters are scaled\n"
    "//               is specified by set_small_caps_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_small_caps_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_small_caps(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_small_caps_309(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_small_caps(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSmallCaps", key_word_list));
        else
            (PyArg_Parse(args, ":clearSmallCaps"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_small_caps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearSmallCaps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSmallCaps(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_small_caps_309_comment =
    "C++ Interface:\n"
    "clearSmallCaps(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_small_caps\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_small_caps_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_small_caps_scale(float small_caps_scale)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_small_caps_scale_310(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_small_caps_scale(float small_caps_scale)
        double param1;
        static char * key_word_list[] = {(char *)"small_caps_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSmallCapsScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSmallCapsScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_small_caps_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setSmallCapsScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSmallCapsScale(non-const TextNode this, float small_caps_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_small_caps_scale_310_comment =
    "C++ Interface:\n"
    "setSmallCapsScale(non-const TextNode this, float small_caps_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_small_caps_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets the scale factor applied to lowercase letters\n"
    "//               from their uppercase equivalents, when the small_caps\n"
    "//               flag is in effect.  See set_small_caps().  Normally,\n"
    "//               this will be a number less than one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_small_caps_scale_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_small_caps_scale(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_small_caps_scale_311(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_small_caps_scale(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSmallCapsScale", key_word_list));
        else
            (PyArg_Parse(args, ":clearSmallCapsScale"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_small_caps_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearSmallCapsScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSmallCapsScale(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_small_caps_scale_311_comment =
    "C++ Interface:\n"
    "clearSmallCapsScale(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_small_caps_scale\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_small_caps_scale_311_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_slant(float slant)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_slant_312(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_slant(float slant)
        double param1;
        static char * key_word_list[] = {(char *)"slant", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSlant", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSlant", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_slant((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setSlant() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSlant(non-const TextNode this, float slant)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_slant_312_comment =
    "C++ Interface:\n"
    "setSlant(non-const TextNode this, float slant)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_slant\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_slant_312_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_slant(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_slant_313(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_slant(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSlant", key_word_list));
        else
            (PyArg_Parse(args, ":clearSlant"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_slant();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearSlant() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSlant(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_slant_313_comment =
    "C++ Interface:\n"
    "clearSlant(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_slant\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_slant_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_align(TextProperties::Alignment align_type)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_align_314(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_align(TextProperties::Alignment align_type)
        int param1;
        static char * key_word_list[] = {(char *)"align_type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAlign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAlign", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_align((TextProperties::Alignment)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setAlign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlign(non-const TextNode this, int align_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_align_314_comment =
    "C++ Interface:\n"
    "setAlign(non-const TextNode this, int align_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_align\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_align_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_align(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_align_315(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_align(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAlign", key_word_list));
        else
            (PyArg_Parse(args, ":clearAlign"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_align();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearAlign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAlign(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_align_315_comment =
    "C++ Interface:\n"
    "clearAlign(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_align\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_align_315_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_indent(float indent)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_indent_316(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_indent(float indent)
        double param1;
        static char * key_word_list[] = {(char *)"indent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setIndent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setIndent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_indent((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setIndent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIndent(non-const TextNode this, float indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_indent_316_comment =
    "C++ Interface:\n"
    "setIndent(non-const TextNode this, float indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_indent\n"
    "//       Access: Published\n"
    "//  Description: Specifies the amount of extra space that is inserted\n"
    "//               before the first character of each line.  This can be\n"
    "//               thought of as a left margin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_indent_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_indent(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_indent_317(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_indent(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearIndent", key_word_list));
        else
            (PyArg_Parse(args, ":clearIndent"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_indent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearIndent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearIndent(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_indent_317_comment =
    "C++ Interface:\n"
    "clearIndent(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_indent\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_indent_317_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_wordwrap(float wordwrap)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_wordwrap_318(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_wordwrap(float wordwrap)
        double param1;
        static char * key_word_list[] = {(char *)"wordwrap", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWordwrap", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWordwrap", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_wordwrap((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setWordwrap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWordwrap(non-const TextNode this, float wordwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_wordwrap_318_comment =
    "C++ Interface:\n"
    "setWordwrap(non-const TextNode this, float wordwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Sets the text up to automatically wordwrap when it\n"
    "//               exceeds the indicated width.  This can be thought of\n"
    "//               as a right margin or margin width.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_wordwrap_318_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_wordwrap(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_wordwrap_319(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_wordwrap(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearWordwrap", key_word_list));
        else
            (PyArg_Parse(args, ":clearWordwrap"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearWordwrap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearWordwrap(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_wordwrap_319_comment =
    "C++ Interface:\n"
    "clearWordwrap(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Removes the wordwrap setting from the TextNode.  Text\n"
    "//               will be as wide as it is.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_wordwrap_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_text_color(LVecBase4f const &text_color)
 * inline void TextNode::set_text_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_text_color_320(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextNode::set_text_color(LVecBase4f const &text_color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"text_color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTextColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setTextColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextNode.setTextColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_text_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextNode.setTextColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_text_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setTextColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_text_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setTextColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setTextColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setTextColor(non-const TextNode this, const VBase4 text_color)\n"
          "setTextColor(non-const TextNode this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_text_color_320_comment =
    "C++ Interface:\n"
    "setTextColor(non-const TextNode this, const VBase4 text_color)\n"
    "setTextColor(non-const TextNode this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_text_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_text_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_text_color_320_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_text_color(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_text_color_321(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_text_color(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTextColor", key_word_list));
        else
            (PyArg_Parse(args, ":clearTextColor"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_text_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearTextColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTextColor(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_text_color_321_comment =
    "C++ Interface:\n"
    "clearTextColor(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_text_color\n"
    "//       Access: Published\n"
    "//  Description: Removes the text color specification; the text will\n"
    "//               be colored whatever it was in the source font file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_text_color_321_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_shadow_color(LVecBase4f const &shadow_color)
 * inline void TextNode::set_shadow_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_shadow_color_322(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextNode::set_shadow_color(LVecBase4f const &shadow_color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"shadow_color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setShadowColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setShadowColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "TextNode.setShadowColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_shadow_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextNode.setShadowColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_shadow_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setShadowColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_shadow_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setShadowColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setShadowColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setShadowColor(non-const TextNode this, const VBase4 shadow_color)\n"
          "setShadowColor(non-const TextNode this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_shadow_color_322_comment =
    "C++ Interface:\n"
    "setShadowColor(non-const TextNode this, const VBase4 shadow_color)\n"
    "setShadowColor(non-const TextNode this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_shadow_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_shadow_color\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_shadow_color_322_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_shadow_color(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_shadow_color_323(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_shadow_color(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearShadowColor", key_word_list));
        else
            (PyArg_Parse(args, ":clearShadowColor"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_shadow_color();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearShadowColor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearShadowColor(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_shadow_color_323_comment =
    "C++ Interface:\n"
    "clearShadowColor(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_shadow_color\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_shadow_color_323_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_shadow(LVecBase2f const &shadow_offset)
 * inline void TextNode::set_shadow(float xoffset, float yoffset)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_shadow_324(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void TextNode::set_shadow(LVecBase2f const &shadow_offset)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"shadow_offset", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setShadow", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setShadow", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "TextNode.setShadow", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_shadow(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TextNode.setShadow() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_shadow(float xoffset, float yoffset)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"xoffset", (char *)"yoffset", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setShadow", key_word_list, &param1, &param2))
            {
                (local_this)->set_shadow((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setShadow() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setShadow() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setShadow(non-const TextNode this, const VBase2 shadow_offset)\n"
          "setShadow(non-const TextNode this, float xoffset, float yoffset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_shadow_324_comment =
    "C++ Interface:\n"
    "setShadow(non-const TextNode this, const VBase2 shadow_offset)\n"
    "setShadow(non-const TextNode this, float xoffset, float yoffset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the text should be drawn with a\n"
    "//               shadow, by creating a second copy of the text and\n"
    "//               offsetting it slightly behind the first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the text should be drawn with a\n"
    "//               shadow, by creating a second copy of the text and\n"
    "//               offsetting it slightly behind the first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_shadow_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_shadow(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_shadow_325(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_shadow(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearShadow", key_word_list));
        else
            (PyArg_Parse(args, ":clearShadow"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_shadow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearShadow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearShadow(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_shadow_325_comment =
    "C++ Interface:\n"
    "clearShadow(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a shadow will not be drawn behind the\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_shadow_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_bin(basic_string< char > const &bin)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_bin_326(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_bin(basic_string< char > const &bin)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"bin", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setBin", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setBin", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bin(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setBin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBin(non-const TextNode this, string bin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_bin_326_comment =
    "C++ Interface:\n"
    "setBin(non-const TextNode this, string bin)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_bin\n"
    "//       Access: Published\n"
    "//  Description: Names the GeomBin that the TextNode geometry should\n"
    "//               be assigned to.  If this is set, then a\n"
    "//               GeomBinTransition will be created to explicitly place\n"
    "//               each component in the named bin.\n"
    "//\n"
    "//               The draw_order value will also be passed to each\n"
    "//               GeomBinTransition as appropriate; this is\n"
    "//               particularly useful if this names a GeomBinFixed,\n"
    "//               e.g. \"fixed\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_bin_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_bin(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_bin_327(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_bin(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearBin", key_word_list));
        else
            (PyArg_Parse(args, ":clearBin"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_bin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearBin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearBin(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_bin_327_comment =
    "C++ Interface:\n"
    "clearBin(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_bin\n"
    "//       Access: Published\n"
    "//  Description: Removes the effect of a previous call to\n"
    "//               set_bin().  Text will be drawn in whatever bin\n"
    "//               it would like to be drawn in, with no explicit\n"
    "//               ordering.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_bin_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextNode::set_draw_order(int draw_order)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_draw_order_328(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int TextNode::set_draw_order(int draw_order)
        int param1;
        static char * key_word_list[] = {(char *)"draw_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setDrawOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setDrawOrder", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->set_draw_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setDrawOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDrawOrder(non-const TextNode this, int draw_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_draw_order_328_comment =
    "C++ Interface:\n"
    "setDrawOrder(non-const TextNode this, int draw_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_draw_order\n"
    "//       Access: Published\n"
    "//  Description: Sets the drawing order of text created by the\n"
    "//               TextMaker.  This is actually the draw order of the\n"
    "//               card and frame.  The shadow is drawn at\n"
    "//               _draw_order+1, and the text at _draw_order+2.\n"
    "//\n"
    "//               This affects the sorting order assigned to the arcs\n"
    "//               as they are created, and also is passed to whatever\n"
    "//               bin may be assigned via set_bin().\n"
    "//\n"
    "//               The return value is the first unused draw_order\n"
    "//               number, e.g. _draw_order + 3.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_draw_order_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_draw_order(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_draw_order_329(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_draw_order(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDrawOrder", key_word_list));
        else
            (PyArg_Parse(args, ":clearDrawOrder"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_draw_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearDrawOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDrawOrder(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_draw_order_329_comment =
    "C++ Interface:\n"
    "clearDrawOrder(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_draw_order\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_draw_order_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_tab_width(float tab_width)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_tab_width_330(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_tab_width(float tab_width)
        double param1;
        static char * key_word_list[] = {(char *)"tab_width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTabWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTabWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tab_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setTabWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTabWidth(non-const TextNode this, float tab_width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_tab_width_330_comment =
    "C++ Interface:\n"
    "setTabWidth(non-const TextNode this, float tab_width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_tab_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the width of each tab stop, in screen units.  A\n"
    "//               tab character embedded in the text will advance the\n"
    "//               horizontal position to the next tab stop.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_tab_width_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_tab_width(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_tab_width_331(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_tab_width(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTabWidth", key_word_list));
        else
            (PyArg_Parse(args, ":clearTabWidth"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_tab_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearTabWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTabWidth(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_tab_width_331_comment =
    "C++ Interface:\n"
    "clearTabWidth(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_tab_width\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_tab_width_331_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_glyph_scale(float glyph_scale)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_glyph_scale_332(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_glyph_scale(float glyph_scale)
        double param1;
        static char * key_word_list[] = {(char *)"glyph_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGlyphScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setGlyphScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_glyph_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setGlyphScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGlyphScale(non-const TextNode this, float glyph_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_glyph_scale_332_comment =
    "C++ Interface:\n"
    "setGlyphScale(non-const TextNode this, float glyph_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_glyph_scale\n"
    "//       Access: Published\n"
    "//  Description: Specifies the factor by which to scale each letter of\n"
    "//               the text as it is placed.  This can be used (possibly\n"
    "//               in conjunction with set_glyph_shift()) to implement\n"
    "//               superscripting or subscripting.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_glyph_scale_332_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_glyph_scale(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_glyph_scale_333(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_glyph_scale(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearGlyphScale", key_word_list));
        else
            (PyArg_Parse(args, ":clearGlyphScale"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_glyph_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearGlyphScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearGlyphScale(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_glyph_scale_333_comment =
    "C++ Interface:\n"
    "clearGlyphScale(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_glyph_scale\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_glyph_scale_333_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_glyph_shift(float glyph_shift)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_glyph_shift_334(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_glyph_shift(float glyph_shift)
        double param1;
        static char * key_word_list[] = {(char *)"glyph_shift", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGlyphShift", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setGlyphShift", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_glyph_shift((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setGlyphShift() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGlyphShift(non-const TextNode this, float glyph_shift)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_glyph_shift_334_comment =
    "C++ Interface:\n"
    "setGlyphShift(non-const TextNode this, float glyph_shift)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_glyph_shift\n"
    "//       Access: Published\n"
    "//  Description: Specifies a vertical amount to shift each letter of\n"
    "//               the text as it is placed.  This can be used (possibly\n"
    "//               in conjunction with set_glyph_scale()) to implement\n"
    "//               superscripting or subscripting.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_glyph_shift_334_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_glyph_shift(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_glyph_shift_335(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_glyph_shift(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearGlyphShift", key_word_list));
        else
            (PyArg_Parse(args, ":clearGlyphShift"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_glyph_shift();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearGlyphShift() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearGlyphShift(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_glyph_shift_335_comment =
    "C++ Interface:\n"
    "clearGlyphShift(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_glyph_shift\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_glyph_shift_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_text(basic_string< char > const &text)
 * inline void TextNode::set_text(basic_string< char > const &text, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_text_336(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_text(basic_string< char > const &text)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"text", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setText", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setText", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                (local_this)->set_text(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setText() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextNode::set_text(basic_string< char > const &text, TextEncoder::Encoding encoding)
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"text", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setText", key_word_list, &param1_str, &param1_len, &param2))
            {
                (local_this)->set_text(basic_string<char>(param1_str, param1_len), (TextEncoder::Encoding)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextNode.setText() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setText() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setText(non-const TextNode this, string text)\n"
          "setText(non-const TextNode this, string text, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_text_336_comment =
    "C++ Interface:\n"
    "setText(non-const TextNode this, string text)\n"
    "setText(non-const TextNode this, string text, int encoding)\n"
    "\n"
    "// These methods are inherited from TextEncoder, but we override\n"
    "// here so we can flag the TextNode as dirty when they have been\n"
    "// changed.\n"
    "\n"
    "// These methods are inherited from TextEncoder, but we override\n"
    "// here so we can flag the TextNode as dirty when they have been\n"
    "// changed.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_text\n"
    "//       Access: Published\n"
    "//  Description: Changes the text that is displayed under the\n"
    "//               TextNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_text\n"
    "//       Access: Published\n"
    "//  Description: The two-parameter version of set_text() accepts an\n"
    "//               explicit encoding; the text is immediately decoded\n"
    "//               and stored as a wide-character string.  Subsequent\n"
    "//               calls to get_text() will return the same text\n"
    "//               re-encoded using whichever encoding is specified by\n"
    "//               set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_text_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::clear_text(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_clear_text_337(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::clear_text(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearText", key_word_list));
        else
            (PyArg_Parse(args, ":clearText"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.clearText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearText(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_clear_text_337_comment =
    "C++ Interface:\n"
    "clearText(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::clear_text\n"
    "//       Access: Published\n"
    "//  Description: Removes the text from the TextNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_clear_text_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::append_text(basic_string< char > const &text)
 *******************************************************************/
static PyObject *Dtool_TextNode_append_text_338(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::append_text(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:appendText", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:appendText", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->append_text(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.appendText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendText(non-const TextNode this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_append_text_338_comment =
    "C++ Interface:\n"
    "appendText(non-const TextNode this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::append_text\n"
    "//       Access: Published\n"
    "//  Description: Appends the indicates string to the end of the stored\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_append_text_338_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::append_unicode_char(wchar_t character)
 *******************************************************************/
static PyObject *Dtool_TextNode_append_unicode_char_339(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::append_unicode_char(wchar_t character)
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:appendUnicodeChar", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:appendUnicodeChar", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->append_unicode_char((wchar_t)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.appendUnicodeChar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendUnicodeChar(non-const TextNode this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_append_unicode_char_339_comment =
    "C++ Interface:\n"
    "appendUnicodeChar(non-const TextNode this, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::append_unicode_char\n"
    "//       Access: Published\n"
    "//  Description: Appends a single character to the end of the stored\n"
    "//               text.  This may be a wide character, up to 16 bits in\n"
    "//               Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_append_unicode_char_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TextNode::get_wordwrapped_text(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_wordwrapped_text_340(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > TextNode::get_wordwrapped_text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWordwrappedText", key_word_list));
        else
            (PyArg_Parse(args, ":getWordwrappedText"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const TextNode*)local_this)->get_wordwrapped_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWordwrappedText(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_wordwrapped_text_340_comment =
    "C++ Interface:\n"
    "getWordwrappedText(const TextNode this)\n"
    "\n"
    "// After the text has been set, you can query this to determine how\n"
    "// it will be wordwrapped.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_wordwrapped_text\n"
    "//       Access: Public\n"
    "//  Description: Returns a string that represents the contents of the\n"
    "//               text, as it has been formatted by wordwrap rules.\n"
    "//\n"
    "//               In earlier versions, this did not contain any\n"
    "//               embedded special characters like \\1 or \\3; now it\n"
    "//               does.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_wordwrapped_text_340_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::calc_width(basic_string< char > const &line) const
 * float TextNode::calc_width(basic_string< wchar_t > const &line) const
 * float TextNode::calc_width(wchar_t character) const
 *******************************************************************/
static PyObject *Dtool_TextNode_calc_width_341(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 float TextNode::calc_width(basic_string< wchar_t > const &line) const
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"line", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:calcWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:calcWidth", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            float return_value = ((const TextNode*)local_this)->calc_width(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 inline float TextNode::calc_width(basic_string< char > const &line) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"line", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:calcWidth", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:calcWidth", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->calc_width(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 float TextNode::calc_width(wchar_t character) const
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:calcWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:calcWidth", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->calc_width((wchar_t)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcWidth(const TextNode this, string line)\n"
          "calcWidth(const TextNode this, string line)\n"
          "calcWidth(const TextNode this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_calc_width_341_comment =
    "C++ Interface:\n"
    "calcWidth(const TextNode this, string line)\n"
    "calcWidth(const TextNode this, string line)\n"
    "calcWidth(const TextNode this, int character)\n"
    "\n"
    "// These methods calculate the width of a single character or a line\n"
    "// of text in the current font.\n"
    "\n"
    "// These methods calculate the width of a single character or a line\n"
    "// of text in the current font.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::calc_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of a line of text of arbitrary\n"
    "//               characters.  The line should not include the newline\n"
    "//               character.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::calc_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of a single character of the font,\n"
    "//               or 0.0 if the character is not known.  This may be a\n"
    "//               wide character (greater than 255).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::calc_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width of a line of text of arbitrary\n"
    "//               characters.  The line should not include the newline\n"
    "//               character or any embedded control characters like \\1\n"
    "//               or \\3.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_calc_width_341_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextNode::has_exact_character(wchar_t character) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_exact_character_342(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TextNode::has_exact_character(wchar_t character) const
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasExactCharacter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasExactCharacter", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_exact_character((wchar_t)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasExactCharacter(const TextNode this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_exact_character_342_comment =
    "C++ Interface:\n"
    "hasExactCharacter(const TextNode this, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_exact_character\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the named character exists in the\n"
    "//               font exactly as named, false otherwise.  Note that\n"
    "//               because Panda can assemble glyphs together\n"
    "//               automatically using cheesy accent marks, this is not\n"
    "//               a reliable indicator of whether a suitable glyph can\n"
    "//               be rendered for the character.  For that, use\n"
    "//               has_character() instead.\n"
    "//\n"
    "//               This returns true for whitespace and Unicode\n"
    "//               whitespace characters (if they exist in the font),\n"
    "//               but returns false for characters that would render\n"
    "//               with the \"invalid glyph\".  It also returns false for\n"
    "//               characters that would be synthesized within Panda,\n"
    "//               but see has_character().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_exact_character_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextNode::has_character(wchar_t character) const
 *******************************************************************/
static PyObject *Dtool_TextNode_has_character_343(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TextNode::has_character(wchar_t character) const
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasCharacter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasCharacter", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->has_character((wchar_t)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCharacter(const TextNode this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_has_character_343_comment =
    "C++ Interface:\n"
    "hasCharacter(const TextNode this, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::has_character\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the named character exists in the\n"
    "//               font or can be synthesized by Panda, false otherwise.\n"
    "//               (Panda can synthesize some accented characters by\n"
    "//               combining similar-looking glyphs from the font.)\n"
    "//\n"
    "//               This returns true for whitespace and Unicode\n"
    "//               whitespace characters (if they exist in the font),\n"
    "//               but returns false for characters that would render\n"
    "//               with the \"invalid glyph\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_has_character_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextNode::is_whitespace(wchar_t character) const
 *******************************************************************/
static PyObject *Dtool_TextNode_is_whitespace_344(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TextNode::is_whitespace(wchar_t character) const
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isWhitespace", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isWhitespace", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextNode*)local_this)->is_whitespace((wchar_t)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWhitespace(const TextNode this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_is_whitespace_344_comment =
    "C++ Interface:\n"
    "isWhitespace(const TextNode this, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::is_whitespace\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated character represents\n"
    "//               whitespace in the font, or false if anything visible\n"
    "//               will be rendered for it.\n"
    "//\n"
    "//               This returns true for whitespace and Unicode\n"
    "//               whitespace characters (if they exist in the font),\n"
    "//               and returns false for any other characters, including\n"
    "//               characters that do not exist in the font (these would\n"
    "//               be rendered with the \"invalid glyph\", which is\n"
    "//               visible).\n"
    "//\n"
    "//               Note that this function can be reliably used to\n"
    "//               identify Unicode whitespace characters only if the\n"
    "//               font has all of the whitespace characters defined.\n"
    "//               It will return false for any character not in the\n"
    "//               font, even if it is an official Unicode whitespace\n"
    "//               character.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_is_whitespace_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::set_wtext(basic_string< wchar_t > const &wtext)
 *******************************************************************/
static PyObject *Dtool_TextNode_set_wtext_345(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::set_wtext(basic_string< wchar_t > const &wtext)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"wtext", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:setWtext", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:setWtext", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            (local_this)->set_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.setWtext() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWtext(non-const TextNode this, string wtext)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_set_wtext_345_comment =
    "C++ Interface:\n"
    "setWtext(non-const TextNode this, string wtext)\n"
    "\n"
    "// Direct support for wide-character strings.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::set_wtext\n"
    "//       Access: Published\n"
    "//  Description: Changes the text that is displayed under the\n"
    "//               TextNode, with a wide text.  This automatically sets\n"
    "//               the string reported by get_text() to the 8-bit\n"
    "//               encoded version of the same string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_set_wtext_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::append_wtext(basic_string< wchar_t > const &text)
 *******************************************************************/
static PyObject *Dtool_TextNode_append_wtext_346(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::append_wtext(basic_string< wchar_t > const &text)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:appendWtext", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:appendWtext", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            (local_this)->append_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.appendWtext() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendWtext(non-const TextNode this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_append_wtext_346_comment =
    "C++ Interface:\n"
    "appendWtext(non-const TextNode this, string text)\n"
    "\n"
    "// Direct support for wide-character strings.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::append_wtext\n"
    "//       Access: Published\n"
    "//  Description: Appends the indicates string to the end of the stored\n"
    "//               wide-character text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_append_wtext_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< wchar_t > TextNode::get_wordwrapped_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_wordwrapped_wtext_347(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< wchar_t > TextNode::get_wordwrapped_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWordwrappedWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getWordwrappedWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const TextNode*)local_this)->get_wordwrapped_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWordwrappedWtext(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_wordwrapped_wtext_347_comment =
    "C++ Interface:\n"
    "getWordwrappedWtext(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_wordwrapped_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns a wstring that represents the contents of the\n"
    "//               text, as it has been formatted by wordwrap rules.\n"
    "//\n"
    "//               In earlier versions, this did not contain any\n"
    "//               embedded special characters like \\1 or \\3; now it\n"
    "//               does.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_wordwrapped_wtext_347_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void TextNode::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_TextNode_output_348(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void TextNode::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextNode.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const TextNode*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const TextNode this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_output_348_comment =
    "C++ Interface:\n"
    "output(const TextNode this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::output\n"
    "//       Access: Public, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_output_348_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void TextNode::write(ostream &out, int indent_level) const
 * virtual void TextNode::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_TextNode_write_349(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void TextNode::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const TextNode*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void TextNode::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TextNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const TextNode*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const TextNode this, non-const Ostream out)\n"
          "write(const TextNode this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_write_349_comment =
    "C++ Interface:\n"
    "write(const TextNode this, non-const Ostream out)\n"
    "write(const TextNode this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::write\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_write_349_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_left(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_left_350(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_left(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeft", key_word_list));
        else
            (PyArg_Parse(args, ":getLeft"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_left();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeft(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_left_350_comment =
    "C++ Interface:\n"
    "getLeft(const TextNode this)\n"
    "\n"
    "// The following functions return information about the text that\n"
    "// was last built (and is currently visible).\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_left\n"
    "//       Access: Published\n"
    "//  Description: Returns the leftmost extent of the text in local 2-d\n"
    "//               coordinates, unmodified by the set_transform()\n"
    "//               matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_left_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_right(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_right_351(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_right(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRight", key_word_list));
        else
            (PyArg_Parse(args, ":getRight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_right();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRight(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_right_351_comment =
    "C++ Interface:\n"
    "getRight(const TextNode this)\n"
    "\n"
    "// The following functions return information about the text that\n"
    "// was last built (and is currently visible).\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_right\n"
    "//       Access: Published\n"
    "//  Description: Returns the rightmost extent of the text in local 2-d\n"
    "//               coordinates, unmodified by the set_transform()\n"
    "//               matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_right_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_bottom(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_bottom_352(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_bottom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBottom", key_word_list));
        else
            (PyArg_Parse(args, ":getBottom"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_bottom();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBottom(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_bottom_352_comment =
    "C++ Interface:\n"
    "getBottom(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_bottom\n"
    "//       Access: Published\n"
    "//  Description: Returns the bottommost extent of the text in local\n"
    "//               2-d coordinates, unmodified by the set_transform()\n"
    "//               matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_bottom_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_top(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_top_353(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_top(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTop", key_word_list));
        else
            (PyArg_Parse(args, ":getTop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_top();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTop(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_top_353_comment =
    "C++ Interface:\n"
    "getTop(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_top\n"
    "//       Access: Published\n"
    "//  Description: Returns the topmost extent of the text in local 2-d\n"
    "//               coordinates, unmodified by the set_transform()\n"
    "//               matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_top_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_height_354(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_height_354_comment =
    "C++ Interface:\n"
    "getHeight(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the net height of the text in local 2-d\n"
    "//               coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_height_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TextNode::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_width_355(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TextNode::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TextNode*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_width_355_comment =
    "C++ Interface:\n"
    "getWidth(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the net width of the text in local 2-d\n"
    "//               coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_width_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f TextNode::get_upper_left_3d(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_upper_left_3d_356(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f TextNode::get_upper_left_3d(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUpperLeft3d", key_word_list));
        else
            (PyArg_Parse(args, ":getUpperLeft3d"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const TextNode*)local_this)->get_upper_left_3d();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUpperLeft3d(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_upper_left_3d_356_comment =
    "C++ Interface:\n"
    "getUpperLeft3d(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_upper_left_3d\n"
    "//       Access: Published\n"
    "//  Description: Returns the upper-left extent of the text object,\n"
    "//               after it has been transformed into 3-d space by\n"
    "//               applying the set_transform() matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_upper_left_3d_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f TextNode::get_lower_right_3d(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_lower_right_3d_357(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f TextNode::get_lower_right_3d(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowerRight3d", key_word_list));
        else
            (PyArg_Parse(args, ":getLowerRight3d"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const TextNode*)local_this)->get_lower_right_3d();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowerRight3d(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_lower_right_3d_357_comment =
    "C++ Interface:\n"
    "getLowerRight3d(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_lower_right_3d\n"
    "//       Access: Published\n"
    "//  Description: Returns the lower-right extent of the text object,\n"
    "//               after it has been transformed into 3-d space by\n"
    "//               applying the set_transform() matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_lower_right_3d_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextNode::get_num_rows(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_num_rows_358(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextNode::get_num_rows(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumRows", key_word_list));
        else
            (PyArg_Parse(args, ":getNumRows"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextNode*)local_this)->get_num_rows();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumRows(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_num_rows_358_comment =
    "C++ Interface:\n"
    "getNumRows(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_num_rows\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of rows of text that were\n"
    "//               generated.  This counts word-wrapped rows as well as\n"
    "//               rows generated due to embedded newlines.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_num_rows_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > TextNode::generate(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_generate_359(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< PandaNode > TextNode::generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":generate", key_word_list));
        else
            (PyArg_Parse(args, ":generate"));
        if(!PyErr_Occurred())
        {
            PointerTo< PandaNode > return_value = (local_this)->generate();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.generate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_generate_359_comment =
    "C++ Interface:\n"
    "generate(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::generate\n"
    "//       Access: Published\n"
    "//  Description: Generates the text, according to the parameters\n"
    "//               indicated within the TextNode, and returns a Node\n"
    "//               that may be parented within the tree to represent it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_generate_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::update(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_update_360(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_update_360_comment =
    "C++ Interface:\n"
    "update(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::update\n"
    "//       Access: Published\n"
    "//  Description: Can be called after the TextNode has been fully\n"
    "//               configured, to force the node to recompute its text\n"
    "//               immediately, rather than waiting for it to be drawn.\n"
    "//               This call is optional.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_update_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextNode::force_update(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_force_update_361(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextNode::force_update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":forceUpdate", key_word_list));
        else
            (PyArg_Parse(args, ":forceUpdate"));
        if(!PyErr_Occurred())
        {
            (local_this)->force_update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.forceUpdate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forceUpdate(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_force_update_361_comment =
    "C++ Interface:\n"
    "forceUpdate(non-const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::force_update\n"
    "//       Access: Published\n"
    "//  Description: Forces the TextNode to recompute itself now, even if\n"
    "//               it believes nothing has changed.  Normally, this\n"
    "//               should not need to be called, but it may be useful if\n"
    "//               some properties change outside of the TextNode's\n"
    "//               knowledge (for instance, within the font).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_force_update_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PandaNode *TextNode::get_internal_geom(void) const
 *******************************************************************/
static PyObject *Dtool_TextNode_get_internal_geom_362(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PandaNode *TextNode::get_internal_geom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInternalGeom", key_word_list));
        else
            (PyArg_Parse(args, ":getInternalGeom"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const TextNode*)local_this)->get_internal_geom();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInternalGeom(const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_internal_geom_362_comment =
    "C++ Interface:\n"
    "getInternalGeom(const TextNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextNode::get_internal_geom\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual node that is used internally to\n"
    "//               render the text, if the TextNode is parented within\n"
    "//               the scene graph.\n"
    "//\n"
    "//               In general, you should not call this method.  Call\n"
    "//               generate() instead if you want to get a handle to\n"
    "//               geometry that represents the text.  This method is\n"
    "//               provided as a debugging aid only.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextNode_get_internal_geom_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TextNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_get_class_type_363(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TextNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TextNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_get_class_type_363_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TextNode_get_class_type_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PandaNode *TextNode::upcast_to_PandaNode(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_upcast_to_PandaNode_248(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PandaNode *TextNode::upcast_to_PandaNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToPandaNode", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToPandaNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = (PandaNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.upcastToPandaNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToPandaNode(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_upcast_to_PandaNode_248_comment =
    "C++ Interface:\n"
    "upcastToPandaNode(non-const TextNode this)\n"
    "\n"
    "upcast from TextNode to PandaNode\n"
    "";
#else
static const char * Dtool_TextNode_upcast_to_PandaNode_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextEncoder *TextNode::upcast_to_TextEncoder(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_upcast_to_TextEncoder_251(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextEncoder *TextNode::upcast_to_TextEncoder(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTextEncoder", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTextEncoder"));
        if(!PyErr_Occurred())
        {
            TextEncoder *return_value = (TextEncoder *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextEncoder,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.upcastToTextEncoder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTextEncoder(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_upcast_to_TextEncoder_251_comment =
    "C++ Interface:\n"
    "upcastToTextEncoder(non-const TextNode this)\n"
    "\n"
    "upcast from TextNode to TextEncoder\n"
    "";
#else
static const char * Dtool_TextNode_upcast_to_TextEncoder_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextProperties *TextNode::upcast_to_TextProperties(void)
 *******************************************************************/
static PyObject *Dtool_TextNode_upcast_to_TextProperties_253(PyObject *self, PyObject *args,PyObject *kwds) {
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TextProperties *TextNode::upcast_to_TextProperties(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTextProperties", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTextProperties"));
        if(!PyErr_Occurred())
        {
            TextProperties *return_value = (TextProperties *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextNode.upcastToTextProperties() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTextProperties(non-const TextNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextNode_upcast_to_TextProperties_253_comment =
    "C++ Interface:\n"
    "upcastToTextProperties(non-const TextNode this)\n"
    "\n"
    "upcast from TextNode to TextProperties\n"
    "";
#else
static const char * Dtool_TextNode_upcast_to_TextProperties_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextNode::TextNode(basic_string< char > const &name)
 * TextNode::TextNode(basic_string< char > const &name, TextProperties const &copy)
 *******************************************************************/
int  Dtool_Init_TextNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-TextNode::TextNode(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:TextNode", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:TextNode", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                TextNode *return_value = new TextNode(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TextNode,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-TextNode::TextNode(basic_string< char > const &name, TextProperties const &copy)
                char *param0_str; int param0_len;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"name", (char *)"copy", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:TextNode", key_word_list, &param0_str, &param0_len, &param1))
                {
                    TextProperties *param1_this = (TextProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextProperties, 1, "TextNode.TextNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        TextNode *return_value = new TextNode(basic_string<char>(param0_str, param0_len), *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TextNode,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TextNode() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TextNode(string name)\n"
          "TextNode(string name, const TextProperties copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TextNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextNode)
    {
        printf("TextNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextNode * local_this = (TextNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TextEncoder)
        return ( TextEncoder *) local_this;
    if(requested_type == &Dtool_TextProperties)
        return ( TextProperties *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (TextNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (TextNode*)other_this;
    }
    if(from_type == &Dtool_TextEncoder)
    {
          TextEncoder* other_this = (TextEncoder*)from_this;
          return (TextNode*)other_this;
    }
    if(from_type == &Dtool_TextProperties)
    {
          TextProperties* other_this = (TextProperties*)from_this;
          return (TextNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TextNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (TextNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. TextFont | TextFont
//********************************************************************
PyMethodDef Dtool_Methods_TextFont[]= {
  { "makeCopy",(PyCFunction ) &Dtool_TextFont_make_copy_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_make_copy_11_comment},
  { "isValid",(PyCFunction ) &Dtool_TextFont_is_valid_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_is_valid_12_comment},
  { "getLineHeight",(PyCFunction ) &Dtool_TextFont_get_line_height_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_get_line_height_14_comment},
  { "setLineHeight",(PyCFunction ) &Dtool_TextFont_set_line_height_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_set_line_height_15_comment},
  { "getSpaceAdvance",(PyCFunction ) &Dtool_TextFont_get_space_advance_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_get_space_advance_16_comment},
  { "setSpaceAdvance",(PyCFunction ) &Dtool_TextFont_set_space_advance_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_set_space_advance_17_comment},
  { "write",(PyCFunction ) &Dtool_TextFont_write_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_write_18_comment},
  { "getClassType",(PyCFunction ) &Dtool_TextFont_get_class_type_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_get_class_type_19_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_TextFont_operator_typecast_bool_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_operator_typecast_bool_13_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_TextFont_upcast_to_TypedReferenceCount_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_upcast_to_TypedReferenceCount_3_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_TextFont_upcast_to_Namable_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_upcast_to_Namable_6_comment},
  { "downcastToDynamicTextFont",(PyCFunction ) &Dtool_TextFont_downcast_to_DynamicTextFont_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextFont_downcast_to_DynamicTextFont_27_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     TextFont ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_TextFont_operator_typecast_bool_13__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_TextFont_operator_typecast_bool_13(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A __str__ Function
//     TextFont
//////////////////
static PyObject *  Dtool_Str_TextFont(PyObject * self)
{
    TextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextFont,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_TextFont(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextFont.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextFont\n"
          "// Description : An encapsulation of a font; i.e. a set of glyphs that\n"
          "//               may be assembled together by a TextNode to represent\n"
          "//               a string of text.\n"
          "//\n"
          "//               This is just an abstract interface; see\n"
          "//               StaticTextFont or DynamicTextFont for an actual\n"
          "//               implementation.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_TextFont.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_TextFont.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextFont.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_TextFont.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_TextFont_operator_typecast_bool_13__nonzero__;
        // __str__
        Dtool_TextFont.As_PyTypeObject().tp_str = & Dtool_Str_TextFont;
        // Enum  TextFont::RenderMode;
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"RMTexture",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"RMWireframe",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"RMPolygon",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"RMExtruded",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"RMSolid",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"RMInvalid",PyInt_FromLong(5));
        // Enum  TextFont::WindingOrder;
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"WODefault",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"WOLeft",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"WORight",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"WOInvalid",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_TextFont.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextFont)");
             printf(" Error In PyType_ReadyTextFont");
             return;
        }
        Py_INCREF(&Dtool_TextFont.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"TextFont",&Dtool_TextFont.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TextFont.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TextFont[7],&Dtool_TextFont.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TextFont,TextFont::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextFont.As_PyTypeObject());
        PyModule_AddObject(module, "TextFont",(PyObject *)&Dtool_TextFont.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DynamicTextPage | DynamicTextPage
//********************************************************************
PyMethodDef Dtool_Methods_DynamicTextPage[]= {
  { "isEmpty",(PyCFunction ) &Dtool_DynamicTextPage_is_empty_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextPage_is_empty_22_comment},
  { "getClassType",(PyCFunction ) &Dtool_DynamicTextPage_get_class_type_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextPage_get_class_type_23_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DynamicTextPage(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DynamicTextPage.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DynamicTextPage\n"
          "// Description : A single \"page\" of a DynamicTextFont.  This is a\n"
          "//               single texture that holds a number of glyphs for\n"
          "//               rendering.  The font starts out with one page, and\n"
          "//               will add more as it needs them.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Texture._Dtool_ClassInit(NULL);
        Dtool_DynamicTextPage.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Texture.As_PyTypeObject());
        Dtool_DynamicTextPage.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DynamicTextPage.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DynamicTextPage.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DynamicTextPage.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DynamicTextPage)");
             printf(" Error In PyType_ReadyDynamicTextPage");
             return;
        }
        Py_INCREF(&Dtool_DynamicTextPage.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DynamicTextPage.As_PyTypeObject().tp_dict,"DynamicTextPage",&Dtool_DynamicTextPage.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DynamicTextPage.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DynamicTextPage[1],&Dtool_DynamicTextPage.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DynamicTextPage,DynamicTextPage::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DynamicTextPage.As_PyTypeObject());
        PyModule_AddObject(module, "DynamicTextPage",(PyObject *)&Dtool_DynamicTextPage.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DynamicTextFont | DynamicTextFont
//********************************************************************
PyMethodDef Dtool_Methods_DynamicTextFont[]= {
  { "makeCopy",(PyCFunction ) &Dtool_DynamicTextFont_make_copy_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_make_copy_33_comment},
  { "getName",(PyCFunction ) &Dtool_DynamicTextFont_get_name_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_name_34_comment},
  { "setPointSize",(PyCFunction ) &Dtool_DynamicTextFont_set_point_size_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_point_size_35_comment},
  { "getPointSize",(PyCFunction ) &Dtool_DynamicTextFont_get_point_size_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_point_size_36_comment},
  { "setPixelsPerUnit",(PyCFunction ) &Dtool_DynamicTextFont_set_pixels_per_unit_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_pixels_per_unit_37_comment},
  { "getPixelsPerUnit",(PyCFunction ) &Dtool_DynamicTextFont_get_pixels_per_unit_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_pixels_per_unit_38_comment},
  { "setScaleFactor",(PyCFunction ) &Dtool_DynamicTextFont_set_scale_factor_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_scale_factor_39_comment},
  { "getScaleFactor",(PyCFunction ) &Dtool_DynamicTextFont_get_scale_factor_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_scale_factor_40_comment},
  { "setNativeAntialias",(PyCFunction ) &Dtool_DynamicTextFont_set_native_antialias_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_native_antialias_41_comment},
  { "getNativeAntialias",(PyCFunction ) &Dtool_DynamicTextFont_get_native_antialias_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_native_antialias_42_comment},
  { "getFontPixelSize",(PyCFunction ) &Dtool_DynamicTextFont_get_font_pixel_size_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_font_pixel_size_43_comment},
  { "getLineHeight",(PyCFunction ) &Dtool_DynamicTextFont_get_line_height_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_line_height_44_comment},
  { "getSpaceAdvance",(PyCFunction ) &Dtool_DynamicTextFont_get_space_advance_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_space_advance_45_comment},
  { "setTextureMargin",(PyCFunction ) &Dtool_DynamicTextFont_set_texture_margin_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_texture_margin_46_comment},
  { "getTextureMargin",(PyCFunction ) &Dtool_DynamicTextFont_get_texture_margin_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_texture_margin_47_comment},
  { "setPolyMargin",(PyCFunction ) &Dtool_DynamicTextFont_set_poly_margin_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_poly_margin_48_comment},
  { "getPolyMargin",(PyCFunction ) &Dtool_DynamicTextFont_get_poly_margin_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_poly_margin_49_comment},
  { "setPageSize",(PyCFunction ) &Dtool_DynamicTextFont_set_page_size_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_page_size_50_comment},
  { "getPageXSize",(PyCFunction ) &Dtool_DynamicTextFont_get_page_x_size_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_page_x_size_51_comment},
  { "getPageYSize",(PyCFunction ) &Dtool_DynamicTextFont_get_page_y_size_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_page_y_size_52_comment},
  { "setMinfilter",(PyCFunction ) &Dtool_DynamicTextFont_set_minfilter_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_minfilter_53_comment},
  { "getMinfilter",(PyCFunction ) &Dtool_DynamicTextFont_get_minfilter_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_minfilter_54_comment},
  { "setMagfilter",(PyCFunction ) &Dtool_DynamicTextFont_set_magfilter_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_magfilter_55_comment},
  { "getMagfilter",(PyCFunction ) &Dtool_DynamicTextFont_get_magfilter_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_magfilter_56_comment},
  { "setAnisotropicDegree",(PyCFunction ) &Dtool_DynamicTextFont_set_anisotropic_degree_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_anisotropic_degree_57_comment},
  { "getAnisotropicDegree",(PyCFunction ) &Dtool_DynamicTextFont_get_anisotropic_degree_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_anisotropic_degree_58_comment},
  { "setRenderMode",(PyCFunction ) &Dtool_DynamicTextFont_set_render_mode_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_render_mode_59_comment},
  { "getRenderMode",(PyCFunction ) &Dtool_DynamicTextFont_get_render_mode_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_render_mode_60_comment},
  { "setWindingOrder",(PyCFunction ) &Dtool_DynamicTextFont_set_winding_order_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_winding_order_61_comment},
  { "getWindingOrder",(PyCFunction ) &Dtool_DynamicTextFont_get_winding_order_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_winding_order_62_comment},
  { "setFg",(PyCFunction ) &Dtool_DynamicTextFont_set_fg_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_fg_63_comment},
  { "getFg",(PyCFunction ) &Dtool_DynamicTextFont_get_fg_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_fg_64_comment},
  { "setBg",(PyCFunction ) &Dtool_DynamicTextFont_set_bg_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_bg_65_comment},
  { "getBg",(PyCFunction ) &Dtool_DynamicTextFont_get_bg_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_bg_66_comment},
  { "setOutline",(PyCFunction ) &Dtool_DynamicTextFont_set_outline_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_set_outline_67_comment},
  { "getOutlineColor",(PyCFunction ) &Dtool_DynamicTextFont_get_outline_color_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_outline_color_68_comment},
  { "getOutlineWidth",(PyCFunction ) &Dtool_DynamicTextFont_get_outline_width_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_outline_width_69_comment},
  { "getOutlineFeather",(PyCFunction ) &Dtool_DynamicTextFont_get_outline_feather_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_outline_feather_70_comment},
  { "getTexFormat",(PyCFunction ) &Dtool_DynamicTextFont_get_tex_format_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_tex_format_71_comment},
  { "getNumPages",(PyCFunction ) &Dtool_DynamicTextFont_get_num_pages_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_num_pages_72_comment},
  { "getPage",(PyCFunction ) &Dtool_DynamicTextFont_get_page_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_page_73_comment},
  { "garbageCollect",(PyCFunction ) &Dtool_DynamicTextFont_garbage_collect_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_garbage_collect_74_comment},
  { "clear",(PyCFunction ) &Dtool_DynamicTextFont_clear_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_clear_75_comment},
  { "write",(PyCFunction ) &Dtool_DynamicTextFont_write_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_write_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_DynamicTextFont_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_get_class_type_77_comment},
  { "upcastToTextFont",(PyCFunction ) &Dtool_DynamicTextFont_upcast_to_TextFont_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_upcast_to_TextFont_26_comment},
  { "upcastToFreetypeFont",(PyCFunction ) &Dtool_DynamicTextFont_upcast_to_FreetypeFont_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DynamicTextFont_upcast_to_FreetypeFont_29_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getPages",(PyCFunction) &MakeSeq_DynamicTextFont_get_pages, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     DynamicTextFont
//////////////////
static PyObject *  Dtool_Str_DynamicTextFont(PyObject * self)
{
    DynamicTextFont * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DynamicTextFont,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DynamicTextFont(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DynamicTextFont.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DynamicTextFont\n"
          "// Description : A DynamicTextFont is a special TextFont object that\n"
          "//               rasterizes its glyphs from a standard font file\n"
          "//               (e.g. a TTF file) on the fly.  It requires the\n"
          "//               FreeType 2.0 library (or any higher,\n"
          "//               backward-compatible version).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TextFont._Dtool_ClassInit(NULL);
        Dtool_FreetypeFont._Dtool_ClassInit(NULL);
        Dtool_DynamicTextFont.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TextFont.As_PyTypeObject(),&Dtool_FreetypeFont.As_PyTypeObject());
        Dtool_DynamicTextFont.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DynamicTextFont.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DynamicTextFont.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_DynamicTextFont.As_PyTypeObject().tp_str = & Dtool_Str_DynamicTextFont;
        if(PyType_Ready(&Dtool_DynamicTextFont.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DynamicTextFont)");
             printf(" Error In PyType_ReadyDynamicTextFont");
             return;
        }
        Py_INCREF(&Dtool_DynamicTextFont.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DynamicTextFont.As_PyTypeObject().tp_dict,"DynamicTextFont",&Dtool_DynamicTextFont.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DynamicTextFont.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DynamicTextFont[44],&Dtool_DynamicTextFont.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DynamicTextFont,DynamicTextFont::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DynamicTextFont.As_PyTypeObject());
        PyModule_AddObject(module, "DynamicTextFont",(PyObject *)&Dtool_DynamicTextFont.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FontPool | FontPool
//********************************************************************
PyMethodDef Dtool_Methods_FontPool[]= {
  { "hasFont",(PyCFunction ) &Dtool_FontPool_has_font_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_has_font_79_comment},
  { "verifyFont",(PyCFunction ) &Dtool_FontPool_verify_font_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_verify_font_80_comment},
  { "loadFont",(PyCFunction ) &Dtool_FontPool_load_font_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_load_font_81_comment},
  { "addFont",(PyCFunction ) &Dtool_FontPool_add_font_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_add_font_82_comment},
  { "releaseFont",(PyCFunction ) &Dtool_FontPool_release_font_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_release_font_83_comment},
  { "releaseAllFonts",(PyCFunction ) &Dtool_FontPool_release_all_fonts_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_release_all_fonts_84_comment},
  { "garbageCollect",(PyCFunction ) &Dtool_FontPool_garbage_collect_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_garbage_collect_85_comment},
  { "listContents",(PyCFunction ) &Dtool_FontPool_list_contents_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_list_contents_86_comment},
  { "write",(PyCFunction ) &Dtool_FontPool_write_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FontPool_write_87_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     FontPool
//////////////////
static PyObject *  Dtool_Str_FontPool(PyObject * self)
{
    FontPool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FontPool,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_FontPool(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FontPool.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FontPool\n"
          "// Description : This is the preferred interface for loading fonts for\n"
          "//               the TextNode system.  It is similar to ModelPool and\n"
          "//               TexturePool in that it unifies references to the same\n"
          "//               filename.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_FontPool.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_FontPool.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FontPool.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_FontPool.As_PyTypeObject().tp_str = & Dtool_Str_FontPool;
        if(PyType_Ready(&Dtool_FontPool.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FontPool)");
             printf(" Error In PyType_ReadyFontPool");
             return;
        }
        Py_INCREF(&Dtool_FontPool.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"FontPool",&Dtool_FontPool.As_PyObject());
        //  Static Method hasFont
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"hasFont",PyCFunction_New(&Dtool_Methods_FontPool[0],&Dtool_FontPool.As_PyObject()));
        //  Static Method verifyFont
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"verifyFont",PyCFunction_New(&Dtool_Methods_FontPool[1],&Dtool_FontPool.As_PyObject()));
        //  Static Method loadFont
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"loadFont",PyCFunction_New(&Dtool_Methods_FontPool[2],&Dtool_FontPool.As_PyObject()));
        //  Static Method addFont
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"addFont",PyCFunction_New(&Dtool_Methods_FontPool[3],&Dtool_FontPool.As_PyObject()));
        //  Static Method releaseFont
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"releaseFont",PyCFunction_New(&Dtool_Methods_FontPool[4],&Dtool_FontPool.As_PyObject()));
        //  Static Method releaseAllFonts
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"releaseAllFonts",PyCFunction_New(&Dtool_Methods_FontPool[5],&Dtool_FontPool.As_PyObject()));
        //  Static Method garbageCollect
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"garbageCollect",PyCFunction_New(&Dtool_Methods_FontPool[6],&Dtool_FontPool.As_PyObject()));
        //  Static Method listContents
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"listContents",PyCFunction_New(&Dtool_Methods_FontPool[7],&Dtool_FontPool.As_PyObject()));
        //  Static Method write
        PyDict_SetItemString(Dtool_FontPool.As_PyTypeObject().tp_dict,"write",PyCFunction_New(&Dtool_Methods_FontPool[8],&Dtool_FontPool.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FontPool,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FontPool.As_PyTypeObject());
        PyModule_AddObject(module, "FontPool",(PyObject *)&Dtool_FontPool.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GeomTextGlyph | GeomTextGlyph
//********************************************************************
PyMethodDef Dtool_Methods_GeomTextGlyph[]= {
  { "getClassType",(PyCFunction ) &Dtool_GeomTextGlyph_get_class_type_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomTextGlyph_get_class_type_91_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GeomTextGlyph(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GeomTextGlyph.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GeomTextGlyph\n"
          "// Description : This is a specialization on Geom for containing a\n"
          "//               primitive intended to represent a DynamicTextGlyph.\n"
          "//               Its sole purpose is to maintain the geom count on the\n"
          "//               glyph, so we can determine the actual usage count on\n"
          "//               a dynamic glyph (and thus know when it is safe to\n"
          "//               recycle the glyph).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Geom._Dtool_ClassInit(NULL);
        Dtool_GeomTextGlyph.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Geom.As_PyTypeObject());
        Dtool_GeomTextGlyph.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GeomTextGlyph.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GeomTextGlyph.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GeomTextGlyph.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GeomTextGlyph)");
             printf(" Error In PyType_ReadyGeomTextGlyph");
             return;
        }
        Py_INCREF(&Dtool_GeomTextGlyph.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GeomTextGlyph.As_PyTypeObject().tp_dict,"GeomTextGlyph",&Dtool_GeomTextGlyph.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GeomTextGlyph.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GeomTextGlyph[0],&Dtool_GeomTextGlyph.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GeomTextGlyph,GeomTextGlyph::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GeomTextGlyph.As_PyTypeObject());
        PyModule_AddObject(module, "GeomTextGlyph",(PyObject *)&Dtool_GeomTextGlyph.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StaticTextFont | StaticTextFont
//********************************************************************
PyMethodDef Dtool_Methods_StaticTextFont[]= {
  { "getClassType",(PyCFunction ) &Dtool_StaticTextFont_get_class_type_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StaticTextFont_get_class_type_94_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StaticTextFont(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StaticTextFont.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StaticTextFont\n"
          "// Description : A StaticTextFont is loaded up from a model that was\n"
          "//               previously generated via egg-mkfont, and contains all\n"
          "//               of its glyphs already generated and available for\n"
          "//               use.  It doesn't require linking with any external\n"
          "//               libraries like FreeType.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TextFont._Dtool_ClassInit(NULL);
        Dtool_StaticTextFont.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TextFont.As_PyTypeObject());
        Dtool_StaticTextFont.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StaticTextFont.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StaticTextFont.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StaticTextFont.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StaticTextFont)");
             printf(" Error In PyType_ReadyStaticTextFont");
             return;
        }
        Py_INCREF(&Dtool_StaticTextFont.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StaticTextFont.As_PyTypeObject().tp_dict,"StaticTextFont",&Dtool_StaticTextFont.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_StaticTextFont.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_StaticTextFont[0],&Dtool_StaticTextFont.As_PyObject()));
        RegisterRuntimeClass(&Dtool_StaticTextFont,StaticTextFont::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StaticTextFont.As_PyTypeObject());
        PyModule_AddObject(module, "StaticTextFont",(PyObject *)&Dtool_StaticTextFont.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TextProperties | TextProperties
//********************************************************************
PyMethodDef Dtool_Methods_TextProperties[]= {
  { "assign",(PyCFunction ) &Dtool_TextProperties_operator_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_operator_99_comment},
  { "eq",(PyCFunction ) &Dtool_TextProperties_operator_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_operator_100_comment},
  { "ne",(PyCFunction ) &Dtool_TextProperties_operator_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_operator_101_comment},
  { "clear",(PyCFunction ) &Dtool_TextProperties_clear_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_102_comment},
  { "isAnySpecified",(PyCFunction ) &Dtool_TextProperties_is_any_specified_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_is_any_specified_103_comment},
  { "setDefaultFont",(PyCFunction ) &Dtool_TextProperties_set_default_font_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_default_font_104_comment},
  { "getDefaultFont",(PyCFunction ) &Dtool_TextProperties_get_default_font_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_default_font_105_comment},
  { "setFont",(PyCFunction ) &Dtool_TextProperties_set_font_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_font_106_comment},
  { "clearFont",(PyCFunction ) &Dtool_TextProperties_clear_font_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_font_107_comment},
  { "hasFont",(PyCFunction ) &Dtool_TextProperties_has_font_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_font_108_comment},
  { "getFont",(PyCFunction ) &Dtool_TextProperties_get_font_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_font_109_comment},
  { "setSmallCaps",(PyCFunction ) &Dtool_TextProperties_set_small_caps_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_small_caps_110_comment},
  { "clearSmallCaps",(PyCFunction ) &Dtool_TextProperties_clear_small_caps_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_small_caps_111_comment},
  { "hasSmallCaps",(PyCFunction ) &Dtool_TextProperties_has_small_caps_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_small_caps_112_comment},
  { "getSmallCaps",(PyCFunction ) &Dtool_TextProperties_get_small_caps_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_small_caps_113_comment},
  { "setSmallCapsScale",(PyCFunction ) &Dtool_TextProperties_set_small_caps_scale_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_small_caps_scale_114_comment},
  { "clearSmallCapsScale",(PyCFunction ) &Dtool_TextProperties_clear_small_caps_scale_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_small_caps_scale_115_comment},
  { "hasSmallCapsScale",(PyCFunction ) &Dtool_TextProperties_has_small_caps_scale_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_small_caps_scale_116_comment},
  { "getSmallCapsScale",(PyCFunction ) &Dtool_TextProperties_get_small_caps_scale_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_small_caps_scale_117_comment},
  { "setSlant",(PyCFunction ) &Dtool_TextProperties_set_slant_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_slant_118_comment},
  { "clearSlant",(PyCFunction ) &Dtool_TextProperties_clear_slant_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_slant_119_comment},
  { "hasSlant",(PyCFunction ) &Dtool_TextProperties_has_slant_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_slant_120_comment},
  { "getSlant",(PyCFunction ) &Dtool_TextProperties_get_slant_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_slant_121_comment},
  { "setUnderscore",(PyCFunction ) &Dtool_TextProperties_set_underscore_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_underscore_122_comment},
  { "clearUnderscore",(PyCFunction ) &Dtool_TextProperties_clear_underscore_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_underscore_123_comment},
  { "hasUnderscore",(PyCFunction ) &Dtool_TextProperties_has_underscore_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_underscore_124_comment},
  { "getUnderscore",(PyCFunction ) &Dtool_TextProperties_get_underscore_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_underscore_125_comment},
  { "setUnderscoreHeight",(PyCFunction ) &Dtool_TextProperties_set_underscore_height_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_underscore_height_126_comment},
  { "clearUnderscoreHeight",(PyCFunction ) &Dtool_TextProperties_clear_underscore_height_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_underscore_height_127_comment},
  { "hasUnderscoreHeight",(PyCFunction ) &Dtool_TextProperties_has_underscore_height_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_underscore_height_128_comment},
  { "getUnderscoreHeight",(PyCFunction ) &Dtool_TextProperties_get_underscore_height_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_underscore_height_129_comment},
  { "setAlign",(PyCFunction ) &Dtool_TextProperties_set_align_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_align_130_comment},
  { "clearAlign",(PyCFunction ) &Dtool_TextProperties_clear_align_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_align_131_comment},
  { "hasAlign",(PyCFunction ) &Dtool_TextProperties_has_align_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_align_132_comment},
  { "getAlign",(PyCFunction ) &Dtool_TextProperties_get_align_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_align_133_comment},
  { "setIndent",(PyCFunction ) &Dtool_TextProperties_set_indent_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_indent_134_comment},
  { "clearIndent",(PyCFunction ) &Dtool_TextProperties_clear_indent_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_indent_135_comment},
  { "hasIndent",(PyCFunction ) &Dtool_TextProperties_has_indent_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_indent_136_comment},
  { "getIndent",(PyCFunction ) &Dtool_TextProperties_get_indent_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_indent_137_comment},
  { "setWordwrap",(PyCFunction ) &Dtool_TextProperties_set_wordwrap_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_wordwrap_138_comment},
  { "clearWordwrap",(PyCFunction ) &Dtool_TextProperties_clear_wordwrap_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_wordwrap_139_comment},
  { "hasWordwrap",(PyCFunction ) &Dtool_TextProperties_has_wordwrap_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_wordwrap_140_comment},
  { "getWordwrap",(PyCFunction ) &Dtool_TextProperties_get_wordwrap_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_wordwrap_141_comment},
  { "setPreserveTrailingWhitespace",(PyCFunction ) &Dtool_TextProperties_set_preserve_trailing_whitespace_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_preserve_trailing_whitespace_142_comment},
  { "clearPreserveTrailingWhitespace",(PyCFunction ) &Dtool_TextProperties_clear_preserve_trailing_whitespace_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_preserve_trailing_whitespace_143_comment},
  { "hasPreserveTrailingWhitespace",(PyCFunction ) &Dtool_TextProperties_has_preserve_trailing_whitespace_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_preserve_trailing_whitespace_144_comment},
  { "getPreserveTrailingWhitespace",(PyCFunction ) &Dtool_TextProperties_get_preserve_trailing_whitespace_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_preserve_trailing_whitespace_145_comment},
  { "setTextColor",(PyCFunction ) &Dtool_TextProperties_set_text_color_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_text_color_146_comment},
  { "clearTextColor",(PyCFunction ) &Dtool_TextProperties_clear_text_color_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_text_color_147_comment},
  { "hasTextColor",(PyCFunction ) &Dtool_TextProperties_has_text_color_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_text_color_148_comment},
  { "getTextColor",(PyCFunction ) &Dtool_TextProperties_get_text_color_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_text_color_149_comment},
  { "setShadowColor",(PyCFunction ) &Dtool_TextProperties_set_shadow_color_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_shadow_color_150_comment},
  { "clearShadowColor",(PyCFunction ) &Dtool_TextProperties_clear_shadow_color_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_shadow_color_151_comment},
  { "hasShadowColor",(PyCFunction ) &Dtool_TextProperties_has_shadow_color_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_shadow_color_152_comment},
  { "getShadowColor",(PyCFunction ) &Dtool_TextProperties_get_shadow_color_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_shadow_color_153_comment},
  { "setShadow",(PyCFunction ) &Dtool_TextProperties_set_shadow_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_shadow_154_comment},
  { "clearShadow",(PyCFunction ) &Dtool_TextProperties_clear_shadow_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_shadow_155_comment},
  { "hasShadow",(PyCFunction ) &Dtool_TextProperties_has_shadow_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_shadow_156_comment},
  { "getShadow",(PyCFunction ) &Dtool_TextProperties_get_shadow_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_shadow_157_comment},
  { "setBin",(PyCFunction ) &Dtool_TextProperties_set_bin_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_bin_158_comment},
  { "clearBin",(PyCFunction ) &Dtool_TextProperties_clear_bin_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_bin_159_comment},
  { "hasBin",(PyCFunction ) &Dtool_TextProperties_has_bin_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_bin_160_comment},
  { "getBin",(PyCFunction ) &Dtool_TextProperties_get_bin_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_bin_161_comment},
  { "setDrawOrder",(PyCFunction ) &Dtool_TextProperties_set_draw_order_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_draw_order_162_comment},
  { "clearDrawOrder",(PyCFunction ) &Dtool_TextProperties_clear_draw_order_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_draw_order_163_comment},
  { "hasDrawOrder",(PyCFunction ) &Dtool_TextProperties_has_draw_order_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_draw_order_164_comment},
  { "getDrawOrder",(PyCFunction ) &Dtool_TextProperties_get_draw_order_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_draw_order_165_comment},
  { "setTabWidth",(PyCFunction ) &Dtool_TextProperties_set_tab_width_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_tab_width_166_comment},
  { "clearTabWidth",(PyCFunction ) &Dtool_TextProperties_clear_tab_width_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_tab_width_167_comment},
  { "hasTabWidth",(PyCFunction ) &Dtool_TextProperties_has_tab_width_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_tab_width_168_comment},
  { "getTabWidth",(PyCFunction ) &Dtool_TextProperties_get_tab_width_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_tab_width_169_comment},
  { "setGlyphScale",(PyCFunction ) &Dtool_TextProperties_set_glyph_scale_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_glyph_scale_170_comment},
  { "clearGlyphScale",(PyCFunction ) &Dtool_TextProperties_clear_glyph_scale_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_glyph_scale_171_comment},
  { "hasGlyphScale",(PyCFunction ) &Dtool_TextProperties_has_glyph_scale_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_glyph_scale_172_comment},
  { "getGlyphScale",(PyCFunction ) &Dtool_TextProperties_get_glyph_scale_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_glyph_scale_173_comment},
  { "setGlyphShift",(PyCFunction ) &Dtool_TextProperties_set_glyph_shift_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_glyph_shift_174_comment},
  { "clearGlyphShift",(PyCFunction ) &Dtool_TextProperties_clear_glyph_shift_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_glyph_shift_175_comment},
  { "hasGlyphShift",(PyCFunction ) &Dtool_TextProperties_has_glyph_shift_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_glyph_shift_176_comment},
  { "getGlyphShift",(PyCFunction ) &Dtool_TextProperties_get_glyph_shift_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_glyph_shift_177_comment},
  { "setTextScale",(PyCFunction ) &Dtool_TextProperties_set_text_scale_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_set_text_scale_178_comment},
  { "clearTextScale",(PyCFunction ) &Dtool_TextProperties_clear_text_scale_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_clear_text_scale_179_comment},
  { "hasTextScale",(PyCFunction ) &Dtool_TextProperties_has_text_scale_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_has_text_scale_180_comment},
  { "getTextScale",(PyCFunction ) &Dtool_TextProperties_get_text_scale_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_text_scale_181_comment},
  { "addProperties",(PyCFunction ) &Dtool_TextProperties_add_properties_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_add_properties_182_comment},
  { "write",(PyCFunction ) &Dtool_TextProperties_write_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_write_183_comment},
  { "getClassType",(PyCFunction ) &Dtool_TextProperties_get_class_type_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_get_class_type_184_comment},
  { "downcastToTextNode",(PyCFunction ) &Dtool_TextProperties_downcast_to_TextNode_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextProperties_downcast_to_TextNode_254_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     TextProperties
//////////////////
static PyObject *  Dtool_Str_TextProperties(PyObject * self)
{
    TextProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextProperties,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_TextProperties(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextProperties.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextProperties\n"
          "// Description : This defines the set of visual properties that may be\n"
          "//               assigned to the individual characters of the text.\n"
          "//               (Properties which affect the overall block of text\n"
          "//               can only be specified on the TextNode directly).\n"
          "//\n"
          "//               Typically, there is just one set of properties on a\n"
          "//               given block of text, which is set directly on the\n"
          "//               TextNode (TextNode inherits from TextProperties).\n"
          "//               That makes all of the text within a particular block\n"
          "//               have the same appearance.\n"
          "//\n"
          "//               This separate class exists in order to implement\n"
          "//               multiple different kinds of text appearing within one\n"
          "//               block.  The text string itself may reference a\n"
          "//               TextProperties structure by name using the \\1 and \\2\n"
          "//               tokens embedded within the string; each nested\n"
          "//               TextProperties structure modifies the appearance of\n"
          "//               subsequent text within the block.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TextProperties.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TextProperties.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextProperties.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_TextProperties.As_PyTypeObject().tp_str = & Dtool_Str_TextProperties;
        // Enum  TextProperties::Alignment;
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"ALeft",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"ARight",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"ACenter",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"ABoxedLeft",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"ABoxedRight",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"ABoxedCenter",PyInt_FromLong(5));
        if(PyType_Ready(&Dtool_TextProperties.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextProperties)");
             printf(" Error In PyType_ReadyTextProperties");
             return;
        }
        Py_INCREF(&Dtool_TextProperties.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"TextProperties",&Dtool_TextProperties.As_PyObject());
        //  Static Method setDefaultFont
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"setDefaultFont",PyCFunction_New(&Dtool_Methods_TextProperties[5],&Dtool_TextProperties.As_PyObject()));
        //  Static Method getDefaultFont
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"getDefaultFont",PyCFunction_New(&Dtool_Methods_TextProperties[6],&Dtool_TextProperties.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TextProperties.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TextProperties[85],&Dtool_TextProperties.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TextProperties,TextProperties::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextProperties.As_PyTypeObject());
        PyModule_AddObject(module, "TextProperties",(PyObject *)&Dtool_TextProperties.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TextGraphic | TextGraphic
//********************************************************************
PyMethodDef Dtool_Methods_TextGraphic[]= {
  { "getModel",(PyCFunction ) &Dtool_TextGraphic_get_model_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextGraphic_get_model_188_comment},
  { "setModel",(PyCFunction ) &Dtool_TextGraphic_set_model_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextGraphic_set_model_189_comment},
  { "getFrame",(PyCFunction ) &Dtool_TextGraphic_get_frame_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextGraphic_get_frame_190_comment},
  { "setFrame",(PyCFunction ) &Dtool_TextGraphic_set_frame_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextGraphic_set_frame_191_comment},
  { "getInstanceFlag",(PyCFunction ) &Dtool_TextGraphic_get_instance_flag_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextGraphic_get_instance_flag_192_comment},
  { "setInstanceFlag",(PyCFunction ) &Dtool_TextGraphic_set_instance_flag_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextGraphic_set_instance_flag_193_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TextGraphic(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextGraphic.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextGraphic\n"
          "// Description : This defines a special model that has been\n"
          "//               constructed for the purposes of embedding an\n"
          "//               arbitrary graphic image within a text paragraph.\n"
          "//\n"
          "//               It can be any arbitrary model, though it should be\n"
          "//               built along the same scale as the text, and it should\n"
          "//               probably be at least mostly two-dimensional.\n"
          "//               Typically, this means it should be constructed in the\n"
          "//               X-Z plane, and it should have a maximum vertical (Z)\n"
          "//               height of 1.0.\n"
          "//\n"
          "//               The frame specifies an arbitrary bounding volume in\n"
          "//               the form (left, right, bottom, top).  This indicates\n"
          "//               the amount of space that will be reserved within the\n"
          "//               paragraph.  The actual model is not actually required\n"
          "//               to fit within this rectangle, but if it does not, it\n"
          "//               may visually overlap with nearby text.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TextGraphic.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TextGraphic.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextGraphic.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextGraphic.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TextGraphic.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextGraphic)");
             printf(" Error In PyType_ReadyTextGraphic");
             return;
        }
        Py_INCREF(&Dtool_TextGraphic.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextGraphic.As_PyTypeObject().tp_dict,"TextGraphic",&Dtool_TextGraphic.As_PyObject());
        RegisterRuntimeClass(&Dtool_TextGraphic,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextGraphic.As_PyTypeObject());
        PyModule_AddObject(module, "TextGraphic",(PyObject *)&Dtool_TextGraphic.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TextPropertiesManager | TextPropertiesManager
//********************************************************************
PyMethodDef Dtool_Methods_TextPropertiesManager[]= {
  { "setProperties",(PyCFunction ) &Dtool_TextPropertiesManager_set_properties_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_set_properties_196_comment},
  { "getProperties",(PyCFunction ) &Dtool_TextPropertiesManager_get_properties_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_get_properties_197_comment},
  { "hasProperties",(PyCFunction ) &Dtool_TextPropertiesManager_has_properties_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_has_properties_198_comment},
  { "clearProperties",(PyCFunction ) &Dtool_TextPropertiesManager_clear_properties_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_clear_properties_199_comment},
  { "setGraphic",(PyCFunction ) &Dtool_TextPropertiesManager_set_graphic_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_set_graphic_200_comment},
  { "getGraphic",(PyCFunction ) &Dtool_TextPropertiesManager_get_graphic_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_get_graphic_201_comment},
  { "hasGraphic",(PyCFunction ) &Dtool_TextPropertiesManager_has_graphic_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_has_graphic_202_comment},
  { "clearGraphic",(PyCFunction ) &Dtool_TextPropertiesManager_clear_graphic_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_clear_graphic_203_comment},
  { "write",(PyCFunction ) &Dtool_TextPropertiesManager_write_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_write_204_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_TextPropertiesManager_get_global_ptr_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextPropertiesManager_get_global_ptr_205_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     TextPropertiesManager
//////////////////
static PyObject *  Dtool_Str_TextPropertiesManager(PyObject * self)
{
    TextPropertiesManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextPropertiesManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_TextPropertiesManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextPropertiesManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextPropertiesManager\n"
          "// Description : This defines all of the TextProperties structures\n"
          "//               that might be referenced by name from an embedded\n"
          "//               text string.\n"
          "//\n"
          "//               A text string, as rendered by a TextNode, can contain\n"
          "//               embedded references to one of the TextProperties\n"
          "//               defined here, by enclosing the name between \\1 (ASCII\n"
          "//               0x01) characters; this causes a \"push\" to the named\n"
          "//               state.  All text following the closing \\1 character\n"
          "//               will then be rendered in the new state.  The next \\2\n"
          "//               (ASCII 0x02) character will then restore the previous\n"
          "//               state for subsequent text.\n"
          "//\n"
          "//               For instance, \"x\\1up\\1n\\2 + y\" indicates that the\n"
          "//               character \"x\" will be rendered in the normal state,\n"
          "//               the character \"n\" will be rendered in the \"up\" state,\n"
          "//               and then \" + y\" will be rendered in the normal state\n"
          "//               again.\n"
          "//\n"
          "//               This can also be used to define arbitrary models that\n"
          "//               can serve as embedded graphic images in a text\n"
          "//               paragraph.  This works similarly; the convention is\n"
          "//               to create a TextGraphic that describes the graphic\n"
          "//               image, and then associate it here via the\n"
          "//               set_graphic() call.  Then \"\\5name\\5\" will embed the\n"
          "//               named graphic.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TextPropertiesManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TextPropertiesManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextPropertiesManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextPropertiesManager.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_TextPropertiesManager.As_PyTypeObject().tp_str = & Dtool_Str_TextPropertiesManager;
        if(PyType_Ready(&Dtool_TextPropertiesManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextPropertiesManager)");
             printf(" Error In PyType_ReadyTextPropertiesManager");
             return;
        }
        Py_INCREF(&Dtool_TextPropertiesManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextPropertiesManager.As_PyTypeObject().tp_dict,"TextPropertiesManager",&Dtool_TextPropertiesManager.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_TextPropertiesManager.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_TextPropertiesManager[9],&Dtool_TextPropertiesManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TextPropertiesManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextPropertiesManager.As_PyTypeObject());
        PyModule_AddObject(module, "TextPropertiesManager",(PyObject *)&Dtool_TextPropertiesManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TextAssembler | TextAssembler
//********************************************************************
PyMethodDef Dtool_Methods_TextAssembler[]= {
  { "assign",(PyCFunction ) &Dtool_TextAssembler_operator_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_operator_208_comment},
  { "clear",(PyCFunction ) &Dtool_TextAssembler_clear_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_clear_210_comment},
  { "setUsageHint",(PyCFunction ) &Dtool_TextAssembler_set_usage_hint_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_usage_hint_211_comment},
  { "getUsageHint",(PyCFunction ) &Dtool_TextAssembler_get_usage_hint_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_usage_hint_212_comment},
  { "setMaxRows",(PyCFunction ) &Dtool_TextAssembler_set_max_rows_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_max_rows_213_comment},
  { "getMaxRows",(PyCFunction ) &Dtool_TextAssembler_get_max_rows_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_max_rows_214_comment},
  { "setDynamicMerge",(PyCFunction ) &Dtool_TextAssembler_set_dynamic_merge_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_dynamic_merge_215_comment},
  { "getDynamicMerge",(PyCFunction ) &Dtool_TextAssembler_get_dynamic_merge_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_dynamic_merge_216_comment},
  { "setMultilineMode",(PyCFunction ) &Dtool_TextAssembler_set_multiline_mode_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_multiline_mode_217_comment},
  { "getMultilineMode",(PyCFunction ) &Dtool_TextAssembler_get_multiline_mode_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_multiline_mode_218_comment},
  { "setProperties",(PyCFunction ) &Dtool_TextAssembler_set_properties_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_properties_219_comment},
  { "getProperties",(PyCFunction ) &Dtool_TextAssembler_get_properties_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_properties_220_comment},
  { "setWtext",(PyCFunction ) &Dtool_TextAssembler_set_wtext_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_wtext_221_comment},
  { "setWsubstr",(PyCFunction ) &Dtool_TextAssembler_set_wsubstr_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_set_wsubstr_222_comment},
  { "getPlainWtext",(PyCFunction ) &Dtool_TextAssembler_get_plain_wtext_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_plain_wtext_223_comment},
  { "getWordwrappedPlainWtext",(PyCFunction ) &Dtool_TextAssembler_get_wordwrapped_plain_wtext_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_wordwrapped_plain_wtext_224_comment},
  { "getWtext",(PyCFunction ) &Dtool_TextAssembler_get_wtext_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_wtext_225_comment},
  { "getWordwrappedWtext",(PyCFunction ) &Dtool_TextAssembler_get_wordwrapped_wtext_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_wordwrapped_wtext_226_comment},
  { "calcR",(PyCFunction ) &Dtool_TextAssembler_calc_r_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_calc_r_228_comment},
  { "calcC",(PyCFunction ) &Dtool_TextAssembler_calc_c_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_calc_c_229_comment},
  { "calcIndex",(PyCFunction ) &Dtool_TextAssembler_calc_index_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_calc_index_230_comment},
  { "getNumCharacters",(PyCFunction ) &Dtool_TextAssembler_get_num_characters_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_num_characters_231_comment},
  { "getCharacter",(PyCFunction ) &Dtool_TextAssembler_get_character_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_character_232_comment},
  { "getGraphic",(PyCFunction ) &Dtool_TextAssembler_get_graphic_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_graphic_233_comment},
  { "getWidth",(PyCFunction ) &Dtool_TextAssembler_get_width_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_width_234_comment},
  { "getNumRows",(PyCFunction ) &Dtool_TextAssembler_get_num_rows_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_num_rows_235_comment},
  { "getNumCols",(PyCFunction ) &Dtool_TextAssembler_get_num_cols_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_num_cols_236_comment},
  { "getXpos",(PyCFunction ) &Dtool_TextAssembler_get_xpos_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_xpos_237_comment},
  { "getYpos",(PyCFunction ) &Dtool_TextAssembler_get_ypos_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_ypos_238_comment},
  { "assembleText",(PyCFunction ) &Dtool_TextAssembler_assemble_text_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_assemble_text_239_comment},
  { "getUl",(PyCFunction ) &Dtool_TextAssembler_get_ul_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_ul_240_comment},
  { "getLr",(PyCFunction ) &Dtool_TextAssembler_get_lr_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_get_lr_241_comment},
  { "calcWidth",(PyCFunction ) &Dtool_TextAssembler_calc_width_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_calc_width_242_comment},
  { "hasExactCharacter",(PyCFunction ) &Dtool_TextAssembler_has_exact_character_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_has_exact_character_243_comment},
  { "hasCharacter",(PyCFunction ) &Dtool_TextAssembler_has_character_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_has_character_244_comment},
  { "isWhitespace",(PyCFunction ) &Dtool_TextAssembler_is_whitespace_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextAssembler_is_whitespace_245_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TextAssembler(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextAssembler.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextAssembler\n"
          "// Description : This class is not normally used directly by user\n"
          "//               code, but is used by the TextNode to lay out a block\n"
          "//               of text and convert it into rows of Geoms according\n"
          "//               to the TextProperties.  However, user code may take\n"
          "//               advantage of it, if desired, for very low-level text\n"
          "//               operations.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TextAssembler.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TextAssembler.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextAssembler.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextAssembler.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TextAssembler.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextAssembler)");
             printf(" Error In PyType_ReadyTextAssembler");
             return;
        }
        Py_INCREF(&Dtool_TextAssembler.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextAssembler.As_PyTypeObject().tp_dict,"TextAssembler",&Dtool_TextAssembler.As_PyObject());
        //  Static Method calcWidth
        PyDict_SetItemString(Dtool_TextAssembler.As_PyTypeObject().tp_dict,"calcWidth",PyCFunction_New(&Dtool_Methods_TextAssembler[32],&Dtool_TextAssembler.As_PyObject()));
        //  Static Method hasExactCharacter
        PyDict_SetItemString(Dtool_TextAssembler.As_PyTypeObject().tp_dict,"hasExactCharacter",PyCFunction_New(&Dtool_Methods_TextAssembler[33],&Dtool_TextAssembler.As_PyObject()));
        //  Static Method hasCharacter
        PyDict_SetItemString(Dtool_TextAssembler.As_PyTypeObject().tp_dict,"hasCharacter",PyCFunction_New(&Dtool_Methods_TextAssembler[34],&Dtool_TextAssembler.As_PyObject()));
        //  Static Method isWhitespace
        PyDict_SetItemString(Dtool_TextAssembler.As_PyTypeObject().tp_dict,"isWhitespace",PyCFunction_New(&Dtool_Methods_TextAssembler[35],&Dtool_TextAssembler.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TextAssembler,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextAssembler.As_PyTypeObject());
        PyModule_AddObject(module, "TextAssembler",(PyObject *)&Dtool_TextAssembler.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TextNode | TextNode
//********************************************************************
PyMethodDef Dtool_Methods_TextNode[]= {
  { "getLineHeight",(PyCFunction ) &Dtool_TextNode_get_line_height_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_line_height_258_comment},
  { "setMaxRows",(PyCFunction ) &Dtool_TextNode_set_max_rows_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_max_rows_259_comment},
  { "clearMaxRows",(PyCFunction ) &Dtool_TextNode_clear_max_rows_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_max_rows_260_comment},
  { "hasMaxRows",(PyCFunction ) &Dtool_TextNode_has_max_rows_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_max_rows_261_comment},
  { "getMaxRows",(PyCFunction ) &Dtool_TextNode_get_max_rows_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_max_rows_262_comment},
  { "hasOverflow",(PyCFunction ) &Dtool_TextNode_has_overflow_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_overflow_263_comment},
  { "setFrameColor",(PyCFunction ) &Dtool_TextNode_set_frame_color_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_frame_color_264_comment},
  { "getFrameColor",(PyCFunction ) &Dtool_TextNode_get_frame_color_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_frame_color_265_comment},
  { "setCardBorder",(PyCFunction ) &Dtool_TextNode_set_card_border_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_card_border_266_comment},
  { "clearCardBorder",(PyCFunction ) &Dtool_TextNode_clear_card_border_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_card_border_267_comment},
  { "getCardBorderSize",(PyCFunction ) &Dtool_TextNode_get_card_border_size_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_border_size_268_comment},
  { "getCardBorderUvPortion",(PyCFunction ) &Dtool_TextNode_get_card_border_uv_portion_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_border_uv_portion_269_comment},
  { "hasCardBorder",(PyCFunction ) &Dtool_TextNode_has_card_border_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_card_border_270_comment},
  { "setCardColor",(PyCFunction ) &Dtool_TextNode_set_card_color_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_card_color_271_comment},
  { "getCardColor",(PyCFunction ) &Dtool_TextNode_get_card_color_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_color_272_comment},
  { "setCardTexture",(PyCFunction ) &Dtool_TextNode_set_card_texture_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_card_texture_273_comment},
  { "clearCardTexture",(PyCFunction ) &Dtool_TextNode_clear_card_texture_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_card_texture_274_comment},
  { "hasCardTexture",(PyCFunction ) &Dtool_TextNode_has_card_texture_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_card_texture_275_comment},
  { "getCardTexture",(PyCFunction ) &Dtool_TextNode_get_card_texture_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_texture_276_comment},
  { "setFrameAsMargin",(PyCFunction ) &Dtool_TextNode_set_frame_as_margin_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_frame_as_margin_277_comment},
  { "setFrameActual",(PyCFunction ) &Dtool_TextNode_set_frame_actual_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_frame_actual_278_comment},
  { "clearFrame",(PyCFunction ) &Dtool_TextNode_clear_frame_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_frame_279_comment},
  { "hasFrame",(PyCFunction ) &Dtool_TextNode_has_frame_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_frame_280_comment},
  { "isFrameAsMargin",(PyCFunction ) &Dtool_TextNode_is_frame_as_margin_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_is_frame_as_margin_281_comment},
  { "getFrameAsSet",(PyCFunction ) &Dtool_TextNode_get_frame_as_set_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_frame_as_set_282_comment},
  { "getFrameActual",(PyCFunction ) &Dtool_TextNode_get_frame_actual_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_frame_actual_283_comment},
  { "setFrameLineWidth",(PyCFunction ) &Dtool_TextNode_set_frame_line_width_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_frame_line_width_284_comment},
  { "getFrameLineWidth",(PyCFunction ) &Dtool_TextNode_get_frame_line_width_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_frame_line_width_285_comment},
  { "setFrameCorners",(PyCFunction ) &Dtool_TextNode_set_frame_corners_286, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_frame_corners_286_comment},
  { "getFrameCorners",(PyCFunction ) &Dtool_TextNode_get_frame_corners_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_frame_corners_287_comment},
  { "setCardAsMargin",(PyCFunction ) &Dtool_TextNode_set_card_as_margin_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_card_as_margin_288_comment},
  { "setCardActual",(PyCFunction ) &Dtool_TextNode_set_card_actual_289, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_card_actual_289_comment},
  { "setCardDecal",(PyCFunction ) &Dtool_TextNode_set_card_decal_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_card_decal_290_comment},
  { "clearCard",(PyCFunction ) &Dtool_TextNode_clear_card_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_card_291_comment},
  { "hasCard",(PyCFunction ) &Dtool_TextNode_has_card_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_card_292_comment},
  { "getCardDecal",(PyCFunction ) &Dtool_TextNode_get_card_decal_293, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_decal_293_comment},
  { "isCardAsMargin",(PyCFunction ) &Dtool_TextNode_is_card_as_margin_294, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_is_card_as_margin_294_comment},
  { "getCardAsSet",(PyCFunction ) &Dtool_TextNode_get_card_as_set_295, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_as_set_295_comment},
  { "getCardActual",(PyCFunction ) &Dtool_TextNode_get_card_actual_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_actual_296_comment},
  { "getCardTransformed",(PyCFunction ) &Dtool_TextNode_get_card_transformed_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_card_transformed_297_comment},
  { "setTransform",(PyCFunction ) &Dtool_TextNode_set_transform_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_transform_298_comment},
  { "getTransform",(PyCFunction ) &Dtool_TextNode_get_transform_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_transform_299_comment},
  { "setCoordinateSystem",(PyCFunction ) &Dtool_TextNode_set_coordinate_system_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_coordinate_system_300_comment},
  { "getCoordinateSystem",(PyCFunction ) &Dtool_TextNode_get_coordinate_system_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_coordinate_system_301_comment},
  { "setUsageHint",(PyCFunction ) &Dtool_TextNode_set_usage_hint_302, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_usage_hint_302_comment},
  { "getUsageHint",(PyCFunction ) &Dtool_TextNode_get_usage_hint_303, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_usage_hint_303_comment},
  { "setFlattenFlags",(PyCFunction ) &Dtool_TextNode_set_flatten_flags_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_flatten_flags_304_comment},
  { "getFlattenFlags",(PyCFunction ) &Dtool_TextNode_get_flatten_flags_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_flatten_flags_305_comment},
  { "setFont",(PyCFunction ) &Dtool_TextNode_set_font_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_font_306_comment},
  { "clearFont",(PyCFunction ) &Dtool_TextNode_clear_font_307, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_font_307_comment},
  { "setSmallCaps",(PyCFunction ) &Dtool_TextNode_set_small_caps_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_small_caps_308_comment},
  { "clearSmallCaps",(PyCFunction ) &Dtool_TextNode_clear_small_caps_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_small_caps_309_comment},
  { "setSmallCapsScale",(PyCFunction ) &Dtool_TextNode_set_small_caps_scale_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_small_caps_scale_310_comment},
  { "clearSmallCapsScale",(PyCFunction ) &Dtool_TextNode_clear_small_caps_scale_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_small_caps_scale_311_comment},
  { "setSlant",(PyCFunction ) &Dtool_TextNode_set_slant_312, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_slant_312_comment},
  { "clearSlant",(PyCFunction ) &Dtool_TextNode_clear_slant_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_slant_313_comment},
  { "setAlign",(PyCFunction ) &Dtool_TextNode_set_align_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_align_314_comment},
  { "clearAlign",(PyCFunction ) &Dtool_TextNode_clear_align_315, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_align_315_comment},
  { "setIndent",(PyCFunction ) &Dtool_TextNode_set_indent_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_indent_316_comment},
  { "clearIndent",(PyCFunction ) &Dtool_TextNode_clear_indent_317, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_indent_317_comment},
  { "setWordwrap",(PyCFunction ) &Dtool_TextNode_set_wordwrap_318, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_wordwrap_318_comment},
  { "clearWordwrap",(PyCFunction ) &Dtool_TextNode_clear_wordwrap_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_wordwrap_319_comment},
  { "setTextColor",(PyCFunction ) &Dtool_TextNode_set_text_color_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_text_color_320_comment},
  { "clearTextColor",(PyCFunction ) &Dtool_TextNode_clear_text_color_321, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_text_color_321_comment},
  { "setShadowColor",(PyCFunction ) &Dtool_TextNode_set_shadow_color_322, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_shadow_color_322_comment},
  { "clearShadowColor",(PyCFunction ) &Dtool_TextNode_clear_shadow_color_323, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_shadow_color_323_comment},
  { "setShadow",(PyCFunction ) &Dtool_TextNode_set_shadow_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_shadow_324_comment},
  { "clearShadow",(PyCFunction ) &Dtool_TextNode_clear_shadow_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_shadow_325_comment},
  { "setBin",(PyCFunction ) &Dtool_TextNode_set_bin_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_bin_326_comment},
  { "clearBin",(PyCFunction ) &Dtool_TextNode_clear_bin_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_bin_327_comment},
  { "setDrawOrder",(PyCFunction ) &Dtool_TextNode_set_draw_order_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_draw_order_328_comment},
  { "clearDrawOrder",(PyCFunction ) &Dtool_TextNode_clear_draw_order_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_draw_order_329_comment},
  { "setTabWidth",(PyCFunction ) &Dtool_TextNode_set_tab_width_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_tab_width_330_comment},
  { "clearTabWidth",(PyCFunction ) &Dtool_TextNode_clear_tab_width_331, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_tab_width_331_comment},
  { "setGlyphScale",(PyCFunction ) &Dtool_TextNode_set_glyph_scale_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_glyph_scale_332_comment},
  { "clearGlyphScale",(PyCFunction ) &Dtool_TextNode_clear_glyph_scale_333, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_glyph_scale_333_comment},
  { "setGlyphShift",(PyCFunction ) &Dtool_TextNode_set_glyph_shift_334, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_glyph_shift_334_comment},
  { "clearGlyphShift",(PyCFunction ) &Dtool_TextNode_clear_glyph_shift_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_glyph_shift_335_comment},
  { "setText",(PyCFunction ) &Dtool_TextNode_set_text_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_text_336_comment},
  { "clearText",(PyCFunction ) &Dtool_TextNode_clear_text_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_clear_text_337_comment},
  { "appendText",(PyCFunction ) &Dtool_TextNode_append_text_338, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_append_text_338_comment},
  { "appendUnicodeChar",(PyCFunction ) &Dtool_TextNode_append_unicode_char_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_append_unicode_char_339_comment},
  { "getWordwrappedText",(PyCFunction ) &Dtool_TextNode_get_wordwrapped_text_340, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_wordwrapped_text_340_comment},
  { "calcWidth",(PyCFunction ) &Dtool_TextNode_calc_width_341, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_calc_width_341_comment},
  { "hasExactCharacter",(PyCFunction ) &Dtool_TextNode_has_exact_character_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_exact_character_342_comment},
  { "hasCharacter",(PyCFunction ) &Dtool_TextNode_has_character_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_has_character_343_comment},
  { "isWhitespace",(PyCFunction ) &Dtool_TextNode_is_whitespace_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_is_whitespace_344_comment},
  { "setWtext",(PyCFunction ) &Dtool_TextNode_set_wtext_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_set_wtext_345_comment},
  { "appendWtext",(PyCFunction ) &Dtool_TextNode_append_wtext_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_append_wtext_346_comment},
  { "getWordwrappedWtext",(PyCFunction ) &Dtool_TextNode_get_wordwrapped_wtext_347, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_wordwrapped_wtext_347_comment},
  { "output",(PyCFunction ) &Dtool_TextNode_output_348, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_output_348_comment},
  { "write",(PyCFunction ) &Dtool_TextNode_write_349, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_write_349_comment},
  { "getLeft",(PyCFunction ) &Dtool_TextNode_get_left_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_left_350_comment},
  { "getRight",(PyCFunction ) &Dtool_TextNode_get_right_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_right_351_comment},
  { "getBottom",(PyCFunction ) &Dtool_TextNode_get_bottom_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_bottom_352_comment},
  { "getTop",(PyCFunction ) &Dtool_TextNode_get_top_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_top_353_comment},
  { "getHeight",(PyCFunction ) &Dtool_TextNode_get_height_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_height_354_comment},
  { "getWidth",(PyCFunction ) &Dtool_TextNode_get_width_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_width_355_comment},
  { "getUpperLeft3d",(PyCFunction ) &Dtool_TextNode_get_upper_left_3d_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_upper_left_3d_356_comment},
  { "getLowerRight3d",(PyCFunction ) &Dtool_TextNode_get_lower_right_3d_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_lower_right_3d_357_comment},
  { "getNumRows",(PyCFunction ) &Dtool_TextNode_get_num_rows_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_num_rows_358_comment},
  { "generate",(PyCFunction ) &Dtool_TextNode_generate_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_generate_359_comment},
  { "update",(PyCFunction ) &Dtool_TextNode_update_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_update_360_comment},
  { "forceUpdate",(PyCFunction ) &Dtool_TextNode_force_update_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_force_update_361_comment},
  { "getInternalGeom",(PyCFunction ) &Dtool_TextNode_get_internal_geom_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_internal_geom_362_comment},
  { "getClassType",(PyCFunction ) &Dtool_TextNode_get_class_type_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_get_class_type_363_comment},
  { "upcastToPandaNode",(PyCFunction ) &Dtool_TextNode_upcast_to_PandaNode_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_upcast_to_PandaNode_248_comment},
  { "upcastToTextEncoder",(PyCFunction ) &Dtool_TextNode_upcast_to_TextEncoder_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_upcast_to_TextEncoder_251_comment},
  { "upcastToTextProperties",(PyCFunction ) &Dtool_TextNode_upcast_to_TextProperties_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextNode_upcast_to_TextProperties_253_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     TextNode
//////////////////
static PyObject *  Dtool_Repr_TextNode(PyObject * self)
{
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     TextNode
//////////////////
static PyObject *  Dtool_Str_TextNode(PyObject * self)
{
    TextNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_TextNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextNode\n"
          "// Description : The primary interface to this module.  This class\n"
          "//               does basic text assembly; given a string of text and\n"
          "//               a TextFont object, it creates a piece of geometry\n"
          "//               that may be placed in the 3-d or 2-d world to\n"
          "//               represent the indicated text.\n"
          "//\n"
          "//               The TextNode may be used in one of two ways.\n"
          "//               Naively, it may simply be parented directly into the\n"
          "//               scene graph and rendered as if it were a GeomNode; in\n"
          "//               this mode, the actual polygon geometry that renders\n"
          "//               the text is not directly visible or accessible, but\n"
          "//               remains hidden within the TextNode.\n"
          "//\n"
          "//               The second way TextNode may be used is as a text\n"
          "//               generator.  To use it in this way, do not parent the\n"
          "//               TextNode to the scene graph; instead, set the\n"
          "//               properties of the text and call generate() to return\n"
          "//               an ordinary node, containing ordinary geometry, which\n"
          "//               you may use however you like.  Each time you call\n"
          "//               generate() a new node is returned.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_TextEncoder._Dtool_ClassInit(NULL);
        Dtool_TextProperties._Dtool_ClassInit(NULL);
        Dtool_TextNode.As_PyTypeObject().tp_bases = Py_BuildValue("(OOO)",&Dtool_PandaNode.As_PyTypeObject(),&Dtool_TextEncoder.As_PyTypeObject(),&Dtool_TextProperties.As_PyTypeObject());
        Dtool_TextNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextNode.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_TextNode.As_PyTypeObject().tp_repr = & Dtool_Repr_TextNode;
        // __str__
        Dtool_TextNode.As_PyTypeObject().tp_str = & Dtool_Str_TextNode;
        // Enum  TextNode::FlattenFlags;
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"FFNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"FFLight",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"FFMedium",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"FFStrong",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"FFDynamicMerge",PyInt_FromLong(8));
        if(PyType_Ready(&Dtool_TextNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextNode)");
             printf(" Error In PyType_ReadyTextNode");
             return;
        }
        Py_INCREF(&Dtool_TextNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"TextNode",&Dtool_TextNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TextNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TextNode[105],&Dtool_TextNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TextNode,TextNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextNode.As_PyTypeObject());
        PyModule_AddObject(module, "TextNode",(PyObject *)&Dtool_TextNode.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
//********************************************************************
//*** Module Init Updcall ..TextFont
//********************************************************************
   Dtool_PyModuleClassInit_TextFont(module);
//********************************************************************
//*** Module Init Updcall ..DynamicTextPage
//********************************************************************
   Dtool_PyModuleClassInit_DynamicTextPage(module);
//********************************************************************
//*** Module Init Updcall ..DynamicTextFont
//********************************************************************
   Dtool_PyModuleClassInit_DynamicTextFont(module);
//********************************************************************
//*** Module Init Updcall ..FontPool
//********************************************************************
   Dtool_PyModuleClassInit_FontPool(module);
//********************************************************************
//*** Module Init Updcall ..GeomTextGlyph
//********************************************************************
   Dtool_PyModuleClassInit_GeomTextGlyph(module);
//********************************************************************
//*** Module Init Updcall ..StaticTextFont
//********************************************************************
   Dtool_PyModuleClassInit_StaticTextFont(module);
//********************************************************************
//*** Module Init Updcall ..TextProperties
//********************************************************************
   Dtool_PyModuleClassInit_TextProperties(module);
//********************************************************************
//*** Module Init Updcall ..TextGraphic
//********************************************************************
   Dtool_PyModuleClassInit_TextGraphic(module);
//********************************************************************
//*** Module Init Updcall ..TextPropertiesManager
//********************************************************************
   Dtool_PyModuleClassInit_TextPropertiesManager(module);
//********************************************************************
//*** Module Init Updcall ..TextAssembler
//********************************************************************
   Dtool_PyModuleClassInit_TextAssembler(module);
//********************************************************************
//*** Module Init Updcall ..TextNode
//********************************************************************
   Dtool_PyModuleClassInit_TextNode(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libtext_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212887,  /* file_identifier */
  "libtext",  /* library_name */
  "pUk_",  /* library_hash_name */
  "panda",  /* module_name */
  "libtext.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  805  /* next_index */
};

Configure(_in_configure_libtext);
ConfigureFn(_in_configure_libtext) {
  interrogate_request_module(&_in_module_def);
}

