/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/grutil -Ipanda/src/grutil -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libgrutil_igate.cxx -od built_Rocket/pandac/input/libgrutil.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/grutil -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/ffmpeg/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libgrutil cardMaker.h config_grutil.h ffmpegTexture.h fisheyeMaker.h frameRateMeter.h geoMipTerrain.h grutil_composite.cxx heightfieldTesselator.h lineSegs.h meshDrawer.h meshDrawer2D.h movieTexture.h multitexReducer.h nodeVertexTransform.h pipeOcclusionCullTraverser.h rigidBodyCombiner.h sceneGraphAnalyzerMeter.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libgrutil
#include "py_panda.h"  

#include "cardMaker.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_grutil.h"
#include "displayRegion.h"
#include "ffmpegTexture.h"
#include "fisheyeMaker.h"
#include "frameRateMeter.h"
#include "geoMipTerrain.h"
#include "geomNode.h"
#include "graphicsOutput.h"
#include "heightfieldTesselator.h"
#include "libavcodec/avcodec.h"
#include "libavformat/avformat.h"
#include "lineSegs.h"
#include "luse.h"
#include "meshDrawer.h"
#include "meshDrawer2D.h"
#include "movieTexture.h"
#include "multitexReducer.h"
#include "namable.h"
#include "nodePath.h"
#include "nodeVertexTransform.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pipeOcclusionCullTraverser.h"
#include "pmap.h"
#include "pnmImage.h"
#include "pointerTo.h"
#include "pvector.h"
#include "rigidBodyCombiner.h"
#include "sceneGraphAnalyzerMeter.h"
#include "texMatrixAttrib.h"
#include "textNode.h"
#include "texture.h"
#include "textureAttrib.h"
#include "textureStage.h"
#include "transformState.h"
#include "videoTexture.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CardMaker
//********************************************************************
typedef  CardMaker  CardMaker_localtype;
Define_Module_Class(panda,CardMaker,CardMaker_localtype,CardMaker);
//********************************************************************
//*** prototypes for .. FFMpegTexture
//********************************************************************
typedef  FFMpegTexture  FFMpegTexture_localtype;
Define_Module_ClassRef(panda,FFMpegTexture,FFMpegTexture_localtype,FFMpegTexture);
//********************************************************************
//*** prototypes for .. FisheyeMaker
//********************************************************************
typedef  FisheyeMaker  FisheyeMaker_localtype;
Define_Module_Class(panda,FisheyeMaker,FisheyeMaker_localtype,FisheyeMaker);
//********************************************************************
//*** prototypes for .. FrameRateMeter
//********************************************************************
typedef  FrameRateMeter  FrameRateMeter_localtype;
Define_Module_ClassRef(panda,FrameRateMeter,FrameRateMeter_localtype,FrameRateMeter);
//********************************************************************
//*** prototypes for .. GeoMipTerrain
//********************************************************************
typedef  GeoMipTerrain  GeoMipTerrain_localtype;
Define_Module_Class(panda,GeoMipTerrain,GeoMipTerrain_localtype,GeoMipTerrain);
//********************************************************************
//*** prototypes for .. HeightfieldTesselator
//********************************************************************
typedef  HeightfieldTesselator  HeightfieldTesselator_localtype;
Define_Module_Class(panda,HeightfieldTesselator,HeightfieldTesselator_localtype,HeightfieldTesselator);
//********************************************************************
//*** prototypes for .. SceneGraphAnalyzerMeter
//********************************************************************
typedef  SceneGraphAnalyzerMeter  SceneGraphAnalyzerMeter_localtype;
Define_Module_ClassRef(panda,SceneGraphAnalyzerMeter,SceneGraphAnalyzerMeter_localtype,SceneGraphAnalyzerMeter);
//********************************************************************
//*** prototypes for .. MeshDrawer
//********************************************************************
typedef  MeshDrawer  MeshDrawer_localtype;
Define_Module_Class(panda,MeshDrawer,MeshDrawer_localtype,MeshDrawer);
//********************************************************************
//*** prototypes for .. MeshDrawer2D
//********************************************************************
typedef  MeshDrawer2D  MeshDrawer2D_localtype;
Define_Module_Class(panda,MeshDrawer2D,MeshDrawer2D_localtype,MeshDrawer2D);
//********************************************************************
//*** prototypes for .. MovieTexture
//********************************************************************
typedef  MovieTexture  MovieTexture_localtype;
Define_Module_ClassRef(panda,MovieTexture,MovieTexture_localtype,MovieTexture);
//********************************************************************
//*** prototypes for .. NodeVertexTransform
//********************************************************************
typedef  NodeVertexTransform  NodeVertexTransform_localtype;
Define_Module_ClassRef(panda,NodeVertexTransform,NodeVertexTransform_localtype,NodeVertexTransform);
//********************************************************************
//*** prototypes for .. RigidBodyCombiner
//********************************************************************
typedef  RigidBodyCombiner  RigidBodyCombiner_localtype;
Define_Module_ClassRef(panda,RigidBodyCombiner,RigidBodyCombiner_localtype,RigidBodyCombiner);
//********************************************************************
//*** prototypes for .. PipeOcclusionCullTraverser
//********************************************************************
typedef  PipeOcclusionCullTraverser  PipeOcclusionCullTraverser_localtype;
Define_Module_ClassRef(panda,PipeOcclusionCullTraverser,PipeOcclusionCullTraverser_localtype,PipeOcclusionCullTraverser);
//********************************************************************
//*** prototypes for .. LineSegs
//********************************************************************
typedef  LineSegs  LineSegs_localtype;
Define_Module_Class(panda,LineSegs,LineSegs_localtype,LineSegs);
//********************************************************************
//*** prototypes for .. MultitexReducer
//********************************************************************
typedef  MultitexReducer  MultitexReducer_localtype;
Define_Module_Class(panda,MultitexReducer,MultitexReducer_localtype,MultitexReducer);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AnimInterface;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AudioSound;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_BitMask_unsigned_int_32;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ClockObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CullTraverser;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DisplayRegion;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GeomNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsOutput;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovieVideo;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PNMImage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_RenderState;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_SceneSetup;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextEncoder;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextProperties;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextureStage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TransformState;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VertexTransform;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VideoTexture;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CardMaker 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void CardMaker::reset(void)
 *******************************************************************/
static PyObject *Dtool_CardMaker_reset_5(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CardMaker::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const CardMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_reset_5_comment =
    "C++ Interface:\n"
    "reset(non-const CardMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::reset\n"
    "//       Access: Public\n"
    "//  Description: Resets all the parameters to their initial defaults.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_reset_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CardMaker::set_uv_range(LPoint2f const &ll, LPoint2f const &ur)
 * void CardMaker::set_uv_range(LPoint2f const &ll, LPoint2f const &lr, LPoint2f const &ur, LPoint2f const &ul)
 * void CardMaker::set_uv_range(LPoint3f const &ll, LPoint3f const &lr, LPoint3f const &ur, LPoint3f const &ul)
 * void CardMaker::set_uv_range(LVector4f const &x, LVector4f const &y, LVector4f const &z)
 * void CardMaker::set_uv_range(Texture const *tex)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_uv_range_6(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void CardMaker::set_uv_range(Texture const *tex)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"tex", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUvRange", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setUvRange", &param1));
                if(!PyErr_Occurred())
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_uv_range(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CardMaker.setUvRange() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void CardMaker::set_uv_range(LPoint2f const &ll, LPoint2f const &ur)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"ll", (char *)"ur", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setUvRange", key_word_list, &param1, &param2))
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint2f *param2_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint2f, 2, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->set_uv_range(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CardMaker.setUvRange() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void CardMaker::set_uv_range(LVector4f const &x, LVector4f const &y, LVector4f const &z)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setUvRange", key_word_list, &param1, &param2, &param3))
                {
                    LVector4f *param1_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector4f, 1, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        (local_this)->set_uv_range(*param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CardMaker.setUvRange() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void CardMaker::set_uv_range(LPoint3f const &ll, LPoint3f const &lr, LPoint3f const &ur, LPoint3f const &ul)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"ll", (char *)"lr", (char *)"ur", (char *)"ul", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:setUvRange", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint3f *param4_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LPoint3f, 4, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        (local_this)->set_uv_range(*param1_this, *param2_this, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void CardMaker::set_uv_range(LPoint2f const &ll, LPoint2f const &lr, LPoint2f const &ur, LPoint2f const &ul)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"ll", (char *)"lr", (char *)"ur", (char *)"ul", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:setUvRange", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint2f *param2_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint2f, 2, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint2f *param3_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint2f, 3, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);
LPoint2f *param4_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LPoint2f, 4, "CardMaker.setUvRange", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        (local_this)->set_uv_range(*param1_this, *param2_this, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setUvRange() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setUvRange(non-const CardMaker this, const Texture tex)\n"
          "setUvRange(non-const CardMaker this, const Point2 ll, const Point2 ur)\n"
          "setUvRange(non-const CardMaker this, const Vec4 x, const Vec4 y, const Vec4 z)\n"
          "setUvRange(non-const CardMaker this, const Point3 ll, const Point3 lr, const Point3 ur, const Point3 ul)\n"
          "setUvRange(non-const CardMaker this, const Point2 ll, const Point2 lr, const Point2 ur, const Point2 ul)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_uv_range_6_comment =
    "C++ Interface:\n"
    "setUvRange(non-const CardMaker this, const Texture tex)\n"
    "setUvRange(non-const CardMaker this, const Point2 ll, const Point2 ur)\n"
    "setUvRange(non-const CardMaker this, const Vec4 x, const Vec4 y, const Vec4 z)\n"
    "setUvRange(non-const CardMaker this, const Point3 ll, const Point3 lr, const Point3 ur, const Point3 ul)\n"
    "setUvRange(non-const CardMaker this, const Point2 ll, const Point2 lr, const Point2 ur, const Point2 ul)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_uv_range\n"
    "//       Access: Public\n"
    "//  Description: Sets the range of UV's that will be applied to the\n"
    "//               vertices.  If set_has_uvs() is true (as it is by\n"
    "//               default), the vertices will be generated with the\n"
    "//               indicated range of UV's, which will be useful if a\n"
    "//               texture is applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_uv_range\n"
    "//       Access: Public\n"
    "//  Description: Sets the range of UV's that will be applied to the\n"
    "//               vertices.  If set_has_uvs() is true (as it is by\n"
    "//               default), the vertices will be generated with the\n"
    "//               indicated range of UV's, which will be useful if a\n"
    "//               texture is applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_uv_range\n"
    "//       Access: Public\n"
    "//  Description: Sets the range of UV's that will be applied to the\n"
    "//               vertices.  If set_has_uvs() is true (as it is by\n"
    "//               default), the vertices will be generated with the\n"
    "//               indicated range of UV's, which will be useful if a\n"
    "//               texture is applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_uv_range\n"
    "//       Access: Public\n"
    "//  Description: Sets the range of UV's that will be applied to the\n"
    "//               vertices.  If set_has_uvs() is true (as it is by\n"
    "//               default), the vertices will be generated with the\n"
    "//               indicated range of UV's, which will be useful if a\n"
    "//               texture is applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_uv_range\n"
    "//       Access: Public\n"
    "//  Description: Sets the range of UV's that will be applied to the\n"
    "//               vertices appropriately to show the non-pad region\n"
    "//               of the texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_uv_range_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CardMaker::set_uv_range_cube(int face)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_uv_range_cube_7(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CardMaker::set_uv_range_cube(int face)
        int param1;
        static char * key_word_list[] = {(char *)"face", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setUvRangeCube", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setUvRangeCube", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_uv_range_cube((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.setUvRangeCube() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUvRangeCube(non-const CardMaker this, int face)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_uv_range_cube_7_comment =
    "C++ Interface:\n"
    "setUvRangeCube(non-const CardMaker this, int face)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_uv_range_cube\n"
    "//       Access: Public\n"
    "//  Description: Sets the range of UV's that will be applied to the\n"
    "//               vertices appropriately for a cube-map face.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_uv_range_cube_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_has_uvs(bool flag)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_has_uvs_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CardMaker::set_has_uvs(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHasUvs", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setHasUvs", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_has_uvs((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.setHasUvs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHasUvs(non-const CardMaker this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_has_uvs_8_comment =
    "C++ Interface:\n"
    "setHasUvs(non-const CardMaker this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_has_uvs\n"
    "//       Access: Public\n"
    "//  Description: Sets the flag indicating whether vertices will be\n"
    "//               generated with UV's or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_has_uvs_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_has_3d_uvs(bool flag)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_has_3d_uvs_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CardMaker::set_has_3d_uvs(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHas3dUvs", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setHas3dUvs", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_has_3d_uvs((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.setHas3dUvs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHas3dUvs(non-const CardMaker this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_has_3d_uvs_9_comment =
    "C++ Interface:\n"
    "setHas3dUvs(non-const CardMaker this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_has_3d_uvs\n"
    "//       Access: Public\n"
    "//  Description: Sets the flag indicating whether vertices will be\n"
    "//               generated with 3-component UVW's (true) or\n"
    "//               2-component UV's (the default, false).  Normally,\n"
    "//               this will be implicitly set by setting the uv_range.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_has_3d_uvs_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_frame(LPoint3f const &ll, LPoint3f const &lr, LPoint3f const &ur, LPoint3f const &ul)
 * inline void CardMaker::set_frame(LVecBase4f const &frame)
 * inline void CardMaker::set_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_frame_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CardMaker::set_frame(LVecBase4f const &frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "CardMaker.setFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CardMaker.setFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void CardMaker::set_frame(LPoint3f const &ll, LPoint3f const &lr, LPoint3f const &ur, LPoint3f const &ul)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"ll", (char *)"lr", (char *)"ur", (char *)"ul", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:setFrame", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CardMaker.setFrame", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CardMaker.setFrame", 1, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "CardMaker.setFrame", 1, coerced_ptr, report_errors);
LPoint3f *param4_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LPoint3f, 4, "CardMaker.setFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        (local_this)->set_frame(*param1_this, *param2_this, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void CardMaker::set_frame(float left, float right, float bottom, float top)
                double param1;
                double param2;
                double param3;
                double param4;
                static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrame", key_word_list, &param1, &param2, &param3, &param4))
                {
                    (local_this)->set_frame((float)param1, (float)param2, (float)param3, (float)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrame(non-const CardMaker this, const VBase4 frame)\n"
          "setFrame(non-const CardMaker this, const Point3 ll, const Point3 lr, const Point3 ur, const Point3 ul)\n"
          "setFrame(non-const CardMaker this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_frame_10_comment =
    "C++ Interface:\n"
    "setFrame(non-const CardMaker this, const VBase4 frame)\n"
    "setFrame(non-const CardMaker this, const Point3 ll, const Point3 lr, const Point3 ur, const Point3 ul)\n"
    "setFrame(non-const CardMaker this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_frame\n"
    "//       Access: Public\n"
    "//  Description: Sets the size of the card.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_frame\n"
    "//       Access: Public\n"
    "//  Description: Sets the size of the card.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_frame\n"
    "//       Access: Public\n"
    "//  Description: Sets the size of the card.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_frame_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_frame_fullscreen_quad(void)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_frame_fullscreen_quad_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CardMaker::set_frame_fullscreen_quad(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setFrameFullscreenQuad", key_word_list));
        else
            (PyArg_Parse(args, ":setFrameFullscreenQuad"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_fullscreen_quad();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.setFrameFullscreenQuad() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameFullscreenQuad(non-const CardMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_frame_fullscreen_quad_11_comment =
    "C++ Interface:\n"
    "setFrameFullscreenQuad(non-const CardMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_frame_fullscreen_quad\n"
    "//       Access: Public\n"
    "//  Description: Sets the card to (-1,1,-1,1), which is appropriate\n"
    "//               if you plan to parent it to render2d and use it\n"
    "//               as a fullscreen quad.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_frame_fullscreen_quad_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_color(LVecBase4f const &color)
 * inline void CardMaker::set_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_color_12(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CardMaker::set_color(LVecBase4f const &color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "CardMaker.setColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CardMaker.setColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CardMaker::set_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CardMaker.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setColor(non-const CardMaker this, const VBase4 color)\n"
          "setColor(non-const CardMaker this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_color_12_comment =
    "C++ Interface:\n"
    "setColor(non-const CardMaker this, const VBase4 color)\n"
    "setColor(non-const CardMaker this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_color\n"
    "//       Access: Public\n"
    "//  Description: Sets the color of the card.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_color\n"
    "//       Access: Public\n"
    "//  Description: Sets the color of the card.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_color_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_has_normals(bool flag)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_has_normals_13(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CardMaker::set_has_normals(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHasNormals", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setHasNormals", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_has_normals((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.setHasNormals() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHasNormals(non-const CardMaker this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_has_normals_13_comment =
    "C++ Interface:\n"
    "setHasNormals(non-const CardMaker this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_has_normals\n"
    "//       Access: Public\n"
    "//  Description: Sets the flag indicating whether vertices will be\n"
    "//               generated with normals or not.  Normals are required\n"
    "//               if you intend to enable lighting on the card, but are\n"
    "//               just wasted space and bandwidth otherwise, so there\n"
    "//               is a (slight) optimization for disabling them.  If\n"
    "//               enabled, the normals will be generated perpendicular\n"
    "//               to the card's face.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_has_normals_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::set_source_geometry(PandaNode *node, LVecBase4f const &frame)
 *******************************************************************/
static PyObject *Dtool_CardMaker_set_source_geometry_14(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CardMaker::set_source_geometry(PandaNode *node, LVecBase4f const &frame)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"node", (char *)"frame", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setSourceGeometry", key_word_list, &param1, &param2))
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CardMaker.setSourceGeometry", 0, coerced_ptr, report_errors);
LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "CardMaker.setSourceGeometry", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_source_geometry(param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CardMaker.setSourceGeometry() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSourceGeometry(non-const CardMaker this, non-const PandaNode node, const VBase4 frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_set_source_geometry_14_comment =
    "C++ Interface:\n"
    "setSourceGeometry(non-const CardMaker this, non-const PandaNode node, const VBase4 frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::set_source_geometry\n"
    "//       Access: Published\n"
    "//  Description: Sets a node that will be copied (and scaled and\n"
    "//               translated) to generate the frame, instead of\n"
    "//               generating a new polygon.  The node may contain\n"
    "//               arbitrary geometry that describes a flat polygon\n"
    "//               contained within the indicated left, right, bottom,\n"
    "//               top frame.\n"
    "//\n"
    "//               When generate() is called, the geometry in this node\n"
    "//               will be scaled and translated appropriately to give\n"
    "//               it the size and aspect ratio specified by\n"
    "//               set_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_set_source_geometry_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CardMaker::clear_source_geometry(void)
 *******************************************************************/
static PyObject *Dtool_CardMaker_clear_source_geometry_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CardMaker::clear_source_geometry(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSourceGeometry", key_word_list));
        else
            (PyArg_Parse(args, ":clearSourceGeometry"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_source_geometry();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.clearSourceGeometry() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSourceGeometry(non-const CardMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_clear_source_geometry_15_comment =
    "C++ Interface:\n"
    "clearSourceGeometry(non-const CardMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::clear_source_geometry\n"
    "//       Access: Published\n"
    "//  Description: Removes the node specified by an earlier call to\n"
    "//               set_source_geometry().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_clear_source_geometry_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > CardMaker::generate(void)
 *******************************************************************/
static PyObject *Dtool_CardMaker_generate_16(PyObject *self, PyObject *args,PyObject *kwds) {
    CardMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CardMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< PandaNode > CardMaker::generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":generate", key_word_list));
        else
            (PyArg_Parse(args, ":generate"));
        if(!PyErr_Occurred())
        {
            PointerTo< PandaNode > return_value = (local_this)->generate();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CardMaker.generate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const CardMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CardMaker_generate_16_comment =
    "C++ Interface:\n"
    "generate(non-const CardMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CardMaker::generate\n"
    "//       Access: Public\n"
    "//  Description: Generates a GeomNode that renders the specified\n"
    "//               geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CardMaker_generate_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CardMaker::CardMaker(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_CardMaker(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline CardMaker::CardMaker(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:CardMaker", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:CardMaker", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            CardMaker *return_value = new CardMaker(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CardMaker,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CardMaker(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CardMaker(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CardMaker)
    {
        printf("CardMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CardMaker * local_this = (CardMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CardMaker)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CardMaker(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CardMaker)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CardMaker*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FFMpegTexture 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FFMpegTexture::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FFMpegTexture_get_class_type_20(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FFMpegTexture::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FFMpegTexture::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FFMpegTexture_get_class_type_20_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FFMpegTexture_get_class_type_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FFMpegTexture::FFMpegTexture(basic_string< char > const &name)
 * FFMpegTexture::FFMpegTexture(basic_string< char > const &name = ((string())))
 *******************************************************************/
int  Dtool_Init_FFMpegTexture(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-FFMpegTexture::FFMpegTexture(basic_string< char > const &name = ((string())))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":FFMpegTexture", key_word_list))
            {
                FFMpegTexture *return_value = new FFMpegTexture();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_FFMpegTexture,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-FFMpegTexture::FFMpegTexture(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FFMpegTexture", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:FFMpegTexture", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                FFMpegTexture *return_value = new FFMpegTexture(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_FFMpegTexture,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FFMpegTexture() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FFMpegTexture()\n"
          "FFMpegTexture(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FFMpegTexture(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FFMpegTexture)
    {
        printf("FFMpegTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FFMpegTexture * local_this = (FFMpegTexture *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FFMpegTexture)
        return local_this;
    if(requested_type == &Dtool_AnimInterface)
        return ( AnimInterface *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_Texture)
        return ( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Texture *)( VideoTexture *) local_this;
    if(requested_type == &Dtool_VideoTexture)
        return ( VideoTexture *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FFMpegTexture(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FFMpegTexture)
        return from_this;
    if(from_type == &Dtool_AnimInterface)
    {
          AnimInterface* other_this = (AnimInterface*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_Texture)
    {
          Texture* other_this = (Texture*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (FFMpegTexture*)other_this;
    }
    if(from_type == &Dtool_VideoTexture)
    {
          VideoTexture* other_this = (VideoTexture*)from_this;
          return (FFMpegTexture*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FisheyeMaker 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void FisheyeMaker::reset(void)
 *******************************************************************/
static PyObject *Dtool_FisheyeMaker_reset_24(PyObject *self, PyObject *args,PyObject *kwds) {
    FisheyeMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FisheyeMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FisheyeMaker::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FisheyeMaker.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const FisheyeMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeMaker_reset_24_comment =
    "C++ Interface:\n"
    "reset(non-const FisheyeMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FisheyeMaker::reset\n"
    "//       Access: Public\n"
    "//  Description: Resets all the parameters to their initial defaults.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FisheyeMaker_reset_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FisheyeMaker::set_fov(float fov)
 *******************************************************************/
static PyObject *Dtool_FisheyeMaker_set_fov_25(PyObject *self, PyObject *args,PyObject *kwds) {
    FisheyeMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FisheyeMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FisheyeMaker::set_fov(float fov)
        double param1;
        static char * key_word_list[] = {(char *)"fov", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFov", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFov", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fov((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FisheyeMaker.setFov() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFov(non-const FisheyeMaker this, float fov)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeMaker_set_fov_25_comment =
    "C++ Interface:\n"
    "setFov(non-const FisheyeMaker this, float fov)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FisheyeMaker::set_fov\n"
    "//       Access: Public\n"
    "//  Description: Specifies the field of view of the fisheye\n"
    "//               projection.  A sphere map will have a 360-degree\n"
    "//               field of view (and this is the default).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FisheyeMaker_set_fov_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FisheyeMaker::set_num_vertices(int num_vertices)
 *******************************************************************/
static PyObject *Dtool_FisheyeMaker_set_num_vertices_26(PyObject *self, PyObject *args,PyObject *kwds) {
    FisheyeMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FisheyeMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FisheyeMaker::set_num_vertices(int num_vertices)
        int param1;
        static char * key_word_list[] = {(char *)"num_vertices", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumVertices", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumVertices", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_vertices((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FisheyeMaker.setNumVertices() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumVertices(non-const FisheyeMaker this, int num_vertices)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeMaker_set_num_vertices_26_comment =
    "C++ Interface:\n"
    "setNumVertices(non-const FisheyeMaker this, int num_vertices)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FisheyeMaker::set_num_vertices\n"
    "//       Access: Public\n"
    "//  Description: Specifies the approximate number of vertices to be\n"
    "//               used to generate the rose.  This is the approximate\n"
    "//               number of vertices that will be located within the\n"
    "//               rose's unit circle, not counting the inscribing\n"
    "//               square (if any).  The actual number of vertices used\n"
    "//               may be +/- 25% of this value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FisheyeMaker_set_num_vertices_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FisheyeMaker::set_square_inscribed(bool square_inscribed, float square_radius)
 *******************************************************************/
static PyObject *Dtool_FisheyeMaker_set_square_inscribed_27(PyObject *self, PyObject *args,PyObject *kwds) {
    FisheyeMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FisheyeMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FisheyeMaker::set_square_inscribed(bool square_inscribed, float square_radius)
        PyObject *param1;
        double param2;
        static char * key_word_list[] = {(char *)"square_inscribed", (char *)"square_radius", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setSquareInscribed", key_word_list, &param1, &param2))
        {
            (local_this)->set_square_inscribed((PyObject_IsTrue(param1)!=0), (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FisheyeMaker.setSquareInscribed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSquareInscribed(non-const FisheyeMaker this, bool square_inscribed, float square_radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeMaker_set_square_inscribed_27_comment =
    "C++ Interface:\n"
    "setSquareInscribed(non-const FisheyeMaker this, bool square_inscribed, float square_radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FisheyeMaker::set_square_inscribed\n"
    "//       Access: Public\n"
    "//  Description: Sets the flag that indicates whether the rose should\n"
    "//               be inscribed within a square.  When this is true, an\n"
    "//               additional square is generated to inscribed the\n"
    "//               circular rose, with the indicated \"radius\" (the sides\n"
    "//               of the square will be 2 * square_radius).  The\n"
    "//               texture coordinates of the square will uniformly map\n"
    "//               to the back pole of the cube map.\n"
    "//\n"
    "//               This is mainly useful to provide a good uniform\n"
    "//               background color for a sphere map so that it does not\n"
    "//               have a sharp circular edge that might produce\n"
    "//               artifacts due to numerical imprecision when mapping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FisheyeMaker_set_square_inscribed_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FisheyeMaker::set_reflection(bool reflection)
 *******************************************************************/
static PyObject *Dtool_FisheyeMaker_set_reflection_28(PyObject *self, PyObject *args,PyObject *kwds) {
    FisheyeMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FisheyeMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FisheyeMaker::set_reflection(bool reflection)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"reflection", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setReflection", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setReflection", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_reflection((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FisheyeMaker.setReflection() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReflection(non-const FisheyeMaker this, bool reflection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeMaker_set_reflection_28_comment =
    "C++ Interface:\n"
    "setReflection(non-const FisheyeMaker this, bool reflection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FisheyeMaker::set_reflection\n"
    "//       Access: Public\n"
    "//  Description: Sets the flag indicating whether the texture image\n"
    "//               should be mirrored (true) or normal (false).  When\n"
    "//               this is true, the 3-D texture coordinates will be\n"
    "//               reversed so that the image is appropriate for a\n"
    "//               reflection.  This is the best choice for generating a\n"
    "//               sphere map from a cube map.  The default is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FisheyeMaker_set_reflection_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > FisheyeMaker::generate(void)
 *******************************************************************/
static PyObject *Dtool_FisheyeMaker_generate_29(PyObject *self, PyObject *args,PyObject *kwds) {
    FisheyeMaker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FisheyeMaker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< PandaNode > FisheyeMaker::generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":generate", key_word_list));
        else
            (PyArg_Parse(args, ":generate"));
        if(!PyErr_Occurred())
        {
            PointerTo< PandaNode > return_value = (local_this)->generate();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FisheyeMaker.generate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const FisheyeMaker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeMaker_generate_29_comment =
    "C++ Interface:\n"
    "generate(non-const FisheyeMaker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FisheyeMaker::generate\n"
    "//       Access: Public\n"
    "//  Description: Generates a GeomNode that renders the specified\n"
    "//               geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FisheyeMaker_generate_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline FisheyeMaker::FisheyeMaker(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_FisheyeMaker(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline FisheyeMaker::FisheyeMaker(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FisheyeMaker", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:FisheyeMaker", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            FisheyeMaker *return_value = new FisheyeMaker(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_FisheyeMaker,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FisheyeMaker(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FisheyeMaker(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FisheyeMaker)
    {
        printf("FisheyeMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FisheyeMaker * local_this = (FisheyeMaker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FisheyeMaker)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FisheyeMaker(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FisheyeMaker)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FisheyeMaker*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FrameRateMeter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void FrameRateMeter::setup_window(GraphicsOutput *window)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_setup_window_33(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void FrameRateMeter::setup_window(GraphicsOutput *window)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"window", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setupWindow", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setupWindow", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "FrameRateMeter.setupWindow", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->setup_window(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrameRateMeter.setupWindow() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupWindow(non-const FrameRateMeter this, non-const GraphicsOutput window)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_setup_window_33_comment =
    "C++ Interface:\n"
    "setupWindow(non-const FrameRateMeter this, non-const GraphicsOutput window)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::setup_window\n"
    "//       Access: Published\n"
    "//  Description: Sets up the frame rate meter to create a\n"
    "//               DisplayRegion to render itself into the indicated\n"
    "//               window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_setup_window_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FrameRateMeter::clear_window(void)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_clear_window_34(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FrameRateMeter::clear_window(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearWindow", key_word_list));
        else
            (PyArg_Parse(args, ":clearWindow"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_window();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameRateMeter.clearWindow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearWindow(non-const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_clear_window_34_comment =
    "C++ Interface:\n"
    "clearWindow(non-const FrameRateMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::clear_window\n"
    "//       Access: Published\n"
    "//  Description: Undoes the effect of a previous call to\n"
    "//               setup_window().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_clear_window_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput *FrameRateMeter::get_window(void) const
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_get_window_35(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsOutput *FrameRateMeter::get_window(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindow", key_word_list));
        else
            (PyArg_Parse(args, ":getWindow"));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = ((const FrameRateMeter*)local_this)->get_window();
            if (return_value != (GraphicsOutput *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindow(const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_get_window_35_comment =
    "C++ Interface:\n"
    "getWindow(const FrameRateMeter this)\n"
    "\n"
    "// Filename: frameRateMeter.I\n"
    "// Created by:  drose (23Dec03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::get_window\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsOutput that was passed to\n"
    "//               setup_window(), or NULL if setup_window() has not\n"
    "//               been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_get_window_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *FrameRateMeter::get_display_region(void) const
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_get_display_region_36(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DisplayRegion *FrameRateMeter::get_display_region(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayRegion", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayRegion"));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = ((const FrameRateMeter*)local_this)->get_display_region();
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayRegion(const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_get_display_region_36_comment =
    "C++ Interface:\n"
    "getDisplayRegion(const FrameRateMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::get_display_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the DisplayRegion that the meter has created\n"
    "//               to render itself into the window to setup_window(),\n"
    "//               or NULL if setup_window() has not been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_get_display_region_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameRateMeter::set_update_interval(double update_interval)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_set_update_interval_37(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameRateMeter::set_update_interval(double update_interval)
        double param1;
        static char * key_word_list[] = {(char *)"update_interval", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setUpdateInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setUpdateInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_update_interval((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameRateMeter.setUpdateInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUpdateInterval(non-const FrameRateMeter this, float update_interval)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_set_update_interval_37_comment =
    "C++ Interface:\n"
    "setUpdateInterval(non-const FrameRateMeter this, float update_interval)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::set_update_interval\n"
    "//       Access: Published\n"
    "//  Description: Specifies the number of seconds that should elapse\n"
    "//               between updates to the frame rate indication.  This\n"
    "//               should be reasonably slow (e.g. 0.2 to 1.0) so that\n"
    "//               the calculation of the frame rate text does not\n"
    "//               itself dominate the frame rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_set_update_interval_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double FrameRateMeter::get_update_interval(void) const
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_get_update_interval_38(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double FrameRateMeter::get_update_interval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUpdateInterval", key_word_list));
        else
            (PyArg_Parse(args, ":getUpdateInterval"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const FrameRateMeter*)local_this)->get_update_interval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUpdateInterval(const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_get_update_interval_38_comment =
    "C++ Interface:\n"
    "getUpdateInterval(const FrameRateMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::get_update_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of seconds that will elapse\n"
    "//               between updates to the frame rate indication.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_get_update_interval_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameRateMeter::set_text_pattern(basic_string< char > const &text_pattern)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_set_text_pattern_39(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameRateMeter::set_text_pattern(basic_string< char > const &text_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setTextPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setTextPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_text_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameRateMeter.setTextPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextPattern(non-const FrameRateMeter this, string text_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_set_text_pattern_39_comment =
    "C++ Interface:\n"
    "setTextPattern(non-const FrameRateMeter this, string text_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::set_text_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the sprintf() pattern that is used to format the\n"
    "//               text.  The string \"%f\" or some variant will be\n"
    "//               replaced with the current frame rate in frames per\n"
    "//               second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_set_text_pattern_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &FrameRateMeter::get_text_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_get_text_pattern_40(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &FrameRateMeter::get_text_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getTextPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const FrameRateMeter*)local_this)->get_text_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextPattern(const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_get_text_pattern_40_comment =
    "C++ Interface:\n"
    "getTextPattern(const FrameRateMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::get_text_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the sprintf() pattern that is used to format the\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_get_text_pattern_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameRateMeter::set_clock_object(ClockObject *clock_object)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_set_clock_object_41(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void FrameRateMeter::set_clock_object(ClockObject *clock_object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"clock_object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClockObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setClockObject", &param1));
            if(!PyErr_Occurred())
            {
                ClockObject *param1_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ClockObject, 1, "FrameRateMeter.setClockObject", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_clock_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrameRateMeter.setClockObject() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClockObject(non-const FrameRateMeter this, non-const ClockObject clock_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_set_clock_object_41_comment =
    "C++ Interface:\n"
    "setClockObject(non-const FrameRateMeter this, non-const ClockObject clock_object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::set_clock_object\n"
    "//       Access: Published\n"
    "//  Description: Sets the clock that is used to determine the frame\n"
    "//               rate.  The default is the application's global clock\n"
    "//               (ClockObject::get_global_clock()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_set_clock_object_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ClockObject *FrameRateMeter::get_clock_object(void) const
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_get_clock_object_42(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ClockObject *FrameRateMeter::get_clock_object(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClockObject", key_word_list));
        else
            (PyArg_Parse(args, ":getClockObject"));
        if(!PyErr_Occurred())
        {
            ClockObject *return_value = ((const FrameRateMeter*)local_this)->get_clock_object();
            if (return_value != (ClockObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ClockObject,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClockObject(const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_get_clock_object_42_comment =
    "C++ Interface:\n"
    "getClockObject(const FrameRateMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::get_clock_object\n"
    "//       Access: Published\n"
    "//  Description: Returns the clock that is used to determine the frame\n"
    "//               rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_get_clock_object_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FrameRateMeter::update(void)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_update_43(PyObject *self, PyObject *args,PyObject *kwds) {
    FrameRateMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FrameRateMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FrameRateMeter::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrameRateMeter.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const FrameRateMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_update_43_comment =
    "C++ Interface:\n"
    "update(non-const FrameRateMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FrameRateMeter::update\n"
    "//       Access: Published\n"
    "//  Description: You can call this to explicitly force the\n"
    "//               FrameRateMeter to update itself with the latest frame\n"
    "//               rate information.  Normally, it is not necessary to\n"
    "//               call this explicitly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FrameRateMeter_update_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FrameRateMeter::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FrameRateMeter_get_class_type_44(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FrameRateMeter::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FrameRateMeter::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FrameRateMeter_get_class_type_44_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FrameRateMeter_get_class_type_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FrameRateMeter::FrameRateMeter(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_FrameRateMeter(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-FrameRateMeter::FrameRateMeter(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FrameRateMeter", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:FrameRateMeter", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            FrameRateMeter *return_value = new FrameRateMeter(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_FrameRateMeter,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FrameRateMeter(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FrameRateMeter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FrameRateMeter)
    {
        printf("FrameRateMeter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FrameRateMeter * local_this = (FrameRateMeter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FrameRateMeter)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_TextEncoder)
        return ( TextEncoder *)( TextNode *) local_this;
    if(requested_type == &Dtool_TextNode)
        return ( TextNode *) local_this;
    if(requested_type == &Dtool_TextProperties)
        return ( TextProperties *)( TextNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( TextNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FrameRateMeter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FrameRateMeter)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FrameRateMeter*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (FrameRateMeter*)other_this;
    }
    if(from_type == &Dtool_TextEncoder)
    {
          TextEncoder* other_this = (TextEncoder*)from_this;
          return (FrameRateMeter*)other_this;
    }
    if(from_type == &Dtool_TextNode)
    {
          TextNode* other_this = (TextNode*)from_this;
          return (FrameRateMeter*)other_this;
    }
    if(from_type == &Dtool_TextProperties)
    {
          TextProperties* other_this = (TextProperties*)from_this;
          return (FrameRateMeter*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FrameRateMeter*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FrameRateMeter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GeoMipTerrain 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PNMImage &GeoMipTerrain::heightfield(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_heightfield_48(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PNMImage &GeoMipTerrain::heightfield(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":heightfield", key_word_list));
        else
            (PyArg_Parse(args, ":heightfield"));
        if(!PyErr_Occurred())
        {
            PNMImage *return_value = &((local_this)->heightfield());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.heightfield() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "heightfield(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_heightfield_48_comment =
    "C++ Interface:\n"
    "heightfield(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::heightfield\n"
    "//       Access: Published\n"
    "//  Description: Returns a reference to the heightfield (a PNMImage)\n"
    "//               contained inside GeoMipTerrain.  You can use\n"
    "//               the reference to alter the heightfield.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_heightfield_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [bool GeoMipTerrain::set_heightfield(Filename const &filename, PNMFileType *type)]
 * bool GeoMipTerrain::set_heightfield(Filename const &filename, PNMFileType *type = ((void *)(0)))
 * inline bool GeoMipTerrain::set_heightfield(PNMImage const &image)
 * inline bool GeoMipTerrain::set_heightfield(basic_string< char > const &path)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_heightfield_49(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool GeoMipTerrain::set_heightfield(Filename const &filename, PNMFileType *type = ((void *)(0)))
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHeightfield", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setHeightfield", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "GeoMipTerrain.setHeightfield", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_heightfield(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeoMipTerrain::set_heightfield(basic_string< char > const &path)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"path", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setHeightfield", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setHeightfield", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->set_heightfield(basic_string<char>(param1_str, param1_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeoMipTerrain::set_heightfield(PNMImage const &image)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"image", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHeightfield", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setHeightfield", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "GeoMipTerrain.setHeightfield", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_heightfield(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeightfield(non-const GeoMipTerrain this, const Filename filename)\n"
          "setHeightfield(non-const GeoMipTerrain this, string path)\n"
          "setHeightfield(non-const GeoMipTerrain this, const PNMImage image)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_heightfield_49_comment =
    "C++ Interface:\n"
    "setHeightfield(non-const GeoMipTerrain this, const Filename filename)\n"
    "setHeightfield(non-const GeoMipTerrain this, string path)\n"
    "setHeightfield(non-const GeoMipTerrain this, const PNMImage image)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_heightfield\n"
    "//       Access: Published\n"
    "//  Description: Loads the specified heightmap image file into\n"
    "//               the heightfield. Returns true if succeeded, or\n"
    "//               false if an error has occured.\n"
    "//               If the heightmap is not a power of two plus one,\n"
    "//               it is scaled up using a gaussian filter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_heightfield\n"
    "//       Access: Published\n"
    "//  Description: Loads the specified heightmap image file into\n"
    "//               the heightfield. Returns true if succeeded, or\n"
    "//               false if an error has occured.\n"
    "//               If the heightmap is not a power of two plus one,\n"
    "//               it is scaled up using a gaussian filter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_heightfield_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImage &GeoMipTerrain::color_map(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_color_map_50(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PNMImage &GeoMipTerrain::color_map(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":colorMap", key_word_list));
        else
            (PyArg_Parse(args, ":colorMap"));
        if(!PyErr_Occurred())
        {
            PNMImage *return_value = &((local_this)->color_map());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.colorMap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "colorMap(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_color_map_50_comment =
    "C++ Interface:\n"
    "colorMap(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::color_map\n"
    "//       Access: Published\n"
    "//  Description: Returns a reference to the color map (a PNMImage)\n"
    "//               contained inside GeoMipTerrain.  You can use\n"
    "//               the reference to alter the color map.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_color_map_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [inline bool GeoMipTerrain::set_color_map(Filename const &filename, PNMFileType *type)]
 * inline bool GeoMipTerrain::set_color_map(Filename const &filename, PNMFileType *type = ((void *)(0)))
 * inline bool GeoMipTerrain::set_color_map(PNMImage const &image)
 * inline bool GeoMipTerrain::set_color_map(Texture const *image)
 * inline bool GeoMipTerrain::set_color_map(basic_string< char > const &path)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_color_map_51(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeoMipTerrain::set_color_map(basic_string< char > const &path)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"path", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setColorMap", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setColorMap", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->set_color_map(basic_string<char>(param1_str, param1_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeoMipTerrain::set_color_map(Filename const &filename, PNMFileType *type = ((void *)(0)))
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColorMap", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColorMap", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "GeoMipTerrain.setColorMap", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_color_map(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeoMipTerrain::set_color_map(PNMImage const &image)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"image", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColorMap", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColorMap", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "GeoMipTerrain.setColorMap", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_color_map(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeoMipTerrain::set_color_map(Texture const *image)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"image", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColorMap", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColorMap", &param1));
            if(!PyErr_Occurred())
            {
                Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "GeoMipTerrain.setColorMap", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_color_map(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColorMap(non-const GeoMipTerrain this, string path)\n"
          "setColorMap(non-const GeoMipTerrain this, const Filename filename)\n"
          "setColorMap(non-const GeoMipTerrain this, const PNMImage image)\n"
          "setColorMap(non-const GeoMipTerrain this, const Texture image)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_color_map_51_comment =
    "C++ Interface:\n"
    "setColorMap(non-const GeoMipTerrain this, string path)\n"
    "setColorMap(non-const GeoMipTerrain this, const Filename filename)\n"
    "setColorMap(non-const GeoMipTerrain this, const PNMImage image)\n"
    "setColorMap(non-const GeoMipTerrain this, const Texture image)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_color_map\n"
    "//       Access: Published\n"
    "//  Description: Loads the specified image as color map. The next\n"
    "//               time generate() is called, the terrain is painted\n"
    "//               with this color map using the vertex color column.\n"
    "//               Returns a boolean indicating whether the operation\n"
    "//               has succeeded.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_color_map_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeoMipTerrain::has_color_map(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_has_color_map_52(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool GeoMipTerrain::has_color_map(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasColorMap", key_word_list));
        else
            (PyArg_Parse(args, ":hasColorMap"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->has_color_map();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.hasColorMap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasColorMap(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_has_color_map_52_comment =
    "C++ Interface:\n"
    "hasColorMap(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::has_color_map\n"
    "//       Access: Published\n"
    "//  Description: Returns whether a color map has been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_has_color_map_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::clear_color_map(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_clear_color_map_53(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::clear_color_map(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearColorMap", key_word_list));
        else
            (PyArg_Parse(args, ":clearColorMap"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_color_map();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.clearColorMap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearColorMap(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_clear_color_map_53_comment =
    "C++ Interface:\n"
    "clearColorMap(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::clear_color_map\n"
    "//       Access: Published\n"
    "//  Description: Clears the color map.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_clear_color_map_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double GeoMipTerrain::get_elevation(double x, double y)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_elevation_54(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-double GeoMipTerrain::get_elevation(double x, double y)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:getElevation", key_word_list, &param1, &param2))
        {
            double return_value = (local_this)->get_elevation((double)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getElevation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElevation(non-const GeoMipTerrain this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_elevation_54_comment =
    "C++ Interface:\n"
    "getElevation(non-const GeoMipTerrain this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_elevation\n"
    "//       Access: Published\n"
    "//  Description: Fetches the elevation at (x, y), where the input\n"
    "//               coordinate is specified in pixels. This ignores\n"
    "//               the current LOD level and instead provides an\n"
    "//               accurate number. Linear blending is used for \n"
    "//               non-integral coordinates.\n"
    "//               Terrain scale is NOT taken into account! To get\n"
    "//               accurate normals, please multiply this with the\n"
    "//               terrain Z scale!\n"
    "//\n"
    "//               trueElev = terr.get_elevation(x,y) * terr.get_sz();\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_elevation_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f GeoMipTerrain::get_normal(int x, int y)
 * inline LVector3f GeoMipTerrain::get_normal(unsigned short int mx, unsigned short int my, int x, int y)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_normal_55(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-LVector3f GeoMipTerrain::get_normal(int x, int y)
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getNormal", key_word_list, &param1, &param2))
            {
                LVector3f result = (local_this)->get_normal((int)param1, (int)param2);
                LVector3f *return_value = new LVector3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GeoMipTerrain.getNormal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline LVector3f GeoMipTerrain::get_normal(unsigned short int mx, unsigned short int my, int x, int y)
            PyObject *param1;
            PyObject *param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"mx", (char *)"my", (char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOii:getNormal", key_word_list, &param1, &param2, &param3, &param4))
            {
                 PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param1_uint == NULL)|| (param2_uint == NULL)))
                {
                    LVector3f result = (local_this)->get_normal(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), (int)param3, (int)param4);
                    LVector3f *return_value = new LVector3f(result);
                     Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GeoMipTerrain.getNormal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getNormal() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getNormal(non-const GeoMipTerrain this, int x, int y)\n"
          "getNormal(non-const GeoMipTerrain this, unsigned int mx, unsigned int my, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_normal_55_comment =
    "C++ Interface:\n"
    "getNormal(non-const GeoMipTerrain this, int x, int y)\n"
    "getNormal(non-const GeoMipTerrain this, unsigned int mx, unsigned int my, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_normal\n"
    "//       Access: Published\n"
    "//  Description: Fetches the terrain normal at (x,y), where the input\n"
    "//               coordinate is specified in pixels. This ignores the\n"
    "//               current LOD level and instead provides an\n"
    "//               accurate number.\n"
    "//               Terrain scale is NOT taken into account! To get\n"
    "//               accurate normals, please divide it by the\n"
    "//               terrain scale and normalize it again!\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_normal\n"
    "//       Access: Published\n"
    "//  Description: Fetches the terrain normal at (x, y), where the\n"
    "//               input coordinate is specified in pixels. This\n"
    "//               ignores the current LOD level and instead provides\n"
    "//               an accurate number.\n"
    "//               Terrain scale is NOT taken into account! To get\n"
    "//               accurate normals, please divide it by the\n"
    "//               terrain scale and normalize it again, like this:\n"
    "//\n"
    "//               LVector3f normal (terr.get_normal(x, y));\n"
    "//               normal.set(normal.get_x() / root.get_sx(),\n"
    "//                          normal.get_y() / root.get_sy(),\n"
    "//                          normal.get_z() / root.get_sz());\n"
    "//               normal.normalize();\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_normal_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_bruteforce(bool bf)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_bruteforce_56(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_bruteforce(bool bf)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"bf", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBruteforce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setBruteforce", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bruteforce((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setBruteforce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBruteforce(non-const GeoMipTerrain this, bool bf)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_bruteforce_56_comment =
    "C++ Interface:\n"
    "setBruteforce(non-const GeoMipTerrain this, bool bf)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_bruteforce\n"
    "//       Access: Published\n"
    "//  Description: Sets a boolean specifying whether the terrain will\n"
    "//               be rendered bruteforce. If the terrain is rendered\n"
    "//               bruteforce, there will be no Level of Detail, and\n"
    "//               the update() call will only update the\n"
    "//               terrain if it is marked dirty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_bruteforce_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeoMipTerrain::get_bruteforce(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_bruteforce_57(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool GeoMipTerrain::get_bruteforce(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBruteforce", key_word_list));
        else
            (PyArg_Parse(args, ":getBruteforce"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_bruteforce();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getBruteforce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBruteforce(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_bruteforce_57_comment =
    "C++ Interface:\n"
    "getBruteforce(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_bruteforce\n"
    "//       Access: Published\n"
    "//  Description: Returns a boolean whether the terrain is rendered\n"
    "//               bruteforce or not. See set_bruteforce for more\n"
    "//               information.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_bruteforce_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_auto_flatten(int mode)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_auto_flatten_59(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_auto_flatten(int mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAutoFlatten", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAutoFlatten", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_flatten((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setAutoFlatten() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoFlatten(non-const GeoMipTerrain this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_auto_flatten_59_comment =
    "C++ Interface:\n"
    "setAutoFlatten(non-const GeoMipTerrain this, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_auto_flatten\n"
    "//       Access: Private\n"
    "//  Description: The terrain can be automatically flattened (using\n"
    "//               flatten_light, flatten_medium, or flatten_strong)\n"
    "//               after each update.  This only affects future\n"
    "//               updates, it doesn't flatten the current terrain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_auto_flatten_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_focal_point(LPoint2d fp)
 * inline void GeoMipTerrain::set_focal_point(LPoint2f fp)
 * inline void GeoMipTerrain::set_focal_point(LPoint3d fp)
 * inline void GeoMipTerrain::set_focal_point(LPoint3f fp)
 * inline void GeoMipTerrain::set_focal_point(NodePath fnp)
 * inline void GeoMipTerrain::set_focal_point(double x, double y)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_focal_point_60(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void GeoMipTerrain::set_focal_point(NodePath fnp)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"fnp", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFocalPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFocalPoint", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "GeoMipTerrain.setFocalPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_focal_point(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void GeoMipTerrain::set_focal_point(LPoint2d fp)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"fp", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFocalPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFocalPoint", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2d *param1_this = (LPoint2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2d, 1, "GeoMipTerrain.setFocalPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_focal_point(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void GeoMipTerrain::set_focal_point(LPoint3f fp)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"fp", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFocalPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFocalPoint", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "GeoMipTerrain.setFocalPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_focal_point(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void GeoMipTerrain::set_focal_point(LPoint3d fp)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"fp", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFocalPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFocalPoint", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "GeoMipTerrain.setFocalPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_focal_point(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void GeoMipTerrain::set_focal_point(LPoint2f fp)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"fp", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFocalPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFocalPoint", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "GeoMipTerrain.setFocalPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_focal_point(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void GeoMipTerrain::set_focal_point(double x, double y)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setFocalPoint", key_word_list, &param1, &param2))
            {
                (local_this)->set_focal_point((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GeoMipTerrain.setFocalPoint() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFocalPoint() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFocalPoint(non-const GeoMipTerrain this, const NodePath fnp)\n"
          "setFocalPoint(non-const GeoMipTerrain this, const Point2D fp)\n"
          "setFocalPoint(non-const GeoMipTerrain this, const Point3 fp)\n"
          "setFocalPoint(non-const GeoMipTerrain this, const Point3D fp)\n"
          "setFocalPoint(non-const GeoMipTerrain this, const Point2 fp)\n"
          "setFocalPoint(non-const GeoMipTerrain this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_focal_point_60_comment =
    "C++ Interface:\n"
    "setFocalPoint(non-const GeoMipTerrain this, const NodePath fnp)\n"
    "setFocalPoint(non-const GeoMipTerrain this, const Point2D fp)\n"
    "setFocalPoint(non-const GeoMipTerrain this, const Point3 fp)\n"
    "setFocalPoint(non-const GeoMipTerrain this, const Point3D fp)\n"
    "setFocalPoint(non-const GeoMipTerrain this, const Point2 fp)\n"
    "setFocalPoint(non-const GeoMipTerrain this, float x, float y)\n"
    "\n"
    "// The focal point is the point at which the terrain will have the\n"
    "// highest quality (lowest level of detail). Parts farther away from\n"
    "// the focal point will have a lower quality (higher level of detail).\n"
    "// The focal point is not taken in respect if bruteforce is set true.\n"
    "\n"
    "// The focal point is the point at which the terrain will have the\n"
    "// highest quality (lowest level of detail). Parts farther away from\n"
    "// the focal point will have a lower quality (higher level of detail).\n"
    "// The focal point is not taken in respect if bruteforce is set true.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_focal_point\n"
    "//       Access: Published\n"
    "//  Description: Sets the focal point.  GeoMipTerrain generates\n"
    "//               high-resolution terrain around the focal point, and\n"
    "//               progressively lower and lower resolution terrain\n"
    "//               as you get farther away. If a point is supplied\n"
    "//               and not a NodePath, make sure it's relative to\n"
    "//               the terrain. Only the x and y coordinates of\n"
    "//               the focal point are taken in respect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_focal_point_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath GeoMipTerrain::get_focal_point(void) const
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_focal_point_61(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath GeoMipTerrain::get_focal_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocalPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getFocalPoint"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const GeoMipTerrain*)local_this)->get_focal_point();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocalPoint(const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_focal_point_61_comment =
    "C++ Interface:\n"
    "getFocalPoint(const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_focal_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the focal point, as a NodePath.\n"
    "//               If you have set it to be just a point, it will\n"
    "//               return an empty node at the focal position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_focal_point_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath GeoMipTerrain::get_root(void) const
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_root_62(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath GeoMipTerrain::get_root(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRoot", key_word_list));
        else
            (PyArg_Parse(args, ":getRoot"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const GeoMipTerrain*)local_this)->get_root();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRoot(const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_root_62_comment =
    "C++ Interface:\n"
    "getRoot(const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_root\n"
    "//       Access: Published\n"
    "//  Description: Returns the root of the terrain.  This is a\n"
    "//               single PandaNode to which all the rest of the\n"
    "//               terrain is parented.  The generate and update\n"
    "//               operations replace the nodes which are parented\n"
    "//               to this root, but they don't replace this root\n"
    "//               itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_root_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_block_size(unsigned short int newbs)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_block_size_63(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_block_size(unsigned short int newbs)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"newbs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBlockSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setBlockSize", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_block_size(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setBlockSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlockSize(non-const GeoMipTerrain this, unsigned int newbs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_block_size_63_comment =
    "C++ Interface:\n"
    "setBlockSize(non-const GeoMipTerrain this, unsigned int newbs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_block_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the block size. If it is not a power of two,\n"
    "//               the closest power of two is used.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_block_size_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int GeoMipTerrain::get_block_size(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_block_size_64(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int GeoMipTerrain::get_block_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlockSize", key_word_list));
        else
            (PyArg_Parse(args, ":getBlockSize"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_block_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getBlockSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockSize(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_block_size_64_comment =
    "C++ Interface:\n"
    "getBlockSize(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_block_size\n"
    "//       Access: Published\n"
    "//  Description: Gets the block size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_block_size_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int GeoMipTerrain::get_max_level(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_max_level_65(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int GeoMipTerrain::get_max_level(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxLevel", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxLevel"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_max_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getMaxLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxLevel(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_max_level_65_comment =
    "C++ Interface:\n"
    "getMaxLevel(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_max_level\n"
    "//       Access: Published\n"
    "//  Description: Returns the highest level possible for this block\n"
    "//               size. When a block is at this level, it will be\n"
    "//               the worst quality possible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_max_level_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_min_level(unsigned short int minlevel)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_min_level_66(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_min_level(unsigned short int minlevel)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"minlevel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMinLevel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setMinLevel", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_min_level(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setMinLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinLevel(non-const GeoMipTerrain this, unsigned int minlevel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_min_level_66_comment =
    "C++ Interface:\n"
    "setMinLevel(non-const GeoMipTerrain this, unsigned int minlevel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_min_level\n"
    "//       Access: Published\n"
    "//  Description: Sets the minimum level of detail at which blocks\n"
    "//               may be generated by generate() or update().\n"
    "//               The default value is 0, which is the highest\n"
    "//               quality. This value is also taken in respect when\n"
    "//               generating the terrain bruteforce.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_min_level_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int GeoMipTerrain::get_min_level(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_min_level_67(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int GeoMipTerrain::get_min_level(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinLevel", key_word_list));
        else
            (PyArg_Parse(args, ":getMinLevel"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_min_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getMinLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinLevel(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_min_level_67_comment =
    "C++ Interface:\n"
    "getMinLevel(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_min_level\n"
    "//       Access: Published\n"
    "//  Description: Gets the minimum level of detail at which blocks\n"
    "//               may be generated by generate() or update().\n"
    "//               The default value is 0, which is the highest\n"
    "//               quality.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_min_level_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeoMipTerrain::is_dirty(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_is_dirty_68(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool GeoMipTerrain::is_dirty(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDirty", key_word_list));
        else
            (PyArg_Parse(args, ":isDirty"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_dirty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.isDirty() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDirty(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_is_dirty_68_comment =
    "C++ Interface:\n"
    "isDirty(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::is_dirty\n"
    "//       Access: Published\n"
    "//  Description: Returns a bool indicating whether the terrain is\n"
    "//               marked 'dirty', that means the terrain has to be\n"
    "//               regenerated on the next update() call, because\n"
    "//               for instance the heightfield has changed.\n"
    "//               Once the terrain has been regenerated, the dirty\n"
    "//               flag automatically gets reset internally.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_is_dirty_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_factor(float factor)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_factor_69(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_factor(float factor)
        double param1;
        static char * key_word_list[] = {(char *)"factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFactor(non-const GeoMipTerrain this, float factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_factor_69_comment =
    "C++ Interface:\n"
    "setFactor(non-const GeoMipTerrain this, float factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_factor\n"
    "//       Access: Published\n"
    "//  Description: DEPRECATED method. Use set_near/far instead.\n"
    "//               Sets the quality factor at which blocks must be\n"
    "//               generated. The higher this level, the better\n"
    "//               quality the terrain will be, but more expensive\n"
    "//               to render. A value of 0 makes the terrain the\n"
    "//               lowest quality possible, depending on blocksize.\n"
    "//               The default value is 100.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_factor_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_near_far(double input_near, double input_far)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_near_far_70(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_near_far(double input_near, double input_far)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"input_near", (char *)"input_far", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setNearFar", key_word_list, &param1, &param2))
        {
            (local_this)->set_near_far((double)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setNearFar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNearFar(non-const GeoMipTerrain this, float input_near, float input_far)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_near_far_70_comment =
    "C++ Interface:\n"
    "setNearFar(non-const GeoMipTerrain this, float input_near, float input_far)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_near_far\n"
    "//       Access: Published\n"
    "//  Description: Sets the near and far LOD distances in one call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_near_far_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_near(double input_near)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_near_71(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_near(double input_near)
        double param1;
        static char * key_word_list[] = {(char *)"input_near", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setNear", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setNear", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_near((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setNear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNear(non-const GeoMipTerrain this, float input_near)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_near_71_comment =
    "C++ Interface:\n"
    "setNear(non-const GeoMipTerrain this, float input_near)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_near\n"
    "//       Access: Published\n"
    "//  Description: Sets the near LOD distance, at which the terrain\n"
    "//               will be rendered at highest quality.\n"
    "//               This distance is in the terrain's coordinate space!\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_near_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_far(double input_far)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_far_72(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_far(double input_far)
        double param1;
        static char * key_word_list[] = {(char *)"input_far", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFar", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFar", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_far((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setFar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFar(non-const GeoMipTerrain this, float input_far)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_far_72_comment =
    "C++ Interface:\n"
    "setFar(non-const GeoMipTerrain this, float input_far)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_far\n"
    "//       Access: Published\n"
    "//  Description: Sets the far LOD distance, at which the terrain\n"
    "//               will be rendered at lowest quality.\n"
    "//               This distance is in the terrain's coordinate space!\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_far_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const GeoMipTerrain::get_block_node_path(unsigned short int mx, unsigned short int my)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_block_node_path_73(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline NodePath const GeoMipTerrain::get_block_node_path(unsigned short int mx, unsigned short int my)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"mx", (char *)"my", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getBlockNodePath", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                NodePath const result = (local_this)->get_block_node_path(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                NodePath const *return_value = new NodePath const(result);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, true);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getBlockNodePath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockNodePath(non-const GeoMipTerrain this, unsigned int mx, unsigned int my)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_block_node_path_73_comment =
    "C++ Interface:\n"
    "getBlockNodePath(non-const GeoMipTerrain this, unsigned int mx, unsigned int my)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_block_node_path\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath of the specified block.\n"
    "//               If auto-flatten is enabled and the node is\n"
    "//               getting removed during the flattening process,\n"
    "//               it will still return a NodePath with the\n"
    "//               appropriate terrain chunk, but it will be in\n"
    "//               a temporary scenegraph.\n"
    "//               Please note that this returns a const object and\n"
    "//               you can not modify the node. Modify the heightfield\n"
    "//               instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_block_node_path_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f GeoMipTerrain::get_block_from_pos(double x, double y)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_block_from_pos_74(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline LVecBase2f GeoMipTerrain::get_block_from_pos(double x, double y)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:getBlockFromPos", key_word_list, &param1, &param2))
        {
            LVecBase2f result = (local_this)->get_block_from_pos((double)param1, (double)param2);
            LVecBase2f *return_value = new LVecBase2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getBlockFromPos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockFromPos(non-const GeoMipTerrain this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_block_from_pos_74_comment =
    "C++ Interface:\n"
    "getBlockFromPos(non-const GeoMipTerrain this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_block_from_pos\n"
    "//       Access: Published\n"
    "//  Description: Gets the coordinates of the block at the specified\n"
    "//               position. This position must be relative to the\n"
    "//               terrain, not to render. Returns an array containing\n"
    "//               two values: the block x and the block y coords.\n"
    "//               If the positions are out of range, the closest\n"
    "//               block is taken.\n"
    "//               Note that the VecBase returned does not represent\n"
    "//               a vector, position, or rotation, but it contains\n"
    "//               the block index of the block which you can use\n"
    "//               in GeoMipTerrain::get_block_node_path.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_block_from_pos_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeoMipTerrain::set_border_stitching(bool stitching)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_set_border_stitching_75(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeoMipTerrain::set_border_stitching(bool stitching)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"stitching", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBorderStitching", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setBorderStitching", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_border_stitching((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.setBorderStitching() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBorderStitching(non-const GeoMipTerrain this, bool stitching)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_set_border_stitching_75_comment =
    "C++ Interface:\n"
    "setBorderStitching(non-const GeoMipTerrain this, bool stitching)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::set_border_stitching\n"
    "//       Access: Published\n"
    "//  Description: If this value is true, the LOD level at the\n"
    "//               borders of the terrain will be 0. This is useful\n"
    "//               if you have multiple terrains attached and you\n"
    "//               want to stitch them together, to fix seams.\n"
    "//               This setting also has effect when bruteforce is\n"
    "//               enabled, although in that case you are probably\n"
    "//               better off with setting the minlevels to the same\n"
    "//               value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_set_border_stitching_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeoMipTerrain::get_border_stitching(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_border_stitching_76(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool GeoMipTerrain::get_border_stitching(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBorderStitching", key_word_list));
        else
            (PyArg_Parse(args, ":getBorderStitching"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_border_stitching();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.getBorderStitching() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBorderStitching(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_border_stitching_76_comment =
    "C++ Interface:\n"
    "getBorderStitching(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::get_stitching\n"
    "//       Access: Published\n"
    "//  Description: Returns the current stitching setting. False by\n"
    "//               default, unless set_stitching has been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_border_stitching_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMImage GeoMipTerrain::make_slope_image(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_make_slope_image_77(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PNMImage GeoMipTerrain::make_slope_image(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeSlopeImage", key_word_list));
        else
            (PyArg_Parse(args, ":makeSlopeImage"));
        if(!PyErr_Occurred())
        {
            PNMImage result = (local_this)->make_slope_image();
            PNMImage *return_value = new PNMImage(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.makeSlopeImage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeSlopeImage(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_make_slope_image_77_comment =
    "C++ Interface:\n"
    "makeSlopeImage(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::make_slope_image\n"
    "//       Access: Published\n"
    "//  Description: Returns a new grayscale image containing the slope\n"
    "//               angles. A white pixel value means a vertical slope,\n"
    "//               while a black pixel will mean that the terrain is\n"
    "//               entirely flat at that pixel.\n"
    "//               You can translate it to degrees by mapping the\n"
    "//               greyscale values from 0 to 90 degrees.\n"
    "//               The resulting image will have the same size as the\n"
    "//               heightfield image.\n"
    "//               The scale will be taken into respect -- meaning,\n"
    "//               if you change the terrain scale, the slope image\n"
    "//               will need to be regenerated in order to be correct.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_make_slope_image_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GeoMipTerrain::generate(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_generate_78(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void GeoMipTerrain::generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":generate", key_word_list));
        else
            (PyArg_Parse(args, ":generate"));
        if(!PyErr_Occurred())
        {
            (local_this)->generate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.generate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_generate_78_comment =
    "C++ Interface:\n"
    "generate(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::generate\n"
    "//       Access: Published\n"
    "//  Description: (Re)generates the entire terrain, erasing the\n"
    "//               current.\n"
    "//               This call un-flattens the terrain, so make sure\n"
    "//               you have set auto-flatten if you want to keep\n"
    "//               your terrain flattened.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_generate_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GeoMipTerrain::update(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_update_79(PyObject *self, PyObject *args,PyObject *kwds) {
    GeoMipTerrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeoMipTerrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool GeoMipTerrain::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeoMipTerrain.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const GeoMipTerrain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_update_79_comment =
    "C++ Interface:\n"
    "update(non-const GeoMipTerrain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeoMipTerrain::update\n"
    "//       Access: Published\n"
    "//  Description: Loops through all of the terrain blocks, and\n"
    "//               checks whether they need to be updated.\n"
    "//               If that is indeed the case, it regenerates the\n"
    "//               mipmap. Returns a true when the terrain has\n"
    "//               changed. Returns false when the terrain isn't\n"
    "//               updated at all. If there is no terrain yet,\n"
    "//               it generates the entire terrain.\n"
    "//               This call un-flattens the terrain, so make sure\n"
    "//               you have set auto-flatten if you want to keep\n"
    "//               your terrain flattened.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_update_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GeoMipTerrain::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GeoMipTerrain_get_class_type_80(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GeoMipTerrain::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GeoMipTerrain::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeoMipTerrain_get_class_type_80_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GeoMipTerrain_get_class_type_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GeoMipTerrain::GeoMipTerrain(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_GeoMipTerrain(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline GeoMipTerrain::GeoMipTerrain(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GeoMipTerrain", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:GeoMipTerrain", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            GeoMipTerrain *return_value = new GeoMipTerrain(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_GeoMipTerrain,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GeoMipTerrain(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_GeoMipTerrain(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GeoMipTerrain)
    {
        printf("GeoMipTerrain ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GeoMipTerrain * local_this = (GeoMipTerrain *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GeoMipTerrain)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GeoMipTerrain(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GeoMipTerrain)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GeoMipTerrain*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HeightfieldTesselator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PNMImage &HeightfieldTesselator::heightfield(void)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_heightfield_84(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PNMImage &HeightfieldTesselator::heightfield(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":heightfield", key_word_list));
        else
            (PyArg_Parse(args, ":heightfield"));
        if(!PyErr_Occurred())
        {
            PNMImage *return_value = &((local_this)->heightfield());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.heightfield() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "heightfield(non-const HeightfieldTesselator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_heightfield_84_comment =
    "C++ Interface:\n"
    "heightfield(non-const HeightfieldTesselator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::heightfield\n"
    "//       Access: Published\n"
    "//  Description: Returns a reference to the heightfield (a PNMImage)\n"
    "//               contained inside the HeightfieldTesselator.  You\n"
    "//               can use the reference to alter the heightfield.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_heightfield_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [inline bool HeightfieldTesselator::set_heightfield(Filename const &filename, PNMFileType *type)]
 * inline bool HeightfieldTesselator::set_heightfield(Filename const &filename, PNMFileType *type = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_heightfield_85(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool HeightfieldTesselator::set_heightfield(Filename const &filename, PNMFileType *type = ((void *)(0)))
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHeightfield", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setHeightfield", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "HeightfieldTesselator.setHeightfield", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->set_heightfield(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HeightfieldTesselator.setHeightfield() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeightfield(non-const HeightfieldTesselator this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_heightfield_85_comment =
    "C++ Interface:\n"
    "setHeightfield(non-const HeightfieldTesselator this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_heightfield\n"
    "//       Access: Published\n"
    "//  Description: Loads the specified greyscale image file into\n"
    "//               the heightfield.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_heightfield_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HeightfieldTesselator::set_poly_count(int n)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_poly_count_86(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HeightfieldTesselator::set_poly_count(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPolyCount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPolyCount", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_poly_count((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.setPolyCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPolyCount(non-const HeightfieldTesselator this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_poly_count_86_comment =
    "C++ Interface:\n"
    "setPolyCount(non-const HeightfieldTesselator this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_poly_count\n"
    "//       Access: Public\n"
    "//  Description: Sets the polygon-count target.  The tesselator\n"
    "//               usually manages to come within about 20% of the\n"
    "//               target, plus or minus.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_poly_count_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HeightfieldTesselator::set_visibility_radius(int r)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_visibility_radius_87(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HeightfieldTesselator::set_visibility_radius(int r)
        int param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setVisibilityRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setVisibilityRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_visibility_radius((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.setVisibilityRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVisibilityRadius(non-const HeightfieldTesselator this, int r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_visibility_radius_87_comment =
    "C++ Interface:\n"
    "setVisibilityRadius(non-const HeightfieldTesselator this, int r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_visibility_radius\n"
    "//       Access: Published\n"
    "//  Description: Sets the visibility radius.  Polygons that\n"
    "//               are completely outside the radius (relative to\n"
    "//               the focal point) are cropped away.  The cropping\n"
    "//               is imperfect (all approximations are conservative),\n"
    "//               so this should be used in conjunction with a far\n"
    "//               clipping plane, fog, or some other visibility\n"
    "//               limiting mechanism.  The units are in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_visibility_radius_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HeightfieldTesselator::set_focal_point(int x, int y)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_focal_point_88(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HeightfieldTesselator::set_focal_point(int x, int y)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setFocalPoint", key_word_list, &param1, &param2))
        {
            (local_this)->set_focal_point((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.setFocalPoint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFocalPoint(non-const HeightfieldTesselator this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_focal_point_88_comment =
    "C++ Interface:\n"
    "setFocalPoint(non-const HeightfieldTesselator this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_focal_point\n"
    "//       Access: Published\n"
    "//  Description: Sets the focal point.  The tesselator generates\n"
    "//               high-resolution terrain around the focal point, and\n"
    "//               progressively lower and lower resolution terrain\n"
    "//               as you get farther away.  The units are in pixels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_focal_point_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HeightfieldTesselator::set_horizontal_scale(double h)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_horizontal_scale_89(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HeightfieldTesselator::set_horizontal_scale(double h)
        double param1;
        static char * key_word_list[] = {(char *)"h", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHorizontalScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHorizontalScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_horizontal_scale((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.setHorizontalScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHorizontalScale(non-const HeightfieldTesselator this, float h)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment =
    "C++ Interface:\n"
    "setHorizontalScale(non-const HeightfieldTesselator this, float h)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_horizontal_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets the horizontal scale.  The default scale is 1.0,\n"
    "//               meaning that each pixel in the heightfield is\n"
    "//               1x1 panda units wide.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HeightfieldTesselator::set_vertical_scale(double v)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_vertical_scale_90(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HeightfieldTesselator::set_vertical_scale(double v)
        double param1;
        static char * key_word_list[] = {(char *)"v", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVerticalScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVerticalScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_vertical_scale((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.setVerticalScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerticalScale(non-const HeightfieldTesselator this, float v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_vertical_scale_90_comment =
    "C++ Interface:\n"
    "setVerticalScale(non-const HeightfieldTesselator this, float v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_vertical_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets the vertical scale.  The default scale is 255.0,\n"
    "//               meaning that each as the gray value ranges from (0-1),\n"
    "//               the elevation ranges from (0-255) feet.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_vertical_scale_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HeightfieldTesselator::set_max_triangles(int n)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_set_max_triangles_91(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HeightfieldTesselator::set_max_triangles(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxTriangles", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxTriangles", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_triangles((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.setMaxTriangles() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxTriangles(non-const HeightfieldTesselator this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_set_max_triangles_91_comment =
    "C++ Interface:\n"
    "setMaxTriangles(non-const HeightfieldTesselator this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::set_max_triangles\n"
    "//       Access: Published\n"
    "//  Description: Sets the max triangles per geom.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_set_max_triangles_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double HeightfieldTesselator::get_elevation(double x, double y)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_get_elevation_92(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-double HeightfieldTesselator::get_elevation(double x, double y)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:getElevation", key_word_list, &param1, &param2))
        {
            double return_value = (local_this)->get_elevation((double)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.getElevation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElevation(non-const HeightfieldTesselator this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_get_elevation_92_comment =
    "C++ Interface:\n"
    "getElevation(non-const HeightfieldTesselator this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::get_elevation\n"
    "//       Access: Private\n"
    "//  Description: Fetches the elevation at (x,y), where the input\n"
    "//               coordinate is specified in pixels.  This ignores the\n"
    "//               current tesselation level and instead provides an\n"
    "//               accurate number.  Linear blending is used for \n"
    "//               non-integral coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_get_elevation_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath HeightfieldTesselator::generate(void)
 *******************************************************************/
static PyObject *Dtool_HeightfieldTesselator_generate_93(PyObject *self, PyObject *args,PyObject *kwds) {
    HeightfieldTesselator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HeightfieldTesselator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePath HeightfieldTesselator::generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":generate", key_word_list));
        else
            (PyArg_Parse(args, ":generate"));
        if(!PyErr_Occurred())
        {
            NodePath result = (local_this)->generate();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HeightfieldTesselator.generate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const HeightfieldTesselator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HeightfieldTesselator_generate_93_comment =
    "C++ Interface:\n"
    "generate(non-const HeightfieldTesselator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HeightfieldTesselator::generate\n"
    "//       Access: Published\n"
    "//  Description: Generates a tree of nodes that represents the\n"
    "//               heightfield.  This can be reparented into the scene.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HeightfieldTesselator_generate_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HeightfieldTesselator::HeightfieldTesselator(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_HeightfieldTesselator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline HeightfieldTesselator::HeightfieldTesselator(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:HeightfieldTesselator", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:HeightfieldTesselator", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            HeightfieldTesselator *return_value = new HeightfieldTesselator(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_HeightfieldTesselator,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "HeightfieldTesselator(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HeightfieldTesselator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HeightfieldTesselator)
    {
        printf("HeightfieldTesselator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HeightfieldTesselator * local_this = (HeightfieldTesselator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HeightfieldTesselator)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HeightfieldTesselator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HeightfieldTesselator)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (HeightfieldTesselator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SceneGraphAnalyzerMeter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void SceneGraphAnalyzerMeter::setup_window(GraphicsOutput *window)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_setup_window_96(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SceneGraphAnalyzerMeter::setup_window(GraphicsOutput *window)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"window", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setupWindow", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setupWindow", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "SceneGraphAnalyzerMeter.setupWindow", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->setup_window(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SceneGraphAnalyzerMeter.setupWindow() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupWindow(non-const SceneGraphAnalyzerMeter this, non-const GraphicsOutput window)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_setup_window_96_comment =
    "C++ Interface:\n"
    "setupWindow(non-const SceneGraphAnalyzerMeter this, non-const GraphicsOutput window)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::setup_window\n"
    "//       Access: Published\n"
    "//  Description: Sets up the frame rate meter to create a\n"
    "//               DisplayRegion to render itself into the indicated\n"
    "//               window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_setup_window_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SceneGraphAnalyzerMeter::clear_window(void)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_clear_window_97(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void SceneGraphAnalyzerMeter::clear_window(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearWindow", key_word_list));
        else
            (PyArg_Parse(args, ":clearWindow"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_window();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SceneGraphAnalyzerMeter.clearWindow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearWindow(non-const SceneGraphAnalyzerMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_clear_window_97_comment =
    "C++ Interface:\n"
    "clearWindow(non-const SceneGraphAnalyzerMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::clear_window\n"
    "//       Access: Published\n"
    "//  Description: Undoes the effect of a previous call to\n"
    "//               setup_window().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_clear_window_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput *SceneGraphAnalyzerMeter::get_window(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_window_98(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsOutput *SceneGraphAnalyzerMeter::get_window(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindow", key_word_list));
        else
            (PyArg_Parse(args, ":getWindow"));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = ((const SceneGraphAnalyzerMeter*)local_this)->get_window();
            if (return_value != (GraphicsOutput *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindow(const SceneGraphAnalyzerMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_get_window_98_comment =
    "C++ Interface:\n"
    "getWindow(const SceneGraphAnalyzerMeter this)\n"
    "\n"
    "// Filename: sceneGraphAnalyzerMeter.I\n"
    "// Created by:  pratt (14Feb07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::get_window\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsOutput that was passed to\n"
    "//               setup_window(), or NULL if setup_window() has not\n"
    "//               been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_get_window_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *SceneGraphAnalyzerMeter::get_display_region(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_display_region_99(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DisplayRegion *SceneGraphAnalyzerMeter::get_display_region(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayRegion", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayRegion"));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = ((const SceneGraphAnalyzerMeter*)local_this)->get_display_region();
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayRegion(const SceneGraphAnalyzerMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_get_display_region_99_comment =
    "C++ Interface:\n"
    "getDisplayRegion(const SceneGraphAnalyzerMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::get_display_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the DisplayRegion that the meter has created\n"
    "//               to render itself into the window to setup_window(),\n"
    "//               or NULL if setup_window() has not been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_get_display_region_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SceneGraphAnalyzerMeter::set_update_interval(double update_interval)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_set_update_interval_100(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SceneGraphAnalyzerMeter::set_update_interval(double update_interval)
        double param1;
        static char * key_word_list[] = {(char *)"update_interval", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setUpdateInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setUpdateInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_update_interval((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SceneGraphAnalyzerMeter.setUpdateInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUpdateInterval(non-const SceneGraphAnalyzerMeter this, float update_interval)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_set_update_interval_100_comment =
    "C++ Interface:\n"
    "setUpdateInterval(non-const SceneGraphAnalyzerMeter this, float update_interval)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::set_update_interval\n"
    "//       Access: Published\n"
    "//  Description: Specifies the number of seconds that should elapse\n"
    "//               between updates to the meter.  This should be\n"
    "//               reasonably slow (e.g. 0.5 to 2.0) so that the\n"
    "//               calculation of the scene graph analysis does not\n"
    "//               itself dominate the frame rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_set_update_interval_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SceneGraphAnalyzerMeter::get_update_interval(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_update_interval_101(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SceneGraphAnalyzerMeter::get_update_interval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUpdateInterval", key_word_list));
        else
            (PyArg_Parse(args, ":getUpdateInterval"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SceneGraphAnalyzerMeter*)local_this)->get_update_interval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUpdateInterval(const SceneGraphAnalyzerMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_get_update_interval_101_comment =
    "C++ Interface:\n"
    "getUpdateInterval(const SceneGraphAnalyzerMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::get_update_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of seconds that will elapse\n"
    "//               between updates to the frame rate indication.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_get_update_interval_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SceneGraphAnalyzerMeter::set_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_set_node_102(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SceneGraphAnalyzerMeter::set_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "SceneGraphAnalyzerMeter.setNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SceneGraphAnalyzerMeter.setNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNode(non-const SceneGraphAnalyzerMeter this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_set_node_102_comment =
    "C++ Interface:\n"
    "setNode(non-const SceneGraphAnalyzerMeter this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::set_node\n"
    "//       Access: Published\n"
    "//  Description: Sets the node to be analyzed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_set_node_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *SceneGraphAnalyzerMeter::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_node_103(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *SceneGraphAnalyzerMeter::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const SceneGraphAnalyzerMeter*)local_this)->get_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const SceneGraphAnalyzerMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_get_node_103_comment =
    "C++ Interface:\n"
    "getNode(const SceneGraphAnalyzerMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the node to be analyzed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_get_node_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SceneGraphAnalyzerMeter::update(void)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_update_104(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzerMeter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzerMeter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SceneGraphAnalyzerMeter::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SceneGraphAnalyzerMeter.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const SceneGraphAnalyzerMeter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_update_104_comment =
    "C++ Interface:\n"
    "update(non-const SceneGraphAnalyzerMeter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzerMeter::update\n"
    "//       Access: Published\n"
    "//  Description: You can call this to explicitly force the\n"
    "//               SceneGraphAnalyzerMeter to update itself with the\n"
    "//               latest scene graph analysis information.\n"
    "//               Normally, it is not necessary to call this explicitly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_update_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SceneGraphAnalyzerMeter::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzerMeter_get_class_type_105(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SceneGraphAnalyzerMeter::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SceneGraphAnalyzerMeter::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzerMeter_get_class_type_105_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzerMeter_get_class_type_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(basic_string< char > const &name, PandaNode *node)
 *******************************************************************/
int  Dtool_Init_SceneGraphAnalyzerMeter(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(basic_string< char > const &name, PandaNode *node)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:SceneGraphAnalyzerMeter", key_word_list, &param0_str, &param0_len, &param1))
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "SceneGraphAnalyzerMeter.SceneGraphAnalyzerMeter", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    SceneGraphAnalyzerMeter *return_value = new SceneGraphAnalyzerMeter(basic_string<char>(param0_str, param0_len), param1_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_SceneGraphAnalyzerMeter,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SceneGraphAnalyzerMeter(string name, non-const PandaNode node)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SceneGraphAnalyzerMeter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SceneGraphAnalyzerMeter)
    {
        printf("SceneGraphAnalyzerMeter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SceneGraphAnalyzerMeter * local_this = (SceneGraphAnalyzerMeter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SceneGraphAnalyzerMeter)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_TextEncoder)
        return ( TextEncoder *)( TextNode *) local_this;
    if(requested_type == &Dtool_TextNode)
        return ( TextNode *) local_this;
    if(requested_type == &Dtool_TextProperties)
        return ( TextProperties *)( TextNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( TextNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( TextNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SceneGraphAnalyzerMeter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SceneGraphAnalyzerMeter)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    if(from_type == &Dtool_TextEncoder)
    {
          TextEncoder* other_this = (TextEncoder*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    if(from_type == &Dtool_TextNode)
    {
          TextNode* other_this = (TextNode*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    if(from_type == &Dtool_TextProperties)
    {
          TextProperties* other_this = (TextProperties*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (SceneGraphAnalyzerMeter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MeshDrawer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer::set_budget(int budget)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_set_budget_108(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MeshDrawer::set_budget(int budget)
        int param1;
        static char * key_word_list[] = {(char *)"budget", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBudget", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBudget", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_budget((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer.setBudget() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBudget(non-const MeshDrawer this, int budget)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_set_budget_108_comment =
    "C++ Interface:\n"
    "setBudget(non-const MeshDrawer this, int budget)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::set_budget\n"
    "//       Access: Published\n"
    "//  Description: Sets the total triangle budget of the drawer.\n"
    "//               This will not be exceeded.  Don't set some thing too \n"
    "//               large because it will be slow\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_set_budget_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MeshDrawer::get_budget(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_get_budget_109(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int MeshDrawer::get_budget(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBudget", key_word_list));
        else
            (PyArg_Parse(args, ":getBudget"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_budget();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer.getBudget() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBudget(non-const MeshDrawer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_get_budget_109_comment =
    "C++ Interface:\n"
    "getBudget(non-const MeshDrawer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::get_budget()\n"
    "//       Access: Published\n"
    "//  Description: Gets the total triangle budget of the drawer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_get_budget_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath MeshDrawer::get_root(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_get_root_110(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline NodePath MeshDrawer::get_root(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRoot", key_word_list));
        else
            (PyArg_Parse(args, ":getRoot"));
        if(!PyErr_Occurred())
        {
            NodePath result = (local_this)->get_root();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer.getRoot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRoot(non-const MeshDrawer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_get_root_110_comment =
    "C++ Interface:\n"
    "getRoot(non-const MeshDrawer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::get_root\n"
    "//       Access: Published\n"
    "//  Description: Returns the root NodePath.  You should use this node\n"
    "//               to reparent mesh drawer onto the scene\n"
    "//               might also want to disable depth draw or enable\n"
    "//               transparency.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_get_root_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::begin(NodePath camera, NodePath render)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_begin_111(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::begin(NodePath camera, NodePath render)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"camera", (char *)"render", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:begin", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "MeshDrawer.begin", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "MeshDrawer.begin", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->begin(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.begin() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "begin(non-const MeshDrawer this, const NodePath camera, const NodePath render)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_begin_111_comment =
    "C++ Interface:\n"
    "begin(non-const MeshDrawer this, const NodePath camera, const NodePath render)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::begin\n"
    "//       Access: Published\n"
    "//  Description: Pass the current camera node and the root node.\n"
    "//               Passing the camera is required to generate\n"
    "//               bill boards that face it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_begin_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer::tri(LVector3f v1, LVector4f c1, LVector2f uv1, LVector3f v2, LVector4f c2, LVector2f uv2, LVector3f v3, LVector4f c3, LVector2f uv3)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_tri_112(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MeshDrawer::tri(LVector3f v1, LVector4f c1, LVector2f uv1, LVector3f v2, LVector4f c2, LVector2f uv2, LVector3f v3, LVector4f c3, LVector2f uv3)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            PyObject *param5;
            PyObject *param6;
            PyObject *param7;
            PyObject *param8;
            PyObject *param9;
            static char * key_word_list[] = {(char *)"v1", (char *)"c1", (char *)"uv1", (char *)"v2", (char *)"c2", (char *)"uv2", (char *)"v3", (char *)"c3", (char *)"uv3", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOOOO:tri", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector2f *param3_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector2f, 3, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector3f *param4_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector3f, 4, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector2f *param6_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVector2f, 6, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector3f *param7_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LVector3f, 7, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector4f *param8_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param8, &Dtool_LVector4f, 8, "MeshDrawer.tri", 1, coerced_ptr, report_errors);
LVector2f *param9_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_LVector2f, 9, "MeshDrawer.tri", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)|| (param7_this == NULL)|| (param8_this == NULL)|| (param9_this == NULL)))
                {
                    (local_this)->tri(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this, *param8_this, *param9_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.tri() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tri(non-const MeshDrawer this, const Vec3 v1, const Vec4 c1, const Vec2 uv1, const Vec3 v2, const Vec4 c2, const Vec2 uv2, const Vec3 v3, const Vec4 c3, const Vec2 uv3)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_tri_112_comment =
    "C++ Interface:\n"
    "tri(non-const MeshDrawer this, const Vec3 v1, const Vec4 c1, const Vec2 uv1, const Vec3 v2, const Vec4 c2, const Vec2 uv2, const Vec3 v3, const Vec4 c3, const Vec2 uv3)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::tri\n"
    "//       Access: Published\n"
    "//  Description: Draws a triangle with the given parameters.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_tri_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::particle(LVector3f pos, LVector4f frame, float size, LVector4f color, float rotation)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_particle_113(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::particle(LVector3f pos, LVector4f frame, float size, LVector4f color, float rotation)
            PyObject *param1;
            PyObject *param2;
            double param3;
            PyObject *param4;
            double param5;
            static char * key_word_list[] = {(char *)"pos", (char *)"frame", (char *)"size", (char *)"color", (char *)"rotation", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOdOd:particle", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.particle", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.particle", 1, coerced_ptr, report_errors);
LVector4f *param4_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector4f, 4, "MeshDrawer.particle", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)))
                {
                    (local_this)->particle(*param1_this, *param2_this, (float)param3, *param4_this, (float)param5);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.particle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "particle(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float size, const Vec4 color, float rotation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_particle_113_comment =
    "C++ Interface:\n"
    "particle(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float size, const Vec4 color, float rotation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::particle\n"
    "//       Access: Published\n"
    "//  Description: Draws a particle that is sort of like a bill board\n"
    "//               but has an extra rotation component.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_particle_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::blended_particle(LVector3f pos, LVector4f frame1, LVector4f frame2, float blend, float size, LVector4f color, float rotation)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_blended_particle_114(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::blended_particle(LVector3f pos, LVector4f frame1, LVector4f frame2, float blend, float size, LVector4f color, float rotation)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            double param4;
            double param5;
            PyObject *param6;
            double param7;
            static char * key_word_list[] = {(char *)"pos", (char *)"frame1", (char *)"frame2", (char *)"blend", (char *)"size", (char *)"color", (char *)"rotation", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOddOd:blendedParticle", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.blendedParticle", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.blendedParticle", 1, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "MeshDrawer.blendedParticle", 1, coerced_ptr, report_errors);
LVector4f *param6_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVector4f, 6, "MeshDrawer.blendedParticle", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param6_this == NULL)))
                {
                    (local_this)->blended_particle(*param1_this, *param2_this, *param3_this, (float)param4, (float)param5, *param6_this, (float)param7);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.blendedParticle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "blendedParticle(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame1, const Vec4 frame2, float blend, float size, const Vec4 color, float rotation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_blended_particle_114_comment =
    "C++ Interface:\n"
    "blendedParticle(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame1, const Vec4 frame2, float blend, float size, const Vec4 color, float rotation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::blended_particle\n"
    "//       Access: Published\n"
    "//  Description: Works just like particle but accepts 2 frames and\n"
    "//               a blend (from 0 to 1) component between them\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_blended_particle_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::billboard(LVector3f pos, LVector4f frame, float size, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_billboard_115(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::billboard(LVector3f pos, LVector4f frame, float size, LVector4f color)
            PyObject *param1;
            PyObject *param2;
            double param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"pos", (char *)"frame", (char *)"size", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOdO:billboard", key_word_list, &param1, &param2, &param3, &param4))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.billboard", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.billboard", 1, coerced_ptr, report_errors);
LVector4f *param4_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector4f, 4, "MeshDrawer.billboard", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)))
                {
                    (local_this)->billboard(*param1_this, *param2_this, (float)param3, *param4_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.billboard() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "billboard(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float size, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_billboard_115_comment =
    "C++ Interface:\n"
    "billboard(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float size, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::billboard\n"
    "//       Access: Published\n"
    "//  Description: Draws a billboard - particle with no rotation.\n"
    "//               Billboards always face the camera.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_billboard_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::segment(LVector3f start, LVector3f stop, LVector4f frame, float thickness, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_segment_116(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::segment(LVector3f start, LVector3f stop, LVector4f frame, float thickness, LVector4f color)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            double param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"start", (char *)"stop", (char *)"frame", (char *)"thickness", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOdO:segment", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.segment", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "MeshDrawer.segment", 1, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "MeshDrawer.segment", 1, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "MeshDrawer.segment", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                {
                    (local_this)->segment(*param1_this, *param2_this, *param3_this, (float)param4, *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.segment() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "segment(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float thickness, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_segment_116_comment =
    "C++ Interface:\n"
    "segment(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float thickness, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::segment\n"
    "//       Access: Published\n"
    "//  Description: Draws a segment a line with a thickness. That has\n"
    "//               billboarding effect.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_segment_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::cross_segment(LVector3f start, LVector3f stop, LVector4f frame, float thickness, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_cross_segment_117(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::cross_segment(LVector3f start, LVector3f stop, LVector4f frame, float thickness, LVector4f color)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            double param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"start", (char *)"stop", (char *)"frame", (char *)"thickness", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOdO:crossSegment", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.crossSegment", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "MeshDrawer.crossSegment", 1, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "MeshDrawer.crossSegment", 1, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "MeshDrawer.crossSegment", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                {
                    (local_this)->cross_segment(*param1_this, *param2_this, *param3_this, (float)param4, *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.crossSegment() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "crossSegment(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float thickness, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_cross_segment_117_comment =
    "C++ Interface:\n"
    "crossSegment(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float thickness, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::cross_segment\n"
    "//       Access: Published\n"
    "//  Description: Draws a segment a line with a thickness.  This\n"
    "//               segment does not use the bill boarding behavior\n"
    "//               and instead draws 2 planes in a cross.\n"
    "//               Stars at start and ends at stop.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_cross_segment_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::uneven_segment(LVector3f start, LVector3f stop, LVector4f frame, float thickness_start, LVector4f color_start, float thickness_stop, LVector4f color_stop)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_uneven_segment_118(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::uneven_segment(LVector3f start, LVector3f stop, LVector4f frame, float thickness_start, LVector4f color_start, float thickness_stop, LVector4f color_stop)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            double param4;
            PyObject *param5;
            double param6;
            PyObject *param7;
            static char * key_word_list[] = {(char *)"start", (char *)"stop", (char *)"frame", (char *)"thickness_start", (char *)"color_start", (char *)"thickness_stop", (char *)"color_stop", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOdOdO:unevenSegment", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.unevenSegment", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "MeshDrawer.unevenSegment", 1, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "MeshDrawer.unevenSegment", 1, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "MeshDrawer.unevenSegment", 1, coerced_ptr, report_errors);
LVector4f *param7_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LVector4f, 7, "MeshDrawer.unevenSegment", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)|| (param7_this == NULL)))
                {
                    (local_this)->uneven_segment(*param1_this, *param2_this, *param3_this, (float)param4, *param5_this, (float)param6, *param7_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.unevenSegment() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unevenSegment(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float thickness_start, const Vec4 color_start, float thickness_stop, const Vec4 color_stop)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_uneven_segment_118_comment =
    "C++ Interface:\n"
    "unevenSegment(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float thickness_start, const Vec4 color_start, float thickness_stop, const Vec4 color_stop)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::uneven_segment\n"
    "//       Access: Published\n"
    "//  Description: Draws a segment a line with different thickness\n"
    "//               and color on both sides.\n"
    "//               Stars at start and ends at stop.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_uneven_segment_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::link_segment(LVector3f pos, LVector4f frame, float thickness, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_link_segment_119(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::link_segment(LVector3f pos, LVector4f frame, float thickness, LVector4f color)
            PyObject *param1;
            PyObject *param2;
            double param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"pos", (char *)"frame", (char *)"thickness", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOdO:linkSegment", key_word_list, &param1, &param2, &param3, &param4))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.linkSegment", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.linkSegment", 1, coerced_ptr, report_errors);
LVector4f *param4_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector4f, 4, "MeshDrawer.linkSegment", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)))
                {
                    (local_this)->link_segment(*param1_this, *param2_this, (float)param3, *param4_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.linkSegment() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "linkSegment(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float thickness, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_link_segment_119_comment =
    "C++ Interface:\n"
    "linkSegment(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float thickness, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::link_segment\n"
    "//       Access: Published\n"
    "//  Description: Stars or continues linked segment.\n"
    "//               Control position, frame, thickness and color with\n"
    "//               parameters.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_link_segment_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::link_segment_end(LVector4f frame, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_link_segment_end_120(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::link_segment_end(LVector4f frame, LVector4f color)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:linkSegmentEnd", key_word_list, &param1, &param2))
            {
                LVector4f *param1_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector4f, 1, "MeshDrawer.linkSegmentEnd", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.linkSegmentEnd", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->link_segment_end(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.linkSegmentEnd() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "linkSegmentEnd(non-const MeshDrawer this, const Vec4 frame, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_link_segment_end_120_comment =
    "C++ Interface:\n"
    "linkSegmentEnd(non-const MeshDrawer this, const Vec4 frame, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::link_segment_end\n"
    "//       Access: Published\n"
    "//  Description: Finish drawing linked segments, needs at least\n"
    "//               two calls to link_segment before it can end\n"
    "//               the linked segment.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_link_segment_end_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::explosion(LVector3f pos, LVector4f frame, float size, LVector4f color, int seed, int number, float distance)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_explosion_121(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::explosion(LVector3f pos, LVector4f frame, float size, LVector4f color, int seed, int number, float distance)
            PyObject *param1;
            PyObject *param2;
            double param3;
            PyObject *param4;
            int param5;
            int param6;
            double param7;
            static char * key_word_list[] = {(char *)"pos", (char *)"frame", (char *)"size", (char *)"color", (char *)"seed", (char *)"number", (char *)"distance", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOdOiid:explosion", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.explosion", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer.explosion", 1, coerced_ptr, report_errors);
LVector4f *param4_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector4f, 4, "MeshDrawer.explosion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)))
                {
                    (local_this)->explosion(*param1_this, *param2_this, (float)param3, *param4_this, (int)param5, (int)param6, (float)param7);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.explosion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "explosion(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float size, const Vec4 color, int seed, int number, float distance)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_explosion_121_comment =
    "C++ Interface:\n"
    "explosion(non-const MeshDrawer this, const Vec3 pos, const Vec4 frame, float size, const Vec4 color, int seed, int number, float distance)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::explosion\n"
    "//       Access: Published\n"
    "//  Description: Draws number of particles in a sphere like emitter.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_explosion_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::stream(LVector3f start, LVector3f stop, LVector4f frame, float size, LVector4f color, int number, float offset)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_stream_122(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::stream(LVector3f start, LVector3f stop, LVector4f frame, float size, LVector4f color, int number, float offset)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            double param4;
            PyObject *param5;
            int param6;
            double param7;
            static char * key_word_list[] = {(char *)"start", (char *)"stop", (char *)"frame", (char *)"size", (char *)"color", (char *)"number", (char *)"offset", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOdOid:stream", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer.stream", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "MeshDrawer.stream", 1, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "MeshDrawer.stream", 1, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "MeshDrawer.stream", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                {
                    (local_this)->stream(*param1_this, *param2_this, *param3_this, (float)param4, *param5_this, (int)param6, (float)param7);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.stream() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stream(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float size, const Vec4 color, int number, float offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_stream_122_comment =
    "C++ Interface:\n"
    "stream(non-const MeshDrawer this, const Vec3 start, const Vec3 stop, const Vec4 frame, float size, const Vec4 color, int number, float offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::stream\n"
    "//       Access: Published\n"
    "//  Description: Draws a number of particles in a big line with a\n"
    "//               shift dictated by the offset.\n"
    "//               Frame contains u,v,u-size,v-size quadruple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_stream_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::geometry(NodePath node)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_geometry_123(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer::geometry(NodePath node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:geometry", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:geometry", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "MeshDrawer.geometry", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->geometry(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer.geometry() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "geometry(non-const MeshDrawer this, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_geometry_123_comment =
    "C++ Interface:\n"
    "geometry(non-const MeshDrawer this, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::geometry\n"
    "//       Access: Published\n"
    "//  Description: Draws the geometry that is inside this node path into\n"
    "//               the MeshDrawer object.  This performs a similar\n"
    "//               functions as RigidBodyCombiner but for very\n"
    "//               dynamic situations that share the same texture\n"
    "//               like physcal chunks of explosions.  \n"
    "//               It can be a little slow \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_geometry_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer::end(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_end_124(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MeshDrawer::end(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":end", key_word_list));
        else
            (PyArg_Parse(args, ":end"));
        if(!PyErr_Occurred())
        {
            (local_this)->end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer.end() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "end(non-const MeshDrawer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_end_124_comment =
    "C++ Interface:\n"
    "end(non-const MeshDrawer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer::end\n"
    "//       Access: Published\n"
    "//  Description: Finish the drawing and clearing off the remaining\n"
    "//               vertexes.  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer_end_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MeshDrawer::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer_get_class_type_125(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MeshDrawer::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MeshDrawer::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer_get_class_type_125_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MeshDrawer_get_class_type_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MeshDrawer::MeshDrawer(void)
 *******************************************************************/
int  Dtool_Init_MeshDrawer(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline MeshDrawer::MeshDrawer(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":MeshDrawer", key_word_list))
        {
            MeshDrawer *return_value = new MeshDrawer();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MeshDrawer,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MeshDrawer()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MeshDrawer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MeshDrawer)
    {
        printf("MeshDrawer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MeshDrawer * local_this = (MeshDrawer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MeshDrawer)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MeshDrawer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MeshDrawer)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MeshDrawer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MeshDrawer2D 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer2D::set_budget(int budget)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_set_budget_128(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MeshDrawer2D::set_budget(int budget)
        int param1;
        static char * key_word_list[] = {(char *)"budget", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBudget", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBudget", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_budget((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer2D.setBudget() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBudget(non-const MeshDrawer2D this, int budget)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_set_budget_128_comment =
    "C++ Interface:\n"
    "setBudget(non-const MeshDrawer2D this, int budget)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::set_budget\n"
    "//       Access: Published\n"
    "//  Description: Sets the total triangle budget of the drawer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_set_budget_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MeshDrawer2D::get_budget(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_get_budget_129(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int MeshDrawer2D::get_budget(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBudget", key_word_list));
        else
            (PyArg_Parse(args, ":getBudget"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_budget();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer2D.getBudget() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBudget(non-const MeshDrawer2D this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_get_budget_129_comment =
    "C++ Interface:\n"
    "getBudget(non-const MeshDrawer2D this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::get_budget()\n"
    "//       Access: Published\n"
    "//  Description: Gets the total triangle budget of the drawer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_get_budget_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath MeshDrawer2D::get_root(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_get_root_130(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline NodePath MeshDrawer2D::get_root(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRoot", key_word_list));
        else
            (PyArg_Parse(args, ":getRoot"));
        if(!PyErr_Occurred())
        {
            NodePath result = (local_this)->get_root();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer2D.getRoot() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRoot(non-const MeshDrawer2D this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_get_root_130_comment =
    "C++ Interface:\n"
    "getRoot(non-const MeshDrawer2D this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::get_root\n"
    "//       Access: Published\n"
    "//  Description: Returns the root NodePath.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_get_root_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer2D::quad_raw(LVector3f v1, LVector4f c1, LVector2f uv1, LVector3f v2, LVector4f c2, LVector2f uv2, LVector3f v3, LVector4f c3, LVector2f uv3, LVector3f v4, LVector4f c4, LVector2f uv4)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_quad_raw_131(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MeshDrawer2D::quad_raw(LVector3f v1, LVector4f c1, LVector2f uv1, LVector3f v2, LVector4f c2, LVector2f uv2, LVector3f v3, LVector4f c3, LVector2f uv3, LVector3f v4, LVector4f c4, LVector2f uv4)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            PyObject *param5;
            PyObject *param6;
            PyObject *param7;
            PyObject *param8;
            PyObject *param9;
            PyObject *param10;
            PyObject *param11;
            PyObject *param12;
            static char * key_word_list[] = {(char *)"v1", (char *)"c1", (char *)"uv1", (char *)"v2", (char *)"c2", (char *)"uv2", (char *)"v3", (char *)"c3", (char *)"uv3", (char *)"v4", (char *)"c4", (char *)"uv4", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOOOOOOO:quadRaw", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector2f *param3_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector2f, 3, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector3f *param4_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector3f, 4, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector2f *param6_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVector2f, 6, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector3f *param7_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LVector3f, 7, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector4f *param8_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param8, &Dtool_LVector4f, 8, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector2f *param9_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_LVector2f, 9, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector3f *param10_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param10, &Dtool_LVector3f, 10, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector4f *param11_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param11, &Dtool_LVector4f, 11, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);
LVector2f *param12_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param12, &Dtool_LVector2f, 12, "MeshDrawer2D.quadRaw", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)|| (param7_this == NULL)|| (param8_this == NULL)|| (param9_this == NULL)|| (param10_this == NULL)|| (param11_this == NULL)|| (param12_this == NULL)))
                {
                    (local_this)->quad_raw(*param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this, *param8_this, *param9_this, *param10_this, *param11_this, *param12_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer2D.quadRaw() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "quadRaw(non-const MeshDrawer2D this, const Vec3 v1, const Vec4 c1, const Vec2 uv1, const Vec3 v2, const Vec4 c2, const Vec2 uv2, const Vec3 v3, const Vec4 c3, const Vec2 uv3, const Vec3 v4, const Vec4 c4, const Vec2 uv4)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_quad_raw_131_comment =
    "C++ Interface:\n"
    "quadRaw(non-const MeshDrawer2D this, const Vec3 v1, const Vec4 c1, const Vec2 uv1, const Vec3 v2, const Vec4 c2, const Vec2 uv2, const Vec3 v3, const Vec4 c3, const Vec2 uv3, const Vec3 v4, const Vec4 c4, const Vec2 uv4)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::quad\n"
    "//       Access: Published\n"
    "//  Description: Draws a 2d rectangle.\n"
    "//               Ignores the cliping rectangle\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_quad_raw_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer2D::rectangle_raw(float x, float y, float w, float h, float u, float v, float us, float vs, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_rectangle_raw_132(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MeshDrawer2D::rectangle_raw(float x, float y, float w, float h, float u, float v, float us, float vs, LVector4f color)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            PyObject *param9;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"w", (char *)"h", (char *)"u", (char *)"v", (char *)"us", (char *)"vs", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddO:rectangleRaw", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
            {
                LVector4f *param9_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_LVector4f, 9, "MeshDrawer2D.rectangleRaw", 1, coerced_ptr, report_errors);

                if (!((param9_this == NULL)))
                {
                    (local_this)->rectangle_raw((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, *param9_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer2D.rectangleRaw() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rectangleRaw(non-const MeshDrawer2D this, float x, float y, float w, float h, float u, float v, float us, float vs, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_rectangle_raw_132_comment =
    "C++ Interface:\n"
    "rectangleRaw(non-const MeshDrawer2D this, float x, float y, float w, float h, float u, float v, float us, float vs, const Vec4 color)\n"
    "\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_rectangle_raw_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer2D::set_clip(float x, float y, float w, float h)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_set_clip_133(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MeshDrawer2D::set_clip(float x, float y, float w, float h)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"w", (char *)"h", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setClip", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_clip((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer2D.setClip() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClip(non-const MeshDrawer2D this, float x, float y, float w, float h)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_set_clip_133_comment =
    "C++ Interface:\n"
    "setClip(non-const MeshDrawer2D this, float x, float y, float w, float h)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::set_budget\n"
    "//       Access: Published\n"
    "//  Description: Sets clipping rectangle\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_set_clip_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MeshDrawer2D::rectangle(float x, float y, float w, float h, float u, float v, float us, float vs, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_rectangle_134(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MeshDrawer2D::rectangle(float x, float y, float w, float h, float u, float v, float us, float vs, LVector4f color)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            PyObject *param9;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"w", (char *)"h", (char *)"u", (char *)"v", (char *)"us", (char *)"vs", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddO:rectangle", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
            {
                LVector4f *param9_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_LVector4f, 9, "MeshDrawer2D.rectangle", 1, coerced_ptr, report_errors);

                if (!((param9_this == NULL)))
                {
                    (local_this)->rectangle((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, *param9_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer2D.rectangle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rectangle(non-const MeshDrawer2D this, float x, float y, float w, float h, float u, float v, float us, float vs, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_rectangle_134_comment =
    "C++ Interface:\n"
    "rectangle(non-const MeshDrawer2D this, float x, float y, float w, float h, float u, float v, float us, float vs, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::quad\n"
    "//       Access: Published\n"
    "//  Description: Draws a 2d rectangle, that can be cliped\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_rectangle_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer2D::rectangle_border(float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_rectangle_border_135(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer2D::rectangle_border(float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, LVector4f color)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            double param9;
            double param10;
            double param11;
            double param12;
            double param13;
            double param14;
            double param15;
            double param16;
            PyObject *param17;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"w", (char *)"h", (char *)"r", (char *)"t", (char *)"l", (char *)"b", (char *)"tr", (char *)"tt", (char *)"tl", (char *)"tb", (char *)"u", (char *)"v", (char *)"us", (char *)"vs", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddddddddddO:rectangleBorder", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17))
            {
                LVector4f *param17_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param17, &Dtool_LVector4f, 17, "MeshDrawer2D.rectangleBorder", 1, coerced_ptr, report_errors);

                if (!((param17_this == NULL)))
                {
                    (local_this)->rectangle_border((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15, (float)param16, *param17_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer2D.rectangleBorder() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rectangleBorder(non-const MeshDrawer2D this, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_rectangle_border_135_comment =
    "C++ Interface:\n"
    "rectangleBorder(non-const MeshDrawer2D this, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::quad\n"
    "//       Access: Published\n"
    "//  Description: Draws a 2d rectangle, with borders and corders, \n"
    "//               taken from the surrounding texture\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_rectangle_border_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer2D::rectangle_border_tiled(float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_rectangle_border_tiled_136(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer2D::rectangle_border_tiled(float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, LVector4f color)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            double param9;
            double param10;
            double param11;
            double param12;
            double param13;
            double param14;
            double param15;
            double param16;
            PyObject *param17;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"w", (char *)"h", (char *)"r", (char *)"t", (char *)"l", (char *)"b", (char *)"tr", (char *)"tt", (char *)"tl", (char *)"tb", (char *)"u", (char *)"v", (char *)"us", (char *)"vs", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddddddddddO:rectangleBorderTiled", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17))
            {
                LVector4f *param17_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param17, &Dtool_LVector4f, 17, "MeshDrawer2D.rectangleBorderTiled", 1, coerced_ptr, report_errors);

                if (!((param17_this == NULL)))
                {
                    (local_this)->rectangle_border_tiled((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15, (float)param16, *param17_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer2D.rectangleBorderTiled() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rectangleBorderTiled(non-const MeshDrawer2D this, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_rectangle_border_tiled_136_comment =
    "C++ Interface:\n"
    "rectangleBorderTiled(non-const MeshDrawer2D this, float x, float y, float w, float h, float r, float t, float l, float b, float tr, float tt, float tl, float tb, float u, float v, float us, float vs, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::quad\n"
    "//       Access: Published\n"
    "//  Description: Draws a 2d rectangle, with borders and corders, \n"
    "//               taken from the surrounding texture\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_rectangle_border_tiled_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer2D::rectangle_tiled(float x, float y, float w, float h, float u, float v, float us, float vs, LVector4f color)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_rectangle_tiled_137(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MeshDrawer2D::rectangle_tiled(float x, float y, float w, float h, float u, float v, float us, float vs, LVector4f color)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            PyObject *param9;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"w", (char *)"h", (char *)"u", (char *)"v", (char *)"us", (char *)"vs", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddO:rectangleTiled", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
            {
                LVector4f *param9_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_LVector4f, 9, "MeshDrawer2D.rectangleTiled", 1, coerced_ptr, report_errors);

                if (!((param9_this == NULL)))
                {
                    (local_this)->rectangle_tiled((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, *param9_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MeshDrawer2D.rectangleTiled() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rectangleTiled(non-const MeshDrawer2D this, float x, float y, float w, float h, float u, float v, float us, float vs, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_rectangle_tiled_137_comment =
    "C++ Interface:\n"
    "rectangleTiled(non-const MeshDrawer2D this, float x, float y, float w, float h, float u, float v, float us, float vs, const Vec4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::quad\n"
    "//       Access: Published\n"
    "//  Description: Draws a tiled rectangle, size of tiles is in \n"
    "//               us and vs\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_rectangle_tiled_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer2D::begin(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_begin_138(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MeshDrawer2D::begin(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":begin", key_word_list));
        else
            (PyArg_Parse(args, ":begin"));
        if(!PyErr_Occurred())
        {
            (local_this)->begin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer2D.begin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "begin(non-const MeshDrawer2D this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_begin_138_comment =
    "C++ Interface:\n"
    "begin(non-const MeshDrawer2D this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::begin\n"
    "//       Access: Published\n"
    "//  Description: Opens up the geom for drawing, dont forget to call\n"
    "//               MeshDrawer2D::end()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_begin_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshDrawer2D::end(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_end_139(PyObject *self, PyObject *args,PyObject *kwds) {
    MeshDrawer2D * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MeshDrawer2D,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MeshDrawer2D::end(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":end", key_word_list));
        else
            (PyArg_Parse(args, ":end"));
        if(!PyErr_Occurred())
        {
            (local_this)->end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MeshDrawer2D.end() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "end(non-const MeshDrawer2D this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_end_139_comment =
    "C++ Interface:\n"
    "end(non-const MeshDrawer2D this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MeshDrawer2D::end\n"
    "//       Access: Published\n"
    "//  Description: Finish the drawing and clearing off the remaining\n"
    "//               vertexes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_end_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MeshDrawer2D::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MeshDrawer2D_get_class_type_140(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MeshDrawer2D::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MeshDrawer2D::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MeshDrawer2D_get_class_type_140_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MeshDrawer2D_get_class_type_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MeshDrawer2D::MeshDrawer2D(void)
 *******************************************************************/
int  Dtool_Init_MeshDrawer2D(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline MeshDrawer2D::MeshDrawer2D(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":MeshDrawer2D", key_word_list))
        {
            MeshDrawer2D *return_value = new MeshDrawer2D();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MeshDrawer2D,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MeshDrawer2D()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MeshDrawer2D(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MeshDrawer2D)
    {
        printf("MeshDrawer2D ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MeshDrawer2D * local_this = (MeshDrawer2D *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MeshDrawer2D)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MeshDrawer2D(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MeshDrawer2D)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MeshDrawer2D*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovieTexture 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline double MovieTexture::get_video_length(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_video_length_144(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MovieTexture::get_video_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVideoLength", key_word_list));
        else
            (PyArg_Parse(args, ":getVideoLength"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieTexture*)local_this)->get_video_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVideoLength(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_video_length_144_comment =
    "C++ Interface:\n"
    "getVideoLength(const MovieTexture this)\n"
    "\n"
    "// Filename: movieTexture.I\n"
    "// Created by: jyelon (01Aug2007)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_video_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the length of the video.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_video_length_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieTexture::get_video_width(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_video_width_145(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieTexture::get_video_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVideoWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getVideoWidth"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieTexture*)local_this)->get_video_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVideoWidth(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_video_width_145_comment =
    "C++ Interface:\n"
    "getVideoWidth(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_video_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width in texels of the source video\n"
    "//               stream.  This is not necessarily the width of the\n"
    "//               actual texture, since the texture may have been\n"
    "//               expanded to raise it to a power of 2.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_video_width_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieTexture::get_video_height(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_video_height_146(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieTexture::get_video_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVideoHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getVideoHeight"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieTexture*)local_this)->get_video_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVideoHeight(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_video_height_146_comment =
    "C++ Interface:\n"
    "getVideoHeight(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_video_height\n"
    "//       Access: Published\n"
    "//  Description: Returns the height in texels of the source video\n"
    "//               stream.  This is not necessarily the height of the\n"
    "//               actual texture, since the texture may have been\n"
    "//               expanded to raise it to a power of 2.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_video_height_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f MovieTexture::get_tex_scale(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_tex_scale_147(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f MovieTexture::get_tex_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexScale", key_word_list));
        else
            (PyArg_Parse(args, ":getTexScale"));
        if(!PyErr_Occurred())
        {
            LVecBase2f result = ((const MovieTexture*)local_this)->get_tex_scale();
            LVecBase2f *return_value = new LVecBase2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTexScale(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_tex_scale_147_comment =
    "C++ Interface:\n"
    "getTexScale(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_tex_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns a scale pair that is suitable for applying to\n"
    "//               geometry via NodePath::set_tex_scale(), which will\n"
    "//               convert texture coordinates on the geometry from the\n"
    "//               range 0..1 into the appropriate range to render the\n"
    "//               video part of the texture.\n"
    "//\n"
    "//               This is necessary in the event the video source is\n"
    "//               not a power of two and set_power_2() is true.  In\n"
    "//               this case, the video image will be mapped to the\n"
    "//               lower-left corner of the texture, and the rest of the\n"
    "//               texture space will be unused; so we will need to\n"
    "//               remap any texture coordinates to fill the space\n"
    "//               correctly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_tex_scale_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::restart(void)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_restart_148(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::restart(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":restart", key_word_list));
        else
            (PyArg_Parse(args, ":restart"));
        if(!PyErr_Occurred())
        {
            (local_this)->restart();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.restart() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "restart(non-const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_restart_148_comment =
    "C++ Interface:\n"
    "restart(non-const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::restart\n"
    "//       Access: Published\n"
    "//  Description: Start playing the movie from where it was last\n"
    "//               paused.  Has no effect if the movie is not paused,\n"
    "//               or if the movie's cursor is already at the end.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_restart_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::stop(void)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_stop_149(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::stop(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stop", key_word_list));
        else
            (PyArg_Parse(args, ":stop"));
        if(!PyErr_Occurred())
        {
            (local_this)->stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.stop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stop(non-const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_stop_149_comment =
    "C++ Interface:\n"
    "stop(non-const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::stop\n"
    "//       Access: Published\n"
    "//  Description: Stops a currently playing or looping movie right\n"
    "//               where it is.  The movie's cursor remains frozen at\n"
    "//               the point where it was stopped.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_stop_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::play(void)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_play_150(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::play(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":play", key_word_list));
        else
            (PyArg_Parse(args, ":play"));
        if(!PyErr_Occurred())
        {
            (local_this)->play();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.play() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "play(non-const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_play_150_comment =
    "C++ Interface:\n"
    "play(non-const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::play\n"
    "//       Access: Published\n"
    "//  Description: Plays the movie from the beginning.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_play_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::set_time(double t)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_set_time_151(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::set_time(double t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_time((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.setTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTime(non-const MovieTexture this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_set_time_151_comment =
    "C++ Interface:\n"
    "setTime(non-const MovieTexture this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::set_time\n"
    "//       Access: Published\n"
    "//  Description: Sets the movie's cursor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_set_time_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double MovieTexture::get_time(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_time_152(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double MovieTexture::get_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTime", key_word_list));
        else
            (PyArg_Parse(args, ":getTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieTexture*)local_this)->get_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTime(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_time_152_comment =
    "C++ Interface:\n"
    "getTime(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the current value of the movie's cursor.\n"
    "//               If the movie's loop count is greater than one, then\n"
    "//               its length is effectively multiplied for the\n"
    "//               purposes of this function.  In other words, \n"
    "//               the return value will be in the range 0.0 \n"
    "//               to (length * loopcount).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_time_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::set_loop(bool enable)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_set_loop_153(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::set_loop(bool enable)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"enable", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLoop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setLoop", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_loop((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.setLoop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLoop(non-const MovieTexture this, bool enable)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_set_loop_153_comment =
    "C++ Interface:\n"
    "setLoop(non-const MovieTexture this, bool enable)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::set_loop\n"
    "//       Access: Published\n"
    "//  Description: If true, sets the movie's loop count to 1 billion.\n"
    "//               If false, sets the movie's loop count to one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_set_loop_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MovieTexture::get_loop(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_loop_154(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool MovieTexture::get_loop(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLoop", key_word_list));
        else
            (PyArg_Parse(args, ":getLoop"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieTexture*)local_this)->get_loop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLoop(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_loop_154_comment =
    "C++ Interface:\n"
    "getLoop(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_loop\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the movie's loop count is not equal\n"
    "//               to one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_loop_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::set_loop_count(int count)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_set_loop_count_155(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::set_loop_count(int count)
        int param1;
        static char * key_word_list[] = {(char *)"count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLoopCount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLoopCount", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_loop_count((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.setLoopCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLoopCount(non-const MovieTexture this, int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_set_loop_count_155_comment =
    "C++ Interface:\n"
    "setLoopCount(non-const MovieTexture this, int count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::set_loop_count\n"
    "//       Access: Published\n"
    "//  Description: Sets the movie's loop count to the desired value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_set_loop_count_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int MovieTexture::get_loop_count(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_loop_count_156(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int MovieTexture::get_loop_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLoopCount", key_word_list));
        else
            (PyArg_Parse(args, ":getLoopCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieTexture*)local_this)->get_loop_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLoopCount(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_loop_count_156_comment =
    "C++ Interface:\n"
    "getLoopCount(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_loop_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the movie's loop count.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_loop_count_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::set_play_rate(double play_rate)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_set_play_rate_157(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::set_play_rate(double play_rate)
        double param1;
        static char * key_word_list[] = {(char *)"play_rate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPlayRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPlayRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_play_rate((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.setPlayRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlayRate(non-const MovieTexture this, float play_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_set_play_rate_157_comment =
    "C++ Interface:\n"
    "setPlayRate(non-const MovieTexture this, float play_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::set_play_rate\n"
    "//       Access: Published\n"
    "//  Description: Sets the movie's play-rate.  This is the speed at\n"
    "//               which the movie's cursor advances.  The default is\n"
    "//               to advance 1.0 movie-seconds per real-time second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_set_play_rate_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double MovieTexture::get_play_rate(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_play_rate_158(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double MovieTexture::get_play_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlayRate", key_word_list));
        else
            (PyArg_Parse(args, ":getPlayRate"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieTexture*)local_this)->get_play_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlayRate(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_play_rate_158_comment =
    "C++ Interface:\n"
    "getPlayRate(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::get_play_rate\n"
    "//       Access: Published\n"
    "//  Description: Gets the movie's play-rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_get_play_rate_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MovieTexture::is_playing(void) const
 *******************************************************************/
static PyObject *Dtool_MovieTexture_is_playing_159(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool MovieTexture::is_playing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPlaying", key_word_list));
        else
            (PyArg_Parse(args, ":isPlaying"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieTexture*)local_this)->is_playing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPlaying(const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_is_playing_159_comment =
    "C++ Interface:\n"
    "isPlaying(const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::is_playing\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the movie's cursor is advancing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_is_playing_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::synchronize_to(AudioSound *sound)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_synchronize_to_160(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MovieTexture::synchronize_to(AudioSound *sound)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"sound", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:synchronizeTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:synchronizeTo", &param1));
            if(!PyErr_Occurred())
            {
                AudioSound *param1_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AudioSound, 1, "MovieTexture.synchronizeTo", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->synchronize_to(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MovieTexture.synchronizeTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "synchronizeTo(non-const MovieTexture this, non-const AudioSound sound)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_synchronize_to_160_comment =
    "C++ Interface:\n"
    "synchronizeTo(non-const MovieTexture this, non-const AudioSound sound)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::synchronize_to\n"
    "//       Access: Published\n"
    "//  Description: Synchronize this texture to a sound.  Typically,\n"
    "//               you would load the texture and the sound from the\n"
    "//               same AVI file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_synchronize_to_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieTexture::unsynchronize(void)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_unsynchronize_161(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieTexture * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieTexture,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MovieTexture::unsynchronize(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unsynchronize", key_word_list));
        else
            (PyArg_Parse(args, ":unsynchronize"));
        if(!PyErr_Occurred())
        {
            (local_this)->unsynchronize();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieTexture.unsynchronize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unsynchronize(non-const MovieTexture this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_unsynchronize_161_comment =
    "C++ Interface:\n"
    "unsynchronize(non-const MovieTexture this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieTexture::unsynchronize\n"
    "//       Access: Published\n"
    "//  Description: Stop synchronizing with a sound.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieTexture_unsynchronize_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovieTexture::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovieTexture_get_class_type_162(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovieTexture::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovieTexture::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieTexture_get_class_type_162_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovieTexture_get_class_type_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MovieTexture::MovieTexture(PointerTo< MovieVideo > video)
 * MovieTexture::MovieTexture(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_MovieTexture(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 MovieTexture::MovieTexture(PointerTo< MovieVideo > video)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"video", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:MovieTexture", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:MovieTexture", &param0));
            if(!PyErr_Occurred())
            {
                MovieVideo *param0_this = (MovieVideo *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_MovieVideo, 0, "MovieTexture.MovieTexture", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    MovieTexture *return_value = new MovieTexture(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieTexture,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 MovieTexture::MovieTexture(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:MovieTexture", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:MovieTexture", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                MovieTexture *return_value = new MovieTexture(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieTexture,true,false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MovieTexture(const MovieVideo video)\n"
          "MovieTexture(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MovieTexture(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovieTexture)
    {
        printf("MovieTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovieTexture * local_this = (MovieTexture *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovieTexture)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Texture *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Texture *) local_this;
    if(requested_type == &Dtool_Texture)
        return ( Texture *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Texture *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Texture *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Texture *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovieTexture(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovieTexture)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovieTexture*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovieTexture*)other_this;
    }
    if(from_type == &Dtool_Texture)
    {
          Texture* other_this = (Texture*)from_this;
          return (MovieTexture*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovieTexture*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovieTexture*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovieTexture*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NodeVertexTransform 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PandaNode const *NodeVertexTransform::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_NodeVertexTransform_get_node_166(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeVertexTransform * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeVertexTransform,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode const *NodeVertexTransform::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            PandaNode const *return_value = ((const NodeVertexTransform*)local_this)->get_node();
            if (return_value != (PandaNode const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const NodeVertexTransform this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeVertexTransform_get_node_166_comment =
    "C++ Interface:\n"
    "getNode(const NodeVertexTransform this)\n"
    "\n"
    "// Filename: nodeVertexTransform.I\n"
    "// Created by:  drose (22Feb07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeVertexTransform::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the PandaNode whose transform supplies this\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeVertexTransform_get_node_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline VertexTransform const *NodeVertexTransform::get_prev(void) const
 *******************************************************************/
static PyObject *Dtool_NodeVertexTransform_get_prev_167(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeVertexTransform * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeVertexTransform,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline VertexTransform const *NodeVertexTransform::get_prev(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPrev", key_word_list));
        else
            (PyArg_Parse(args, ":getPrev"));
        if(!PyErr_Occurred())
        {
            VertexTransform const *return_value = ((const NodeVertexTransform*)local_this)->get_prev();
            if (return_value != (VertexTransform const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_VertexTransform,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrev(const NodeVertexTransform this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeVertexTransform_get_prev_167_comment =
    "C++ Interface:\n"
    "getPrev(const NodeVertexTransform this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeVertexTransform::get_prev\n"
    "//       Access: Published\n"
    "//  Description: Returns the VertexTransform object whose matrix will\n"
    "//               be composed with the result of this node's transform.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeVertexTransform_get_prev_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NodeVertexTransform::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NodeVertexTransform_get_class_type_168(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NodeVertexTransform::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NodeVertexTransform::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeVertexTransform_get_class_type_168_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NodeVertexTransform_get_class_type_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev)
 * NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev = ((void *)(0)))
 *******************************************************************/
int  Dtool_Init_NodeVertexTransform(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev = ((void *)(0)))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"node", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:NodeVertexTransform", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:NodeVertexTransform", &param0));
                if(!PyErr_Occurred())
                {
                    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "NodeVertexTransform.NodeVertexTransform", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        NodeVertexTransform *return_value = new NodeVertexTransform(param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_NodeVertexTransform,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"node", (char *)"prev", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:NodeVertexTransform", key_word_list, &param0, &param1))
                {
                    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "NodeVertexTransform.NodeVertexTransform", 1, coerced_ptr, report_errors);
VertexTransform *param1_this = (VertexTransform *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_VertexTransform, 1, "NodeVertexTransform.NodeVertexTransform", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        NodeVertexTransform *return_value = new NodeVertexTransform(param0_this, param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_NodeVertexTransform,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "NodeVertexTransform() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "NodeVertexTransform(const PandaNode node)\n"
          "NodeVertexTransform(const PandaNode node, const VertexTransform prev)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NodeVertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NodeVertexTransform)
    {
        printf("NodeVertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NodeVertexTransform * local_this = (NodeVertexTransform *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NodeVertexTransform)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_VertexTransform)
        return ( VertexTransform *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NodeVertexTransform(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NodeVertexTransform)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NodeVertexTransform*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NodeVertexTransform*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (NodeVertexTransform*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (NodeVertexTransform*)other_this;
    }
    if(from_type == &Dtool_VertexTransform)
    {
          VertexTransform* other_this = (VertexTransform*)from_this;
          return (NodeVertexTransform*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. RigidBodyCombiner 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void RigidBodyCombiner::collect(void)
 *******************************************************************/
static PyObject *Dtool_RigidBodyCombiner_collect_173(PyObject *self, PyObject *args,PyObject *kwds) {
    RigidBodyCombiner * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RigidBodyCombiner,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void RigidBodyCombiner::collect(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":collect", key_word_list));
        else
            (PyArg_Parse(args, ":collect"));
        if(!PyErr_Occurred())
        {
            (local_this)->collect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RigidBodyCombiner.collect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "collect(non-const RigidBodyCombiner this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RigidBodyCombiner_collect_173_comment =
    "C++ Interface:\n"
    "collect(non-const RigidBodyCombiner this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RigidBodyCombiner::collect\n"
    "//       Access: Published\n"
    "//  Description: Walks through the entire subgraph of nodes rooted at\n"
    "//               this node, accumulates all of the RenderAttribs and\n"
    "//               Geoms below this node, flattening them into just one\n"
    "//               Geom (or as few as possible, if there are multiple\n"
    "//               different states).\n"
    "//\n"
    "//               Nodes that have transforms on them at the time of\n"
    "//               collect(), or any ModelNodes with the\n"
    "//               preserve_transform flag, will be identified as\n"
    "//               \"moving\" nodes, and their transforms will be\n"
    "//               monitored as they change in future frames and each\n"
    "//               new transform directly applied to the vertices.\n"
    "//               \n"
    "//               This call must be made after adding any nodes to or\n"
    "//               removing any nodes from the subgraph rooted at this\n"
    "//               node.  It should not be made too often, as it is a\n"
    "//               relatively expensive call.  If you need to hide\n"
    "//               children of this node, consider scaling them to zero\n"
    "//               (or very near zero), or moving them behind the\n"
    "//               camera, instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RigidBodyCombiner_collect_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath RigidBodyCombiner::get_internal_scene(void)
 *******************************************************************/
static PyObject *Dtool_RigidBodyCombiner_get_internal_scene_174(PyObject *self, PyObject *args,PyObject *kwds) {
    RigidBodyCombiner * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RigidBodyCombiner,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePath RigidBodyCombiner::get_internal_scene(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInternalScene", key_word_list));
        else
            (PyArg_Parse(args, ":getInternalScene"));
        if(!PyErr_Occurred())
        {
            NodePath result = (local_this)->get_internal_scene();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RigidBodyCombiner.getInternalScene() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInternalScene(non-const RigidBodyCombiner this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RigidBodyCombiner_get_internal_scene_174_comment =
    "C++ Interface:\n"
    "getInternalScene(non-const RigidBodyCombiner this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RigidBodyCombiner::get_internal_scene\n"
    "//       Access: Published\n"
    "//  Description: Returns a special NodePath that represents the\n"
    "//               internal node of this object.  This is the node that\n"
    "//               is actually sent to the graphics card for rendering;\n"
    "//               it contains the collection of the children of this\n"
    "//               node into as few Geoms as possible.  \n"
    "//\n"
    "//               This node is filled up by the last call to collect().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RigidBodyCombiner_get_internal_scene_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle RigidBodyCombiner::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_RigidBodyCombiner_get_class_type_175(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle RigidBodyCombiner::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = RigidBodyCombiner::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RigidBodyCombiner_get_class_type_175_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_RigidBodyCombiner_get_class_type_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RigidBodyCombiner::RigidBodyCombiner(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_RigidBodyCombiner(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-RigidBodyCombiner::RigidBodyCombiner(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:RigidBodyCombiner", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:RigidBodyCombiner", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            RigidBodyCombiner *return_value = new RigidBodyCombiner(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_RigidBodyCombiner,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RigidBodyCombiner(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_RigidBodyCombiner(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RigidBodyCombiner)
    {
        printf("RigidBodyCombiner ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RigidBodyCombiner * local_this = (RigidBodyCombiner *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RigidBodyCombiner)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RigidBodyCombiner(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RigidBodyCombiner)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (RigidBodyCombiner*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (RigidBodyCombiner*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (RigidBodyCombiner*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (RigidBodyCombiner*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PipeOcclusionCullTraverser 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void PipeOcclusionCullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render)
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_set_scene_185(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void PipeOcclusionCullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"scene_setup", (char *)"gsg", (char *)"dr_incomplete_render", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setScene", key_word_list, &param1, &param2, &param3))
            {
                SceneSetup *param1_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_SceneSetup, 1, "PipeOcclusionCullTraverser.setScene", 0, coerced_ptr, report_errors);
GraphicsStateGuardianBase *param2_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_GraphicsStateGuardianBase, 2, "PipeOcclusionCullTraverser.setScene", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_scene(param1_this, param2_this, (PyObject_IsTrue(param3)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PipeOcclusionCullTraverser.setScene() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScene(non-const PipeOcclusionCullTraverser this, non-const SceneSetup scene_setup, non-const GraphicsStateGuardianBase gsg, bool dr_incomplete_render)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_set_scene_185_comment =
    "C++ Interface:\n"
    "setScene(non-const PipeOcclusionCullTraverser this, non-const SceneSetup scene_setup, non-const GraphicsStateGuardianBase gsg, bool dr_incomplete_render)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PipeOcclusionCullTraverser::set_scene\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_set_scene_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PipeOcclusionCullTraverser::end_traverse(void)
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_end_traverse_186(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void PipeOcclusionCullTraverser::end_traverse(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":endTraverse", key_word_list));
        else
            (PyArg_Parse(args, ":endTraverse"));
        if(!PyErr_Occurred())
        {
            (local_this)->end_traverse();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PipeOcclusionCullTraverser.endTraverse() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "endTraverse(non-const PipeOcclusionCullTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_end_traverse_186_comment =
    "C++ Interface:\n"
    "endTraverse(non-const PipeOcclusionCullTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PipeOcclusionCullTraverser::end_traverse\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Should be called when the traverser has finished\n"
    "//               traversing its scene, this gives it a chance to do\n"
    "//               any necessary finalization.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_end_traverse_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GraphicsOutput *PipeOcclusionCullTraverser::get_buffer(void) const
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_get_buffer_187(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GraphicsOutput *PipeOcclusionCullTraverser::get_buffer(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBuffer", key_word_list));
        else
            (PyArg_Parse(args, ":getBuffer"));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = ((const PipeOcclusionCullTraverser*)local_this)->get_buffer();
            if (return_value != (GraphicsOutput *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBuffer(const PipeOcclusionCullTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_get_buffer_187_comment =
    "C++ Interface:\n"
    "getBuffer(const PipeOcclusionCullTraverser this)\n"
    "\n"
    "// Filename: pipeOcclusionCullTraverser.I\n"
    "// Created by:  drose (29May07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PipeOcclusionCullTraverser::get_buffer\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_get_buffer_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Texture *PipeOcclusionCullTraverser::get_texture(void)
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_get_texture_188(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Texture *PipeOcclusionCullTraverser::get_texture(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getTexture"));
        if(!PyErr_Occurred())
        {
            Texture *return_value = (local_this)->get_texture();
            if (return_value != (Texture *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PipeOcclusionCullTraverser.getTexture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTexture(non-const PipeOcclusionCullTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_get_texture_188_comment =
    "C++ Interface:\n"
    "getTexture(non-const PipeOcclusionCullTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PipeOcclusionCullTraverser::get_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns a Texture that can be used to visualize the\n"
    "//               efforts of the occlusion cull.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_get_texture_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PipeOcclusionCullTraverser::set_occlusion_mask(BitMask< unsigned int, 32 > const &occlusion_mask)
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_189(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PipeOcclusionCullTraverser::set_occlusion_mask(BitMask< unsigned int, 32 > const &occlusion_mask)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"occlusion_mask", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOcclusionMask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOcclusionMask", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "PipeOcclusionCullTraverser.setOcclusionMask", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_occlusion_mask(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PipeOcclusionCullTraverser.setOcclusionMask() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOcclusionMask(non-const PipeOcclusionCullTraverser this, const BitMask occlusion_mask)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_189_comment =
    "C++ Interface:\n"
    "setOcclusionMask(non-const PipeOcclusionCullTraverser this, const BitMask occlusion_mask)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PipeOcclusionCullTraverser::set_occlusion_mask\n"
    "//       Access: Public\n"
    "//  Description: Specifies the DrawMask that should be set on\n"
    "//               occlusion polygons for this scene.  This identifies\n"
    "//               the polygons that are to be treated as occluders.\n"
    "//               Polygons that do not have this draw mask set will not\n"
    "//               be considered occluders.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > const &PipeOcclusionCullTraverser::get_occlusion_mask(void) const
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_190(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > const &PipeOcclusionCullTraverser::get_occlusion_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOcclusionMask", key_word_list));
        else
            (PyArg_Parse(args, ":getOcclusionMask"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > const *return_value = &(((const PipeOcclusionCullTraverser*)local_this)->get_occlusion_mask());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOcclusionMask(const PipeOcclusionCullTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_190_comment =
    "C++ Interface:\n"
    "getOcclusionMask(const PipeOcclusionCullTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PipeOcclusionCullTraverser::get_occlusion_mask\n"
    "//       Access: Public\n"
    "//  Description: Returns the DrawMask for occlusion polygons.  See\n"
    "//               set_occlusion_mask().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PipeOcclusionCullTraverser::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_get_class_type_191(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PipeOcclusionCullTraverser::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PipeOcclusionCullTraverser::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_get_class_type_191_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_get_class_type_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CullTraverser *PipeOcclusionCullTraverser::upcast_to_CullTraverser(void)
 *******************************************************************/
static PyObject *Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_179(PyObject *self, PyObject *args,PyObject *kwds) {
    PipeOcclusionCullTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PipeOcclusionCullTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-CullTraverser *PipeOcclusionCullTraverser::upcast_to_CullTraverser(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToCullTraverser", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToCullTraverser"));
        if(!PyErr_Occurred())
        {
            CullTraverser *return_value = (CullTraverser *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CullTraverser,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PipeOcclusionCullTraverser.upcastToCullTraverser() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToCullTraverser(non-const PipeOcclusionCullTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_179_comment =
    "C++ Interface:\n"
    "upcastToCullTraverser(non-const PipeOcclusionCullTraverser this)\n"
    "\n"
    "upcast from PipeOcclusionCullTraverser to CullTraverser\n"
    "";
#else
static const char * Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
 * PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(PipeOcclusionCullTraverser const &copy)
 *******************************************************************/
int  Dtool_Init_PipeOcclusionCullTraverser(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(PipeOcclusionCullTraverser const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:PipeOcclusionCullTraverser", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:PipeOcclusionCullTraverser", &param0));
            if(!PyErr_Occurred())
            {
                PipeOcclusionCullTraverser *param0_this = (PipeOcclusionCullTraverser *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PipeOcclusionCullTraverser, 0, "PipeOcclusionCullTraverser.PipeOcclusionCullTraverser", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PipeOcclusionCullTraverser,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"host", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:PipeOcclusionCullTraverser", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:PipeOcclusionCullTraverser", &param0));
            if(!PyErr_Occurred())
            {
                GraphicsOutput *param0_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GraphicsOutput, 0, "PipeOcclusionCullTraverser.PipeOcclusionCullTraverser", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PipeOcclusionCullTraverser *return_value = new PipeOcclusionCullTraverser(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PipeOcclusionCullTraverser,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PipeOcclusionCullTraverser(const PipeOcclusionCullTraverser copy)\n"
          "PipeOcclusionCullTraverser(non-const GraphicsOutput host)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PipeOcclusionCullTraverser(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PipeOcclusionCullTraverser)
    {
        printf("PipeOcclusionCullTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PipeOcclusionCullTraverser * local_this = (PipeOcclusionCullTraverser *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PipeOcclusionCullTraverser)
        return local_this;
    if(requested_type == &Dtool_CullTraverser)
        return ( CullTraverser *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CullTraverser *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CullTraverser *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CullTraverser *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PipeOcclusionCullTraverser(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PipeOcclusionCullTraverser)
        return from_this;
    if(from_type == &Dtool_CullTraverser)
    {
          CullTraverser* other_this = (CullTraverser*)from_this;
          return (PipeOcclusionCullTraverser*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PipeOcclusionCullTraverser*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PipeOcclusionCullTraverser*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (PipeOcclusionCullTraverser*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LineSegs 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void LineSegs::reset(void)
 *******************************************************************/
static PyObject *Dtool_LineSegs_reset_196(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void LineSegs::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LineSegs.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const LineSegs this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_reset_196_comment =
    "C++ Interface:\n"
    "reset(non-const LineSegs this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::reset\n"
    "//       Access: Public\n"
    "//  Description: Removes any lines in progress and resets to the\n"
    "//               initial empty state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_reset_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LineSegs::set_color(LVecBase4f const &color)
 * inline void LineSegs::set_color(float r, float g, float b, float a)
 * inline void LineSegs::set_color(float r, float g, float b, float a = (1))
 *******************************************************************/
static PyObject *Dtool_LineSegs_set_color_197(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void LineSegs::set_color(LVecBase4f const &color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LineSegs.setColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LineSegs.setColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::set_color(float r, float g, float b, float a = (1))
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setColor", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_color((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::set_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setColor() takes 2, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setColor(non-const LineSegs this, const VBase4 color)\n"
          "setColor(non-const LineSegs this, float r, float g, float b)\n"
          "setColor(non-const LineSegs this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_set_color_197_comment =
    "C++ Interface:\n"
    "setColor(non-const LineSegs this, const VBase4 color)\n"
    "setColor(non-const LineSegs this, float r, float g, float b)\n"
    "setColor(non-const LineSegs this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_color\n"
    "//       Access: Public\n"
    "//  Description: Establishes the color that will be assigned to all\n"
    "//               vertices created by future calls to move_to() and\n"
    "//               draw_to().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_color\n"
    "//       Access: Public\n"
    "//  Description: Establishes the color that will be assigned to all\n"
    "//               vertices created by future calls to move_to() and\n"
    "//               draw_to().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_set_color_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LineSegs::set_thickness(float thick)
 *******************************************************************/
static PyObject *Dtool_LineSegs_set_thickness_198(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LineSegs::set_thickness(float thick)
        double param1;
        static char * key_word_list[] = {(char *)"thick", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setThickness", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setThickness", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_thickness((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LineSegs.setThickness() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThickness(non-const LineSegs this, float thick)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_set_thickness_198_comment =
    "C++ Interface:\n"
    "setThickness(non-const LineSegs this, float thick)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_thickness\n"
    "//       Access: Public\n"
    "//  Description: Establishes the line thickness or point size in\n"
    "//               pixels that will be assigned to all lines and points\n"
    "//               created by future calls to create().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_set_thickness_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LineSegs::move_to(LVecBase3f const &v)
 * inline void LineSegs::move_to(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_LineSegs_move_to_199(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void LineSegs::move_to(LVecBase3f const &v)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"v", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:moveTo", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:moveTo", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "LineSegs.moveTo", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->move_to(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LineSegs.moveTo() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::move_to(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:moveTo", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->move_to((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.moveTo() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "moveTo() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "moveTo(non-const LineSegs this, const VBase3 v)\n"
          "moveTo(non-const LineSegs this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_move_to_199_comment =
    "C++ Interface:\n"
    "moveTo(non-const LineSegs this, const VBase3 v)\n"
    "moveTo(non-const LineSegs this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::move_to\n"
    "//       Access: Public\n"
    "//  Description: Moves the pen to the given point without drawing a\n"
    "//               line.  When followed by draw_to(), this marks the\n"
    "//               first point of a line segment; when followed by\n"
    "//               move_to() or create(), this creates a single point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::move_to\n"
    "//       Access: Public\n"
    "//  Description: Moves the pen to the given point without drawing a\n"
    "//               line.  When followed by draw_to(), this marks the\n"
    "//               first point of a line segment; when followed by\n"
    "//               move_to() or create(), this creates a single point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_move_to_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LineSegs::draw_to(LVecBase3f const &v)
 * inline void LineSegs::draw_to(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_LineSegs_draw_to_200(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void LineSegs::draw_to(LVecBase3f const &v)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"v", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:drawTo", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:drawTo", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "LineSegs.drawTo", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->draw_to(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LineSegs.drawTo() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::draw_to(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:drawTo", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->draw_to((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.drawTo() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "drawTo() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "drawTo(non-const LineSegs this, const VBase3 v)\n"
          "drawTo(non-const LineSegs this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_draw_to_200_comment =
    "C++ Interface:\n"
    "drawTo(non-const LineSegs this, const VBase3 v)\n"
    "drawTo(non-const LineSegs this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::draw_to\n"
    "//       Access: Public\n"
    "//  Description: Draws a line segment from the pen's last position\n"
    "//               (the last call to move_to or draw_to) to the\n"
    "//               indicated point.  move_to() and draw_to() only update\n"
    "//               tables; the actual drawing is performed when create()\n"
    "//               is called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::draw_to\n"
    "//       Access: Public\n"
    "//  Description: Draws a line segment from the pen's last position\n"
    "//               (the last call to move_to or draw_to) to the\n"
    "//               indicated point.  move_to() and draw_to() only update\n"
    "//               tables; the actual drawing is performed when create()\n"
    "//               is called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_draw_to_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f const &LineSegs::get_current_position(void)
 *******************************************************************/
static PyObject *Dtool_LineSegs_get_current_position_201(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint3f const &LineSegs::get_current_position(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentPosition"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &((local_this)->get_current_position());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LineSegs.getCurrentPosition() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentPosition(non-const LineSegs this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_get_current_position_201_comment =
    "C++ Interface:\n"
    "getCurrentPosition(non-const LineSegs this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::get_current_position\n"
    "//       Access: Public\n"
    "//  Description: Returns the pen's current position.  The next call to\n"
    "//               draw_to() will draw a line segment from this point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_get_current_position_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool LineSegs::is_empty(void)
 *******************************************************************/
static PyObject *Dtool_LineSegs_is_empty_202(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool LineSegs::is_empty(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LineSegs.isEmpty() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(non-const LineSegs this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_is_empty_202_comment =
    "C++ Interface:\n"
    "isEmpty(non-const LineSegs this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::empty\n"
    "//       Access: Public\n"
    "//  Description: Returns true if move_to() or draw_to() have not been\n"
    "//               called since the last reset() or create(), false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_is_empty_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GeomNode *LineSegs::create(GeomNode *previous, bool dynamic)
 * GeomNode *LineSegs::create(GeomNode *previous, bool dynamic = (0))
 * inline GeomNode *LineSegs::create(bool dynamic)
 * inline GeomNode *LineSegs::create(bool dynamic = (0))
 *******************************************************************/
static PyObject *Dtool_LineSegs_create_203(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline GeomNode *LineSegs::create(bool dynamic = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":create", key_word_list));
            else
                (PyArg_Parse(args, ":create"));
            if(!PyErr_Occurred())
            {
                GeomNode *return_value = (local_this)->create();
                if (return_value != (GeomNode *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GeomNode,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.create() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 GeomNode *LineSegs::create(GeomNode *previous, bool dynamic = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"previous", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:create", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:create", &param1));
                if(!PyErr_Occurred())
                {
                    GeomNode *param1_this = (GeomNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GeomNode, 1, "LineSegs.create", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        GeomNode *return_value = (local_this)->create(param1_this);
                        if (return_value != (GeomNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GeomNode,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline GeomNode *LineSegs::create(bool dynamic)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"dynamic", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:create", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:create", &param1));
                if(!PyErr_Occurred())
                {
                    GeomNode *return_value = (local_this)->create((PyObject_IsTrue(param1)!=0));
                    if (return_value != (GeomNode *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GeomNode,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-GeomNode *LineSegs::create(GeomNode *previous, bool dynamic)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"previous", (char *)"dynamic", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:create", key_word_list, &param1, &param2))
                {
                    GeomNode *param1_this = (GeomNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GeomNode, 1, "LineSegs.create", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        GeomNode *return_value = (local_this)->create(param1_this, (PyObject_IsTrue(param2)!=0));
                        if (return_value != (GeomNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GeomNode,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LineSegs.create() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "create() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "create(non-const LineSegs this)\n"
          "create(non-const LineSegs this, non-const GeomNode previous)\n"
          "create(non-const LineSegs this, bool dynamic)\n"
          "create(non-const LineSegs this, non-const GeomNode previous, bool dynamic)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_create_203_comment =
    "C++ Interface:\n"
    "create(non-const LineSegs this)\n"
    "create(non-const LineSegs this, non-const GeomNode previous)\n"
    "create(non-const LineSegs this, bool dynamic)\n"
    "create(non-const LineSegs this, non-const GeomNode previous, bool dynamic)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::create\n"
    "//       Access: Public\n"
    "//  Description: Creates a new GeomNode that will render the series of\n"
    "//               line segments and points described via calls to\n"
    "//               move_to() and draw_to().  The lines and points are\n"
    "//               created with the color and thickness established by\n"
    "//               calls to set_color() and set_thick().\n"
    "//\n"
    "//               If dynamic is true, the line segments will be created\n"
    "//               with the dynamic Geom setting, optimizing them for\n"
    "//               runtime vertex animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::create\n"
    "//       Access: Public\n"
    "//  Description: Appends to an existing GeomNode a new Geom that\n"
    "//               will render the series of line segments and points\n"
    "//               described via calls to move_to() and draw_to().  The\n"
    "//               lines and points are created with the color and\n"
    "//               thickness established by calls to set_color() and\n"
    "//               set_thick().\n"
    "//\n"
    "//               If dynamic is true, the line segments will be created\n"
    "//               with the dynamic Geom setting, optimizing them for\n"
    "//               runtime vertex animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_create_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LineSegs::get_num_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_LineSegs_get_num_vertices_204(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int LineSegs::get_num_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVertices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const LineSegs*)local_this)->get_num_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVertices(const LineSegs this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_get_num_vertices_204_comment =
    "C++ Interface:\n"
    "getNumVertices(const LineSegs this)\n"
    "\n"
    "// Functions to move the line vertices after they have been created.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::get_num_vertices\n"
    "//       Access: Public\n"
    "//  Description: Returns the total number of line segment and point\n"
    "//               vertices generated by the last call to create().  The\n"
    "//               positions of these vertices may be read and adjusted\n"
    "//               through get_vertex() and set_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_get_num_vertices_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f LineSegs::get_vertex(int n) const
 *******************************************************************/
static PyObject *Dtool_LineSegs_get_vertex_205(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f LineSegs::get_vertex(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVertex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getVertex", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const LineSegs*)local_this)->get_vertex((int)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertex(const LineSegs this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_get_vertex_205_comment =
    "C++ Interface:\n"
    "getVertex(const LineSegs this, int n)\n"
    "\n"
    "// Functions to move the line vertices after they have been created.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::get_vertex\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth point or vertex of the line segment\n"
    "//               sequence generated by the last call to create().  The\n"
    "//               first move_to() generates vertex 0; subsequent\n"
    "//               move_to() and draw_to() calls generate consecutively\n"
    "//               higher vertex numbers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_get_vertex_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LineSegs::set_vertex(int n, LPoint3f const &vert)
 * inline void LineSegs::set_vertex(int vertex, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_LineSegs_set_vertex_206(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void LineSegs::set_vertex(int n, LPoint3f const &vert)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"vert", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setVertex", key_word_list, &param1, &param2))
                {
                    LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "LineSegs.setVertex", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_vertex((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LineSegs.setVertex() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::set_vertex(int vertex, float x, float y, float z)
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"vertex", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:setVertex", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_vertex((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.setVertex() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVertex() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVertex(non-const LineSegs this, int n, const Point3 vert)\n"
          "setVertex(non-const LineSegs this, int vertex, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_set_vertex_206_comment =
    "C++ Interface:\n"
    "setVertex(non-const LineSegs this, int n, const Point3 vert)\n"
    "setVertex(non-const LineSegs this, int vertex, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_vertex\n"
    "//       Access: Public\n"
    "//  Description: Moves the nth point or vertex of the line segment\n"
    "//               sequence generated by the last call to create().  The\n"
    "//               first move_to() generates vertex 0; subsequent\n"
    "//               move_to() and draw_to() calls generate consecutively\n"
    "//               higher vertex numbers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_vertex\n"
    "//       Access: Public\n"
    "//  Description: Moves the nth point or vertex of the line segment\n"
    "//               sequence generated by the last call to create().  The\n"
    "//               first move_to() generates vertex 0; subsequent\n"
    "//               move_to() and draw_to() calls generate consecutively\n"
    "//               higher vertex numbers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_set_vertex_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4f LineSegs::get_vertex_color(int vertex) const
 *******************************************************************/
static PyObject *Dtool_LineSegs_get_vertex_color_207(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase4f LineSegs::get_vertex_color(int vertex) const
        int param1;
        static char * key_word_list[] = {(char *)"vertex", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVertexColor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getVertexColor", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const LineSegs*)local_this)->get_vertex_color((int)param1);
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertexColor(const LineSegs this, int vertex)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_get_vertex_color_207_comment =
    "C++ Interface:\n"
    "getVertexColor(const LineSegs this, int vertex)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::get_vertex_color\n"
    "//       Access: Public\n"
    "//  Description: Returns the color of the nth point or vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_get_vertex_color_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LineSegs::set_vertex_color(int vertex, LVecBase4f const &c)
 * inline void LineSegs::set_vertex_color(int vertex, float r, float g, float b, float a)
 * inline void LineSegs::set_vertex_color(int vertex, float r, float g, float b, float a = (1))
 *******************************************************************/
static PyObject *Dtool_LineSegs_set_vertex_color_208(PyObject *self, PyObject *args,PyObject *kwds) {
    LineSegs * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineSegs,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void LineSegs::set_vertex_color(int vertex, LVecBase4f const &c)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"vertex", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setVertexColor", key_word_list, &param1, &param2))
                {
                    LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "LineSegs.setVertexColor", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_vertex_color((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LineSegs.setVertexColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::set_vertex_color(int vertex, float r, float g, float b, float a = (1))
            int param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"vertex", (char *)"r", (char *)"g", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iddd:setVertexColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_vertex_color((int)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.setVertexColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(5):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineSegs::set_vertex_color(int vertex, float r, float g, float b, float a)
            int param1;
            double param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"vertex", (char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "idddd:setVertexColor", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                (local_this)->set_vertex_color((int)param1, (float)param2, (float)param3, (float)param4, (float)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineSegs.setVertexColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVertexColor() takes 3, 5, or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVertexColor(non-const LineSegs this, int vertex, const VBase4 c)\n"
          "setVertexColor(non-const LineSegs this, int vertex, float r, float g, float b)\n"
          "setVertexColor(non-const LineSegs this, int vertex, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineSegs_set_vertex_color_208_comment =
    "C++ Interface:\n"
    "setVertexColor(non-const LineSegs this, int vertex, const VBase4 c)\n"
    "setVertexColor(non-const LineSegs this, int vertex, float r, float g, float b)\n"
    "setVertexColor(non-const LineSegs this, int vertex, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_vertex_color\n"
    "//       Access: Public\n"
    "//  Description: Changes the vertex color of the nth point or vertex.\n"
    "//               See set_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LineSegs::set_vertex_color\n"
    "//       Access: Public\n"
    "//  Description: Changes the vertex color of the nth point or vertex.\n"
    "//               See set_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineSegs_set_vertex_color_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LineSegs::LineSegs(basic_string< char > const &name)
 * LineSegs::LineSegs(basic_string< char > const &name = ("lines"))
 *******************************************************************/
int  Dtool_Init_LineSegs(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LineSegs::LineSegs(basic_string< char > const &name = ("lines"))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LineSegs", key_word_list))
            {
                LineSegs *return_value = new LineSegs();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LineSegs,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-LineSegs::LineSegs(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LineSegs", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:LineSegs", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                LineSegs *return_value = new LineSegs(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LineSegs,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LineSegs() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LineSegs()\n"
          "LineSegs(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_LineSegs_get_vertices(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumVertices", "getVertex");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_LineSegs_get_vertex_colors(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumVertices", "getVertexColor");
}
inline void  * Dtool_UpcastInterface_LineSegs(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LineSegs)
    {
        printf("LineSegs ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LineSegs * local_this = (LineSegs *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LineSegs)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LineSegs(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LineSegs)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (LineSegs*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MultitexReducer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void MultitexReducer::clear(void)
 *******************************************************************/
static PyObject *Dtool_MultitexReducer_clear_212(PyObject *self, PyObject *args,PyObject *kwds) {
    MultitexReducer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultitexReducer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MultitexReducer::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MultitexReducer.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const MultitexReducer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultitexReducer_clear_212_comment =
    "C++ Interface:\n"
    "clear(non-const MultitexReducer this)\n"
    "\n"
    "";
#else
static const char * Dtool_MultitexReducer_clear_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MultitexReducer::scan(NodePath const &node)
 * inline void MultitexReducer::scan(NodePath const &node, NodePath const &state_from)
 * void MultitexReducer::scan(PandaNode *node, RenderState const *state, TransformState const *transform)
 *******************************************************************/
static PyObject *Dtool_MultitexReducer_scan_213(PyObject *self, PyObject *args,PyObject *kwds) {
    MultitexReducer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultitexReducer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void MultitexReducer::scan(NodePath const &node)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"node", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:scan", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:scan", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "MultitexReducer.scan", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->scan(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MultitexReducer.scan() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void MultitexReducer::scan(NodePath const &node, NodePath const &state_from)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"node", (char *)"state_from", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:scan", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "MultitexReducer.scan", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "MultitexReducer.scan", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->scan(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MultitexReducer.scan() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void MultitexReducer::scan(PandaNode *node, RenderState const *state, TransformState const *transform)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"node", (char *)"state", (char *)"transform", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:scan", key_word_list, &param1, &param2, &param3))
                {
                    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "MultitexReducer.scan", 0, coerced_ptr, report_errors);
RenderState *param2_this = (RenderState *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_RenderState, 2, "MultitexReducer.scan", 1, coerced_ptr, report_errors);
TransformState *param3_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_TransformState, 3, "MultitexReducer.scan", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        (local_this)->scan(param1_this, param2_this, param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MultitexReducer.scan() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "scan() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "scan(non-const MultitexReducer this, const NodePath node)\n"
          "scan(non-const MultitexReducer this, const NodePath node, const NodePath state_from)\n"
          "scan(non-const MultitexReducer this, non-const PandaNode node, const RenderState state, const TransformState transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultitexReducer_scan_213_comment =
    "C++ Interface:\n"
    "scan(non-const MultitexReducer this, const NodePath node)\n"
    "scan(non-const MultitexReducer this, const NodePath node, const NodePath state_from)\n"
    "scan(non-const MultitexReducer this, non-const PandaNode node, const RenderState state, const TransformState transform)\n"
    "\n"
    "// Filename: multitexReducer.I\n"
    "// Created by:  drose (30Nov04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultitexReducer::scan\n"
    "//       Access: Published\n"
    "//  Description: Starts scanning the hierarchy beginning at the\n"
    "//               indicated node.  Any GeomNodes discovered in the\n"
    "//               hierarchy with multitexture will be added to internal\n"
    "//               structures in the MultitexReducer so that a future\n"
    "//               call to flatten() will operate on all of these at\n"
    "//               once.\n"
    "//\n"
    "//               This version of this method does not accumulate state\n"
    "//               from the parents of the indicated node; thus, only\n"
    "//               multitexture effects that have been applied at node\n"
    "//               and below will be considered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MultitexReducer::scan\n"
    "//       Access: Published\n"
    "//  Description: Starts scanning the hierarchy beginning at the\n"
    "//               indicated node.  Any GeomNodes discovered in the\n"
    "//               hierarchy with multitexture will be added to internal\n"
    "//               structures in the MultitexReducer so that a future\n"
    "//               call to flatten() will operate on all of these at\n"
    "//               once.\n"
    "//\n"
    "//               The second parameter represents the NodePath from\n"
    "//               which to accumulate the state that is considered for\n"
    "//               the multitexture.  Pass an empty NodePath to\n"
    "//               accumulate all the state from the root of the graph,\n"
    "//               or you may specify some other node here in order to\n"
    "//               not consider nodes above that as contributing to the\n"
    "//               state to be flattened.  This is particularly useful\n"
    "//               if you have some texture stage which is applied\n"
    "//               globally to a scene (for instance, a caustics\n"
    "//               effect), which you don't want to be considered for\n"
    "//               flattening by the MultitexReducer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MultitexReducer_scan_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MultitexReducer::set_target(TextureStage *stage)
 *******************************************************************/
static PyObject *Dtool_MultitexReducer_set_target_214(PyObject *self, PyObject *args,PyObject *kwds) {
    MultitexReducer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultitexReducer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MultitexReducer::set_target(TextureStage *stage)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stage", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTarget", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTarget", &param1));
            if(!PyErr_Occurred())
            {
                TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextureStage, 1, "MultitexReducer.setTarget", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_target(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MultitexReducer.setTarget() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTarget(non-const MultitexReducer this, non-const TextureStage stage)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultitexReducer_set_target_214_comment =
    "C++ Interface:\n"
    "setTarget(non-const MultitexReducer this, non-const TextureStage stage)\n"
    "\n"
    "";
#else
static const char * Dtool_MultitexReducer_set_target_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MultitexReducer::set_use_geom(bool use_geom)
 *******************************************************************/
static PyObject *Dtool_MultitexReducer_set_use_geom_215(PyObject *self, PyObject *args,PyObject *kwds) {
    MultitexReducer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultitexReducer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MultitexReducer::set_use_geom(bool use_geom)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"use_geom", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUseGeom", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUseGeom", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_use_geom((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MultitexReducer.setUseGeom() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUseGeom(non-const MultitexReducer this, bool use_geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultitexReducer_set_use_geom_215_comment =
    "C++ Interface:\n"
    "setUseGeom(non-const MultitexReducer this, bool use_geom)\n"
    "\n"
    "";
#else
static const char * Dtool_MultitexReducer_set_use_geom_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MultitexReducer::set_allow_tex_mat(bool allow_tex_mat)
 *******************************************************************/
static PyObject *Dtool_MultitexReducer_set_allow_tex_mat_216(PyObject *self, PyObject *args,PyObject *kwds) {
    MultitexReducer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultitexReducer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MultitexReducer::set_allow_tex_mat(bool allow_tex_mat)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"allow_tex_mat", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAllowTexMat", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAllowTexMat", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_allow_tex_mat((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MultitexReducer.setAllowTexMat() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAllowTexMat(non-const MultitexReducer this, bool allow_tex_mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultitexReducer_set_allow_tex_mat_216_comment =
    "C++ Interface:\n"
    "setAllowTexMat(non-const MultitexReducer this, bool allow_tex_mat)\n"
    "\n"
    "";
#else
static const char * Dtool_MultitexReducer_set_allow_tex_mat_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MultitexReducer::flatten(GraphicsOutput *window)
 *******************************************************************/
static PyObject *Dtool_MultitexReducer_flatten_217(PyObject *self, PyObject *args,PyObject *kwds) {
    MultitexReducer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MultitexReducer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MultitexReducer::flatten(GraphicsOutput *window)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"window", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:flatten", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:flatten", &param1));
            if(!PyErr_Occurred())
            {
                GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutput, 1, "MultitexReducer.flatten", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->flatten(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MultitexReducer.flatten() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flatten(non-const MultitexReducer this, non-const GraphicsOutput window)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultitexReducer_flatten_217_comment =
    "C++ Interface:\n"
    "flatten(non-const MultitexReducer this, non-const GraphicsOutput window)\n"
    "\n"
    "";
#else
static const char * Dtool_MultitexReducer_flatten_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MultitexReducer::MultitexReducer(void)
 *******************************************************************/
int  Dtool_Init_MultitexReducer(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-MultitexReducer::MultitexReducer(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":MultitexReducer", key_word_list))
        {
            MultitexReducer *return_value = new MultitexReducer();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MultitexReducer,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MultitexReducer()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MultitexReducer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MultitexReducer)
    {
        printf("MultitexReducer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MultitexReducer * local_this = (MultitexReducer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MultitexReducer)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MultitexReducer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MultitexReducer)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CardMaker | CardMaker
//********************************************************************
PyMethodDef Dtool_Methods_CardMaker[]= {
  { "reset",(PyCFunction ) &Dtool_CardMaker_reset_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_reset_5_comment},
  { "setUvRange",(PyCFunction ) &Dtool_CardMaker_set_uv_range_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_uv_range_6_comment},
  { "setUvRangeCube",(PyCFunction ) &Dtool_CardMaker_set_uv_range_cube_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_uv_range_cube_7_comment},
  { "setHasUvs",(PyCFunction ) &Dtool_CardMaker_set_has_uvs_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_has_uvs_8_comment},
  { "setHas3dUvs",(PyCFunction ) &Dtool_CardMaker_set_has_3d_uvs_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_has_3d_uvs_9_comment},
  { "setFrame",(PyCFunction ) &Dtool_CardMaker_set_frame_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_frame_10_comment},
  { "setFrameFullscreenQuad",(PyCFunction ) &Dtool_CardMaker_set_frame_fullscreen_quad_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_frame_fullscreen_quad_11_comment},
  { "setColor",(PyCFunction ) &Dtool_CardMaker_set_color_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_color_12_comment},
  { "setHasNormals",(PyCFunction ) &Dtool_CardMaker_set_has_normals_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_has_normals_13_comment},
  { "setSourceGeometry",(PyCFunction ) &Dtool_CardMaker_set_source_geometry_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_set_source_geometry_14_comment},
  { "clearSourceGeometry",(PyCFunction ) &Dtool_CardMaker_clear_source_geometry_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_clear_source_geometry_15_comment},
  { "generate",(PyCFunction ) &Dtool_CardMaker_generate_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CardMaker_generate_16_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CardMaker(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CardMaker.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CardMaker\n"
          "// Description : This class generates 2-d \"cards\", that is,\n"
          "//               rectangular polygons, particularly useful for showing\n"
          "//               textures etc. in the 2-d scene graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_CardMaker.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Namable.As_PyTypeObject());
        Dtool_CardMaker.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CardMaker.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CardMaker.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CardMaker.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CardMaker)");
             printf(" Error In PyType_ReadyCardMaker");
             return;
        }
        Py_INCREF(&Dtool_CardMaker.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CardMaker.As_PyTypeObject().tp_dict,"CardMaker",&Dtool_CardMaker.As_PyObject());
        RegisterRuntimeClass(&Dtool_CardMaker,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CardMaker.As_PyTypeObject());
        PyModule_AddObject(module, "CardMaker",(PyObject *)&Dtool_CardMaker.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FFMpegTexture | FFMpegTexture
//********************************************************************
PyMethodDef Dtool_Methods_FFMpegTexture[]= {
  { "getClassType",(PyCFunction ) &Dtool_FFMpegTexture_get_class_type_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FFMpegTexture_get_class_type_20_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FFMpegTexture(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FFMpegTexture.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FFMpegTexture\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VideoTexture._Dtool_ClassInit(NULL);
        Dtool_FFMpegTexture.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VideoTexture.As_PyTypeObject());
        Dtool_FFMpegTexture.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FFMpegTexture.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FFMpegTexture.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FFMpegTexture.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FFMpegTexture)");
             printf(" Error In PyType_ReadyFFMpegTexture");
             return;
        }
        Py_INCREF(&Dtool_FFMpegTexture.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FFMpegTexture.As_PyTypeObject().tp_dict,"FFMpegTexture",&Dtool_FFMpegTexture.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FFMpegTexture.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FFMpegTexture[0],&Dtool_FFMpegTexture.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FFMpegTexture,FFMpegTexture::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FFMpegTexture.As_PyTypeObject());
        PyModule_AddObject(module, "FFMpegTexture",(PyObject *)&Dtool_FFMpegTexture.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FisheyeMaker | FisheyeMaker
//********************************************************************
PyMethodDef Dtool_Methods_FisheyeMaker[]= {
  { "reset",(PyCFunction ) &Dtool_FisheyeMaker_reset_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeMaker_reset_24_comment},
  { "setFov",(PyCFunction ) &Dtool_FisheyeMaker_set_fov_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeMaker_set_fov_25_comment},
  { "setNumVertices",(PyCFunction ) &Dtool_FisheyeMaker_set_num_vertices_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeMaker_set_num_vertices_26_comment},
  { "setSquareInscribed",(PyCFunction ) &Dtool_FisheyeMaker_set_square_inscribed_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeMaker_set_square_inscribed_27_comment},
  { "setReflection",(PyCFunction ) &Dtool_FisheyeMaker_set_reflection_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeMaker_set_reflection_28_comment},
  { "generate",(PyCFunction ) &Dtool_FisheyeMaker_generate_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeMaker_generate_29_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FisheyeMaker(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FisheyeMaker.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FisheyeMaker\n"
          "// Description : This class is similar to CardMaker, but instead of\n"
          "//               generating ordinary cards, it generates a circular\n"
          "//               rose that represents the projection of a 3-D scene\n"
          "//               through a fisheye lens.  The texture coordinates of\n"
          "//               the rose are defined so that each 2-D vertex has a\n"
          "//               3-D UVW that reflects the corresponding position in\n"
          "//               3-D space of that particular vertex.\n"
          "//\n"
          "//               This class is particularly suited for converting cube\n"
          "//               maps to sphere maps.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_FisheyeMaker.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Namable.As_PyTypeObject());
        Dtool_FisheyeMaker.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FisheyeMaker.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FisheyeMaker.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FisheyeMaker.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FisheyeMaker)");
             printf(" Error In PyType_ReadyFisheyeMaker");
             return;
        }
        Py_INCREF(&Dtool_FisheyeMaker.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FisheyeMaker.As_PyTypeObject().tp_dict,"FisheyeMaker",&Dtool_FisheyeMaker.As_PyObject());
        RegisterRuntimeClass(&Dtool_FisheyeMaker,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FisheyeMaker.As_PyTypeObject());
        PyModule_AddObject(module, "FisheyeMaker",(PyObject *)&Dtool_FisheyeMaker.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FrameRateMeter | FrameRateMeter
//********************************************************************
PyMethodDef Dtool_Methods_FrameRateMeter[]= {
  { "setupWindow",(PyCFunction ) &Dtool_FrameRateMeter_setup_window_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_setup_window_33_comment},
  { "clearWindow",(PyCFunction ) &Dtool_FrameRateMeter_clear_window_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_clear_window_34_comment},
  { "getWindow",(PyCFunction ) &Dtool_FrameRateMeter_get_window_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_get_window_35_comment},
  { "getDisplayRegion",(PyCFunction ) &Dtool_FrameRateMeter_get_display_region_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_get_display_region_36_comment},
  { "setUpdateInterval",(PyCFunction ) &Dtool_FrameRateMeter_set_update_interval_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_set_update_interval_37_comment},
  { "getUpdateInterval",(PyCFunction ) &Dtool_FrameRateMeter_get_update_interval_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_get_update_interval_38_comment},
  { "setTextPattern",(PyCFunction ) &Dtool_FrameRateMeter_set_text_pattern_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_set_text_pattern_39_comment},
  { "getTextPattern",(PyCFunction ) &Dtool_FrameRateMeter_get_text_pattern_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_get_text_pattern_40_comment},
  { "setClockObject",(PyCFunction ) &Dtool_FrameRateMeter_set_clock_object_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_set_clock_object_41_comment},
  { "getClockObject",(PyCFunction ) &Dtool_FrameRateMeter_get_clock_object_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_get_clock_object_42_comment},
  { "update",(PyCFunction ) &Dtool_FrameRateMeter_update_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_update_43_comment},
  { "getClassType",(PyCFunction ) &Dtool_FrameRateMeter_get_class_type_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FrameRateMeter_get_class_type_44_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FrameRateMeter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FrameRateMeter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FrameRateMeter\n"
          "// Description : This is a special TextNode that automatically updates\n"
          "//               itself with the current frame rate.  It can be placed\n"
          "//               anywhere in the world where you'd like to see the\n"
          "//               frame rate.\n"
          "//\n"
          "//               It also has a special mode in which it may be\n"
          "//               attached directly to a channel or window.  If this is\n"
          "//               done, it creates a DisplayRegion for itself and renders\n"
          "//               itself in the upper-right-hand corner.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TextNode._Dtool_ClassInit(NULL);
        Dtool_FrameRateMeter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TextNode.As_PyTypeObject());
        Dtool_FrameRateMeter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FrameRateMeter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FrameRateMeter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FrameRateMeter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FrameRateMeter)");
             printf(" Error In PyType_ReadyFrameRateMeter");
             return;
        }
        Py_INCREF(&Dtool_FrameRateMeter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FrameRateMeter.As_PyTypeObject().tp_dict,"FrameRateMeter",&Dtool_FrameRateMeter.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FrameRateMeter.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FrameRateMeter[11],&Dtool_FrameRateMeter.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FrameRateMeter,FrameRateMeter::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FrameRateMeter.As_PyTypeObject());
        PyModule_AddObject(module, "FrameRateMeter",(PyObject *)&Dtool_FrameRateMeter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GeoMipTerrain | GeoMipTerrain
//********************************************************************
PyMethodDef Dtool_Methods_GeoMipTerrain[]= {
  { "heightfield",(PyCFunction ) &Dtool_GeoMipTerrain_heightfield_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_heightfield_48_comment},
  { "setHeightfield",(PyCFunction ) &Dtool_GeoMipTerrain_set_heightfield_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_heightfield_49_comment},
  { "colorMap",(PyCFunction ) &Dtool_GeoMipTerrain_color_map_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_color_map_50_comment},
  { "setColorMap",(PyCFunction ) &Dtool_GeoMipTerrain_set_color_map_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_color_map_51_comment},
  { "hasColorMap",(PyCFunction ) &Dtool_GeoMipTerrain_has_color_map_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_has_color_map_52_comment},
  { "clearColorMap",(PyCFunction ) &Dtool_GeoMipTerrain_clear_color_map_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_clear_color_map_53_comment},
  { "getElevation",(PyCFunction ) &Dtool_GeoMipTerrain_get_elevation_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_elevation_54_comment},
  { "getNormal",(PyCFunction ) &Dtool_GeoMipTerrain_get_normal_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_normal_55_comment},
  { "setBruteforce",(PyCFunction ) &Dtool_GeoMipTerrain_set_bruteforce_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_bruteforce_56_comment},
  { "getBruteforce",(PyCFunction ) &Dtool_GeoMipTerrain_get_bruteforce_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_bruteforce_57_comment},
  { "setAutoFlatten",(PyCFunction ) &Dtool_GeoMipTerrain_set_auto_flatten_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_auto_flatten_59_comment},
  { "setFocalPoint",(PyCFunction ) &Dtool_GeoMipTerrain_set_focal_point_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_focal_point_60_comment},
  { "getFocalPoint",(PyCFunction ) &Dtool_GeoMipTerrain_get_focal_point_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_focal_point_61_comment},
  { "getRoot",(PyCFunction ) &Dtool_GeoMipTerrain_get_root_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_root_62_comment},
  { "setBlockSize",(PyCFunction ) &Dtool_GeoMipTerrain_set_block_size_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_block_size_63_comment},
  { "getBlockSize",(PyCFunction ) &Dtool_GeoMipTerrain_get_block_size_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_block_size_64_comment},
  { "getMaxLevel",(PyCFunction ) &Dtool_GeoMipTerrain_get_max_level_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_max_level_65_comment},
  { "setMinLevel",(PyCFunction ) &Dtool_GeoMipTerrain_set_min_level_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_min_level_66_comment},
  { "getMinLevel",(PyCFunction ) &Dtool_GeoMipTerrain_get_min_level_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_min_level_67_comment},
  { "isDirty",(PyCFunction ) &Dtool_GeoMipTerrain_is_dirty_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_is_dirty_68_comment},
  { "setFactor",(PyCFunction ) &Dtool_GeoMipTerrain_set_factor_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_factor_69_comment},
  { "setNearFar",(PyCFunction ) &Dtool_GeoMipTerrain_set_near_far_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_near_far_70_comment},
  { "setNear",(PyCFunction ) &Dtool_GeoMipTerrain_set_near_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_near_71_comment},
  { "setFar",(PyCFunction ) &Dtool_GeoMipTerrain_set_far_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_far_72_comment},
  { "getBlockNodePath",(PyCFunction ) &Dtool_GeoMipTerrain_get_block_node_path_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_block_node_path_73_comment},
  { "getBlockFromPos",(PyCFunction ) &Dtool_GeoMipTerrain_get_block_from_pos_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_block_from_pos_74_comment},
  { "setBorderStitching",(PyCFunction ) &Dtool_GeoMipTerrain_set_border_stitching_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_set_border_stitching_75_comment},
  { "getBorderStitching",(PyCFunction ) &Dtool_GeoMipTerrain_get_border_stitching_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_border_stitching_76_comment},
  { "makeSlopeImage",(PyCFunction ) &Dtool_GeoMipTerrain_make_slope_image_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_make_slope_image_77_comment},
  { "generate",(PyCFunction ) &Dtool_GeoMipTerrain_generate_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_generate_78_comment},
  { "update",(PyCFunction ) &Dtool_GeoMipTerrain_update_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_update_79_comment},
  { "getClassType",(PyCFunction ) &Dtool_GeoMipTerrain_get_class_type_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeoMipTerrain_get_class_type_80_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GeoMipTerrain(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GeoMipTerrain.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GeoMipTerrain\n"
          "// Description : GeoMipTerrain, meaning Panda3D GeoMipMapping, can convert\n"
          "//               a heightfield image into a 3D terrain, consisting\n"
          "//               of several GeomNodes. It uses the GeoMipMapping\n"
          "//               algorithm, or Geometrical MipMapping, based on\n"
          "//               the LOD (Level of Detail) algorithm. For more\n"
          "//               information about the GeoMipMapping algoritm, see\n"
          "//               this paper, written by Willem H. de Boer:\n"
          "//               http://flipcode.com/articles/article_geomipmaps.pdf\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_GeoMipTerrain.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict);
        // Enum  GeoMipTerrain::AutoFlattenMode;
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"AFMOff",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"AFMLight",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"AFMMedium",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"AFMStrong",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_GeoMipTerrain.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GeoMipTerrain)");
             printf(" Error In PyType_ReadyGeoMipTerrain");
             return;
        }
        Py_INCREF(&Dtool_GeoMipTerrain.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"GeoMipTerrain",&Dtool_GeoMipTerrain.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GeoMipTerrain.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GeoMipTerrain[31],&Dtool_GeoMipTerrain.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GeoMipTerrain,GeoMipTerrain::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GeoMipTerrain.As_PyTypeObject());
        PyModule_AddObject(module, "GeoMipTerrain",(PyObject *)&Dtool_GeoMipTerrain.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HeightfieldTesselator | HeightfieldTesselator
//********************************************************************
PyMethodDef Dtool_Methods_HeightfieldTesselator[]= {
  { "heightfield",(PyCFunction ) &Dtool_HeightfieldTesselator_heightfield_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_heightfield_84_comment},
  { "setHeightfield",(PyCFunction ) &Dtool_HeightfieldTesselator_set_heightfield_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_heightfield_85_comment},
  { "setPolyCount",(PyCFunction ) &Dtool_HeightfieldTesselator_set_poly_count_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_poly_count_86_comment},
  { "setVisibilityRadius",(PyCFunction ) &Dtool_HeightfieldTesselator_set_visibility_radius_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_visibility_radius_87_comment},
  { "setFocalPoint",(PyCFunction ) &Dtool_HeightfieldTesselator_set_focal_point_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_focal_point_88_comment},
  { "setHorizontalScale",(PyCFunction ) &Dtool_HeightfieldTesselator_set_horizontal_scale_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_horizontal_scale_89_comment},
  { "setVerticalScale",(PyCFunction ) &Dtool_HeightfieldTesselator_set_vertical_scale_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_vertical_scale_90_comment},
  { "setMaxTriangles",(PyCFunction ) &Dtool_HeightfieldTesselator_set_max_triangles_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_set_max_triangles_91_comment},
  { "getElevation",(PyCFunction ) &Dtool_HeightfieldTesselator_get_elevation_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_get_elevation_92_comment},
  { "generate",(PyCFunction ) &Dtool_HeightfieldTesselator_generate_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HeightfieldTesselator_generate_93_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_HeightfieldTesselator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HeightfieldTesselator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HeightfieldTesselator\n"
          "// Description : Converts a height field in the form of a greyscale\n"
          "//               image into a scene consisting of a number of GeomNodes.\n"
          "//\n"
          "//               The tesselation uses an LOD algorithm.  You\n"
          "//               supply a \"focal point\" (X,Y) which tells the\n"
          "//               tesselator where the bulk of the detail should\n"
          "//               be concentrated.  The intent is that as the player\n"
          "//               walks around the terrain, you should occasionally\n"
          "//               move the focal point to wherever the player is.\n"
          "//               You should not move the focal point every frame:\n"
          "//               tesselation is not that fast.  Also, changing the\n"
          "//               focal point may cause popping, so it is best to\n"
          "//               minimize the number of changes.  There are a number\n"
          "//               of parameters that you can use to control tesselation,\n"
          "//               such as a target polygon count, and a visibility\n"
          "//               radius.\n"
          "//\n"
          "//               The heightfield needs to be a multiple of 128 pixels\n"
          "//               in each dimension.  It does not need to be square,\n"
          "//               and it does not need to be a power of two.  For\n"
          "//               example, a 384 x 640 heightfield is fine.\n"
          "//               Be aware that tesselation time is proportional to\n"
          "//               heightfield area, so if you plan to use a size larger\n"
          "//               than about 512x512, it may be desirable to benchmark.\n"
          "//\n"
          "//               Altering parameters, such as the poly count, the\n"
          "//               view radius, or the focal point, does not alter any\n"
          "//               GeomNodes already generated.  Parameter changes only\n"
          "//               affect subsequently-generated GeomNodes.  It is\n"
          "//               possible to cache many different tesselations of the\n"
          "//               same terrain.\n"
          "//               \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_HeightfieldTesselator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Namable.As_PyTypeObject());
        Dtool_HeightfieldTesselator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HeightfieldTesselator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HeightfieldTesselator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_HeightfieldTesselator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HeightfieldTesselator)");
             printf(" Error In PyType_ReadyHeightfieldTesselator");
             return;
        }
        Py_INCREF(&Dtool_HeightfieldTesselator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HeightfieldTesselator.As_PyTypeObject().tp_dict,"HeightfieldTesselator",&Dtool_HeightfieldTesselator.As_PyObject());
        RegisterRuntimeClass(&Dtool_HeightfieldTesselator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HeightfieldTesselator.As_PyTypeObject());
        PyModule_AddObject(module, "HeightfieldTesselator",(PyObject *)&Dtool_HeightfieldTesselator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SceneGraphAnalyzerMeter | SceneGraphAnalyzerMeter
//********************************************************************
PyMethodDef Dtool_Methods_SceneGraphAnalyzerMeter[]= {
  { "setupWindow",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_setup_window_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_setup_window_96_comment},
  { "clearWindow",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_clear_window_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_clear_window_97_comment},
  { "getWindow",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_get_window_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_get_window_98_comment},
  { "getDisplayRegion",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_get_display_region_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_get_display_region_99_comment},
  { "setUpdateInterval",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_set_update_interval_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_set_update_interval_100_comment},
  { "getUpdateInterval",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_get_update_interval_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_get_update_interval_101_comment},
  { "setNode",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_set_node_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_set_node_102_comment},
  { "getNode",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_get_node_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_get_node_103_comment},
  { "update",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_update_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_update_104_comment},
  { "getClassType",(PyCFunction ) &Dtool_SceneGraphAnalyzerMeter_get_class_type_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzerMeter_get_class_type_105_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SceneGraphAnalyzerMeter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SceneGraphAnalyzerMeter\n"
          "// Description : This is a special TextNode that automatically updates\n"
          "//               itself with output from a SceneGraphAnalyzer instance.\n"
          "//               It can be placed anywhere in the world where you'd like\n"
          "//               to see the output from SceneGraphAnalyzer.\n"
          "//\n"
          "//               It also has a special mode in which it may be\n"
          "//               attached directly to a channel or window.  If this is\n"
          "//               done, it creates a DisplayRegion for itself and renders\n"
          "//               itself in the upper-right-hand corner.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TextNode._Dtool_ClassInit(NULL);
        Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TextNode.As_PyTypeObject());
        Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SceneGraphAnalyzerMeter)");
             printf(" Error In PyType_ReadySceneGraphAnalyzerMeter");
             return;
        }
        Py_INCREF(&Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_dict,"SceneGraphAnalyzerMeter",&Dtool_SceneGraphAnalyzerMeter.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SceneGraphAnalyzerMeter[9],&Dtool_SceneGraphAnalyzerMeter.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SceneGraphAnalyzerMeter,SceneGraphAnalyzerMeter::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject());
        PyModule_AddObject(module, "SceneGraphAnalyzerMeter",(PyObject *)&Dtool_SceneGraphAnalyzerMeter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MeshDrawer | MeshDrawer
//********************************************************************
PyMethodDef Dtool_Methods_MeshDrawer[]= {
  { "setBudget",(PyCFunction ) &Dtool_MeshDrawer_set_budget_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_set_budget_108_comment},
  { "getBudget",(PyCFunction ) &Dtool_MeshDrawer_get_budget_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_get_budget_109_comment},
  { "getRoot",(PyCFunction ) &Dtool_MeshDrawer_get_root_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_get_root_110_comment},
  { "begin",(PyCFunction ) &Dtool_MeshDrawer_begin_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_begin_111_comment},
  { "tri",(PyCFunction ) &Dtool_MeshDrawer_tri_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_tri_112_comment},
  { "particle",(PyCFunction ) &Dtool_MeshDrawer_particle_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_particle_113_comment},
  { "blendedParticle",(PyCFunction ) &Dtool_MeshDrawer_blended_particle_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_blended_particle_114_comment},
  { "billboard",(PyCFunction ) &Dtool_MeshDrawer_billboard_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_billboard_115_comment},
  { "segment",(PyCFunction ) &Dtool_MeshDrawer_segment_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_segment_116_comment},
  { "crossSegment",(PyCFunction ) &Dtool_MeshDrawer_cross_segment_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_cross_segment_117_comment},
  { "unevenSegment",(PyCFunction ) &Dtool_MeshDrawer_uneven_segment_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_uneven_segment_118_comment},
  { "linkSegment",(PyCFunction ) &Dtool_MeshDrawer_link_segment_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_link_segment_119_comment},
  { "linkSegmentEnd",(PyCFunction ) &Dtool_MeshDrawer_link_segment_end_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_link_segment_end_120_comment},
  { "explosion",(PyCFunction ) &Dtool_MeshDrawer_explosion_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_explosion_121_comment},
  { "stream",(PyCFunction ) &Dtool_MeshDrawer_stream_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_stream_122_comment},
  { "geometry",(PyCFunction ) &Dtool_MeshDrawer_geometry_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_geometry_123_comment},
  { "end",(PyCFunction ) &Dtool_MeshDrawer_end_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_end_124_comment},
  { "getClassType",(PyCFunction ) &Dtool_MeshDrawer_get_class_type_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer_get_class_type_125_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MeshDrawer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MeshDrawer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MeshDrawer\n"
          "// Description : Mesh drawer creates a single geom object that can be\n"
          "//               shaped with different draw commands.  This is an \n"
          "//               efficient way to render bunch of billboards, particles, \n"
          "//               fast changing triangles.  Its implemented by recycling \n"
          "//               same geom over and over again.  Max budget specifies \n"
          "//               how many triangles are allowed.  Some uses of this \n"
          "//               class can be : particle system, radar icons, health \n"
          "//               bars, 2d icons, 2d ui, bullets, missile trails.  Any \n"
          "//               that can be drawn with triangles can be drawn with \n"
          "//               this class.  At the low level this uses the \n"
          "//               GeomVertexRewriter's.  The internal geom consists of \n"
          "//               vertex, normal, uv and color channels.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_MeshDrawer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_MeshDrawer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MeshDrawer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MeshDrawer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MeshDrawer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MeshDrawer)");
             printf(" Error In PyType_ReadyMeshDrawer");
             return;
        }
        Py_INCREF(&Dtool_MeshDrawer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MeshDrawer.As_PyTypeObject().tp_dict,"MeshDrawer",&Dtool_MeshDrawer.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MeshDrawer.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MeshDrawer[17],&Dtool_MeshDrawer.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MeshDrawer,MeshDrawer::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MeshDrawer.As_PyTypeObject());
        PyModule_AddObject(module, "MeshDrawer",(PyObject *)&Dtool_MeshDrawer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MeshDrawer2D | MeshDrawer2D
//********************************************************************
PyMethodDef Dtool_Methods_MeshDrawer2D[]= {
  { "setBudget",(PyCFunction ) &Dtool_MeshDrawer2D_set_budget_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_set_budget_128_comment},
  { "getBudget",(PyCFunction ) &Dtool_MeshDrawer2D_get_budget_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_get_budget_129_comment},
  { "getRoot",(PyCFunction ) &Dtool_MeshDrawer2D_get_root_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_get_root_130_comment},
  { "quadRaw",(PyCFunction ) &Dtool_MeshDrawer2D_quad_raw_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_quad_raw_131_comment},
  { "rectangleRaw",(PyCFunction ) &Dtool_MeshDrawer2D_rectangle_raw_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_rectangle_raw_132_comment},
  { "setClip",(PyCFunction ) &Dtool_MeshDrawer2D_set_clip_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_set_clip_133_comment},
  { "rectangle",(PyCFunction ) &Dtool_MeshDrawer2D_rectangle_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_rectangle_134_comment},
  { "rectangleBorder",(PyCFunction ) &Dtool_MeshDrawer2D_rectangle_border_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_rectangle_border_135_comment},
  { "rectangleBorderTiled",(PyCFunction ) &Dtool_MeshDrawer2D_rectangle_border_tiled_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_rectangle_border_tiled_136_comment},
  { "rectangleTiled",(PyCFunction ) &Dtool_MeshDrawer2D_rectangle_tiled_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_rectangle_tiled_137_comment},
  { "begin",(PyCFunction ) &Dtool_MeshDrawer2D_begin_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_begin_138_comment},
  { "end",(PyCFunction ) &Dtool_MeshDrawer2D_end_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_end_139_comment},
  { "getClassType",(PyCFunction ) &Dtool_MeshDrawer2D_get_class_type_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MeshDrawer2D_get_class_type_140_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MeshDrawer2D(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MeshDrawer2D.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MeshDrawer2D\n"
          "// Description : This class allows the drawing of 2d objects - \n"
          "//               mainly based on quads and rectangles.\n"
          "//               Alows clipping and serverl high level UI theme\n"
          "//               functions. \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_MeshDrawer2D.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_MeshDrawer2D.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MeshDrawer2D.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MeshDrawer2D.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MeshDrawer2D.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MeshDrawer2D)");
             printf(" Error In PyType_ReadyMeshDrawer2D");
             return;
        }
        Py_INCREF(&Dtool_MeshDrawer2D.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MeshDrawer2D.As_PyTypeObject().tp_dict,"MeshDrawer2D",&Dtool_MeshDrawer2D.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MeshDrawer2D.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MeshDrawer2D[12],&Dtool_MeshDrawer2D.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MeshDrawer2D,MeshDrawer2D::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MeshDrawer2D.As_PyTypeObject());
        PyModule_AddObject(module, "MeshDrawer2D",(PyObject *)&Dtool_MeshDrawer2D.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovieTexture | MovieTexture
//********************************************************************
PyMethodDef Dtool_Methods_MovieTexture[]= {
  { "getVideoLength",(PyCFunction ) &Dtool_MovieTexture_get_video_length_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_video_length_144_comment},
  { "getVideoWidth",(PyCFunction ) &Dtool_MovieTexture_get_video_width_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_video_width_145_comment},
  { "getVideoHeight",(PyCFunction ) &Dtool_MovieTexture_get_video_height_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_video_height_146_comment},
  { "getTexScale",(PyCFunction ) &Dtool_MovieTexture_get_tex_scale_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_tex_scale_147_comment},
  { "restart",(PyCFunction ) &Dtool_MovieTexture_restart_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_restart_148_comment},
  { "stop",(PyCFunction ) &Dtool_MovieTexture_stop_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_stop_149_comment},
  { "play",(PyCFunction ) &Dtool_MovieTexture_play_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_play_150_comment},
  { "setTime",(PyCFunction ) &Dtool_MovieTexture_set_time_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_set_time_151_comment},
  { "getTime",(PyCFunction ) &Dtool_MovieTexture_get_time_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_time_152_comment},
  { "setLoop",(PyCFunction ) &Dtool_MovieTexture_set_loop_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_set_loop_153_comment},
  { "getLoop",(PyCFunction ) &Dtool_MovieTexture_get_loop_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_loop_154_comment},
  { "setLoopCount",(PyCFunction ) &Dtool_MovieTexture_set_loop_count_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_set_loop_count_155_comment},
  { "getLoopCount",(PyCFunction ) &Dtool_MovieTexture_get_loop_count_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_loop_count_156_comment},
  { "setPlayRate",(PyCFunction ) &Dtool_MovieTexture_set_play_rate_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_set_play_rate_157_comment},
  { "getPlayRate",(PyCFunction ) &Dtool_MovieTexture_get_play_rate_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_play_rate_158_comment},
  { "isPlaying",(PyCFunction ) &Dtool_MovieTexture_is_playing_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_is_playing_159_comment},
  { "synchronizeTo",(PyCFunction ) &Dtool_MovieTexture_synchronize_to_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_synchronize_to_160_comment},
  { "unsynchronize",(PyCFunction ) &Dtool_MovieTexture_unsynchronize_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_unsynchronize_161_comment},
  { "getClassType",(PyCFunction ) &Dtool_MovieTexture_get_class_type_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieTexture_get_class_type_162_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovieTexture(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovieTexture.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovieTexture\n"
          "// Description : A texture that fetches video frames from an\n"
          "//               underlying object of class Movie.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Texture._Dtool_ClassInit(NULL);
        Dtool_MovieTexture.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Texture.As_PyTypeObject());
        Dtool_MovieTexture.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovieTexture.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovieTexture.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovieTexture.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovieTexture)");
             printf(" Error In PyType_ReadyMovieTexture");
             return;
        }
        Py_INCREF(&Dtool_MovieTexture.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovieTexture.As_PyTypeObject().tp_dict,"MovieTexture",&Dtool_MovieTexture.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovieTexture.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovieTexture[18],&Dtool_MovieTexture.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovieTexture,MovieTexture::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovieTexture.As_PyTypeObject());
        PyModule_AddObject(module, "MovieTexture",(PyObject *)&Dtool_MovieTexture.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NodeVertexTransform | NodeVertexTransform
//********************************************************************
PyMethodDef Dtool_Methods_NodeVertexTransform[]= {
  { "getNode",(PyCFunction ) &Dtool_NodeVertexTransform_get_node_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeVertexTransform_get_node_166_comment},
  { "getPrev",(PyCFunction ) &Dtool_NodeVertexTransform_get_prev_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeVertexTransform_get_prev_167_comment},
  { "getClassType",(PyCFunction ) &Dtool_NodeVertexTransform_get_class_type_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeVertexTransform_get_class_type_168_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NodeVertexTransform(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NodeVertexTransform.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NodeVertexTransform\n"
          "// Description : This VertexTransform gets its matrix from the\n"
          "//               Transform stored on a node.  It can also compose its\n"
          "//               node's transform with another VertexTransform,\n"
          "//               allowing you to build up a chain of\n"
          "//               NodeVertexTransforms that represent a list of\n"
          "//               composed matrices.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VertexTransform._Dtool_ClassInit(NULL);
        Dtool_NodeVertexTransform.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VertexTransform.As_PyTypeObject());
        Dtool_NodeVertexTransform.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NodeVertexTransform.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NodeVertexTransform.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NodeVertexTransform.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NodeVertexTransform)");
             printf(" Error In PyType_ReadyNodeVertexTransform");
             return;
        }
        Py_INCREF(&Dtool_NodeVertexTransform.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NodeVertexTransform.As_PyTypeObject().tp_dict,"NodeVertexTransform",&Dtool_NodeVertexTransform.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NodeVertexTransform.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NodeVertexTransform[2],&Dtool_NodeVertexTransform.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NodeVertexTransform,NodeVertexTransform::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NodeVertexTransform.As_PyTypeObject());
        PyModule_AddObject(module, "NodeVertexTransform",(PyObject *)&Dtool_NodeVertexTransform.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. RigidBodyCombiner | RigidBodyCombiner
//********************************************************************
PyMethodDef Dtool_Methods_RigidBodyCombiner[]= {
  { "collect",(PyCFunction ) &Dtool_RigidBodyCombiner_collect_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RigidBodyCombiner_collect_173_comment},
  { "getInternalScene",(PyCFunction ) &Dtool_RigidBodyCombiner_get_internal_scene_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RigidBodyCombiner_get_internal_scene_174_comment},
  { "getClassType",(PyCFunction ) &Dtool_RigidBodyCombiner_get_class_type_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RigidBodyCombiner_get_class_type_175_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RigidBodyCombiner(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_RigidBodyCombiner.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : RigidBodyCombiner\n"
          "// Description : This is a special node that combines multiple\n"
          "//               independently-moving rigid nodes into one Geom\n"
          "//               internally (or as few Geoms as possible), for the\n"
          "//               purposes of improving rendering performance.\n"
          "//\n"
          "//               To use it, parent a number of moving objects to this\n"
          "//               node and call collect().  A child node is identified\n"
          "//               as \"moving\" if (a) it has a non-identity transform\n"
          "//               initially, or (b) it is a ModelNode with the\n"
          "//               preserve_transform flag set.  Any other nodes will be\n"
          "//               considered static, and later transforms applied to\n"
          "//               them will not be identified.\n"
          "//\n"
          "//               You should call collect() only at startup or if you\n"
          "//               change the set of children; it is a relatively\n"
          "//               expensive call.\n"
          "//\n"
          "//               Once you call collect(), you may change the\n"
          "//               transforms on the child nodes freely without having\n"
          "//               to call collect() again.\n"
          "//\n"
          "//               RenderEffects such as Billboards are not supported\n"
          "//               below this node.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_RigidBodyCombiner.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_RigidBodyCombiner.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RigidBodyCombiner.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RigidBodyCombiner.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_RigidBodyCombiner.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RigidBodyCombiner)");
             printf(" Error In PyType_ReadyRigidBodyCombiner");
             return;
        }
        Py_INCREF(&Dtool_RigidBodyCombiner.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RigidBodyCombiner.As_PyTypeObject().tp_dict,"RigidBodyCombiner",&Dtool_RigidBodyCombiner.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_RigidBodyCombiner.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_RigidBodyCombiner[2],&Dtool_RigidBodyCombiner.As_PyObject()));
        RegisterRuntimeClass(&Dtool_RigidBodyCombiner,RigidBodyCombiner::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RigidBodyCombiner.As_PyTypeObject());
        PyModule_AddObject(module, "RigidBodyCombiner",(PyObject *)&Dtool_RigidBodyCombiner.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PipeOcclusionCullTraverser | PipeOcclusionCullTraverser
//********************************************************************
PyMethodDef Dtool_Methods_PipeOcclusionCullTraverser[]= {
  { "setScene",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_set_scene_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_set_scene_185_comment},
  { "endTraverse",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_end_traverse_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_end_traverse_186_comment},
  { "getBuffer",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_get_buffer_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_get_buffer_187_comment},
  { "getTexture",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_get_texture_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_get_texture_188_comment},
  { "setOcclusionMask",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_set_occlusion_mask_189_comment},
  { "getOcclusionMask",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_get_occlusion_mask_190_comment},
  { "getClassType",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_get_class_type_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_get_class_type_191_comment},
  { "upcastToCullTraverser",(PyCFunction ) &Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PipeOcclusionCullTraverser_upcast_to_CullTraverser_179_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PipeOcclusionCullTraverser(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PipeOcclusionCullTraverser\n"
          "// Description : This specialization of CullTraverser uses the\n"
          "//               graphics pipe itself to perform occlusion culling.\n"
          "//               As such, it's likely to be inefficient (since it\n"
          "//               interferes with the pipe's normal mode of rendering),\n"
          "//               and is mainly useful to test other, CPU-based\n"
          "//               occlusion algorithms.\n"
          "//\n"
          "//               This cannot be used in a multithreaded pipeline\n"
          "//               environment where cull and draw are operating\n"
          "//               simultaneously.\n"
          "//\n"
          "//               It can't be defined in the cull subdirectory, because\n"
          "//               it needs access to GraphicsPipe and DisplayRegion and\n"
          "//               other classes in display.  So we put it in grutil\n"
          "//               instead, for lack of any better ideas.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CullTraverser._Dtool_ClassInit(NULL);
        Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CullTraverser.As_PyTypeObject());
        Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PipeOcclusionCullTraverser.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PipeOcclusionCullTraverser)");
             printf(" Error In PyType_ReadyPipeOcclusionCullTraverser");
             return;
        }
        Py_INCREF(&Dtool_PipeOcclusionCullTraverser.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_dict,"PipeOcclusionCullTraverser",&Dtool_PipeOcclusionCullTraverser.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PipeOcclusionCullTraverser.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PipeOcclusionCullTraverser[6],&Dtool_PipeOcclusionCullTraverser.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PipeOcclusionCullTraverser,PipeOcclusionCullTraverser::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PipeOcclusionCullTraverser.As_PyTypeObject());
        PyModule_AddObject(module, "PipeOcclusionCullTraverser",(PyObject *)&Dtool_PipeOcclusionCullTraverser.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LineSegs | LineSegs
//********************************************************************
PyMethodDef Dtool_Methods_LineSegs[]= {
  { "reset",(PyCFunction ) &Dtool_LineSegs_reset_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_reset_196_comment},
  { "setColor",(PyCFunction ) &Dtool_LineSegs_set_color_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_set_color_197_comment},
  { "setThickness",(PyCFunction ) &Dtool_LineSegs_set_thickness_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_set_thickness_198_comment},
  { "moveTo",(PyCFunction ) &Dtool_LineSegs_move_to_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_move_to_199_comment},
  { "drawTo",(PyCFunction ) &Dtool_LineSegs_draw_to_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_draw_to_200_comment},
  { "getCurrentPosition",(PyCFunction ) &Dtool_LineSegs_get_current_position_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_get_current_position_201_comment},
  { "isEmpty",(PyCFunction ) &Dtool_LineSegs_is_empty_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_is_empty_202_comment},
  { "create",(PyCFunction ) &Dtool_LineSegs_create_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_create_203_comment},
  { "getNumVertices",(PyCFunction ) &Dtool_LineSegs_get_num_vertices_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_get_num_vertices_204_comment},
  { "getVertex",(PyCFunction ) &Dtool_LineSegs_get_vertex_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_get_vertex_205_comment},
  { "setVertex",(PyCFunction ) &Dtool_LineSegs_set_vertex_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_set_vertex_206_comment},
  { "getVertexColor",(PyCFunction ) &Dtool_LineSegs_get_vertex_color_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_get_vertex_color_207_comment},
  { "setVertexColor",(PyCFunction ) &Dtool_LineSegs_set_vertex_color_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineSegs_set_vertex_color_208_comment},
  { "getVertices",(PyCFunction) &MakeSeq_LineSegs_get_vertices, METH_NOARGS, NULL},
  { "getVertexColors",(PyCFunction) &MakeSeq_LineSegs_get_vertex_colors, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LineSegs(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LineSegs.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LineSegs\n"
          "// Description : Encapsulates creation of a series of connected or\n"
          "//               disconnected line segments or points, for drawing\n"
          "//               paths or rays.  This class doesn't attempt to be the\n"
          "//               smartest it could possibly be; it's intended\n"
          "//               primarily as a visualization and editing tool.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_LineSegs.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Namable.As_PyTypeObject());
        Dtool_LineSegs.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LineSegs.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LineSegs.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LineSegs.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LineSegs)");
             printf(" Error In PyType_ReadyLineSegs");
             return;
        }
        Py_INCREF(&Dtool_LineSegs.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LineSegs.As_PyTypeObject().tp_dict,"LineSegs",&Dtool_LineSegs.As_PyObject());
        RegisterRuntimeClass(&Dtool_LineSegs,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LineSegs.As_PyTypeObject());
        PyModule_AddObject(module, "LineSegs",(PyObject *)&Dtool_LineSegs.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MultitexReducer | MultitexReducer
//********************************************************************
PyMethodDef Dtool_Methods_MultitexReducer[]= {
  { "clear",(PyCFunction ) &Dtool_MultitexReducer_clear_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultitexReducer_clear_212_comment},
  { "scan",(PyCFunction ) &Dtool_MultitexReducer_scan_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultitexReducer_scan_213_comment},
  { "setTarget",(PyCFunction ) &Dtool_MultitexReducer_set_target_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultitexReducer_set_target_214_comment},
  { "setUseGeom",(PyCFunction ) &Dtool_MultitexReducer_set_use_geom_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultitexReducer_set_use_geom_215_comment},
  { "setAllowTexMat",(PyCFunction ) &Dtool_MultitexReducer_set_allow_tex_mat_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultitexReducer_set_allow_tex_mat_216_comment},
  { "flatten",(PyCFunction ) &Dtool_MultitexReducer_flatten_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultitexReducer_flatten_217_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MultitexReducer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MultitexReducer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MultitexReducer\n"
          "// Description : This object presents an interface for generating new\n"
          "//               texture images that represent the combined images\n"
          "//               from one or more individual textures, reproducing \n"
          "//               certain kinds of multitexture effects without\n"
          "//               depending on multitexture support in the hardware.\n"
          "//\n"
          "//               This also flattens out texture matrices and removes\n"
          "//               extra texture coordinates from the Geoms.  It is thus\n"
          "//               not a complete substitute for true multitexturing,\n"
          "//               because it does not lend itself well to dynamic\n"
          "//               animation of the textures once they have been\n"
          "//               flattened.  It is, however, useful for \"baking in\" a\n"
          "//               particular multitexture effect.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_MultitexReducer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_MultitexReducer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MultitexReducer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MultitexReducer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MultitexReducer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MultitexReducer)");
             printf(" Error In PyType_ReadyMultitexReducer");
             return;
        }
        Py_INCREF(&Dtool_MultitexReducer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MultitexReducer.As_PyTypeObject().tp_dict,"MultitexReducer",&Dtool_MultitexReducer.As_PyObject());
        RegisterRuntimeClass(&Dtool_MultitexReducer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MultitexReducer.As_PyTypeObject());
        PyModule_AddObject(module, "MultitexReducer",(PyObject *)&Dtool_MultitexReducer.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CardMaker
//********************************************************************
   Dtool_PyModuleClassInit_CardMaker(module);
//********************************************************************
//*** Module Init Updcall ..FFMpegTexture
//********************************************************************
   Dtool_PyModuleClassInit_FFMpegTexture(module);
//********************************************************************
//*** Module Init Updcall ..FisheyeMaker
//********************************************************************
   Dtool_PyModuleClassInit_FisheyeMaker(module);
//********************************************************************
//*** Module Init Updcall ..FrameRateMeter
//********************************************************************
   Dtool_PyModuleClassInit_FrameRateMeter(module);
//********************************************************************
//*** Module Init Updcall ..GeoMipTerrain
//********************************************************************
   Dtool_PyModuleClassInit_GeoMipTerrain(module);
//********************************************************************
//*** Module Init Updcall ..HeightfieldTesselator
//********************************************************************
   Dtool_PyModuleClassInit_HeightfieldTesselator(module);
//********************************************************************
//*** Module Init Updcall ..SceneGraphAnalyzerMeter
//********************************************************************
   Dtool_PyModuleClassInit_SceneGraphAnalyzerMeter(module);
//********************************************************************
//*** Module Init Updcall ..MeshDrawer
//********************************************************************
   Dtool_PyModuleClassInit_MeshDrawer(module);
//********************************************************************
//*** Module Init Updcall ..MeshDrawer2D
//********************************************************************
   Dtool_PyModuleClassInit_MeshDrawer2D(module);
//********************************************************************
//*** Module Init Updcall ..MovieTexture
//********************************************************************
   Dtool_PyModuleClassInit_MovieTexture(module);
//********************************************************************
//*** Module Init Updcall ..NodeVertexTransform
//********************************************************************
   Dtool_PyModuleClassInit_NodeVertexTransform(module);
//********************************************************************
//*** Module Init Updcall ..RigidBodyCombiner
//********************************************************************
   Dtool_PyModuleClassInit_RigidBodyCombiner(module);
//********************************************************************
//*** Module Init Updcall ..PipeOcclusionCullTraverser
//********************************************************************
   Dtool_PyModuleClassInit_PipeOcclusionCullTraverser(module);
//********************************************************************
//*** Module Init Updcall ..LineSegs
//********************************************************************
   Dtool_PyModuleClassInit_LineSegs(module);
//********************************************************************
//*** Module Init Updcall ..MultitexReducer
//********************************************************************
   Dtool_PyModuleClassInit_MultitexReducer(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libgrutil_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212900,  /* file_identifier */
  "libgrutil",  /* library_name */
  "Xs2x",  /* library_hash_name */
  "panda",  /* module_name */
  "libgrutil.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  568  /* next_index */
};

Configure(_in_configure_libgrutil);
ConfigureFn(_in_configure_libgrutil) {
  interrogate_request_module(&_in_module_def);
}

